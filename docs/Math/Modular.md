---
layout: default
title: "Modular"
parent: "Math"
nav_order: 2
has_children: false
---

# Modular
어떤 수를 다른 수로 나눴을 때 몫은 버리고, **나머지만 보는 것이 모듈러 연산**

- `a mod b`
- `a % b`
- 뜻 : a를 b로 나눈 나머지

---

## 수학적 정의
정수 a,b에 대해 b > 0 일 때

---

$$ a \ \text{mod} \ b = r $$

---

은 다음 조건을 만족하는 유일한 정수 r

1. $$ a = qb + r $$인 정수 q가 존재한다 (q는 몫, r은 나머지)
2. 0 ≤ r < b (나머지 범위 조건)

> 두 조건으로 인해 나머지 r은 항상 0 이상 b-1 이하가 된다

---

## 모듈러 연산에서의 합동
모듈러 연산은 동치관계를 나타냄

- ≡ mod 는 그 값이 같음을 나타내는 관계
- a - b가 n으로 나누어 떨어질 때에만 성립

정수 n ≥ 1 고정. 정수 a,b에 대해

```
a ≡ b (mod n) ⟺ n ∣ (a − b)
```

- a ≡ b (mod n) ? true : false
- n ∣ (a - b) 에서 ∣ 기호는 "~는 ~로 나누어 떨어진다" 는 의미

**정리**
1. a - b가 n의 배수이다
2. 즉 a와 b를 n으로 나눈 나머지가 서로 같다

---

## 규칙
### 1. 결과는 항상 0 이상, 나누는 수(b)보다 작다
예: 14 mod 4 = 2 → 결과는 0,1,2,3 중 하나.

### 2. 반복되는 주기가 있다
예: 0 mod 3 = 0, 3 mod 3 = 0, 6 mod 3 = 0 → 3씩 커질 때마다 결과가 반복됨

### 3. 원래 수로 계산하든, 나머지로 바꿔서 계산하든 결과가 똑같다
덧셈, 뺄셈, 곱셈과 같은 연산을 할 때, 각 피연산자에 대해 모듈러 연산을 먼저 취한 후 계산해도 그 결과는 같음

- 이를 합동 관계라고 한다

```
덧셈: (a + b) mod n = ((a mod n) + (b mod n)) mod n

뺄셈: (a - b) mod n = ((a mod n) - (b mod n)) mod n

곱셈: (a * b) mod n = ((a mod n) * (b mod n)) mod n
```

- 지수에 대해서도 확장 가능 (RSA 같은 암호학 핵심)

```
(a^k) mod n = ((a mod n)^k) mod n
```

예시 : 7 + 5 mod 3
- 원래 계산 : 12 mod 3 = 0
- 나머지로 바꿔서 계산 : 7 mod 3 = 1, 5 mod 3 = 2
- 합 : 1 + 2 = 3, 3 mod 3 = 0
- 결과가 동일함

> 이 규칙 덕분에 큰 수를 직접 다루지 않고, 작은 나머지로 바꿔 계산해도 결과가 같음
> 암호학, 프로그래밍 등에서 큰 수를 작게 줄여서 계산하는 데 많이 쓰임

---

⚠️ 나눗셈은 일반적인 규칙이 적용되지 않음. 모듈러 역원(modular inverse) 개념 필요

### Modular Inverse (모듈러 역원)
a × x ≡ 1 (mod n)을 만족하는 x를 a의 모듈러 역원이라고 함

- 예: 3 × x ≡ 1 (mod 11)을 만족하는 x는?
- 3 × 4 = 12 ≡ 1 (mod 11) ∴ x = 4

> 모든 수가 모듈러 역원을 가지는 것은 아님
> - a와 n이 서로소일 때만 역원이 존재함

---

## 생활 속 예시
1. 시계: 시계는 12시간마다 반복
- 지금 9시에서 5시간 후는 몇 시?
- 9 + 5 = 14 → 14 mod 12 = 2 → 2시
2. 요일: 요일도 7일마다 반복
- 오늘이 화요일(2번째 날)인데, 10일 뒤는?
- 2 + 10 = 12 → 12 mod 7 = 5 → 금요일

---

## 음수
나누는 수 (=mod 뒤에 오는 수, 보통 b) 는 양수만 쓰는 게 일반적 규칙
- 음수가 들어가면 수학 책이나 프로그래밍 언어마다 정의가 다름

## 1. (-a) mod b (음수 피제수)
예 : -7 mod 3
- `-7 ÷ 3 = -2 … -1` (몫 -2, 나머지 -1)
- **나머지는 0 이상, b보다 작다**는 규칙을 따르기 위해 나머지를 다시 조정
- `-1 + 3 = 2` (나머지에 b 더하기)

피제수(앞 숫자)가 음수여도, 결과는 0 이상 b-1 사이 값으로 조정

---

## 2. a mod (-b) (음수 나누는 수)
실제 수학에서는 음수 modulus를 정의하지 않는다

- 수학적 정의에서 modulus는 양수여야 함 (0 < b)
- `0 ≤ r < b`라는 조건이 음수 b에서는 의미가 없어짐
- 프로그래밍에서도 거의 사용되지 않으며, 언어별로 일관성 없는 결과를 보임

---

## 3. 프로그래밍 언어 차이
정수 나눗셈을 어떻게 정의하느냐에 따라 차이가 난다

### C/C++
Truncate toward 0. 소수 부분을 제거하여 정수로 반올림하는 방법

- 양수 : 소수부분 그냥 버리기 →  2.7은 2, 4.95는 4
- 음수 : -3.2는 -3, -9.5는 -9

**나눗셈 연산**
예: -7 / 3
- 실제 나눗셈 : -2.333...
- trunc toward 0  → q(몫) = -2
- r (나머지) = -7 - (-2) × 3 = **-1**

---

### Python
Floor division 기반. 두 수를 나눈 후, 그 **결과값에 대해 가장 작은 정수로 내림(round down)하여 결과를 반환**하는 연산

- 양수 : 7 / 3은 `2.333...` → 내림하기 → 2
- 음수 : -11 / 2는 -5.5 → 내림 (더 작은 정수) → -6

**나눗셈 연산**
예: -7 / 3
- 실제 나눗셈 : -2.333...
- floor (내림)  → q(몫) = -3
- r (나머지) = -7 - (-3) × 3 = **2**

> 따라서 r은 항상 나누는 수 n과 같은 부호임
> - 0 ≤ r < n 범위에 들어감

---

## 정리
- C/C++: “0 기준으로 잘라라.” → 그래서 음수 나머지 허용
- Python: “항상 아래쪽 정수로 내려라.” → 그래서 몫이 더 작아지고, 그 결과 나머지는 항상 0 ≤ r < n 범위

---

**링크**
- [모듈러 연산이란?](https://ko.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic)