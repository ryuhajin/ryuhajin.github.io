네, 아주 좋은 질문입니다. 그 책은 실용적인 HLSL 기법을 다루기 때문에, 그에 앞서 Direct3D 11의 기본적인
  '뼈대' 코드를 능숙하게 다룰 수 있다고 가정하는 것이 일반적입니다. 사용자가 삼각형을 그려본 경험은 훌륭한
  첫걸음이지만, 책에서 요구하는 수준에 도달하려면 몇 가지 핵심 개념을 추가로 학습하고 직접 구현해 보셔야
  합니다.

  현재 지식 수준에서 책에서 요구하는 바탕 지식을 갖추기 위한 학습 로드맵을 단계별로 제시해 드리겠습니다.

  학습 목표: "장면에 있는 각 메시에 대해 드로우 콜을 설정하고 실행할 수 있으며, 최소한의 정점 쉐이더 계산을
  수행할 수 있다."

  이 목표를 달성하기 위해 알아야 할 것들은 크게 C++ 애플리케이션(CPU) 파트와 HLSL 쉐이더(GPU) 파트로
  나뉩니다.

  ---

  1단계: C++ 애플리케이션에서 렌더링 파이프라인 구축하기

  삼각형 예제에서는 모든 것이 단순화되어 있었을 겁니다. 이제는 3D 공간에 있는 '오브젝트(메시)'를 그린다는
  개념으로 확장해야 합니다.

  핵심 학습 내용:

   1. 상수 버퍼 (Constant Buffers) 마스터하기
       * 이유: 쉐이더에 동적으로 데이터를 넘겨주는 가장 기본적인 방법입니다. 특히 행렬(Matrix)을 넘기는 데
         필수적입니다.
       * 해야 할 일:
           * C++ 코드에서 D3D11_BUFFER_DESC로 상수 버퍼를 생성하는 방법을 익힙니다.
           * ID3D11DeviceContext::UpdateSubresource() 또는 Map/Unmap을 사용해 C++의 행렬 데이터를 상수 버퍼로
             복사하는 방법을 배웁니다.
           * VSSetConstantBuffers() 함수로 특정 상수 버퍼를 Vertex Shader에 연결(바인딩)하는 방법을 익힙니다.

   2. 월드, 뷰, 프로젝션 (WVP) 행렬 이해하고 사용하기
       * 이유: 3D 모델을 화면에 그리기 위한 필수적인 수학적 변환입니다.
       * 해야 할 일:
           * 월드(World) 행렬: 3D 모델의 크기, 회전, 월드 공간 내 위치를 결정합니다. 오브젝트마다 고유한 월드
             행렬을 가집니다.
           * 뷰(View) 행렬: 3D 공간에 있는 카메라의 위치와 방향을 결정합니다. (카메라의 반대 변환)
           * 프로젝션(Projection) 행렬: 3D 씬을 2D 화면에 투영하는 방법을 결정합니다. (원근 투영, 직교 투영)
           * DirectXMath 라이브러리 (XMMatrix... 함수들)를 사용하여 이 세 가지 행렬을 만드는 방법을
             공부하세요.

   3. 메시 데이터 로딩 및 버퍼 생성
       * 이유: 하드코딩된 삼각형 배열에서 벗어나, 실제 3D 모델을 그리려면 정점(vertex)과 인덱스(index)
         데이터를 담을 버퍼가 필요합니다.
       * 해야 할 일:
           * 간단한 3D 모델(예: 정육면체)의 정점 배열과 인덱스 배열을 직접 만들어보세요. 각 정점은
             위치(position)와 노멀(normal) 데이터를 포함해야 합니다.
           * 이 배열 데이터로 정점 버퍼(Vertex Buffer)와 인덱스 버퍼(Index Buffer)를 생성하는 코드를
             작성합니다.

   4. 입력 레이아웃 (Input Layout) 설정
       * 이유: 정점 버퍼에 있는 데이터(위치, 노멀 등)가 Vertex Shader의 입력과 어떻게 연결되는지 D3D에게
         알려줘야 합니다.
       * 해야 할 일:
           * D3D11_INPUT_ELEMENT_DESC 배열을 사용하여 "첫 번째 데이터는 위치(POSITION)고, 두 번째 데이터는
             노멀(NORMAL)이다" 와 같이 정의하는 방법을 익힙니다.

  ---

  2단계: 기본 Vertex/Pixel 쉐이더 직접 작성하기

  예제 쉐이더를 사용하는 대신, 이제 직접 최소한의 기능을 하는 쉐이더를 작성해야 합니다.

  핵심 학습 내용:

   1. Vertex Shader (VS) 작성
       * 목표: 정점의 위치를 클립 공간으로 변환하고, 노멀을 월드 공간으로 변환하여 Pixel Shader로 넘겨줍니다.
       * HLSL 코드 구조:

    1         // C++에서 넘겨받을 상수 버퍼
    2         cbuffer ConstantBuffer : register(b0)
    3         {
    4             matrix World;
    5             matrix View;
    6             matrix Projection;
    7         }
    8
    9         // C++의 Input Layout과 일치하는 입력 구조체
   10         struct VS_INPUT
   11         {
   12             float4 Pos : POSITION;
   13             float3 Norm : NORMAL;
   14         };
   15
   16         // Pixel Shader로 넘겨줄 출력 구조체
   17         struct PS_INPUT
   18         {
   19             float4 Pos : SV_POSITION; // SV_POSITION은 필수 출력!
   20             float3 Norm : NORMAL;
   21         };
   22
   23         // Vertex Shader 메인 함수
   24         PS_INPUT main(VS_INPUT input)
   25         {
   26             PS_INPUT output = (PS_INPUT)0;
   27
   28             // 1. 위치를 월드 -> 뷰 -> 프로젝션 공간으로 변환
   29             output.Pos = mul(input.Pos, World);
   30             output.Pos = mul(output.Pos, View);
   31             output.Pos = mul(output.Pos, Projection);
   32
   33             // 2. 노멀을 월드 공간으로 변환 (회전만 적용되도록)
   34             output.Norm = mul(input.Norm, (float3x3)World);
   35             output.Norm = normalize(output.Norm);
   36
   37             return output;
   38         }

   2. Pixel Shader (PS) 작성
       * 목표: Vertex Shader에서 넘겨받은 데이터를 사용해 픽셀 색상을 결정합니다. 조명 계산은 책에서 다룰
         것이므로, 지금은 단순히 노멀 벡터를 색상으로 출력하여 데이터가 잘 넘어왔는지 확인하는 것만으로도
         충분합니다.
       * HLSL 코드 구조:

    1         struct PS_INPUT
    2         {
    3             float4 Pos : SV_POSITION;
    4             float3 Norm : NORMAL;
    5         };
    6
    7         // Pixel Shader 메인 함수
    8         float4 main(PS_INPUT input) : SV_Target
    9         {
   10             // 월드 공간 노멀을 색상으로 변환 (-1~1 범위를 0~1 범위로)
   11             float3 color = input.Norm * 0.5f + 0.5f;
   12             return float4(color, 1.0f);
   13         }

  추천 학습 방법

   1. 튜토리얼 따라하기: Frank D. Luna의 "Introduction to 3D Game Programming with DirectX 11" 책이나 Rastertek
       같은 웹사이트의 D3D11 튜토리얼을 찾아 정육면체 하나를 그리는 과정까지 직접 코딩하며 따라가 보세요. 이
      과정에서 위의 모든 개념(상수 버퍼, 행렬, 입력 레이아웃 등)을 자연스럽게 배우게 됩니다.
   2. 샌드박스 프로젝트 만들기: 자신만의 간단한 D3D11 프로젝트를 만들고, 위에서 작성한 C++ 코드와 HLSL 코드를
      이용해 화면에 정육면체를 띄워보세요.
   3. 실험하기: 정육면체가 떴다면, C++ 코드에서 월드 행렬을 매 프레임 조금씩 변경(회전)시켜 보세요. 정육면체가
      회전하고, 노멀 기반의 색상도 그에 맞게 변한다면 책을 볼 준비가 완료된 것입니다.

  이 과정을 마치면 "씬의 각 메시에 대해 드로우 콜을 설정하고 실행"하는 능력과 "정점 위치와 노멀을 변환하는"
  능력을 모두 갖추게 되어, HLSL Development Cookbook을 훨씬 수월하게 공부하실 수 있을 겁니다.