---
layout: default
title: "1. Element Array"
parent: "Graphics rendering pipeline"
nav_order: 2
---

# 1. Element Array
인덱스 버퍼(Index Buffer, Element Buffer)라고도 하며, GPU에서 삼각형(또는 기타 프리미티브) 형태로 모델 데이터를 효율적으로 전달하기 위한 방식

## Vertex Array
모델링의 버텍스 데이터가 연속적으로 저장되어 있는 배열

- **인덱스** : n번째 버텍스 (예: 0번째 인덱스 -> 0번째 버텍스)
- **값** : 버텍스의 x,y,x 좌표

```c++
// Vertex Array (각각 [x, y, z] 좌표)
float VertexIndices[][3] = {
    {1, 1, 1},   // 0 번째 버텍스
    {1, 1, -1},  // 1 번째 버텍스
    {1, -1, 1},  // 2 번째 버텍스
    {1, -1, -1}, // 3 ...
    {-1, 1, 1},  // 4
    {-1, 1, -1}, // 5
    {-1, -1, 1}, // 6
    {-1, -1, -1} // 7
};
```

## Element Array
버텍스 배열에서 삼각형을 어떻게 조합할지에 대한 인덱스 정보를 저장한 배열

- **인덱스** : n번째 삼각형 (예: 0번째 인덱스 -> n번째 버텍스)
- **값** : n번째 삼각형을 정의하는 Vertex Array 인덱스 집합
  - 예: `{0, 1, 2}` = Vertex Array의 `[0], [1], [2]` 버텍스를 사용한 삼각형 

```c++
// Element Array (삼각형을 이루는 버텍스 인덱스)
unsigned int Triangle[][3] = {
    {0, 1, 2}, // Vertex Array의 [0], [1], [2] 버텍스를 사용한 삼각형
    {2, 1, 3},
    // ...
    {4, 6, 5},
    {5, 6, 7}
};
```

{: .new-title}
> ❓ 버텍스 배열과 삼각형 배열을 따로 분리하는 이유?
>
- 버텍스 중복 저장 방지 : 3D 모델에서 여러 삼각형이 동일한 버텍스를 공유하는 경우가 매우 많음
- 각 삼각형마다 중복된 좌표 데이터를 저장하지 않고, 인덱스만 다르게 참조
  -  메모리 효율성과 캐싱 효율을 높임

# 동작 과정
## 1. 모델링 파일 파싱
- 애플리케이션/엔진에서 모델링 파일 로드
- 버텍스 좌표, 인덱스 정보 등을 메모리로 읽어옴

### 모델링 파일 예시 (.obj)
- 모델링 파일의 **버텍스 좌표는 모델 로컬 공간 기준으로 저장**됨
  - **예: 모델의 한 꼭짓점 (1,1,1) 은 모델의 중심 (pivot)에서 x,y,z로 각각 1만큼 떨어진 지점에 위치**
- 1-based 인덱스 : 인덱스가 1부터 시작
  - 실제 GPU에선 0-based로 맞춰서 변환 필요

```c++
v 1.000000 1.000000 1.000000     // 버텍스 1 (x, y, z)
v 1.000000 1.000000 -1.000000    // 버텍스 2
v 1.000000 -1.000000 1.000000    // 버텍스 3
v 1.000000 -1.000000 -1.000000   // 버텍스 4

...

f 1 2 3    // face (1,2,3번 버텍스가 삼각형을 이룸)
f 3 2 4
```

## 2. 데이터 정렬
파싱한 값을 버텍스 배열, 삼각형 배열(Element Array)로 정렬/변환

## 3. GPU 업로드
완료된 버텍스 배열과 삼각형 배열을 GPU에 업로드
- GPU는 이 데이터를 바탕으로 렌더링 파이프라인을 시작

