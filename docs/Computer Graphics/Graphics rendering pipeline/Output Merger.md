---
layout: default
title: "Output Merger"
parent: "Graphics rendering pipeline"
nav_order: 9
---

# Depth Buffer & Stencil Buffer
두 버퍼는 일반적으로 하나의 버퍼에 있는 메모리를 공유

- 별개의 두 버퍼를 따로따로 만드는 것이 아니라
> 깊이-스텐실 데이터를 함께 저장하는 특별한 포맷의 텍스처를 하나 생성하여 사용

## Depth-Stencil Buffer (깊이-스텐실 버퍼)
현대의 그래픽스에서는 깊이 정보와 스텐실 정보를 효율적으로 다루기 위해 이 둘을 합친 포맷을 사용하도록 최적화되어 있다

```c++
// d3dclass.cpp - Initialize() 함수 내부

D3D11_TEXTURE2D_DESC depthBufferDesc;
// ...
depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // 바로 이 부분!
// ...
result = m_device->CreateTexture2D(&depthBufferDesc, NULL, &m_depthStencilBuffer);
```

- **DXGI_FORMAT_D24_UNORM_S8_UINT** : 깊이와 스텐실이 합쳐진 대표적인 포맷
  - **D24** : 24비트를 깊이 버퍼로 사용
  - **S8** : 8비트를 스텐실 버퍼로 사용
- **픽셀당 총 32비트(24비트 깊이 + 8비트 스텐실)의 메모리 공간을 사용**하는 하나의 텍스처 포맷

---

## Depth testing & Stencil testing
**깊이 테스트와 스텐실 테스트는** 그래픽스 렌더링 파이프라인의 **거의 마지막 단계인 출력 병합(Output Merger, OM) 단계에서 일어난다**

Direct3D 11의 렌더링 파이프라인은 다음과 같은 단계를 거쳐 3D 모델을 2D 이미지로 변환함

1.  **입력 조립기 (Input Assembler)**: 정점 데이터를 읽어옴
2.  **정점 셰이더 (Vertex Shader)**: 정점의 위치를 변환
3.  **래스터라이저 (Rasterizer)**: 3D 모델을 2D 픽셀 (정확히는 프래그먼트)로 변환
4.  **픽셀 셰이더 (Pixel Shader)**: 각 픽셀의 최종 색상을 계산
5.  **출력 병합기 (Output Merger)**: 완성된 픽셀들을 최종 조립 라인(화면)에 배치하는 단계
- 픽셀 셰이더의 결과를 **최종 렌더링 타겟(화면 버퍼)에 기록**

> 깊이 테스팅, 스텐실 테스팅, 알파 블렌딩은 모두 마지막 단계인 `출력 병합기(Output Merger)`에서 일어남

**읽어보면 좋은 링크**
- [Depth testing](https://learnopengl.com/Advanced-OpenGL/Depth-testing)
- [Stencil testing](https://learnopengl.com/Advanced-OpenGL/Stencil-testing)

---

# Output Merger
완성된 픽셀들을 최종 조립 라인(화면)에 배치하는 단계

## Output Merger 출력 병합기 처리 순서
출력 병합기 단계에 도달한 픽셀(프래그먼트)은 최종적으로 화면에 그려지기 전에 여러 테스트와 혼합 과정을 거침

1.  **스텐실 테스팅 (Stencil Testing)**
- 스텐실 버퍼라는 8비트 정수 버퍼(픽셀 당 0~255 값 저장)를 사용하여, 특정 조건을 만족하는 픽셀에만 그리거나, 그리는 대신 스텐실 버퍼의 값을 변경하는 등의 복잡한 작업을 수행
2.  **깊이 테스팅 (Depth Testing)**
- 카메라에 더 가까운 물체만 그리고, 뒤에 있는 물체는 가려서 보이지 않게 만드는 것
3.  **알파 블렌딩 (Alpha Blending)**
- 반투명한 색상을 어떻게 섞을지 결정
- 픽셀이 반투명할 경우 기존 컬러 버퍼의 색상과 새로 그릴 픽셀의 색상을 정해진 비율로 혼합

---

## Output Merger 상세 처리 과정
픽셀 셰이더로부터 하나의 픽셀을 그리기 위한 정보 **프래그먼트(Fragment)**가 넘어왔다고 가정

- 이 프래그먼트는 자신의 (x, y) 좌표, 색상(RGBA), 깊이(Z) 값을 가지고 있음

---

### 1. Stencil Test
1. 프래그먼트가 그려질 위치 `(x, y)`에 해당하는 **스텐실 버퍼**의 값을 읽어옴
2. 미리 설정된 규칙에 따라 프래그먼트의 스텐실 값과 버퍼의 스텐실 값을 비교하여 테스트를 진행
- 예를 들어 "버퍼의 값이 5일 때만 통과시켜라" 같은 규칙을 설정할 수 있음
3. **결과**:
- **[통과]** → 다음 단계인 **2. 깊이 테스트**로 진행
  - 설정에 따라 스텐실 버퍼의 값을 변경할 수도 있음 (예: 통과한 픽셀의 스텐실 값을 6으로 바꿔라)
- **[실패]** → **프래그먼트는 즉시 버려잠**
  - 이후의 모든 과정(깊이 테스트, 블렌딩)은 생략

> - 스텐실 테스트 실패 = "이번에 그리려던 거, 그냥 없던 일로 할게" 라는 의미
> 해당 픽셀은 이전 상태를 그대로 유지

---

### 2. Depth Test
1. 프래그먼트가 그려질 위치 `(x, y)`에 해당하는 **깊이 버퍼**의 값을 읽어옴
- 이 값은 현재 해당 픽셀에 그려진 물체 중 가장 가까운 것의 깊이 정보
2. 미리 설정된 규칙 (보통 '보다 작을 때'를 사용) 에 따라 프래그먼트의 깊이 값과 깊이 버퍼의 값을 비교
3. **결과**:
- **[통과]** (프래그먼트가 더 앞에 있을 경우) → 이 프래그먼트는 보이는 것으로 간주
  - 다음 단계인 **알파 블렌딩**으로 진행
- **[실패]** (프래그먼트가 이미 그려진 것보다 뒤에 있을 경우) → **프래그먼트는 즉시 버림**
  - 렌더링할 필요가 없는, 가려진 픽셀이기 때문

---

### 3. Alpha Blending
1. 프래그먼트가 그려질 위치 `(x, y)`에 해당하는 **컬러 버퍼(렌더 타겟)**의 현재 색상 값을 읽어옴
2. 프래그먼트의 색상 및 알파 값과 컬러 버퍼에서 읽어온 색상 값을 미리 설정된 혼합 공식(Blend Formula)에 따라 계산하여 **최종 픽셀 색상**을 만들어냄
  - (예: `최종색 = (프래그먼트색 * Alpha) + (기존색 * (1-Alpha))`)
  - 만약 불투명한 객체라면, 혼합 과정 없이 프래그먼트의 색상이 최종 색상이 됨
3. **결과**: 해당 픽셀에 그려질 최종 색상이 결정

---

### 4. Buffer Update
1. 1, 2, 3단계를 모두 통과한 프래그먼트의 최종 정보를 각 버퍼에 기록
2. 결과 :
- **스텐실 버퍼**: 스텐실 버퍼 설정에 따라 필요시 `(x, y)` 위치의 값을 업데이트
- **깊이 버퍼**: 깊이 테스트를 통과한 프래그먼트의 **깊이 값**을 `(x, y)` 위치에 덮어씀
  - 이제 이 깊이가 새로운 '가장 가까운' 값이 됨
- **컬러 버퍼**: 3단계에서 계산된 **최종 픽셀 색상**을 `(x, y)` 위치에 덮어씀

> 모든 테스트를 통과한 프래그먼트의 데이터 (최종 색상, 깊이 값, 새 스텐실 값)가 하나의 논리적인 묶음으로
각 버퍼의 해당 위치에 한 번에 기록된다

- 이 모든 과정이 각 픽셀에 대해 독립적으로 일어나며, 렌더링할 모든 픽셀이 이 처리를 마치면 하나의 완전한 프레임이 완성된다

---

# Early-Z
픽셀 셰이더 이전의 깊이 테스팅

- 현대 GPU는 성능 최적화를 위해 깊이 테스트를 픽셀 셰이더보다 먼저 수행하기도 한다
- 이를 Early-Z 또는 Early Depth Testing 이라고 부른다

## 왜 이런 최적화가 필요할까?
어떤 물체가 다른 물체에 완전히 가려져서 어차피 화면에 보이지 않을 것이라면, 그 보이지도 않을 픽셀의 색상을 계산하는 것은 엄청난 낭비

**Early-Z 동작 과정**
1. 정점 셰이더에서 정점들의 위치와 깊이 값이 계산
2. 래스터라이저는 이 정보를 바탕으로 픽셀들을 생성
3. 이때, GPU는 본격적인 픽셀 셰이더를 실행하기 전에, 해당 픽셀의 깊이 값을 깊이 버퍼의 값과 미리 비교
4. 만약 이 테스트에서 실패하면(즉, 더 뒤에 있는 픽셀이라 판단되면), 해당 픽셀에 대한 픽셀 셰이더를 아예 실행하지 않고 폐기

### 단, Early-Z는 항상 사용할 수 있는 것은 아님
- 픽셀 셰이더가 픽셀의 깊이 값을 변경하거나, 픽셀을 폐기(discard)하는 등의 특정 작업을 수행하면
- GPU는 깊이 값을 미리 알 수 없으므로 Early-Z 최적화를 비활성화하고 원래 순서대로(픽셀 셰이더 실행 후 깊이 테스트) 처리함

**읽어보면 좋은 링크**
- [To Early-Z, or Not To Early-Z](https://therealmjp.github.io/posts/to-earlyz-or-not-to-earlyz/)
