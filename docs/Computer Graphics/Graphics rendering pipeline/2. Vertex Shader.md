---
layout: default
title: "2. Vertex Shader"
parent: "Graphics rendering pipeline"
nav_order: 3
---

# 2. Vertex Shader
가상의 3D 공간에 있는 꼭지점(vertex)들의 위치를 2차원 화면의 좌표로 변환하는 작업을 수행

---

# Vertex Shader Overview
버텍스 쉐이더의 흐름

---
![](/images/vertexShaderOverview.png)

1. **로컬 좌표(local coordinates)** 
    - 오브젝트의 로컬 원점(local origin)을 기준으로 한 좌표를 의미
    - 오브젝트가 처음 위치하는 좌표계
2. **월드 좌표(World-space coordinates)**
   - 더 큰 세계의 글로벌 원점(global origin)을 기준으로 한 좌표
   - 여러 오브젝트들이 모두 이 원점을 기준으로 위치함
3. **뷰 공간 좌표 (view-space coordinates)**
   - 카메라나 뷰어의 시점에서 바라본 좌표
4. **클립 좌표(clip coordinates)**
   - `-1.0` 과 `1.0` 범위로 정규화된 좌표
   - 어떤 버텍스가 화면에 나타날지 결정하는 역할을 한다
5. **스크린 좌표(screen coordinates)**
   - Viewport 
   - 에서 정의한 화면 좌표계 범위로 변환된 좌표

---

# Fundamental Transformations
기본 변환 행렬
- 좌표 변환을 이해하기 위해 기본이 되는 크기(Scale), 회전(Rotation), 이동(Translation) 변환

## Scaling (크기 변환)
오브젝트의 크기를 각 축(x, y, z) 방향으로 조절

$$
S = \begin{pmatrix} S_x & 0 & 0 & 0 \\ 0
& S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \end{pmatrix}
$$

정점의 각 요소 $$(V_x, V_y, V_z)$$ 는 대응하는 크기 조절 값 $$(S_x, S_y, S_z)$$와 곱해짐
- 예 : $$S_x$$ 가 2이면 x축 방향으로 2배 커짐

---

## Rotation (회전 변환)
오브젝트를 특정 축을 기준으로 회전

**X축 기준 회전**

$$
R_x(\theta) = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\theta & -\sin\theta & 0 \\
0 & \sin\theta & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

**Y축 기준 회전**

$$
R_y(\theta) = \begin{pmatrix}
\cos\theta & 0 & \sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-\sin\theta & 0 & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

**Z축 기준 회전**

$$
R_z(\theta) = \begin{pmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\
\sin\theta & \cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

삼각함수(sin, cos)를 사용하여 정점의 좌표를 회전

---

## Translation (이동 변환)
오브젝트를 특정 방향으로 일정 거리만큼 이동

$$ 
T = \begin{pmatrix}
1 & 0 & 0 & T_x \\
0 & 1 & 0 & T_y \\
0 & 0 & 1 & T_z \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

이 행렬을 정점 벡터와 곱하면 정점의 각 좌표에 $$(T_x, T_y, T_z)$$가 더해지는 결과

- 동차 좌표의 w요소(보통 1) 덕분에 행렬의 마지막 열이 이동 값으로 작용하여 덧셈 연산을 곱셈으로 구현

---

# Vertex Transformation Pipeline
실제 셰이더 코드에서는 이 모든 행렬을 미리 CPU에서 곱한 후, 하나의 최종 행렬(WVP 행렬)을 GPU로 보내는 경우가 많음
> - 정점마다 여러 번의 행렬 곱셈을 하지 않고 한 번만 수행하여 효율을 높이기 위함

$$
V_{clip} = M_{projection} \cdot M_{view} \cdot M_{world} \cdot V_{local}
$$

---

$$
M_{wvp} = M_{projection} \cdot M_{view} \cdot M_{world}
$$

---

$$
V_{clip} = M_{wvp} \cdot V_{local}
$$

버텍스 셰이더가 로컬 좌표를 최종 클립 공간 좌표로 변환하는 전체적인 수학적 흐름

- $$V_{clip}$$ : 최종 클립 공간 좌표 (Clip Space Position)
- $$V_{local}$$ : 로컬 공간 좌표 (Local Space Position)
- $$M_{world}$$ : 월드 행렬 (World Matrix)
- $$M_{view}$$ : 뷰 행렬 (View Matrix)
- $$M_{projection}$$ : 투영 행렬 (Projection Matrix)

---

# Local to World (로컬 공간 → 월드 공간)
오브젝트의 고유 좌표계(로컬 공간)에서 게임 세계 전체의 공통 좌표계(월드 공간)로 변환


---

$$
V_{world} = M_{world} \cdot V_{local}
$$

---

- $$V_{local}$$: 로컬 공간의 정점 좌표 $$(x, y, z, 1)$$
- $$M_{world}$$: 월드 변환 행렬
- $$V_{world}$$: 월드 공간으로 변환된 정점 좌표

`월드 행렬(World Matrix)` : 보통 크기, 회전, 이동 변환 행렬의 조합으로 만들어 짐
- ($$M_{world} = T \cdot R \cdot S$$)
- 3D 모델 오브젝트가 게임 월드의 특정 위치에, 특정 크기와 방향을 가지고 배치됨

## Local to World 예시
- 오브젝트를 y축으로 45도 회전($$R_y$$)
- 월드 공간의 (10, 0, 5) 위치로 이동($$T$$)시킨다고 가정
- (크기 변환 S는 단위 행렬로 생략)

---

$$
 R_y(45^{\circ}) = \begin{pmatrix}
\cos(45) & 0 & \sin(45) & 0 \\ 0 & 1 & 0 & 0 \\ -\sin(45) & 0 & \cos(45) & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
= 
\begin{pmatrix}
0.707 & 0 & 0.707 & 0 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

$$
 T(10, 0, 5) = \begin{pmatrix}
1 & 0 & 0 & 10 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

$$
 M_{world} = 
\begin{pmatrix}
1 & 0 & 0 & 10 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
0.707 & 0 & 0.707 & 0 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
=
\begin{pmatrix}
0.707 & 0 & 0.707 & 10 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

- 월드 행렬은 $$M_{world} = T \cdot R_y$$ 순서로 곱함 (오브젝트를 먼저 회전시킨 후 이동)

> - 참고: 행렬 곱셈은 오른쪽에서 왼쪽으로 적용됨
> - `V_world = (T * R) * V_local` 은 `V_local`을 먼저 회전(R)시키고, 그 결과를 이동(T)시키는 것과 같다


---

# World to View (월드 공간 → 뷰 공간)
월드 공간의 정점들을 카메라의 시점으로 변환

---

$$
V_{view} = M_{view} \cdot V_{world}
$$

---

- $$V_{world}$$: 월드 공간의 정점 좌표
- $$M_{view}$$: 뷰 변환 행렬
- $$V_{view}$$: 뷰 공간(카메라 시점)으로 변환된 정점 좌표

---

- **뷰 매트릭스** : "모든 정점을 카메라 좌표계로 이동시키는 변환 도구"
- **카메라 위치** : 월드 공간에서 카메라의 실제 좌표 (뷰 매트릭스 계산에 사용)

> 화면은 고정되어 있고 배경이 움직이면 움직이는 듯한 착시효과를 일으킨다. (카메라 이동 ≠ 뷰 매트릭스)

$$
\mathbf{M}_{view} = (\mathbf{M}_{camera})^{-1}
$$

---

## World to View 예시
- 카메라가 월드 좌표계에서 `(X=5, Y=3, Z=-2)` 에 위치한다고 가정
- 뷰 매트릭스 생성

$$
\mathbf{M}_{view} = \begin{bmatrix}
1 & 0 & 0 & -5 \\
0 & 1 & 0 & -3 \\
0 & 0 & 1 & 2 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

- `-5, -3, +2` 이동 : 모든 오브젝트들이 카메라 반대 방향으로 움직임
> - 따라서 카메라 공간에서 카메라는 항상 `0,0,0`
> - 오브젝트들은 월드 좌표에서 `(-5,-3,+2)` 만큼 이동한 위치로 변환

좌표계| 카메라 위치 |	큐브 위치 | 	설명| 
월드 공간| 	(5,3,-2)	| (7,3,-2)	| 카메라에서 큐브는 오른쪽 2m | 
카메라 공간	| (0,0,0)	| (2,0,0)	| 큐브가 카메라 기준 +X 방향에 있음| 

> - 모든 정점을 카메라 기준으로 재배치하는 이 과정이 다음 단계인 투영 변환을 훨씬 간단하게 만들어 줌

---

## View Matrix 구성 요소

|벡터 |	설명|	시각적 비유|
eye	|카메라의 월드 공간 위치 | "카메라의 렌즈"|
at	| 카메라가 바라보는 목표점 |	"사진작가가 렌즈를 조준하는 점" |
up | 카메라의 머리 부분 위치 | "카메라를 들 때 위쪽을 가리키는 방향" |

## eye, at, up의 수학적 의미와 역할

---

1. **eye - 공간의 원점(Origin)**
    - 월드 공간 내에서 정의된 카메라 좌표계의 원점
      - **뷰 공간의 (0, 0, 0)이 월드 공간의 어느 지점에 위치하는지를 나타내는 위치 벡터(Position Vector)**
2. **at  - Z축을 정의하는 점**
    -  eye 벡터와 함께 카메라 좌표계의 한 축(Z축)의 방향을 결정하는 데 사용되는 월드 공간 상의 위치 벡터
    - at 자체는 방향이 아니며, 오직 **eye와의 관계를 통해서만 의미를 가짐**
       - 벡터 `(at - eye)`는 eye에서 at을 향하는 방향 벡터를 생성함
       - 이 벡터를 정규화(normalize)하면 **카메라의 로컬 Z축이 됨**
       - `z_axis = normalize(at - eye)`
1. **up - 평면을 결정하여 나머지 축들을 정의**
 - 카메라의 Z축에 대한 회전을 결정하기 위해 기준 평면을 정의하는 방향 벡터(Direction Vector)
   - X축 정의 : **up 벡터는 Z축과 외적(cross product)**하여, Z축과 up 벡터 모두에 수직인 새로운 벡터를 생성함
      - 이 벡터가 바로 **카메라의 로컬 X축**
      - `x_axis = normalize(cross(up, z_axis))`
      - up 벡터가 Z축과 평행하지만 않다면, 이 계산을 통해 항상 유일한 X축을 결정할 수 있다
   - Y축 정의: Z축과 X축이 결정되면, 이 두 축에 모두 수직인 마지막 축, 즉 카메라의 로컬 Y축을 외적을 통해
      계산할 수 있다
      - `y_axis = cross(z_axis, x_axis)`

|	좌표계|	'앞' 방향 (Forward)|		Z축 계산 (z_axis)	|	이유|	
DirectX (왼손)|		+Z	|	normalize(at - eye)|		바라보는 방향(at - eye) = +Z|	
OpenGL (오른손)|		-Z	|	normalize(eye - at)	|	바라보는 방향(at - eye) = -Z|	


---

⚠️**주의**
- up 벡터가 z_axis와 완전히 평행하면 외적(cross) 계산이 실패함
- 평행한 경우, up을 (0,1,0.001)처럼 미세하게 변경하여 계산

### 결론
- 우리가 직관적으로 이해하기 쉬운 eye(위치), at(목표), up(방향) 정보로 카메라를 정의
- 이 세 가지 정보를 이용해 카메라 축 계산

---

1. eye와 at로부터 `z_axis` (방향)를 구함
2. up과 z_axis로부터 `x_axis` (오른쪽)를 구함
3. z_axis와 x_axis로부터 `y_axis` (위쪽)를 구함

> - 이렇게 얻어진 x_axis, y_axis, z_axis는 서로 수직이며 크기가 1인 벡터
> - 카메라의 3차원 회전을 정의하는 회전 행렬(Rotation Matrix)의 기반이 됨

---

## view matrix 구하기
1. **회전(Rotation)**
   - 월드 전체를 돌려서, 월드의 X, Y, Z축이 카메라의 로컬 축(xaxis, yaxis, zaxis)과 나란히
      정렬되도록 함
2. **이동(Translation)**
   - 회전된 월드 전체를 다시 이동시켜, 월드에 있던 카메라의 위치(eye)가 월드 원점(0,0,0)으로 오도록 함

> 이 두가지 변환을 하나의 행렬로 표현한 것이 View Matrix

---

- view matrix

 $$
  M_{view} =
  \begin{pmatrix}
  \color{#1E90FF}{x_{axis}.x} & \color{#1E90FF}{x_{axis}.y} & \color{#1E90FF}{x_{axis}.z} &
  \color{orange}{-dot(x_{axis}, eye)} \\
  \color{#32CD32}{y_{axis}.x} & \color{#32CD32}{y_{axis}.y} & \color{#32CD32}{y_{axis}.z} &
  \color{orange}{-dot(y_{axis}, eye)} \\
  \color{#FF4500}{z_{axis}.x} & \color{#FF4500}{z_{axis}.y} & \color{#FF4500}{z_{axis}.z} &
  \color{orange}{-dot(z_{axis}, eye)} \\
  0 & 0 & 0 & 1
  \end{pmatrix}
  $$

---

- `eye(0, 5, -10)`
- `at(0, 0, 0)`
- `up(0, 1, 0)`이라고 가정 (왼손 좌표계 기준)

- 카메라의 로컬 축 계산:
    - `zaxis = normalize(at - eye) = normalize((0, -5, 10)) = (0, -0.447, 0.894)`
    - `xaxis = normalize(cross(up, zaxis)) = normalize((0.894, 0, 0)) = (1, 0, 0)`
    - `yaxis = cross(zaxis, xaxis) = (0, 0.894, 0.447)`

---

- 회전 : 회전의 역변환을 수행
  - 계산한 카메라의 로컬 축 벡터들을 그대로 행렬의 각 행(row)에 넣은 것

$$
\begin{pmatrix}
\color{#1E90FF}{x_{axis}.x} & \color{#1E90FF}{x_{axis}.y} & \color{#1E90FF}{x_{axis}.z} \\
\color{#32CD32}{y_{axis}.x} & \color{#32CD32}{y_{axis}.y} & \color{#32CD32}{y_{axis}.z} \\
\color{#FF4500}{z_{axis}.x} & \color{#FF4500}{z_{axis}.y} & \color{#FF4500}{z_{axis}.z}
\end{pmatrix}
$$

---

- 1행: 카메라의 오른쪽 방향인 xaxis 벡터 (1, 0, 0)
- 2행: 카메라의 위쪽 방향인 yaxis 벡터 (0, 0.894, 0.447)
- 3행: 카메라의 앞쪽 방향인 zaxis 벡터 (0, -0.447, 0.894)

<br>

{: .new-title}
> ❓ 회전 행렬이 이런 구조인 이유?
>
- 어떤 오브젝트를 특정 축으로 회전시키는 행렬은 그 축 벡터들을 열(column)에 배치
- 하지만 View Marix는 반대인 역회전을 해야함
- 회전 행렬의 역행렬은 원래 행렬의 행과 열을 뒤집은 전치 행렬(Transpose Matrix)과 같음

> 따라서 축 벡터들을 행(row)에 배치하는 것만으로 간단하게 역회전 행렬을 만들 수 있다
 
⚠️ **주의** : 위 설명은 직교행렬(Orthogonal Matrix)일 때만 성립

---

- 이동 : 이동의 역변환을 수행
  - 세상을 -eye 만큼 평행이동 시키는 것과 같은 효과
  - 이미 세상이 회전된 후이므로, 회전된 축에 대해 얼마나 이동해야 하는지를 계산

$$
\begin{pmatrix}
\color{orange}{-dot(x_{axis}, eye)} \\
\color{orange}{-dot(y_{axis}, eye)} \\
\color{orange}{-dot(z_{axis}, eye)}
\end{pmatrix}
$$

---

- `dot(xaxis, eye)` : "카메라의 위치 eye가, 카메라의 새로운 X축 방향으로 얼마나 떨어져 있는가?"
- `음수(-)` : 그 거리만큼 정확히 반대로 이동시켜 eye의 X축 성분을 0으로 만듦
-  Y축, Z축에 대해서도 똑같이 계산하여 최종적으로 eye를 원점(0, 0, 0)으로 가져옴

---

- 최종 : `eye(0, 5, -10)`에서 원점을 바라보는 카메라의 뷰 행렬
  - 월드의 모든 정점에 곱해짐

$$
M_{view} =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 0.894 & 0.447 & 0 \\
0 & -0.447 & 0.894 & 11.175 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$


> - 이 계산은 `XMMatrixLookAtLH`와 같은 라이브러리 함수가 자동으로 처리

---

# View to Clip/Projection (뷰 공간 → 클립 공간)
3차원 뷰 공간의 정점들을 2차원 화면에 최종적으로 보여주기 위한 준비 단계로, 카메라의 시야 범위(절두체) 안에 있는 정점들을 정규화된 클립 공간(NDC, Normalized Device Coordinates)으로 변환

---

$$
V_{clip} = M_{projection} \cdot V_{view}
$$

---

- $$V_{view}$$ : 뷰 공간의 정점 좌표
- $$M_{projection}$$ : 투영 변환 행렬
- $$V_{clip}$$ : 클립 공간으로 변환된 정점 좌표 $$(x_c, y_c, z_c, w_c)$$

**참고 링크**
- [pinholeCamera](https://www.scratchapixel.com/lessons/3d-basic-rendering/3d-viewing-pinhole-camera/how-pinhole-camera-works-part-1.html)
- [projection-matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html)
- [Perspective Projection Matrix](https://youtu.be/EqNcqBdrNyI?feature=shared)

---

![](/images/VS_viewfrustum.png)

## Projection Matrix 목표
- 카메라의 시야각과 종횡비로 정의되는 **'뷰 절두체(View Frustum)'** 라는 삐뚤어진 육면체 공간을
- 가로, 세로, 깊이가 모두 -1에서 1 사이인 **'NDC' 라는 정육면체 공간으로 '찌그러뜨리는' 것**

---

$$
\mathbf{M}_{projection} = \text{f(FOV, Aspect Ratio, Near, Far)}
$$

---

## Projection Matrix 구성 요소
- **뷰 절두체(View Frustum)** : 카메라가 볼 수 있는 3D 공간 영역. 가까운 평면(Near Plane)과 먼 평면(Far Plane)으로 잘린 피라미드 형태
- **NDC (Normalized Device Coordinates)** : 최종적으로 2D 화면에 표시될 좌표를 계산하기 위한 표준화된 3D 공간. x, y는 -1에서 1, z는 0에서 1의 범위를 가
   - **n**: 카메라에서 가까운 클리핑 평면까지의 거리 (Near Plane)
   - **f**: 카메라에서 먼 클리핑 평면까지의 거리 (Far Plane)
   - **fov**: 카메라가 세로 방향으로 볼 수 있는 각도
   - **aspect**: 화면의 가로세로 비율 (화면 너비 / 화면 높이)

**변환 목표**
> 뷰 공간의 한 점 $$P(x, y, z)$$를 NDC 공간의 점 $$P_ndc(x_ndc, y_ndc, z_ndc)$$로 변환하기

---

- 나중에 더 추가하기

---

**투영행렬 참고 링크**
- [pinholeCamera](https://www.scratchapixel.com/lessons/3d-basic-rendering/3d-viewing-pinhole-camera/how-pinhole-camera-works-part-1.html)
- [projection-matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html)
- [Perspective Projection Matrix](https://youtu.be/EqNcqBdrNyI?feature=shared)

---

## Clip to Screen (클립 공간 → 스크린 공간)
이 단계는 버텍스 셰이더 이후 **래스터라이저(Rasterizer)** 단계에서 자동으로 처리

-  **원근 분할 (Perspective Division)**
   -  클립 공간 좌표를 $$w_c$$로 나누어 **정규화된 장치 좌표(Normalized Device Coordinates, NDC)**로 변환

$$ 
V_{ndc} = (x_c/w_c, y_c/w_c, z_c/w_c)
$$

- **뷰포트 변환 (Viewport Transform)**
  - NDC 좌표를 실제 창(window)의 픽셀 좌표인 **스크린 좌표**로 변환

---


---

**참고 링크**
- [learnopengl : CoordinateSystems](https://learnopengl.com/Getting-started/Coordinate-Systems)
- [songho.ca : gl_transform](https://www.songho.ca/opengl/gl_transform.html)