---
layout: default
title: "2. Vertex Shader"
parent: "Graphics rendering pipeline"
nav_order: 3
---

# 2. Vertex Shader
가상의 3D 공간에 있는 꼭지점(vertex)들의 위치를 2차원 화면의 좌표로 변환하는 작업을 수행

---

# Vertex Shader Overview
버텍스 쉐이더의 흐름

---
![](../../../images/vertexShaderOverview.png)

1. **로컬 좌표(local coordinates)** 
    - 오브젝트의 로컬 원점(local origin)을 기준으로 한 좌표를 의미
    - 오브젝트가 처음 위치하는 좌표계
2. **월드 좌표(World-space coordinates)**
   - 더 큰 세계의 글로벌 원점(global origin)을 기준으로 한 좌표
   - 여러 오브젝트들이 모두 이 원점을 기준으로 위치함
3. **뷰 공간 좌표 (view-space coordinates)**
   - 카메라나 뷰어의 시점에서 바라본 좌표
4. **클립 좌표(clip coordinates)**
   - `-1.0` 과 `1.0` 범위로 정규화된 좌표
   - 어떤 버텍스가 화면에 나타날지 결정하는 역할을 한다
5. **스크린 좌표(screen coordinates)**
   - Viewport 
   - 에서 정의한 화면 좌표계 범위로 변환된 좌표

---

# Fundamental Transformations
기본 변환 행렬
- 좌표 변환을 이해하기 위해 기본이 되는 크기(Scale), 회전(Rotation), 이동(Translation) 변환

## Scaling (크기 변환)
오브젝트의 크기를 각 축(x, y, z) 방향으로 조절

$$
S = \begin{pmatrix} S_x & 0 & 0 & 0 \\ 0
& S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \end{pmatrix}
$$

정점의 각 요소 $$(V_x, V_y, V_z)$$ 는 대응하는 크기 조절 값 $$(S_x, S_y, S_z)$$와 곱해짐
- 예 : $$S_x$$ 가 2이면 x축 방향으로 2배 커짐

---

## Rotation (회전 변환)
오브젝트를 특정 축을 기준으로 회전

**X축 기준 회전**

$$
R_x(\theta) = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\theta & -\sin\theta & 0 \\
0 & \sin\theta & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

**Y축 기준 회전**

$$
R_y(\theta) = \begin{pmatrix}
\cos\theta & 0 & \sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-\sin\theta & 0 & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

**Z축 기준 회전**

$$
R_z(\theta) = \begin{pmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\
\sin\theta & \cos\theta & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

삼각함수(sin, cos)를 사용하여 정점의 좌표를 회전

---

## Translation (이동 변환)
오브젝트를 특정 방향으로 일정 거리만큼 이동

$$ 
T = \begin{pmatrix}
1 & 0 & 0 & T_x \\
0 & 1 & 0 & T_y \\
0 & 0 & 1 & T_z \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

이 행렬을 정점 벡터와 곱하면 정점의 각 좌표에 $$(T_x, T_y, T_z)$$가 더해지는 결과

- 동차 좌표의 w요소(보통 1) 덕분에 행렬의 마지막 열이 이동 값으로 작용하여 덧셈 연산을 곱셈으로 구현

---

# Vertex Transformation Pipeline
실제 셰이더 코드에서는 이 모든 행렬을 미리 CPU에서 곱한 후, 하나의 최종 행렬(WVP 행렬)을 GPU로 보내는 경우가 많음
> - 정점마다 여러 번의 행렬 곱셈을 하지 않고 한 번만 수행하여 효율을 높이기 위함

$$
V_{clip} = M_{projection} \cdot M_{view} \cdot M_{world} \cdot V_{local}
$$

---

$$
M_{wvp} = M_{projection} \cdot M_{view} \cdot M_{world}
$$

---

$$
V_{clip} = M_{wvp} \cdot V_{local}
$$

버텍스 셰이더가 로컬 좌표를 최종 클립 공간 좌표로 변환하는 전체적인 수학적 흐름

- $$V_{clip}$$ : 최종 클립 공간 좌표 (Clip Space Position)
- $$V_{local}$$ : 로컬 공간 좌표 (Local Space Position)
- $$M_{world}$$ : 월드 행렬 (World Matrix)
- $$M_{view}$$ : 뷰 행렬 (View Matrix)
- $$M_{projection}$$ : 투영 행렬 (Projection Matrix)

---

## Local to World (로컬 공간 → 월드 공간)
오브젝트의 고유 좌표계(로컬 공간)에서 게임 세계 전체의 공통 좌표계(월드 공간)로 변환

$$
V_{world} = M_{world} \cdot V_{local}
$$

- $$V_{local}$$: 로컬 공간의 정점 좌표 $$(x, y, z, 1)$$
- $$M_{world}$$: 월드 변환 행렬
- $$V_{world}$$: 월드 공간으로 변환된 정점 좌표

`월드 행렬(World Matrix)` : 보통 크기, 회전, 이동 변환 행렬의 조합으로 만들어 짐
- ($$M_{world} = S \cdot R \cdot T$$)
- 3D 모델 오브젝트가 게임 월드의 특정 위치에, 특정 크기와 방향을 가지고 배치됨

## 예시
- 오브젝트를 y축으로 45도 회전($$R_y$$)
- 월드 공간의 (10, 0, 5) 위치로 이동($$T$$)시킨다고 가정
- (크기 변환 S는 단위 행렬로 생략)

---

$$
 R_y(45^{\circ}) = \begin{pmatrix}
\cos(45) & 0 & \sin(45) & 0 \\ 0 & 1 & 0 & 0 \\ -\sin(45) & 0 & \cos(45) & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
= 
\begin{pmatrix}
0.707 & 0 & 0.707 & 0 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

$$
 T(10, 0, 5) = \begin{pmatrix}
1 & 0 & 0 & 10 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

$$
 M_{world} = 
\begin{pmatrix}
1 & 0 & 0 & 10 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
0.707 & 0 & 0.707 & 0 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 0 \\ 0 & 0 & 0 & 1
\end{pmatrix}
=
\begin{pmatrix}
0.707 & 0 & 0.707 & 10 \\ 0 & 1 & 0 & 0 \\ -0.707 & 0 & 0.707 & 5 \\ 0 & 0 & 0 & 1
\end{pmatrix}
$$

---

- 월드 행렬은 $$M_{world} = T \cdot R_y$$ 순서로 곱함 (오브젝트를 먼저 회전시킨 후 이동)

> - 참고: 행렬 곱셈은 오른쪽에서 왼쪽으로 적용됨
> - `V_world = (T * R) * V_local` 은 `V_local`을 먼저 회전(R)시키고, 그 결과를 이동(T)시키는 것과 같다


---

## World to View (월드 공간 → 뷰 공간)
월드 공간의 정점들을 카메라의 시점으로 변환

$$
V_{view} = M_{view} \cdot V_{world}
$$

- $$V_{world}$$: 월드 공간의 정점 좌표
- $$M_{view}$$: 뷰 변환 행렬
- $$V_{view}$$: 뷰 공간(카메라 시점)으로 변환된 정점 좌표

`뷰 행렬(View Matrix)` : 카메라의 위치와 방향의 반대 변환(역행렬)
- 세상을 움직여서 카메라를 원점(0,0,0)에 놓고, 카메라가 양의 Z축의 반대 방향을 바라보게 만드는 것과 같음
- 모든 정점을 카메라 기준으로 재배치하는 이 과정은 다음 단계인 투영 변환을 훨씬 간단하게 만들어주기 때문에 필수적

## 예시
- 카메라가 월드 좌표 `eye(0, 5, -10)`에서 `at(0, 0, 0)`을 바라봄
- 카메라의 위쪽 방향이 `up(0, 1, 0)`이라고 가정(Direct3D의 왼손 좌표계 기준)

1.  카메라의 로컬 축 계산:
    - `zaxis = normalize(at - eye) = normalize((0, -5, 10)) = (0, -0.447, 0.894)`
    - `xaxis = normalize(cross(up, zaxis)) = normalize((0.894, 0, 0)) = (1, 0, 0)`
    - `yaxis = cross(zaxis, xaxis) = (0, 0.894, 0.447)`

2.  뷰 행렬 계산:
    - 카메라도 하나의 오브젝트이므로, 월드 변환의 역변환을 통해 뷰 변환을 구함
    - 카메라의 로컬 축과 위치를 사용하여 다음과 같이 구성

$$
 M_{view} = 
\begin{pmatrix}
xaxis.x & yaxis.x & zaxis.x & 0 \\ xaxis.y & yaxis.y & zaxis.y & 0 \\ xaxis.z & yaxis.z & zaxis.z & 0 \\ -dot(xaxis, eye) & -dot(yaxis, eye) & -dot(zaxis, eye) & 1
\end{pmatrix}
= 
\begin{pmatrix}
1 & 0 & 0 & 0 \\ 0 & 0.894 & 0.447 & 0 \\ 0 & -0.447 & 0.894 & 0 \\ 0 & -4.47 & 8.94 & 1
\end{pmatrix}
$$

> - 이 계산은 `XMMatrixLookAtLH`와 같은 라이브러리 함수가 자동으로 처리

---

## View to Clip/Projection (뷰 공간 → 클립 공간)
3차원 뷰 공간을 2차원 화면에 투영하기 위한 준비 단계로, 정점을 `클립 공간`이라는 정규화된 공간으로 변환

$$
V_{clip} = M_{projection} \cdot V_{view}
$$

- $$V_{view}$$ : 뷰 공간의 정점 좌표
- $$M_{projection}$$ : 투영 변환 행렬
- $$V_{clip}$$ : 클립 공간으로 변환된 정점 좌표 $$(x_c, y_c, z_c, w_c)$$

`투영 행렬(Projection Matrix)` : 카메라의 시야각(Field of View), 종횡비(Aspect Ratio), 그리고 렌더링할 거리 범위(Near/Far Plane)를 바탕으로 만들어짐

- 이 변환의 결과로 나온 $$V_{clip}$$의 각 요소는 $$w_c$$로 나누어지기 전의 값
- 하드웨어는 $$-w_c \le x_c, y_c, z_c \le w_c$$ 범위를 벗어나는 정점을 화면 밖으로 간주하여 '클리핑(clipping)' 함
- 원근감을 표현하는 핵심 단계
- 원래 뷰 공간에서의 깊이(z값)가 $$w_c$$ 요소에 저장되어, 이후 단계에서 원근 분할(Perspective Divide)에 사용

---

## Clip to Screen (클립 공간 → 스크린 공간)
이 단계는 버텍스 셰이더 이후 **래스터라이저(Rasterizer)** 단계에서 자동으로 처리

-  **원근 분할 (Perspective Division)**
   -  클립 공간 좌표를 $$w_c$$로 나누어 **정규화된 장치 좌표(Normalized Device Coordinates, NDC)**로 변환

$$ 
V_{ndc} = (x_c/w_c, y_c/w_c, z_c/w_c)
$$

- **뷰포트 변환 (Viewport Transform)**
  - NDC 좌표를 실제 창(window)의 픽셀 좌표인 **스크린 좌표**로 변환

---


---

**참고 링크**
- [learnopengl : CoordinateSystems](https://learnopengl.com/Getting-started/Coordinate-Systems)
- [songho.ca : gl_transform](https://www.songho.ca/opengl/gl_transform.html)