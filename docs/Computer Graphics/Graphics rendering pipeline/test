
  가. Vertex Buffer (정점 버퍼)
   * 정의: 3D 모델을 구성하는 모든 점(Vertex, 정점) 들의 데이터를 담고 있는 메모리 공간(버퍼)입니다.
   * 개념: 3D 모델은 수많은 삼각형(Polygon)으로 이루어져 있고, 이 삼각형은 3개의 정점으로 구성됩니다. 정점
     버퍼에는 각 정점의 위치(x, y, z 좌표) 정보가 필수로 들어가며, 필요에 따라 색상(Color), 법선(Normal, 빛
     계산용), 텍스처 좌표(Texture UV) 등 다양한 부가 정보가 함께 저장됩니다.
   * 비유: "점 잇기" 놀이를 할 때, 도화지에 찍혀있는 점들의 목록이라고 생각하시면 됩니다.

  나. Index Buffer (인덱스 버퍼)
   * 정의: 정점 버퍼에 있는 정점들의 순서(Index, 색인)를 저장하여, 어떤 정점들을 연결해서 삼각형을 만들지
     알려주는 메모리 공간입니다.
   * 개념: 예를 들어 사각형을 2개의 삼각형으로 만들려면 6개의 정점이 필요합니다. 하지만 실제로는 4개의 정점만
     있으면 되죠. 이때 정점 버퍼에는 4개의 정점 데이터만 저장하고, 인덱스 버퍼에 (0, 1, 2) 와 (0, 2, 3) 처럼
     정점의 순번을 저장하면, 중복된 정점 데이터를 아낄 수 있습니다.
   * 목적 (사용 이유):
       * 메모리 절약: 중복되는 정점 데이터를 저장하지 않아도 되므로 GPU 메모리를 크게 아낄 수 있습니다.
       * 성능 향상: GPU는 한번 처리한 정점 데이터를 캐시에 저장해두었다가 재사용하는데, 인덱스 버퍼를 사용하면
          캐시 효율이 극대화되어 렌더링 속도가 빨라집니다.
   * 비유: "점 잇기" 놀이에서, 점 목록을 보고 어떤 순서로 선을 그을지 적어놓은 설명서와 같습니다. "1번 점에서
     2번 점으로, 그다음 3번 점으로 선을 그어 삼각형을 만드세요." 와 같은 지시사항이죠.

  다. HLSL (High-Level Shading Language)
   * 정의: GPU(그래픽 카드)에서 실행되는 작은 프로그램인 셰이더(Shader)를 작성하기 위한 프로그래밍 언어입니다.
      C언어와 문법이 매우 유사합니다.
   * 개념: 과거에는 고정된 기능만 수행하던 GPU를 프로그래머가 직접 제어하여 원하는 그래픽 효과를 만들 수 있게
     해주는 언어입니다. 이 언어로 작성된 코드가 바로 아래에서 설명할 Vertex Shader와 Pixel Shader입니다.

  라. Vertex Shader (정점 셰이더)
   * 정의: 정점 버퍼에 있는 모든 정점(Vertex) 각각에 대해 한 번씩 실행되는 프로그램입니다.
   * 주요 목적:
       1. 좌표 변환 (Coordinate Transformation): 3D 모델의 로컬 좌표를 최종적으로 화면에 표시될 2D 좌표로
          변환하는 가장 중요한 작업을 합니다. (월드 변환, 뷰 변환, 투영 변환)
       2. 정점 단위의 효과: 정점의 위치를 움직여서 애니메이션(깃발 펄럭임 등)을 주거나, 정점의 색상을 바꾸는
          등의 작업을 합니다.
   * 입력:
       * 정점 버퍼로부터 받은 단일 정점 데이터 (위치, 색상, 텍스처 좌표 등)
       * CPU로부터 받은 상수 버퍼(Constant Buffer) 데이터 (좌표 변환에 필요한 행렬, 시간 값 등 모든 정점에
         동일하게 적용되는 데이터)
   * 출력:
       * 변환된 정점의 위치 (Clip Space Position): 화면에 그려질 최종 위치 좌표. 이것이 필수 출력입니다.
       * 픽셀 셰이더로 전달할 데이터: 정점의 색상, 텍스처 좌표 등을 다음 단계인 픽셀 셰이더로 넘겨줍니다.

  마. Pixel Shader (픽셀 셰이더)
   * 정의: 화면에 그려질 모든 픽셀(Pixel) 각각에 대해 한 번씩 실행되는 프로그램입니다. (정확히는
     래스터라이제이션 단계를 거친 프래그먼트(Fragment)에 대해 실행됩니다.)
   * 주요 목적:
       1. 최종 색상 결정: 해당 픽셀을 어떤 색으로 칠할지 최종적으로 결정합니다.
       2. 광원 효과 (Lighting): 빛의 방향, 물체의 재질 등을 계산하여 명암을 표현합니다.
       3. 텍스처 매핑 (Texture Mapping): 모델의 표면에 이미지(텍스처)를 입힙니다.
   * 입력:
       * 정점 셰이더에서 출력되어 보간(Interpolated)된 데이터. (예: 삼각형의 세 꼭짓점 색상이 빨강, 초록,
         파랑이라면, 그 사이 픽셀들은 색상이 부드럽게 섞여서 들어옵니다.)
       * CPU로부터 받은 상수 버퍼 데이터 (광원의 위치, 텍스처, 재질 정보 등)
   * 출력:
       * 해당 픽셀의 최종 색상 (RGBA 값): 이것이 필수 출력입니다.

---


  2. 그래픽 렌더링 파이프라인 과정

  이제 위 요소들이 어떻게 함께 작동하여 화면에 무언가를 그리는지 순서대로 설명하겠습니다.

  [CPU 단계]

   1. 데이터 준비: 프로그래머가 코드(C++)로 3D 모델의 정점 데이터(위치, 색상 등)와 인덱스 데이터를 정의합니다.
   2. 버퍼 생성 및 데이터 전송: 준비된 데이터로 Vertex Buffer와 Index Buffer를 생성하고, 이 버퍼들을 CPU
      메모리에서 GPU 메모리로 복사합니다. 셰이더에서 사용할 상수 버퍼(행렬 등)도 이때 함께 전송합니다.

  [GPU 단계] - 렌더링 파이프라인 시작

   3. Input Assembler (입력 조립기):
       * GPU는 우리가 지정한 Vertex Buffer와 Index Buffer를 읽습니다.
       * 인덱스 버퍼의 "설명서"를 보고, 정점 버퍼에서 필요한 정점들을 가져와 기본 도형(Primitive), 즉
         삼각형으로 조립합니다.

   4. Vertex Shader (정점 셰이더):
       * 조립된 삼각형의 각 정점마다 정점 셰이더 코드가 실행됩니다.
       * 입력: 정점 데이터(위치, 색상 등), 변환 행렬(상수 버퍼)
       * 처리: 주로 행렬 곱셈을 통해 3D 공간상의 정점 위치를 2D 화면상의 위치로 변환합니다.
       * 출력: 변환된 위치(필수), 픽셀 셰이더로 넘겨줄 데이터(색상, 텍스처 좌표 등)

   5. Rasterizer (래스터라이저):
       * 정점 셰이더에서 나온 3개의 변환된 정점 위치를 보고, 이 삼각형이 화면의 어떤 픽셀들을 덮고 있는지
         계산합니다.
       * 또한, 정점 셰이더가 넘겨준 데이터(색상 등)를 삼각형 표면 전체에 걸쳐 부드럽게 보간(interpolate)하여
         각 픽셀에 전달할 값을 준비합니다.

   6. Pixel Shader (픽셀 셰이더):
       * 래스터라이저가 "이 픽셀은 삼각형 안쪽에 있다!"라고 알려준 각 픽셀마다 픽셀 셰이더 코드가 실행됩니다.
       * 입력: 보간된 데이터(색상, 텍스처 좌표 등), 텍스처, 광원 정보(상수 버퍼)
       * 처리: 입력된 값을 사용해 빛 계산, 텍스처 색상 조회 등 복잡한 연산을 수행하여 최종 색상을 계산합니다.
       * 출력: 픽셀의 최종 RGBA 색상 값(필수)

   7. Output Merger (출력 병합기):
       * 픽셀 셰이더가 계산한 최종 색상 값을 화면 버퍼(Back Buffer)에 씁니다. 이때 깊이 값(Z-buffer)을
         비교하여 더 앞에 있는 물체만 그리는 등의 최종 작업을 처리합니다.
       * 이 과정이 모두 끝나면 백 버퍼의 내용이 화면(Front Buffer)에 표시되고, 우리는 결과를 보게 됩니다.