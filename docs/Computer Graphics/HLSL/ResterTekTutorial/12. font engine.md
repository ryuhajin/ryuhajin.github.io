---
layout: default
title: "12. font engine"
parent: "ResterTekTutorial"
nav_order: 13
---

# 12. font engine
화면에 텍스트 쓰기

## 프레임 워크 요소
- **FontClass** 추가 : **글꼴 데이터를 저장**하고 문자열 렌더링에 필요한 정점 버퍼 생성
-   **TextClass** 추가 : 화면에 렌더링해야 하는 각 텍스트 문자열 세트에 대한 **정점 버퍼와 인덱스 버퍼 설정**
-   **FontShaderClass** 추가 : 폰트 쉐이더로 해당 버퍼 렌더링

---

## Font data
- font.txt

```
32   0.0           0.0           0
33 ! 0.0           0.00390625    4
34 " 0.0048828125  0.0107421875  6
35 # 0.01171875    0.025390625   14
36 $ 0.0263671875  0.0390625     13
37 % 0.0400390625  0.0546875     15
38 & 0.0556640625  0.0693359375  14

//...
```

순서대로
> [문자의 ASCII 값] [문자] [왼쪽 텍스처 U 좌표] [오른쪽 텍스처 U 좌표] [문자의 픽셀 너비]

---

## Font data Load
위에 있는 `font.txt` 파일을 읽어 `m_Font` 배열에 저장


```c++
struct FontType
{
    float left, right;
    int size;
};

// 폰트 텍스트 파일 파싱하여 FontType에 데이터 저장하기
bool FontClass::LoadFontData(char* filename)
{
	ifstream fin;
	int i;
	char temp;


	// Create the font spacing buffer.
	m_Font = new FontType[95];

	// Read in the font size and spacing between chars.
	fin.open(filename);
	if (fin.fail())
	{
		return false;
	}

	// Read in the 95 used ascii characters for text.
	for (i = 0; i < 95; i++)
	{
		fin.get(temp);
		while (temp != ' ')
		{
			fin.get(temp);
		}
		fin.get(temp);
		while (temp != ' ')
		{
			fin.get(temp);
		}

		fin >> m_Font[i].left;
		fin >> m_Font[i].right;
		fin >> m_Font[i].size;
	}

	// Close the file.
	fin.close();

	return true;
}
```

---

## font vertex array
각 문자마다 문자를 그릴 사각형 생성해주기

```c++
// text class에서 호출되어 입력으로 전송된 텍스트 문장 기반으로 정점 버퍼 생성
void FontClass::BuildVertexArray(void* vertices, char* sentence, float drawX, float drawY)
{
	VertexType* vertexPtr;
	int numLetters, index, i, letter;


	// 매개변수 vertices를 VertexType 구조체로 변환
	vertexPtr = (VertexType*)vertices;

	// 문장의 문자 수를 가져오기
	numLetters = (int)strlen(sentence);

	// 배열의 인덱스 초기화
	index = 0;

	// 텍스처 좌표와 픽셀 크기를 갖는 m_Font 배열을 사용하여 글꼴 텍스처의 문자를 두 삼각형에 매핑
	// 각 문자를 사각형에 그리기 (사각형 = 두개의 삼각형)

	for (i = 0; i < numLetters; i++)
	{
		// 아스키 코드를 m_font 배열의 유효한 0기반 인덱스로 변환
		letter = ((int)sentence[i]) - 32;

		// 공백 문자일 경우 3픽셀 이동
		if (letter == 0)
		{
			drawX = drawX + m_spaceSize;
		}
		else
		{
			// First triangle in quad.
			vertexPtr[index].position = XMFLOAT3(drawX, drawY, 0.0f);  // Top left.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 0.0f);
			index++;

			vertexPtr[index].position = XMFLOAT3((drawX + m_Font[letter].size), (drawY - m_fontHeight), 0.0f);  // Bottom right.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 1.0f);
			index++;

			vertexPtr[index].position = XMFLOAT3(drawX, (drawY - m_fontHeight), 0.0f);  // Bottom left.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 1.0f);
			index++;

			// Second triangle in quad.
			vertexPtr[index].position = XMFLOAT3(drawX, drawY, 0.0f);  // Top left.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 0.0f);
			index++;

			vertexPtr[index].position = XMFLOAT3(drawX + m_Font[letter].size, drawY, 0.0f);  // Top right.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 0.0f);
			index++;

			vertexPtr[index].position = XMFLOAT3((drawX + m_Font[letter].size), (drawY - m_fontHeight), 0.0f);  // Bottom right.
			vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 1.0f);
			index++;

			// Update the x location for drawing by the size of the letter and one pixel.
			drawX = drawX + m_Font[letter].size + 1.0f;
		}
	}

	return ;
}
```

---

# KEYWORD NOTE
헷갈리는 키워드 정리

## ShaderResourceView
**셰이더가 텍스쳐를 어떻게 해석할지 방법 지정**
- GPU가 리소스에 안전하게 접근할 수 있는 인터페이스를 제공

### ShaderResourceView 사용 예시
- 동일한 텍스쳐를 두 가지 방식으로 해석하기

```c++
// 같은 텍스처를 두 가지 방식으로 해석하는 예제

ID3D11Texture2D* texture; // 원본 텍스처

// SRV 1: RGB 채널로 해석 (색상 텍스처용)
D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc1;
ID3D11ShaderResourceView* srvColorSRV;

srvDesc1.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // 컬러로 해석

// SRV 2: R 채널만 해석 (흑백 높이맵용)
D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc2;
ID3D11ShaderResourceView* srvHeightSRV;

srvDesc2.Format = DXGI_FORMAT_R8_UNORM; // 흑백으로 해석

// 같은 텍스처, 다른 SRV 두 개 생성
m_device->CreateShaderResourceView(texture, &srvDesc1, &srvColorSRV);
m_device->CreateShaderResourceView(texture, &srvDesc2, &srvHeightSRV);
```

---

- 픽셸 쉐이더에서 여러 SRV 사용 예시

```c++
// 실제 게임에서의 사용 예시
class Character {
    ID3D11Texture2D* m_diffuseTexture;    // 알베도 맵 (색상)
    ID3D11Texture2D* m_normalTexture;     // 노말 맵 (법선 벡터)
    ID3D11Texture2D* m_specularTexture;   // 스페큘러 맵 (반사 강도)
    
    // 각 텍스처별로 SRV 생성
    ID3D11ShaderResourceView* m_diffuseSRV;
    ID3D11ShaderResourceView* m_normalSRV; 
    ID3D11ShaderResourceView* m_specularSRV;
};

// 픽셀 셰이더에서 동시에 여러 SRV 사용
void RenderCharacter() {
    // 각 SRV를 다른 슬롯에 바인딩
    context->PSSetShaderResources(0, 1, &m_diffuseSRV);    // t0: 색상
    context->PSSetShaderResources(1, 1, &m_normalSRV);     // t1: 법선
    context->PSSetShaderResources(2, 1, &m_specularSRV);   // t2: 반사
}
```

---

## SUBRESOURCE_DATA vs SHADER_RESOURCE_VIEW
두 구조체의 역할이 헷갈려서 다시 알아보았다

- **D3D11_SUBRESOURCE_DATA** : 데이터를 VRAM에 복사
- **D3D11_SHADER_RESOURCE_VIEW_DESC** : 어떤 종류의 리소스인지 셰이더에게 해석 넘김

---

```c++
// [1단계]: 데이터 준비 (SUB_RESOURCE_DATA)
std::vector<unsigned char> imageData = LoadImage("character.png");

D3D11_SUBRESOURCE_DATA textureData;
textureData.pSysMem = imageData.data();    // "데이터는 여기있어"
textureData.SysMemPitch = 512 * 4;         // "한 줄은 2048바이트야"
textureData.SysMemSlicePitch = 0;

// [2단계]: 텍스처 생성 (GPU 메모리에 데이터 복사)
ID3D11Texture2D* texture;
device->CreateTexture2D(&texDesc, &textureData, &texture);
// ↑ 여기서 textureData의 역할 끝! 데이터 전달 완료

// [3단계]: 해석 방법 설정 (SHADER_RESOURCE_VIEW_DESC)  
D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // "이 텍스처는 RGBA야!"
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
srvDesc.Texture2D.MostDetailedMip = 0;
srvDesc.Texture2D.MipLevels = 1;

// [4단계]: SRV 생성 (셰이더에서 읽을 수 있게)
ID3D11ShaderResourceView* srv;
device->CreateShaderResourceView(texture, &srvDesc, &srv);
```

구분	| D3D11_SUBRESOURCE_DATA	| D3D11_SHADER_RESOURCE_VIEW_DESC| 
목적 | 	CPU → GPU 데이터 복사	| 리소스 해석 방법 정의| 
사용 시점| 	리소스 생성할 때	| SRV 생성할 때| 
데이터 소스| 	CPU 메모리| 	GPU 메모리 (이미 있는 리소스)| 
수명	| 일회성 사용| 	SRV와 함께 유지| 

- **SubResourceData** : "데이터를 어떻게 GPU에 올릴지"
- **ShaderResourceViewDesc** : "올라간 데이터를 어떻게 해석할지"

---

## View
리소스는 그냥 데이터 컨테이너일 뿐, 뷰를 통해야만 역할이 부여

> Direct3D는 모든 리소스 접근에 뷰(View) 시스템을 사용한다

- **SRV(Shader Resource View)**: GPU에 리소스 해석 설정
- **RTV(Render Target View)**: GPU에 렌더링 결과를 여기에 쓰라고 알림
- **UAV(Unordered Access View)**: 컴퓨트 셰이더에게 병렬 처리 가능한 리소스라고 알림
- **DSV(Depth Stencil View)**: 해당 리소스를 깊이/스텐실 버퍼로 사용하라고 알림

리소스는 직접 접근하지 않고, 뷰를 통해 접근한다

---

# Vertex Input Layout (정점 입력 레이아웃)
GPU가 메모리에 저장된 정점(Vertex) 데이터를 어떻게 해석해야 하는지 알려주는 설명서

## 정점 입력 레이아웃이 뭐야?

1. 3D 모델은 수많은 정점(Vertex)들로 구성됨
2. 각 정점은 **위치, 색상, 텍스처 좌표, 법선 벡터(Normal Vector) 등 다양한 속성**들을 가짐
3. 이 정점 데이터는 GPU 메모리의 버퍼(Vertex Buffer)에 저장됨

> 문제는 이 버퍼가 그저 연속된 바이트(byte) 덩어리일 뿐이라는 점

- GPU는 이 바이트 덩어리에서 어떤 부분이 위치이고
- 어떤 부분이 색상이며
- 어떤 데이터 타입(float, int 등)을 가지는지 **알 수 없다**

> 정점 입력 레이아웃은 바로 이 문제를 해결해줌

---

이는 다음과 같은 정보를 포함하여 GPU에 정점 데이터의 구조를 명확하게 알림

- **Semantic Name** (각 정점 속성의 의미) 
    - "이것은 위치(POSITION)다"
    - "이것은 색상(COLOR)이다"
    - "이것은 텍스처 좌표(TEXCOORD)다" 등등
- **struct** 구조체 설정
  - `struct Vertex { float x, y, z; float u, v; };` 와 같이 정점 데이터를 정의
  - 정점 입력 레이아웃은 **C++ 코드의 정점 구조체와 셰이더의 입력 구조체가 서로 일치하도록 보장**
  - GPU가 정점 버퍼의 원시 데이터를 셰이더가 이해할 수 있는 형태로 파싱할 수 있게 해줌

---

### 사용 예시 코드

-  C++에서 정의하는 정점 구조체

```c++

  //    이 구조체의 메모리 레이아웃을 GPU에 알려주는 것이 Input Layout의 목적
  struct VertexType
  {
      DirectX::XMFLOAT3 position; // 3D 위치 (x, y, z)
      DirectX::XMFLOAT2 texture;  // 텍스처 좌표 (u, v)
      DirectX::XMFLOAT4 color;    // 색상 (r, g, b, a)
  };
```

---

- 정점 입력 레이아웃 설명 (D3D11_INPUT_ELEMENT_DESC 배열)

```c++
  // 이 배열이 GPU에게 VertexType 구조체가 어떻게 생겼는지 알림
// VertexType에 3가지 요소가 있으므로 배열 크기 3
  D3D11_INPUT_ELEMENT_DESC polygonLayout[3];

  // 첫 번째 요소: 위치 (POSITION)
  polygonLayout[0].SemanticName = "POSITION";         // 셰이더에서 'POSITION' 시맨틱과 매칭
  polygonLayout[0].SemanticIndex = 0;                 // POSITION0 (하나만 있으므로 0)
  polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT; // 3개의 float (X, Y, Z)
  polygonLayout[0].InputSlot = 0;                     // 0번 정점 버퍼 슬롯에서 가져옴
  polygonLayout[0].AlignedByteOffset = 0;             // 정점 구조체 시작으로부터 0바이트 오프셋
  polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; // 정점마다 데이터가 다름
  polygonLayout[0].InstanceDataStepRate = 0;          // 인스턴싱 사용 안 함

  // 두 번째 요소: 텍스처 좌표 (TEXCOORD)
  polygonLayout[1].SemanticName = "TEXCOORD";
  polygonLayout[1].SemanticIndex = 0;
  polygonLayout[1].Format = DXGI_FORMAT_R32G32_FLOAT; // 2개의 float (U, V)
  polygonLayout[1].InputSlot = 0;
  polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT; // 이전 요소 뒤에 자동으로 오프셋 계산
  polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
  polygonLayout[1].InstanceDataStepRate = 0;

  // 세 번째 요소: 색상 (COLOR)
  polygonLayout[2].SemanticName = "COLOR";
  polygonLayout[2].SemanticIndex = 0;
  polygonLayout[2].Format = DXGI_FORMAT_R32G32B32A32_FLOAT; // 4개의 float (R, G, B, A)
  polygonLayout[2].InputSlot = 0;
  polygonLayout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT; // 이전 요소 뒤에 자동으로 오프셋 계산
  polygonLayout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
  polygonLayout[2].InstanceDataStepRate = 0;
```

---

- 입력 레이아웃 객체 생성

```c++
  //    ID3D11Device* device; // D3D 디바이스 객체 (초기화되어 있어야 함)
  //    ID3DBlob* vertexShaderBuffer; // 컴파일된 버텍스 셰이더 바이트코드 (초기화되어 있어야 함)
  ID3D11InputLayout* m_layout = nullptr;
  unsigned int numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]); // 배열 요소 개수

  device->CreateInputLayout(
      polygonLayout,          // 위에서 정의한 레이아웃 설명 배열
      numElements,            // 배열 요소 개수
      vertexShaderBuffer->GetBufferPointer(), // 버텍스 셰이더 바이트코드 포인터
      vertexShaderBuffer->GetBufferSize(),    // 버텍스 셰이더 바이트코드 크기
      &m_layout               // 생성될 ID3D11InputLayout 객체 포인터
  );
  if (FAILED(hr)) { } // 에러처리
```

---

- 입력 레이아웃 바인딩 (렌더링 파이프라인 설정 시)

```c++
  //    ID3D11DeviceContext* deviceContext; // D3D 디바이스 컨텍스트 객체 (초기화되어 있어야 함)
  deviceContext->IASetInputLayout(m_layout); // Input Assembler (IA) 스테이지에 레이아웃 설정
```
---

- 버텍스 셰이더 입력 구조체 (HLSL 코드)

```c++
  //    이 HLSL 구조체는 C++의 VertexType과 Input Layout에 정의된 내용과 정확히 일치해야 힘

  struct VertexInputType
  {
      float3 position : POSITION; // SemanticName "POSITION", SemanticIndex 0
      float2 tex      : TEXCOORD; // SemanticName "TEXCOORD", SemanticIndex 0
      float4 color    : COLOR;    // SemanticName "COLOR", SemanticIndex 0
  };
```

정점 입력 레이아웃은 GPU가 정점 버퍼의 데이터를 올바르게 읽고, 이를 버텍스 셰이더의 입력으로 정확하게 전달하기 위한 필수적인 설정 단계이다

---

# Sampler (샘플러)
샘플러는 텍스처에서 색상(또는 다른 데이터)을 가져오는(샘플링하는) 방법을 정의하는 GPU의 구성 요소

- 3D 모델에 텍스처를 입힐 때, 화면의 각 픽셀에 해당하는 텍스처 좌표(UV)가 주어지면
- 샘플러는 이 좌표를 사용하여 텍스처 이미지에서 어떤 색상 값을 가져올지 결정

---

## 샘플링이 필요한 이유?
1. **비정수 텍스처 좌표**
- 화면 픽셀에 해당하는 텍스처 좌표는 텍스처 이미지의 실제 픽셀(텍셀, Texel) 중심과 정확히 일치하지 않는 경우가 많음
2. **확대/축소**
- 텍스처가 화면에서 확대되거나 축소될 때, 하나의 텍셀이 여러 화면 픽셀을 덮거나 여러 텍셀이 하나의 화면 픽셀에 압축될 수 있다
- 이때 어떤 색상을 가져와야 자연스러운 결과를 얻을지 결정해야 함
1. **성능 최적화**
- 밉맵(Mipmap)과 같은 기술을 사용하여 텍스처의 축소 시 발생하는 앨리어싱(aliasing) 현상을 줄이고 성능을 향상

---

## SamplerState

`SamplerState`는 텍스처 샘플링 방식을 정의하는 객체

- C++ 코드에서 `D3D11_SAMPLER_DESC` 구조체를 채우고
- `ID3D11Device::CreateSamplerState()` 함수를 호출하여 생성

---

### 코드 예시

- D3D11_SAMPLER_DESC : SamplerState를 정의하는 구조체

```cpp
D3D11_SAMPLER_DESC samplerDesc;
ZeroMemory(&samplerDesc, sizeof(samplerDesc));

// 필터링 설정: 텍스처 확대/축소/밉맵 시 어떤 방식으로 색상을 보간할지 결정
// D3D11_FILTER_MIN_MAG_MIP_LINEAR: 축소, 확대, 밉맵 모두 선형 필터링 (부드러움)
// D3D11_FILTER_MIN_MAG_MIP_POINT: 축소, 확대, 밉맵 모두 점 필터링 (선명하지만 계단 현상)
samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;

// 주소 모드 설정: 텍스처 좌표가 0.0~1.0 범위를 벗어났을 때 처리 방식
samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;   // U 좌표가 범위를 벗어나면 반복 (타일링)
samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;   // V 좌표가 범위를 벗어나면 반복
samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;   // W 좌표 (3D 텍스처용)

// 밉맵 관련 설정 (선택 사항)
samplerDesc.MipLODBias = 0.0f;                       // 밉맵 레벨 바이어스
samplerDesc.MaxAnisotropy = 1;                       // 비등방성 필터링 시 최대 비등방성 값
samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS; // 비교 함수 (주로 섀도우 맵에 사용)
samplerDesc.BorderColor[0] = 0; samplerDesc.BorderColor[1] = 0; // Border 모드 시 경계 색상
samplerDesc.BorderColor[2] = 0; samplerDesc.BorderColor[3] = 0;
samplerDesc.MinLOD = 0;                              // 최소 밉맵 레벨
samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;              // 최대 밉맵 레벨
```

---

- SamplerState 객체 생성

```c++
ID3D11SamplerState* m_sampleState = nullptr;
HRESULT hr = device->CreateSamplerState(&samplerDesc, &m_sampleState);
if (FAILED(hr)) { } // 에러처리
```

---

- 셰이더에 바인딩

```c++
// 생성된 SamplerState를 픽셀 셰이더에 바인딩
deviceContext->PSSetSamplers(0, 1, &m_sampleState); // 0번 슬롯에 바인딩
```

---

- 픽셀 셰이더와의 연계

```c++
// C++에서 ID3D11SamplerState* 로 바인딩된 샘플러 스테이트
// register(s0) : 샘플러 스테이트가 0번 샘플러 슬롯에 바인딩되었음을 나타냄
SamplerState SampleType : register(s0); 

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0; // 텍스처 좌표
};

float4 PixelShaderFunction(PixelInputType input) : SV_TARGET
{
    // Sample() 함수를 사용하여 텍스처에서 색상 샘플링
    // SampleType (SamplerState)의 규칙에 따라 shaderTexture (텍스처)에서
    // input.tex (텍스처 좌표) 위치의 색상을 가져옴
    return shaderTexture.Sample(SampleType, input.tex);
}
```

---

## Sample()

HLSL에서 텍스처를 샘플링하기 위한 내장 함수

```c++
color = shaderTexture.Sample(SampleType, input.tex);
```

- 이 함수는 GPU의 텍스처 샘플링 하드웨어에 직접 명령을 내림

---

## 작동 과정

1.  **입력:** `Sample()` 함수는 두 가지 주요 인자를 받음
    *   **`SamplerState` 객체:** 텍스처를 샘플링할 때 적용할 필터링, 주소 모드 등의 규칙을 정의 (예: `SampleType`)
    *   **텍스처 좌표:** 텍스처에서 색상을 가져올 (U, V) 좌표 (예: `input.tex`)

2.  **좌표 변환 및 텍셀 접근:**
    *   GPU는 주어진 텍스처 좌표(`input.tex`)를 텍스처의 실제 텍셀(픽셀) 좌표로 변환
    *   이때 텍스처 좌표가 0.0 ~ 1.0 범위를 벗어나면 `SamplerState`에 정의된 주소 모드(WRAP, CLAMP 등)에 따라 처리

3.  **필터링 적용:**
    *   변환된 텍셀 좌표가 텍스처의 텍셀 중심과 정확히 일치하지 않거나, 텍스처가 확대/축소된 경우, `SamplerState`에 정의된 필터링 방식(POINT, LINEAR, ANISOTROPIC 등)에 따라 주변 텍셀들의 색상 값을 보간하여 최종 색상을 결정
    *   밉맵이 사용되는 경우, 적절한 밉맵 레벨을 선택하거나 여러 밉맵 레벨 간에 보간하는 과정도 포함

4.  **결과 반환:**
    *   이러한 과정을 거쳐 최종적으로 계산된 색상 값(일반적으로 `float4` RGBA)을 반환
    *   이 색상 값은 픽셀 셰이더의 출력 색상으로 사용되거나, 다른 계산에 활용

> SamplerState는 텍스처 샘플링의 규칙을 정의하는 객체
> - Sample() 함수는 이 규칙을 사용하여 셰이더 내에서 텍스처로부터 색상을 가져오는 GPU의 하드웨어 기능

---
