---
layout: default
title: "8. Specular Lighting"
parent: "ResterTekTutorial"
nav_order: 9
---

# 8. Specular Lighting (정반사광)
매끄럽거나 광택이 나는 표면에서 **빛이 특정 방향으로 강하게 반사되어 생기는 하이라이트를 모델링하는 조명**

- 정반사광은 빛이 거울처럼 특정 각도로 반사되어 우리 눈에 직접 들어올 때만 보이는 밝은 빛이다

---

# Specular Lighting을 계산하는 데 필요한 요소들
하이라이트를 계산하려면 셰이더(Shader) 코드에서 몇 가지 벡터와 값이 필요

1. **광원 벡터 (Light Vector, L)**
- 표면의 한 점에서 광원(조명)을 향하는 방향 벡터
2. **표면 노멀 벡터 (Normal Vector, N)**
- 해당 지점의 표면이 바라보는 방향을 나타내는 벡터. 표면에 수직인 방향
3. **시선 벡터 (View Vector, V)**
- 표면의 한 점에서 카메라(눈)를 향하는 방향 벡터
4. **반사 벡터 (Reflection Vector, R)**
- 광원 벡터(L)가 표면의 법선(N)을 기준으로 반대편으로 반사된 방향 벡터
5. **광택도 (Shininess 또는 Roughness)**
- 표면이 얼마나 매끄러운지를 나타내는 값
  - 값이 높을수록: 하이라이트가 작고 날카로움 (예: 금속, 유리)
  - 값이 낮을수록: 하이라이트가 크고 뭉툭 (예: 플라스틱, 고무)

기본적인 퐁(Phong) 조명 모델에서는 다음과 같은 원리로 정반사광을 계산

> - "반사된 빛의 방향(R)과 우리 눈의 방향(V)이 얼마나 가까운가?"
> - 반사 벡터 (R) 과 눈 방향 (V) 의 방향이 일치할 수록 밝은 하이라이트를 갖게 됨
> - 광택도 값을 조절하여 같은 물체라도 다양한 재질의 느낌을 표현

따라서

1. **둘 사이의 각도를 계산하여 하이라이트의 강도를 결정함**
2. **광택도 값을 제곱 연산(power)의 지수로 사용하여 하이라이트의 집중도를 조절**

---

# Phong Model
- [The Phong Model](https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF/phong-illumination-models-brdf.html)

- RestaerTek 코드 예시

```c++
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
	float3 reflection;
    float4 specular;


	// Sample the pixel color from the texture using the sampler at this texture coordinate location.
	textureColor = shaderTexture.Sample(SampleType, input.tex);

	// Set the default output color to the ambient light value for all pixels.
    color = ambientColor;

	 // Initialize the specular color.
    specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));

	if(lightIntensity > 0.0f)
    {
      // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);

		// Saturate the ambient and diffuse color.
		color = saturate(color);

		// Calculate the reflection vector based on the light intensity, normal vector, and light direction.
        reflection = normalize(2.0f * lightIntensity * input.normal - lightDir); 

		// Determine the amount of specular light based on the reflection vector, viewing direction, and specular power.
        specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower);
    }

    // Multiply the texture pixel and the final diffuse color to get the final pixel color result.
	color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);

	return color;
}
```

---

# Blinn-Phong
블린-퐁은 반사 벡터(R)를 직접 계산하는 대신, **하프웨이 벡터(Halfway Vector, H) 라는 것을 사용**

> - 하프웨이 벡터(H): 광원 벡터(L)와 시선 벡터(V)의 딱 중간 방향을 가리키는 벡터

블린-퐁 모델은 이 **하프웨이 벡터(H)와 법선 벡터(N)가 얼마나 가까운지를 계산한다**

> - "표면의 방향(N)이 빛과 시선의 중간 방향(H)을 얼마나 정확히 바라보고 있는가?"

계산이 더 효율적이고, 특정 상황에서 더 자연스러운 결과를 보여주기 때문에 현대 그래픽스에서 더 널리 사용됨

---

## Blinn-Phong 계산 원리

## 1. 하프웨이 벡터 (Halfway Vector, H) 계산
정반사광을 계산하려는 표면의 한 점을 기준으로 두 개의 벡터를 구함

- **광원 벡터 (L)**: 표면에서 광원을 향하는 단위 벡터
- **시선 벡터 (V)**: 표면에서 카메라(관찰자)를 향하는 단위 벡터

> 하프웨이 벡터는 위 두 벡터의 정확히 중간 방향을 가리키는 단위 벡터

### 하프웨이 벡터 구하기
- 광원 벡터(L)와 시선 벡터(V) 더하기

$$
H = L + V
$$

- 결과 벡터를 정규화(Normalize)하여 크기를 1로 만들기

$$
H = normalize(L + V)
$$

---

## 2. 하이라이트 강도 계산
하이라이트의 밝기를 결정한다. 

- **법선 벡터 (N)**: 표면에 수직인 단위 벡터
- **하프웨이 벡터(H)**: 중간 방향을 가리키는 단위 벡터
 
> 하프웨이 벡터(H)와 표면의 법선 벡터(N)가 얼마나 같은 방향을 바라보는지를 측정

- 표면의 법선 벡터(N)와 하프웨이 벡터(H)가 얼마나 같은 방향을 향하는지 내적(Dot Product)을 통해 계산
- 이 값은 0과 1 사이의 스칼라 값으로, 하이라이트의 기본 밝기를 결정

---

$$
specular_{intensity}  = max(0, dot(H, N))
$$

---

> - 값이 1에 가까울수록 (두 벡터의 방향이 거의 일치), 그 지점은 가장 밝은 하이라이트를 갖게 됨
> - 값이 0에 가까울수록 (두 벡터가 수직에 가까울수록), 하이라이트는 거의 보이지 않게 됨

---

## 3. 광택도 적용하기
위에서 구한 **하이라이트 강도 값에 광택도(Shininess) 계수를 적용하여 하이라이트의 크기를 조절**

- **L_s**: 계산된 반사광의 최종 색상 및 강도
- **k_s**: 물체의 재질에 따라 반사광의 색상과 강도를 정의하는 RGB 값
- **L_light**: 광원의 색상 및 강도
- **shininess**: 광택도를 나타내는 지수

---

$$
L_s = k_s \cdot L_{light} \cdot (specular_{intensity})^{shininess}
$$

---

## shininess 계산 예시
- **매우 낮은 값 (1 ~ 10)**
  - 직물, 무광택 페인트, 거친 나무 등 빛을 넓게 분산시키는 무광 재질을 표현
  - 하이라이트가 매우 넓고 희미하게 나타남
- **중간 값 (50 ~ 200)**
  - 플라스틱, 에나멜 코팅된 표면, 약간 광택이 있는 금속 등 어느 정도의 광택을 가진 재질에 사용
- **높은 값 (200 이상)**
  - 크롬, 유리, 유광 금속 등 매우 매끄럽고 빛을 날카롭게 반사하는 광택 재질을 표현
  - 하이라이트가 매우 작고 강하게 나타남

---

## shininess가 낮은 경우
shininess **값이 2**일 때, 하이라이트 강도의 변화

- (H · N) = 1.0  (정확히 중앙) → $$1.0^2 = 1.0$$ (최대 밝기)
- (H · N) = 0.5 (중앙에서 약간 벗어남) → $$0.5^2 = 0.25$$
- (H · N) = 0.2 (중앙에서 많이 벗어남) → $$0.2^2 = 0.04$$
- (H · N) = 0.0 (하이라이트 영역 밖) → $$0.0^2 = 0.0$$

>  값이 제곱되면서 중앙에서 멀어질수록 강도가 서서히 낮아짐
>  - 이로 인해 넓고 부드러운 하이라이트가 만들어짐

---

## shininess가 높은 경우
shininess **값이 200**일 때, 하이라이트 강도의 변화

- (H · N) = 1.0 (정확히 중앙) → $$1.0^{200} = 1.0$$ (최대 밝기)
- (H · N) = 0.9 (중앙에서 아주 살짝 벗어남) → $$0.9^{200} ≈ 0.000000000012$$ (거의 0에 가까움)
- (H · N) = 0.5 (중앙에서 벗어남) → $$0.5^{200} ≈ 0.0$$

> 값이 200이라는 큰 지수로 거듭제곱되면서, 내적 값이 1에서 아주 조금만 벗어나도 결과값이 급격하게 0으로 수렴
>  - 하이라이트가 매우 작고 날카로운 점처럼 보이게 됨

---

# phong VS Blinn-Phong

- phong Model HLSL 소스코드 예시

```c++
// Pixel Shader
float4 PhongPS(float3 worldPos : WORLDPOS, float3 normal : NORMAL) : SV_Target
{
    // 조명 및 재질 속성 (상수로 선언)
    float3 lightPos = float3(10.0f, 10.0f, -10.0f);
    float3 lightColor = float3(1.0f, 1.0f, 1.0f);
    float3 objectColor = float3(0.0f, 0.5f, 1.0f); // 파란색
    float3 cameraPos = float3(0.0f, 0.0f, -10.0f);
    float shininess = 32.0f;

    // 벡터 계산
    float3 N = normalize(normal); // 법선 벡터
    float3 L = normalize(lightPos - worldPos); // 광원 벡터
    float3 V = normalize(cameraPos - worldPos); // 시선 벡터
    float3 R = reflect(-L, N); // 반사 벡터

    // 1. 주변광 (Ambient)
    float ambientStrength = 0.1f;
    float3 ambient = ambientStrength * lightColor;

    // 2. 난반사광 (Diffuse)
    float diff = max(dot(N, L), 0.0);
    float3 diffuse = diff * lightColor;

    // 3. 정반사광 (Specular)
    float spec = pow(max(dot(V, R), 0.0), shininess);
    float3 specular = spec * lightColor;
    
    // 최종 색상 계산
    float3 result = (ambient + diffuse) * objectColor + specular;
    return float4(result, 1.0f);
}
```
> reflect 함수를 사용하여 반사 벡터 R을 구하고, 이를 시선 벡터 V와 내적(dot)하여 정반사광을 계산

---

- Blinn-Phong HLSL 소스코드 예시

```c++
// Pixel Shader
float4 BlinnPhongPS(float3 worldPos : WORLDPOS, float3 normal : NORMAL) : SV_Target
{
    // 조명 및 재질 속성 (상수로 선언)
    float3 lightPos = float3(10.0f, 10.0f, -10.0f);
    float3 lightColor = float3(1.0f, 1.0f, 1.0f);
    float3 objectColor = float3(0.0f, 0.5f, 1.0f); // 파란색
    float3 cameraPos = float3(0.0f, 0.0f, -10.0f);
    float shininess = 32.0f;

    // 벡터 계산
    float3 N = normalize(normal); // 법선 벡터
    float3 L = normalize(lightPos - worldPos); // 광원 벡터
    float3 V = normalize(cameraPos - worldPos); // 시선 벡터
    float3 H = normalize(L + V); // 하프 벡터

    // 1. 주변광 (Ambient)
    float ambientStrength = 0.1f;
    float3 ambient = ambientStrength * lightColor;

    // 2. 난반사광 (Diffuse)
    float diff = max(dot(N, L), 0.0);
    float3 diffuse = diff * lightColor;

    // 3. 정반사광 (Specular)
    float spec = pow(max(dot(N, H), 0.0), shininess);
    float3 specular = spec * lightColor;

    // 최종 색상 계산
    float3 result = (ambient + diffuse) * objectColor + specular;
    return float4(result, 1.0f);
}
```

> 광원 벡터 L과 시선 벡터 V를 더해 정규화한 **하프 벡터 H**를 구하고, 이를 법선 벡터 N과 내적하여 정반사광을 계산

---

# Clarity Notes
공부하며 헷갈렸던 부분 명료화 하기

---

## bufferNumber
lightshaderclass.cpp 의 `SetShaderParameters()` 의 bufferNumber 사용 목적

- 버텍스 셰이더 :  두 개의 상수 버퍼가 정의

```c++
cbuffer MatrixBuffer  // : register(b0) by default
{
	matrix worldMatrix;
	matrix viewMatrix;
	matrix projectionMatrix;
};

cbuffer CameraBuffer // : register(b1) by default
{
    float3 cameraPosition;
    float padding;
};

```

> - HLSL에서 cbuffer를 선언할 때, 명시적으로 레지스터를 지정하지 않으면
> - 컴파일러가 순서대로 register(b0), register(b1), register(b2)... 와 같이 자동으로 할당

---

- SetShaderParameters()

```c++
// CameraBuffer 설정

// Set the position of the camera constant buffer in the vertex shader.
bufferNumber = 1;

// Now set the camera constant buffer in the vertex shader with the updated values.
deviceContext->VSSetConstantBuffers(bufferNumber, 1, &m_cameraBuffer);
```
- **bufferNumber를 1로 설정하고 VSSetConstantBuffers를 호출**
  - m_cameraBuffer에 담긴 카메라 위치 데이터를 **버텍스 셰이더(VS)의 1번 슬롯(register(b1))에 바인딩**

## 결론
- `bufferNumber = 1;`은 이제부터 **버텍스 셰이더의 1번 상수 버퍼 슬롯에 데이터를 설정하겠다**는 의미

> 그리고 이어지는 VSSetConstantBuffers 함수 호출을 통해 m_cameraBuffer의 내용(카메라 위치)이 버텍스 셰이더의 CameraBuffer(register(b1))로 전달됨

---

## View Direction VS View Matrix
- **viewDirection** : 빛 계산에 사용되는 방향 벡터
- **viewMatrix** : 공간을 변환하는 행렬

---

## View Direction (시선 방향 벡터)
- 목적 : 빛 계산 (Lighting Calculation)
  - viewDirection은 주로 **정반사광(Specular Lighting)을 계산하는 데 필수적**

> 정반사광은 광원에서 나온 빛이 물체 표면에 반사되어 우리 눈(카메라)으로 얼마나 강하게 들어오는지를 표현한다
> - 이 반사광을 계산하려면 표면의 한 지점에서 카메라를 향하는 방향을 알아야 하며
> - 그 역할을 viewDirection이 맡는다

결론 : 물체의 특정 부분이 얼마나 반짝거릴지를 결정하는 데 사용되는 값

### 계산 과정
1. GPU (버텍스 셰이더)에서 **각 정점(vertex)마다 계산됨**
- 코드에서처럼 `cameraPosition.xyz - worldPosition.xyz` 로 계산
  - **worldPosition:** 현재 계산 중인 정점의 월드 공간 위치
  - **cameraPosition**: CPU에서 보내준 카메라의 월드 공간 위치
2. (정점의 위치)에서 (카메라의 위치)를 향하는 벡터를 구한 뒤, 이를 정규화(normalize)하여 길이가 1인
   순수한 방향 벡터로 만들어 픽셀 셰이더로 넘김
- **오브젝트의 모든 정점은 월드에서 위치가 다르므로, 각 정점에서 카메라를 바라보는 viewDirection 벡터도
   모두 미세하게 다름**

---

## View Matrix (뷰 행렬)
- 목적 : 공간 변환 (Coordinate Transformation)
  - viewMatrix의 주된 목적은 **3D 월드에 존재하는 모든 물체(정점)들을 카메라의 시점으로 가져오는 것**

> 3D 공간의 원점에 카메라가 있고 -Z축 방향을 바라보는 것처럼, 월드 전체를 카메라의 좌표계로 변환
> - 이 변환된 공간을 뷰 공간(View Space) 또는 카메라 공간(Camera Space)이라고 부름
> - 이 과정이 있어야 우리가 보는 화면에 물체들이 올바른 위치와 방향으로 그려질 수 있습니다.

### 계산 과정
1. CPU (C++ 애플리케이션)에서 계산
- 일반적으로 카메라의 위치(eye), 카메라가 바라보는 지점(at), 그리고 카메라의 상단 방향(up) 벡터, 이 세
       가지 정보를 이용해 4x4 행렬을 만듦
2. 이렇게 만들어진 행렬은 매 프레임(또는 카메라가 움직일 때마다) **cbuffer를 통해 GPU 셰이더로 전송**
- 셰이더 코드에서는 `output.position = mul(output.position, viewMatrix);` 와 같이 **모든 정점의 위치를 변환하는 데 사용**

---

