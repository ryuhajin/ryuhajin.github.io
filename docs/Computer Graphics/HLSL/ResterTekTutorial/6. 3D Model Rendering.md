---
layout: default
title: "6. 3D Model Scaling, Rotation, Translation"
parent: "ResterTekTutorial"
nav_order: 7
---

# 6. 3D Model Scaling, Rotation, Translation
3D 모델 렌더링 및 크기 조정(Scale), 회전(Rotation), 이동(Translation)

---

# LoadModel
모델 데이터 파싱해서 데이터 읽기

- 모델 구조체

```c++
struct ModelType
{
    float x, y, z;
    float tu, tv; // texture uv
    float nx, ny, nz; // normal x,y,z;
};
```

- 모델 데이터 (파싱할 데이터)

```
Vertex Count: 36

Data:

-1.0  1.0 -1.0 0.0 0.0  0.0  0.0 -1.0
 1.0  1.0 -1.0 1.0 0.0  0.0  0.0 -1.0
-1.0 -1.0 -1.0 0.0 1.0  0.0  0.0 -1.0
-1.0 -1.0 -1.0 0.0 1.0  0.0  0.0 -1.0
 1.0  1.0 -1.0 1.0 0.0  0.0  0.0 -1.0
 1.0 -1.0 -1.0 1.0 1.0  0.0  0.0 -1.0
 1.0  1.0 -1.0 0.0 0.0  1.0  0.0  0.0
 1.0  1.0  1.0 1.0 0.0  1.0  0.0  0.0
 1.0 -1.0 -1.0 0.0 1.0  1.0  0.0  0.0
 1.0 -1.0 -1.0 0.0 1.0  1.0  0.0  0.0
 1.0  1.0  1.0 1.0 0.0  1.0  0.0  0.0
 1.0 -1.0  1.0 1.0 1.0  1.0  0.0  0.0
 1.0  1.0  1.0 0.0 0.0  0.0  0.0  1.0
-1.0  1.0  1.0 1.0 0.0  0.0  0.0  1.0
 1.0 -1.0  1.0 0.0 1.0  0.0  0.0  1.0
 1.0 -1.0  1.0 0.0 1.0  0.0  0.0  1.0
-1.0  1.0  1.0 1.0 0.0  0.0  0.0  1.0
-1.0 -1.0  1.0 1.0 1.0  0.0  0.0  1.0
-1.0  1.0  1.0 0.0 0.0 -1.0  0.0  0.0
-1.0  1.0 -1.0 1.0 0.0 -1.0  0.0  0.0
-1.0 -1.0  1.0 0.0 1.0 -1.0  0.0  0.0
-1.0 -1.0  1.0 0.0 1.0 -1.0  0.0  0.0
-1.0  1.0 -1.0 1.0 0.0 -1.0  0.0  0.0
-1.0 -1.0 -1.0 1.0 1.0 -1.0  0.0  0.0
-1.0  1.0  1.0 0.0 0.0  0.0  1.0  0.0
 1.0  1.0  1.0 1.0 0.0  0.0  1.0  0.0
-1.0  1.0 -1.0 0.0 1.0  0.0  1.0  0.0
-1.0  1.0 -1.0 0.0 1.0  0.0  1.0  0.0
 1.0  1.0  1.0 1.0 0.0  0.0  1.0  0.0
 1.0  1.0 -1.0 1.0 1.0  0.0  1.0  0.0
-1.0 -1.0 -1.0 0.0 0.0  0.0 -1.0  0.0
 1.0 -1.0 -1.0 1.0 0.0  0.0 -1.0  0.0
-1.0 -1.0  1.0 0.0 1.0  0.0 -1.0  0.0
-1.0 -1.0  1.0 0.0 1.0  0.0 -1.0  0.0
 1.0 -1.0 -1.0 1.0 0.0  0.0 -1.0  0.0
 1.0 -1.0  1.0 1.0 1.0  0.0 -1.0  0.0
```

---

# ifstream
'input file stream'의 약자로, C++ 표준 라이브러리(<fstream> 헤더)에 포함된 클래스

- 파일로부터 데이터를 읽어올 때 사용

## read file
1. `ifstream fin;`: `ifstream` 타입의 객체 `fin`을 선언
2. `fin.open(filename);`: `filename`에 해당하는 파일을 열어 `fin` 객체와 연결
3. `if (fin.fail())`: 파일 열기에 실패했는지 확인
4. `fin >> variable;` 또는 `fin.get(char_var);`: 파일에서 데이터를 읽음
- **`>>` 연산자는 공백(스페이스, 탭, 개행)을 무시하고 데이터를 읽음**
-  **`get()` 함수는 한 글자씩(공백 포함) 읽음**
5. `fin.close();`: 파일 사용이 끝나면 닫음

```c++

bool ModelClass::LoadModel(char* filename)
{
	ifstream fin;
	char input;
	int i;

	//모델 파일 열기
	fin.open(filename);

	// 파일 열기 실패시 exit
	if (fin.fail())
	{
		return false;
	}

	// 정점 개수의 값까지 읽기
	fin.get(input);
	while (input != ':')
	{
		fin.get(input);
	}

	// 버텍스 카운트 읽기
	fin >> m_vertexCount;

	// 인덱스 개수를 정점 개수와 동일하게 설정
	m_indexCount = m_vertexCount;

	// 읽은 버텍스 카운트를 사용해 모델 생성
	m_model = new ModelType[m_vertexCount];

	// 데이터의 시작 부분까지 읽기
	fin.get(input);
	while (input != ':')
	{
		fin.get(input);
	}
	fin.get(input);
	fin.get(input);

	for (i = 0; i < m_vertexCount; i++)
	{
		fin >> m_model[i].x >> m_model[i].y >> m_model[i].z;
		fin >> m_model[i].tu >> m_model[i].tv;
		fin >> m_model[i].nx >> m_model[i].ny >> m_model[i].nz;
	}

	// Close the model file.
	fin.close();

	return true;
}
```

- **fin.get(input)**
  - 함수는 파일 스트림에서 **단 한 개의 문자(character)**를 읽어서 변수 `input`에 저장
- **`>>`** 연산자
  - 스페이스, 탭, 개행 문자와 같은 공백 문자는 패스함

---

## Scaling, Rotation, Translation
일반적으로 스케일(Scale) → 회전(Rotation) → 이동(Translation) 순서로 변환 행렬을 적용한다

```c++
XMMATRIX rotateMatrix, translateMatrix, scaleMatrix, srMatrix;

scaleMatrix = XMMatrixScaling(0.5f, 0.5f, 0.5f); // 크기 조정 행렬을 만들기
rotateMatrix = XMMatrixRotationY(rotation); // 회전 행렬을 만들기
translateMatrix = XMMatrixTranslation(2.0f, 0.0f, 0.0f); // 이동 ​​행렬을 만들기

// 크기 조정, 회전, 이동 행렬을 곱하여 최종적인 월드 변환 행렬을 만들기
srMatrix = XMMatrixMultiply(scaleMatrix, rotateMatrix);
worldMatrix = XMMatrixMultiply(srMatrix, translateMatrix);

// 모델 정점 및 인덱스 버퍼를 그래픽 파이프라인에 배치하여 그리기를 준비
m_Model->Render(m_Direct3D->GetDeviceContext());

// 조명 셰이더를 사용하여 모델을 렌더링
result = m_LightShader->Render(m_Direct3D->GetDeviceContext(), m_Model->GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model->GetTexture(), m_Light->GetDirection(), m_Light->GetDiffuseColor());
```

{: .new-title}
> ❓ 왜 SRT(Scale → Rotate → Translate) 순서인가?
>
객체 자신의 로컬 좌표계(Local Space)에서 변환을 시작하여 최종적으로 월드 좌표계(World Space)에 배치하는 자연스러운 과정이다
1. 스케일: 먼저 객체 고유의 크기를 정함 (로컬 공간)
2. 회전: 그 다음 객체 회전 방향을 정함 (로컬 공간)
3. 이동: 마지막으로 월드 공간의 최종 위치로 옮김 (월드 공간)

**이동을 먼저 한 후 회전시키면, 객체는 제자리에서 회전하는 것이 아니라 공전을 하게됨**
- 예: 객체가 월드 공간의 원점을 기준으로 회전하게 되어 마치 달이 지구 주위를 도는 것처럼 움직임

---

# DirectX Math 주요 함수 및 연산
DirectX Math에서 자주 사용되는 주요 함수 및 연산을 기능별로 정리한 표

---

## Vector
벡터는 크기와 방향을 가지는 수학적 객체로, 3D 공간에서의 위치, 방향, 속도 등을 표현하는 데 사용

- 생성 및 초기화

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMVectorSet | 4개의 실수 (x, y, z, w) | `XMVECTOR` | 4개의 실수 값으로 벡터를 생성 | `XMVECTOR v = XMVectorSet(1.0f, 2.0f, 3.0f, 0.0f);` |
| XMLoadFloat3 | `XMFLOAT3` 구조체 포인터 | `XMVECTOR` | `XMFLOAT3` 구조체로부터 벡터를 로드 | `XMFLOAT3 p = {1.0f, 2.0f, 3.0f}; XMVECTOR v = XMLoadFloat3(&p);` |

- 연산

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMVectorAdd | `XMVECTOR`, `XMVECTOR` | `XMVECTOR` | 두 벡터의 각 성분을 더함 | `XMVECTOR result = XMVectorAdd(v1, v2);` |
| XMVectorSubtract | `XMVECTOR`, `XMVECTOR` | `XMVECTOR` | 첫 번째 벡터에서 두 번째 벡터의 각 성분을 뺌 | `XMVECTOR result = XMVectorSubtract(v1, v2);` |
| XMVectorScale | `XMVECTOR`, `float` | `XMVECTOR` | 벡터의 각 성분에 스칼라 값을 곱함 | `XMVECTOR result = XMVectorScale(v, 2.0f);` |
| XMVector3Dot | `XMVECTOR`, `XMVECTOR` | `XMVECTOR` | 두 3D 벡터의 내적을 계산. <br> 결과는 벡터의 모든 성분에 복제 | `XMVECTOR dotProduct = XMVector3Dot(v1, v2);` |
| XMVector3Cross | `XMVECTOR`, `XMVECTOR` | `XMVECTOR` | 두 3D 벡터의 외적을 계산하여 두 벡터에 수직인 벡터를 구함 | `XMVECTOR crossProduct = XMVector3Cross(v1, v2);` |

- 길이 및 정규화

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMVector3Length | `XMVECTOR` | `XMVECTOR` | 3D 벡터의 길이를 계산. <br> 결과는 벡터의 모든 성분에 복제. | `XMVECTOR length = XMVector3Length(v);` |
| XMVector3Normalize| `XMVECTOR` | `XMVECTOR` | 3D 벡터를 정규화하여 길이가 1인 단위 벡터로 만듦 | `XMVECTOR normalizedV = XMVector3Normalize(v);` |

- 변환

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMVector3Transform | `XMVECTOR`, `XMMATRIX` | `XMVECTOR` | 3D 벡터를 주어진 행렬로 변환. <br> (위치 벡터 변환에 사용) | `XMVECTOR transformedV = XMVector3Transform(v, m);` |
| XMVector3TransformNormal | `XMVECTOR`, `XMMATRIX` | `XMVECTOR` | 3D 법선 벡터를 주어진 행렬로 변환 <br> (법선 벡터 변환에 사용) | `XMVECTOR transformedNormal = XMVector3TransformNormal(normal, m);` |

---

## Matrix
행렬은 3D 객체의 변환(이동, 회전, 크기 조절)을 표현하고 계산하는 데 사용되는 핵심적인 도구

- 생성 및 초기화

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMMatrixIdentity | 없음 | `XMMATRIX` | 단위 행렬을 생성합니다. (모든 변환의 기본값) | `XMMATRIX I = XMMatrixIdentity();` |
| XMMatrixTranslation | `float x`, `float y`, `float z` | `XMMATRIX` | 주어진 x, y, z 값으로 이동 행렬을 생성 | `XMMATRIX T = XMMatrixTranslation(1.0f, 2.0f, 3.0f);` |
| XMMatrixRotationX | `float Angle` (라디안) | `XMMATRIX` | X축을 기준으로 주어진 각도만큼 회전하는 행렬을 생성 | `XMMATRIX R = XMMatrixRotationX(XM_PIDIV2);` |
| XMMatrixScaling | `float x`, `float y`, `float z` | `XMMATRIX` | 주어진 x, y, z 비율로 크기를 조절하는 행렬을 생성 | `XMMATRIX S = XMMatrixScaling(2.0f, 2.0f, 2.0f);` |

- 연산

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMMatrixMultiply | `XMMATRIX`, `XMMATRIX` | `XMMATRIX` | 두 행렬을 곱함. <br> 변환을 결합하는 데 사용 | `XMMATRIX M = XMMatrixMultiply(S, R); XMMATRIX world = XMMatrixMultiply(M, T);` |
| XMMatrixTranspose | `XMMATRIX` | `XMMATRIX` | 행렬의 전치 행렬을 구함. | `XMMATRIX T = XMMatrixTranspose(M);` |
| XMMatrixInverse | `XMVECTOR*` (determinant), `XMMATRIX` | `XMMATRIX` | 행렬의 역행렬을 구함. <br> 변환을 되돌리는 데 사용 | `XMVECTOR det; XMMATRIX invM = XMMatrixInverse(&det, M);` |

- 뷰 및 투영 행렬

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMMatrixLookAtLH | `XMVECTOR` (Eye), `XMVECTOR` (At), `XMVECTOR` (Up) | `XMMATRIX` | 카메라의 위치, 바라보는 지점, 상향 벡터를 기반으로 뷰 행렬을 생성 (왼손 좌표계) | `XMMATRIX V = XMMatrixLookAtLH(eye, at, up);` |
| XMMatrixPerspectiveFovLH | `float FovAngleY` (라디안), `float AspectRatio`, `float NearZ`, `float FarZ` | `XMMATRIX` | 원근 투영 행렬을 생성. 3D 장면을 2D 화면에 투영하는 데 사용 (왼손 좌표계) | `XMMATRIX P = XMMatrixPerspectiveFovLH(XM_PIDIV4, aspectRatio, 1.0f, 1000.0f);` |

---

## Quaternion
쿼터니언은 3D 회전을 표현하는 데 사용되는 4차원 복소수이다. 짐벌락(Gimbal Lock) 현상을 피할 수 있어 부드러운 회전 표현에 유리하다

- 생성

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMQuaternionRotationAxis| `XMVECTOR` (Axis), `float Angle` (라디안) | `XMVECTOR` | 주어진 축을 기준으로 특정 각도만큼 회전하는 쿼터니언을 생성 | `XMVECTOR q = XMQuaternionRotationAxis(axis, angle);` |

- 연산

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMQuaternionMultiply | `XMVECTOR`, `XMVECTOR` | `XMVECTOR` | 두 쿼터니언을 곱하여 회전을 결합 | `XMVECTOR q_combined = XMQuaternionMultiply(q1, q2);` |

- 보간

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMQuaternionSlerp | `XMVECTOR` (Q0), `XMVECTOR` (Q1), `float t` | `XMVECTOR` | 두 쿼터니언 사이를 구면 선형 보간하여 부드러운 회전 애니메이션을 만듦 | `XMVECTOR q_interp = XMQuaternionSlerp(q_start, q_end, 0.5f);` |

- 변환

| 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) |
|---|---|---|---|---|
| XMMatrixRotationQuaternion | `XMVECTOR` | `XMMATRIX` | 쿼터니언을 회전 행렬로 변환 | `XMMATRIX R = XMMatrixRotationQuaternion(q);` |
