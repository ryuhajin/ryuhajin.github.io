---
layout: default
title: "7. Ambient Lighting"
parent: "ResterTekTutorial"
nav_order: 8
---

# 7. Ambient Lighting
HLSL을 사용하여 DirectX 11에서 환경광을 사용해보자

---

## Ambient Lighting (환경광)
3D 공간에 존재하는 '간접광'을 흉내 내는 가장 간단한 조명 모델
- 태양(광원)이 직접 보이지는 않지만, 구름에 의해 빛이 사방으로 흩어져 **세상 전체가 은은하게 밝혀지는 것과 같은 원리**

---

## 특징
1. **특정한 광원이 없음**
- 빛이 어디서 오는지 방향성이 없음
2. **모든 물체에 동일하게 적용**
- 모든 방향, 모든 표면에 균일한 강도와 색상으로 빛을 더해줌
3. **그림자를 없애줌**
- 물체의 어두운 부분 (그림자)이 완전히 검은색 (RGB 0,0,0)으로 표현되지 않도록
- 기본 밝기를 제공한다. 이 덕분에 장면이 훨씬 자연스러워 보인다

---

## Ambient Lighting 이 추가된 코드 예시

```c++
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color;
	
	// 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처에서 픽셀 색상을 샘플링
	textureColor = shaderTexture.Sample(SampleType, input.tex);

	// 기본 출력 색상을 모든 픽셀의 주변광 값으로 설정
	color = ambientColor;

	// 계산 위해 빛 방향을 반전
    lightDir = -lightDirection;

    // 이 픽셀에 대한 빛의 양을 계산
	lightIntensity = saturate(dot(input.normal, lightDir));

	if (lightIntensity > 0.0f)
	{
		// 디퓨즈 컬러와 빛의 세기에 따라 최종 디퓨즈 컬러를 결정
		color += (diffuseColor * lightIntensity);
	}

	// Saturate the final light color
    color = saturate(color);

    // 텍스처 픽셀과 최종 확산 색상을 곱하여 최종 픽셀 색상 결과를 얻음
	color = color * textureColor;

    return color;
}
```

### diffuse color 만 있는 코드와의 차이점

- diffuse color 코드 예시

```c++
// 조명 강도와 결합된 확산 색상을 기반으로 최종 확산 색상의 양을 결정
color = saturate(diffuseColor * lightIntensity);
```

> - 빛의 세기(lightIntensity)가 0이면 color도 검은색(0, 0, 0)이 됨
> - 오직 직접광의 영향만으로 색을 결정

---

- diffuse color + ambient color 코드 예시

```c++
// 기본 출력 색상을 모든 픽셀의 주변광 값으로 설정
color = ambientColor;

...

if (lightIntensity > 0.0f)
{
    // 디퓨즈 컬러와 빛의 세기에 따라 최종 디퓨즈 컬러를 결정
    color += (diffuseColor * lightIntensity);
}

```
- 모든 픽셀에 ambientColor라는 기본 밝기를 부여
- 그 후, 빛이 닿는 부분에만 추가로 확산광을 더해 더 밝게 만듦

> - 따라서 빛이 직접 닿지 않아도 물체는 최소한의 형태를 알아볼 수 있게 됨

---

# KEYWORD NOTE

## saturate()
saturate 함수는 입력값을 0.0에서 1.0 사이로 클램핑(clamping)

```c++
float saturate(float x);
float4 saturate(float4 x);
float2x2 saturate(float2x2 x);
```

- 다양한 데이터 타입에 대해 오버로딩되어 있음
- 스칼라(scalar), 벡터(vector), 행렬(matrix) 등 float 기반의 모든 타입에 사용

```c++
// saturate(x)는 아래 코드와 같음
max(0.0, min(1.0, x));
```

**리턴 값**
- x < 0.0 : `0.0` 반환
- x > 1.0 : `1.0` 반환
- 0.0 ≤ x ≤ 1.0 : `x` 그대로 반환

### 사용 예시

```c++
float3 lightDir = normalize(lightPosition - input.worldPos);
float3 normal = normalize(input.worldNormal);

// 내적 결과가 음수가 될 수 있으므로 saturate를 사용해 0~1 범위로 제한
float diffuse = saturate(dot(lightDir, normal));

// 최종 색상 계산
float4 finalColor = lightColor * diffuse;
```

