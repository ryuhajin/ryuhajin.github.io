---
layout: default
title: "4. Texturing"
parent: "ResterTekTutorial"
nav_order: 5
---

# 4. Texturing

## 프레임 워크 요소
- application class 에 하위 클래스 (`TextureShaderClass`) 추가
- Model Class에 하위 클래스 (`TextureClass`) 추가
- `ColorShaderClass` 제거

- **applicationclass** : 그래픽 코드를 처리하여 렌더링
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리
  - **ModelClass** : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화
    - **TextureClass** : TGA 파일을 디스크에서 읽고, 파싱하고, CPU 메모리에 RGB(A) 데이터로 변환한 뒤,
      - 이 데이터를 기반으로 Direct3D 텍스처 리소스(ID3D11Texture2D)와 셰이더 리소스 뷰(ID3D11ShaderResourceView)를 생성
  - **CameraClass** : 씬(Scene)을 바라보는 시점(Viewpoint) 관리
  - **TextureShaderClass** : 매 프레임 렌더링 시점에, TextureClass가 만들어 놓은 셰이더 리소스 뷰를 GPU의 픽셀
      셰이더로 전달하는 역할

---

# Texel Coordinate System (텍셀 좌표계)
Texel은 "Texture Element"의 줄임말

- 픽셀(Picture Element)이 화면의 한 점이라면, **Texel은 텍스처 이미지의 한 점을 의미**
- 3D 모델의 위치를 나타내는 XYZ 좌표와 구분하기 위해, **텍스처의 2D 좌표는 일반적으로 U와 V를 사용**

## UV 좌표
- **U축 :** 텍스처의 수평 방향(가로)
- **V축 :** 텍스처의 수직 방향(세로)

**좌표 범위:** 일반적으로 U와 V 좌표는 `0.0`에서 `1.0` 사이의 값으로 정규화(Normalize) 됨
-   `(0.0, 0.0)`: 텍스처의 왼쪽 상단 모서리
-   `(1.0, 1.0)`: 텍스처의 오른쪽 하단 모서리
-   `(0.5, 0.5)`: 텍스처의 정중앙

<br>

```cpp
//       정점 위치(-1, -1, 0)는 텍스처의 왼쪽 하단(0, 1)에 매핑
vertices[0].position = XMFLOAT3(-1.0f, -1.0f, 0.0f);
vertices[0].texture = XMFLOAT2(0.0f, 1.0f);

//       정점 위치(0, 1, 0)는 텍스처의 위쪽 중앙(0.5, 0)에 매핑
vertices[1].position = XMFLOAT3(0.0f, 1.0f, 0.0f);
vertices[1].texture = XMFLOAT2(0.5f, 0.0f);

//       정점 위치(1, -1, 0)는 텍스처의 오른쪽 하단(1, 1)에 매핑
vertices[2].position = XMFLOAT3(1.0f, -1.0f, 0.0f);
vertices[2].texture = XMFLOAT2(1.0f, 1.0f);
```

> - u, v 좌표를 이용해 3D 모델의 특정 정점이 텍스처의 어느 부분에 해당하는지를 매핑(mapping)
> - 매핑을 통해 렌더링 시 삼각형의 각 정점 사이의 공간은 텍스처의 해당 좌표들 사이의 픽셀들로 채워짐

---

# UV Coordinate Interpolation
사용자가 정점(vertex)에 UV 좌표를 지정하면 그 **정점들로 이루어진 면 내부의 공간은 GPU가 텍스처 픽셀(texel)로 채움**

## 렌더링 파이프 라인 단계

---

**1.데이터 준비 (CPU -> GPU)**
- 정점 버퍼(Vertex Buffer): 3D 모델을 구성하는 각 정점의 데이터를 GPU에 보냄
   - 위치 좌표 (X, Y, Z): 3D 공간에서의 정점 위치
   - 텍스처 좌표 (U, V): 2D 텍스처 맵에서의 정점 위치 (U는 가로, V는 세로)

---

**2.버텍스 셰이더 (Vertex Shader)**
- GPU는 모델의 모든 정점에 대해 버텍스 셰이더를 실행
- 이때, **UV 좌표는 계산하지 않고 그대로 다음 단계로 전달**
- 각 정점은 변환된 화면 좌표와 함께 자신의 UV 좌표를 계속 가지고 있음

---

**3.래스터화 (Rasterization) - 핵심 단계!**

- GPU는 3개의 변환된 정점을 보고, 이 **삼각형 내부에 포함될 모든 픽셀(pixel)들을 찾아냄**(Scan Conversion)
  - 이 때 각 픽셀(프래그먼트)에 대해 깊이 값도 함께 계산된다 
- 이렇게 찾아낸 **픽셀 하나하나를 프래그먼트(Fragment)**라고 부름
- 이제 GPU는 이 수많은 프래그먼트 **각각의 색상을 결정**해야 함

---

**4.UV 좌표 보간 (UV Coordinate Interpolation)**
- GPU는 각 프래그먼트의 색상을 결정하기 위해, 해당 **프래그먼트가 삼각형의 세 꼭짓점으로부터 얼마나 떨어져
 있는지를 계산**
- 이때 **무게중심 좌표(Barycentric Coordinates)**라는 기술이 사용됨
  - 예를 들어, 어떤 프래그먼트가 삼각형의 한가운데에 있다면, 세 꼭짓점의 영향을 동일하게(각각 1/3씩) 받음

GPU는 **가중치(weight)**를 그대로 각 꼭짓점의 **UV 좌표에 적용**함

```
   - 프래그먼트의 U = (A정점 가중치 * A정점 U) + (B정점 가중치 * B정점 U) + (C정점 가중치 * C정점 U)
   - 프래그먼트의 V = (A정점 가중치 * A정점 V) + (B정점 가중치 * B정점 V) + (C정점 가중치 * C정점 V)
```

> - 이 계산을 통해, 삼각형 내부의 모든 프래그먼트(픽셀)는 자신만의 고유한 보간된 UV 좌표를 갖게 됨
> - 꼭짓점 사이의 공간이 자연스럽게 연속적인 UV 값으로 채워짐

---

**5.픽셀 셰이더 (Pixel Shader / Fragment Shader)**

- 이제 각 **프래그먼트는 자신만의 보간된 UV 좌표를 가지고 픽셀 셰이더로 전달**됨
- **텍스처 샘플링(Texture Sampling)** 시작
  - 픽셀 셰이더가 **보간된 UV 좌표를 사용하여 텍스처 맵에서 텍셀 (Texel)을 읽어옴**
  - `SamplerState`에서 설정한 필터링 방식(Filtering) (예: `D3D11_FILTER_MIN_MAG_MIP_LINEAR`)에 따라, 주변의 여러 텍셀(760,761번 등)의 색상을 혼합(Blend) 해서 최종 색상을 만들어냄
- 가져온 **텍셀 색상은 조명 등 다른 요소와 결합되어 프래그먼트의 최종 색상이 결정됨**

---

**6.최종 출력**
- 색상이 결정된 모든 프래그먼트들이 화면에 그려지면서, 매끄럽게 텍스처가 입혀진 3D 모델을 보게 됨

---

## texturing Process
direct3D에서 텍스처링은 크게 **데이터 준비 → D3D 리소스 생성 → 셰이더에서 샘플링의 3단계로 진행**

**1.데이터 준비**
  - 3D 모델링 및 텍스쳐 제작 후 모델의 정점 정보(위치, 법선 등)와 UV 좌표를 함께 파일(예: .fbx, .obj)로 저장하고 제작한 텍스처 이미지(예: .png, .dds)도 저장

---

**2.D3D 리소스 생성 및 설정 (C++ 코드)**
- **텍스처 파일 로드 및 `ID3D11Texture2D` 생성**
  - **디스크에 있는 이미지 파일(.png, .jpg, .dds 등)을 읽어 GPU 메모리에 올림**
  - 이 결과물로 `ID3D11Texture2D`라는 리소스 객체가 생성
  - 이 과정은 복잡하기 때문에 보통 DirectXTex 라이브러리 같은 도우미 라이브러리를 사용

- **셰이더 리소스 뷰 (`ID3D11ShaderResourceView`, SRV) 생성**
  - GPU가 텍스처 리소스(ID3D11Texture2D)를 **셰이더에서 읽을 수 있도록 "뷰(View)"를 만들어야 함**
  - **SRV는 셰이더에게 "이 텍스처를 이런 방식으로 읽어가라"고 알려주는 역할**
  - 텍스처를 사용하려면 반드시 필요

- **샘플러 상태 (`ID3D11SamplerState`) 생성**
  - 셰이더가 **텍스처의 색상 값을 "어떻게 가져올지(Sampling)"에 대한 규칙을 정하는 객체**
  - **필터링(Filtering)**
    - UV 좌표가 텍스처의 픽셀(텍셀)과 정확히 일치하지 않을 때, 주변 픽셀 색을 어떻게 섞어서 부드럽게 표현할지 결정
    - (예: `LINEAR` 필터링 - 부드럽게, `POINT` 필터링 - 픽셀이 보이게)
  - **주소 지정 모드(Addressing Mode)**
    - UV 좌표가 0.0 ~ 1.0 범위를 벗어났을 때 어떻게 처리할지 결정
    - (예: `WRAP` - 바둑판식으로 반복, `CLAMP` - 가장자리 색으로 채움)

- **GPU에 리소스 전달**
  - 렌더링을 하기 직전에, 지금까지 만든 **SRV와 SamplerState를 픽셀 셰이더에 전달**
  - `context->PSSetShaderResources(...)` 함수로 SRV를 설정
  - `context->PSSetSamplers(...)` 함수로 SamplerState를 설정

---

**3.셰이더에서 텍스처 샘플링 (HLSL 코드)**
- 픽셀 셰이더 (Pixel Shader)
  - 정점 셰이더에서 넘어온 UV 좌표는 **래스터라이저에 의해 삼각형 내부의 모든 픽셀에 대해 보간(interpolated)된 값으로 들어옴**
  - HLSL 코드에 텍스처와 샘플러를 위한 변수를 선언

---

### 전체 흐름 요약
1. (C++) **텍스처 파일을 로드**해 `ID3D11Texture2D`를 만든다
2. (C++) **텍스처를 셰이더에서 읽을 수 있도록** `ID3D11ShaderResourceView`를 만든다
3. (C++) **텍스처를 읽는 규칙**인 `ID3D11SamplerState`를 만든다
4. (C++) 렌더링 전, 위에서 만든 View와 Sampler를 **픽셀 셰이더(PS)에 설정**한다
5. (GPU-PS) 픽셀 셰이더는 전달받은 UV 좌표와 Sample() 함수를 이용해 텍스처에서 색상 값을 "뽑아온다"
6. (GPU-PS) 뽑아온 색상을 최종 픽셀 색상으로 출력한다

---

# Targa Parsing

## Targa Header 설정
Targa(.tga) 이미지 파일의 헤더(header) 정보를 파일에 저장된 바이너리(binary) 형식 그대로 읽어오기 위해 정의

- [TGA Image description](https://paulbourke.net/dataformats/tga/)

```c++
	struct TargaHeader
	{
		unsigned char data1[12];
		unsigned short width;
		unsigned short height;
		unsigned char bpp;
		unsigned char data2;
	};
```

- 현재 필요한 정보(width, bpp 등)만 가져오기 위해 data1, data2로 축약

---

## fopen_s()
Targa 파일을 열고 파일 포인터를 연결

```c++
int error;

// Open the targa file for reading in binary.
	error = fopen_s(&filePtr, filename, "rb");
	if(error != 0)
	{
		return false;
	}
```

- **fopen_s(&filePtr, filename, "rb")**
  - **&filePtr** : 파일을 성공적으로 열었을 때 파일 포인터를 저장할 변수의 주소
  - **filename** : 열고자 하는 파일의 경로와 이름
  - **"rb"**: 파일을 **읽기 전용("r")**, **바이너리 모드("b")**로 염

---

## fread()
파일 스트림에서 지정된 크기의 데이터 블록을 읽어와 메모리에 저장

```c++

FILE* filePtr;
TargaHeader targaFileHeader;
unsigned char* targaImage;
int imageSize;

// 1. 파일을 바이너리 모드로 열기
	error = fopen_s(&filePtr, filename, "rb");
	if(error != 0)
	{
		return false;
	}

// 2. Targa 헤더 읽기 (18 바이트)
// 이 fread가 끝나면 filePtr의 위치는 이미지 데이터 시작점으로 이동
	count = (unsigned int)fread(&targaFileHeader, sizeof(TargaHeader), 1, filePtr);
	if(count != 1)
	{
		return false;
	}

m_height = (int)targaFileHeader.height;
m_width = (int)targaFileHeader.width;
imageSize = m_width * m_height * 4;

// 3. 이미지 데이터 읽기 (헤더를 제외한 순수 픽셀 데이터)
	count = (unsigned int)fread(targaImage, 1, imageSize, filePtr);
	if(count != imageSize)
	{
		return false;
	}

	// Close the file.
	error = fclose(filePtr);
	if(error != 0)
	{
		return false;
	}
```

- **fread(&targaFileHeader, sizeof(TargaHeader), 1, filePtr)**
    - **void *ptr**: 읽어온 데이터를 저장할 메모리 버퍼의 포인터
    - **size_t size**: 읽어올 데이터 항목 1개의 크기 (바이트 단위)
    - **size_t nmemb**: size 매개변수에서 지정한 크기의 요소를 몇 개나 읽을지(개수)를 지정
      -  `size * nmemb` 바이트만큼의 데이터를 읽으려고 시도
    - **FILE *stream**: 데이터를 읽어올 파일 스트림의 포인터

> - filePtr이 가리키는 파일에서 TargaHeader 구조체 크기만큼 1번 읽어서 targaFileHeader 변수에 저장

---

## bpp (Bits Per Pixel)
하나의 픽셀(Pixel) 당 사용되는 비트(Bit)의 수

> 점 하나의 색상 정보를 얼마나 정밀하게 표현할 것인가를 나타내는 단위
> - bpp 값이 클수록 더 많은 비트를 사용하여 색상을 표현하므로, 표현할 수 있는 색상이 늘어남

```c++
	// Get the important information from the header.
	m_height = (int)targaFileHeader.height;
	m_width = (int)targaFileHeader.width;
	bpp = (int)targaFileHeader.bpp;

	// Check that it is 32 bit and not 24 bit.
	if(bpp != 32)
	{
		return false;
	}

	// Calculate the size of the 32 bit image data.
	imageSize = m_width * m_height * 4;
```

---

### 8-bpp (8 bits per pixel)
하나의 픽셀을 8비트로 표현 (2⁸ = 256가지의 정보를 표현)
- **흑백 (Grayscale)**
  - 0(검은색) 부터 255(흰색) 까지 256단계의 명암을 표현
- **인덱스 컬러 (Indexed Color)**
  - 256개의 색상으로 구성된 '색상 팔레트(Color Palette)'를 미리 정의해 둠
  - 픽셀 데이터에는 **실제 색상 값(RGB)이 아닌, 팔레트의 몇 번째 색인지를 나타내는 번호(인덱스)만 저장**
  - TGA 파일의 '컬러맵'이 바로 이 방식

---

### 24-bpp (24 bits per pixel)
하나의 픽셀을 24비트로 표현 (2²⁴ ≈ 1670만 가지의 색상을 표현)
- 인간의 눈으로 구분할 수 있는 거의 모든 색을 표현할 수 있다고 해서 **'트루 컬러'라고 부름**
- 빛의 삼원색인 RGB 채널로 나뉨
  - Red (빨강): 8비트 (256 단계)
  - Green (초록): 8비트 (256 단계)
  - Blue (파랑): 8비트 (256 단계)
    - 총 8 + 8 + 8 = 24비트

> - TGA 파일에서 bpp가 24라면, 이미지 데이터는 (B, G, R), (B, G, R), ... 순서로 3바이트짜리 색상 덩어리가 반복되는 구조

---

### 32-bpp (32 bits per pixel)
하나의 픽셀을 32비트로 표현. **24-bpp의 RGB 채널에 알파(Alpha) 채널이 추가**
  - Red (빨강): 8비트
  - Green (초록): 8비트
  - Blue (파랑): 8비트
  - Alpha (알파): 8비트 (투명도)
    - 총 8 + 8 + 8 + 8 = 32비트
  - 알파 채널은 해당 픽셀의 투명도를 저장. **0은 완전 투명, 255는 완전 불투명**을 의미
  - 유리, 불꽃, 연기, UI 아이콘의 배경 등 부분적으로 투명한 텍스처를 만들 때 반드시 필요

---

## bpp가 왜 중요한가
bpp는 다음 두 가지를 결정하기 위해 필수적이다

```
- 이미지 데이터 크기(바이트) = 가로(width) * 세로(height) * (bpp / 8)
```

1. **메모리 크기 계산**
  - **이미지 데이터 전체를 담을 버퍼의 크기를 계산할 때 bpp가 사용**됨
  - bpp는 '비트' 단위이므로 8로 나누어 '바이트' 단위로 변환해야 함

2. **파싱 방식 결정**
  - 이미지 데이터를 읽어 들이는 for 루프 안에서, 한 픽셀을 몇 바이트씩 읽어야 할지 결정
  - if (bpp == 24) 이면 3바이트씩, if (bpp == 32) 이면 4바이트씩 데이터를 처리하고 다음 픽셀로 넘어감

3. **Direct3D 포맷 결정**
  - Direct3D 텍스처를 생성할 때, `DXGI_FORMAT`을 지정해야 함
  - 일반적으로 **32-bpp(RGBA)** 데이터는 `DXGI_FORMAT_R8G8B8A8_UNORM` 포맷에 해당

현대의 GPU는 24비트 포맷을 잘 지원하지 않는다. <br>
그래서 TGA 로더는 bpp가 24인 파일을 읽더라도, 메모리에는 32비트 공간을 할당하고 알파 채널 값을 255(불투명)로 채워서 32비트 데이터로 만들어 처리하는 경우가 매우 흔하다.

---

## targa 데이터 처리
targa 이미지 데이터를 direct3D에 맞게 가공하기

1. 많은 이미지 포맷(TGA, BMP 등)은 데이터 저장 시 이미지의 **가장 아래쪽 줄(bottom row)부터 위쪽 줄(top row) 순서로** 저장함
  - 파일에 가장 먼저 저장된 픽셀 데이터는 이미지의 가장 아래쪽 줄에 해당
  - 그래픽스 API가 화면을 위에서 아래로 그리는 방식과 반대
  - 따라서 **읽은 데이터를 그대로 텍스처에 넣으면 이미지가 상하로 뒤집혀 보임**
2. TGA 파일은 픽셀의 색상 정보를 **BGRA(Blue, Green, Red, Alpha)** 순서로 저장
  - 그래픽스 API는 일반적으로 **RGBA** 순서를 표준으로 사용

```c++
// targa 이미지 데이터의 시작점을 마지막 줄의 시작으로 초기화
k = (m_width * m_height * 4) - (m_width * 4);

// 이미지의 모든 픽셀을 반복
for(j=0; j<m_height; j++)
{
    for(i=0; i<m_width; i++)
    {
    // Targa 이미지(targaImage)에서 m_targaData로 픽셀 데이터를 복사하며 색상 순서를 바꿈
      m_targaData[index + 0] = targaImage[k + 2];  // Red
      m_targaData[index + 1] = targaImage[k + 1];  // Green.
      m_targaData[index + 2] = targaImage[k + 0];  // Blue
      m_targaData[index + 3] = targaImage[k + 3];  // Alpha

      // 다음 픽셀로 이동
      k += 4;
      index += 4;
    }

  // 한 줄(row) 처리가 끝나면, 원본 이미지(targaImage)의 포인터(k)를 이전 줄의 시작점으로 이동시킴
  k -= (m_width * 8);
}
```

1. 이미지 상하 반전 (위에서 아래 순서(Top-to-Bottom)로 저장하기)
- **k = (m_width * m_height * 4) - (m_width * 4);**
  - k를 원본 Targa 이미지 데이터(targaImage)의 마지막 줄 시작 위치로 설정
  - 이미지의 가장 아랫줄부터 읽기 시작
- **k -= (m_width * 8);**
  - 한 줄을 처리하면서 k는 m_width * 4 만큼 이미 증가
  - 따라서 이전 줄로 가려면 현재 증가한 만큼(m_width * 4), 이전 줄의 길이(m_width * 4)를 합쳐 총 m_width * 8 만큼을 빼줌
1. 색상 순서 변경 (BGRA → RGBA)
- **m_targaData[index + 0] = targaImage[k + 2];**
  - 원본의 3번째 바이트(Red)를 목적지의 1번째(Red)로

---

# texture.ps

```c++
//GLOBALS
Texture2D shaderTexture : register(t0);
SamplerState SampleType : register(s0);

//typedefs
struct PixelInputType
{
	float4 position : SV_POSITION;
	float2 tex : TEXCOORD0;
};

//pixel shader
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;

	 // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처의 픽셀 색상을 샘플링
	 textureColor = shaderTexture.Sample(sampleType, input.tex);

	 return textureColor;
}
```

- **Texture2D shaderTexture : register(t0)**
  - HLSL(셰이더 언어)에서 2D 텍스처 리소스를 담을 변수를 선언하는 코드
  - GPU의 특정 리소스 슬롯(slot)에 바인딩(연결)되도록 지정하는 구문
    -  **t** : Texture를 의미
    -  **0** : 0번째 슬롯을 의미
  - C++ 코드에서 `deviceContext->PSSetShaderResources(0, ...)` 함수를 호출할 때, **첫 번째 인자인 `0`이 바로 이 `register(t0)`의 `0`과 일치해야 함**
- **SamplerState SampleType : register(s0)**
  - 텍스처를 어떻게 **샘플링** (텍스처에서 픽셀 색상 값을 읽어오는 방법) 할지에 대한 **규칙(필터링, 주소 지정 모드 등)을 정의하는 객체를 담을 변수**
  - GPU의 샘플러 슬롯 0번에 바인딩하라는 의미
    - **s** : Sampler를 의미
    - **0** : 0번째 슬롯을 의미
  - C++ 코드의 `deviceContext->PSSetSamplers(0, ...)` 함수의 첫 번째 인자인 `0`과 매칭됨
    - 이를 통해 C++에서 설정한 샘플링 방식을 셰이더로 전달

---
# KEYWORD NOTE
textureShaderclass, textureClass에서 모르는 키워드 공부

---

## D3D11_TEXTURE2D_DESC
 `ID3D11Texture2D` 리소스를 생성할 때 필요한 모든 속성을 정의

```c++
D3D11_TEXTURE2D_DESC textureDesc;

textureDesc.Height = m_height;
textureDesc.Width = m_width;
textureDesc.MipLevels = 0;
textureDesc.ArraySize = 1;
textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
textureDesc.SampleDesc.Count = 1;
textureDesc.SampleDesc.Quality = 0;
textureDesc.Usage = D3D11_USAGE_DEFAULT;
textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
textureDesc.CPUAccessFlags = 0;
textureDesc.MiscFlags = D3D11_RESOURCE_MISC_GENERATE_MIPS;
```

-   **Height, Width** : 텍스처의 높이와 너비 (픽셀 단위)
-   **MipLevels** : 밉맵(Mipmap) 레벨의 수. 0으로 설정하면 전체 밉맵 체인이 자동 생성
-   **ArraySize** : 텍스처 배열의 크기. 일반적인 2D 텍스처는 1
-   **Format**: 텍스처의 픽셀 형식 (DXGI_FORMAT_R8G8B8A8_UNORM은 8비트 RGBA 채널을 가진 정규화된 형식)
-   **SampleDesc**: 멀티샘플링(MSAA) 설정
    - Count=1, Quality=0으로 설정하여 멀티샘플링을 사용하지 않음을 의미
-   **Usage** : 리소스의 주된 사용 방식 (D3D11_USAGE_DEFAULT는 GPU가 읽고 쓰는 가장 일반적인 리소스)
-   **BindFlags** : 리소스를 파이프라인의 어느 단계에 바인딩할지 지
    - D3D11_BIND_SHADER_RESOURCE : 셰이더에서 읽을 수 있음
    - D3D11_BIND_RENDER_TARGET : 렌더링 결과를 저장
-   **CPUAccessFlags** : CPU가 이 리소스에 접근하는 방식. 0은 CPU 접근이 없음을 의미
-   **MiscFlags** : 기타 플래그 (D3D11_RESOURCE_MISC_GENERATE_MIPS는 밉맵을 자동으로 생성하도록 허용)

---

## D3D11_USAGE
D3D11_USAGE 플래그와 메모리 위치

### D3D11_USAGE_DEFAULT (가장 일반적인 경우)
- 메모리 위치: **GPU 메모리 (VRAM)**
- 설명:
   - GPU가 가장 빠르게 읽고 쓸 수 있도록 VRAM에 리소스를 생성
   - **CPU는 이 메모리에 직접 접근할 수 없음 (읽기/쓰기 불가)**
   - CPU가 이 리소스의 데이터를 업데이트하려면 UpdateSubresource 또는 CopySubresourceRegion 같은 함수를
     통해 드라이버에게 데이터 복사를 "요청"해야 함
- 용도: **한 번 로드된 후 거의 변경되지 않는 대부분의 텍스처, 모델 데이터** 등에 사용

### D3D11_USAGE_DYNAMIC
- 메모리 위치: **주로 GPU 메모리에 있지만, CPU가 매우 빠르게 쓸 수 있도록 특별한 경로가 마련된 메모리**
- 설명:
   - CPU가 데이터를 자주 업데이트해야 하는 리소스를 위해 사용
   - **CPU는 Map 함수를 호출하여 이 리소스에 대한 포인터를 얻어와서 쓰기 작업을 할 수 있음**
   - (Map과 Unmap 사이에서 데이터를 쓴 후, 드라이버가 효율적으로 GPU로 전송)
   - UpdateSubresource보다 훨씬 빠름
- 용도: **매 프레임 내용이 바뀌는 UI 텍스처, 비디오 텍스처, CPU에서 계산된 파티클 데이터** 등에 사용

### D3D11_USAGE_STAGING
- 메모리 위치: **시스템 메모리 (RAM)**
- 설명:
   - CPU가 자유롭게 읽고 쓸 수 있는 RAM에 리소스를 생성
   - 중요: 이 리소스는 **셰이더 파이프라인에 직접 바인딩할 수 없음**
     - 즉, STAGING 텍스처에 대한 ShaderResourceView를 셰이더에 설정할 수 없음
- 용도: GPU와 CPU 간에 데이터를 전송하는 역할을 함
- 예를 들어, **GPU에 있는 DEFAULT 텍스처의 내용을 CPU로 다시 읽어오고 싶을 때 (스크린샷 저장 등)**
- DEFAULT 리소스 -> STAGING 리소스로 복사한 다음, CPU가 STAGING 리소스를 Map하여 데이터를 읽음

---

## 더 추가 예정