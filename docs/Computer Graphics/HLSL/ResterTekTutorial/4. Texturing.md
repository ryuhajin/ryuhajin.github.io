---
layout: default
title: "4. Texturing"
parent: "ResterTekTutorial"
nav_order: 5
---

# 4. Texturing

## 프레임 워크 요소
- application class 에 하위 클래스 (`TextureShaderClass`) 추가
- Model Class에 하위 클래스 (`TextureClass`) 추가
- `ColorShaderClass` 제거

- **applicationclass** : 그래픽 코드를 처리하여 렌더링
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리
  - **ModelClass** : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화
    - **TextureClass** : TGA 파일을 디스크에서 읽고, 파싱하고, CPU 메모리에 RGB(A) 데이터로 변환한 뒤,
      - 이 데이터를 기반으로 Direct3D 텍스처 리소스(ID3D11Texture2D)와 셰이더 리소스 뷰(ID3D11ShaderResourceView)를 생성
  - **CameraClass** : 씬(Scene)을 바라보는 시점(Viewpoint) 관리
  - **TextureShaderClass** : 매 프레임 렌더링 시점에, TextureClass가 만들어 놓은 셰이더 리소스 뷰를 GPU의 픽셀
      셰이더로 전달하는 역할

---

# Texel Coordinate System (텍셀 좌표계)
Texel은 "Texture Element"의 줄임말

- 픽셀(Picture Element)이 화면의 한 점이라면, **Texel은 텍스처 이미지의 한 점을 의미**
- 3D 모델의 위치를 나타내는 XYZ 좌표와 구분하기 위해, **텍스처의 2D 좌표는 일반적으로 U와 V를 사용**

## UV 좌표
- **U축 :** 텍스처의 수평 방향(가로)
- **V축 :** 텍스처의 수직 방향(세로)

**좌표 범위:** 일반적으로 U와 V 좌표는 `0.0`에서 `1.0` 사이의 값으로 정규화(Normalize) 됨
-   `(0.0, 0.0)`: 텍스처의 왼쪽 상단 모서리
-   `(1.0, 1.0)`: 텍스처의 오른쪽 하단 모서리
-   `(0.5, 0.5)`: 텍스처의 정중앙

<br>

```cpp
//       정점 위치(-1, -1, 0)는 텍스처의 왼쪽 하단(0, 1)에 매핑
vertices[0].position = XMFLOAT3(-1.0f, -1.0f, 0.0f);
vertices[0].texture = XMFLOAT2(0.0f, 1.0f);

//       정점 위치(0, 1, 0)는 텍스처의 위쪽 중앙(0.5, 0)에 매핑
vertices[1].position = XMFLOAT3(0.0f, 1.0f, 0.0f);
vertices[1].texture = XMFLOAT2(0.5f, 0.0f);

//       정점 위치(1, -1, 0)는 텍스처의 오른쪽 하단(1, 1)에 매핑
vertices[2].position = XMFLOAT3(1.0f, -1.0f, 0.0f);
vertices[2].texture = XMFLOAT2(1.0f, 1.0f);
```

> - u, v 좌표를 이용해 3D 모델의 특정 정점이 텍스처의 어느 부분에 해당하는지를 매핑(mapping)
> - 매핑을 통해 렌더링 시 삼각형의 각 정점 사이의 공간은 텍스처의 해당 좌표들 사이의 픽셀들로 채워짐

---

# UV Coordinate Interpolation
사용자가 정점(vertex)에 UV 좌표를 지정하면 그 **정점들로 이루어진 면 내부의 공간은 GPU가 텍스처 픽셀(texel)로 채움**

## 렌더링 파이프 라인 단계

---

**1.데이터 준비 (CPU -> GPU)**
- 정점 버퍼(Vertex Buffer): 3D 모델을 구성하는 각 정점의 데이터를 GPU에 보냄
   - 위치 좌표 (X, Y, Z): 3D 공간에서의 정점 위치
   - 텍스처 좌표 (U, V): 2D 텍스처 맵에서의 정점 위치 (U는 가로, V는 세로)

---

**2.버텍스 셰이더 (Vertex Shader)**
- GPU는 모델의 모든 정점에 대해 버텍스 셰이더를 실행
- 이때, **UV 좌표는 계산하지 않고 그대로 다음 단계로 전달**
- 각 정점은 변환된 화면 좌표와 함께 자신의 UV 좌표를 계속 가지고 있음

---

**3.래스터화 (Rasterization) - 핵심 단계!**

- GPU는 3개의 변환된 정점을 보고, 이 **삼각형 내부에 포함될 모든 픽셀(pixel)들을 찾아냄**(Scan Conversion)
  - 이 때 각 픽셀(프래그먼트)에 대해 깊이 값도 함께 계산된다 
- 이렇게 찾아낸 **픽셀 하나하나를 프래그먼트(Fragment)**라고 부름
- 이제 GPU는 이 수많은 프래그먼트 **각각의 색상을 결정**해야 함

---

**4.UV 좌표 보간 (UV Coordinate Interpolation)**
- GPU는 각 프래그먼트의 색상을 결정하기 위해, 해당 **프래그먼트가 삼각형의 세 꼭짓점으로부터 얼마나 떨어져
 있는지를 계산**
- 이때 **무게중심 좌표(Barycentric Coordinates)**라는 기술이 사용됨
  - 예를 들어, 어떤 프래그먼트가 삼각형의 한가운데에 있다면, 세 꼭짓점의 영향을 동일하게(각각 1/3씩) 받음

GPU는 **가중치(weight)**를 그대로 각 꼭짓점의 **UV 좌표에 적용**함

```
   - 프래그먼트의 U = (A정점 가중치 * A정점 U) + (B정점 가중치 * B정점 U) + (C정점 가중치 * C정점 U)
   - 프래그먼트의 V = (A정점 가중치 * A정점 V) + (B정점 가중치 * B정점 V) + (C정점 가중치 * C정점 V)
```

> - 이 계산을 통해, 삼각형 내부의 모든 프래그먼트(픽셀)는 자신만의 고유한 보간된 UV 좌표를 갖게 됨
> - 꼭짓점 사이의 공간이 자연스럽게 연속적인 UV 값으로 채워짐

---

**5.픽셀 셰이더 (Pixel Shader / Fragment Shader)**

- 이제 각 **프래그먼트는 자신만의 보간된 UV 좌표를 가지고 픽셀 셰이더로 전달**됨
- **텍스처 샘플링(Texture Sampling)** 시작
  - 픽셀 셰이더가 **보간된 UV 좌표를 사용하여 텍스처 맵에서 텍셀 (Texel)을 읽어옴**
  - `SamplerState`에서 설정한 필터링 방식(Filtering) (예: `D3D11_FILTER_MIN_MAG_MIP_LINEAR`)에 따라, 주변의 여러 텍셀(760,761번 등)의 색상을 혼합(Blend) 해서 최종 색상을 만들어냄
- 가져온 **텍셀 색상은 조명 등 다른 요소와 결합되어 프래그먼트의 최종 색상이 결정됨**

---

**6.최종 출력**
- 색상이 결정된 모든 프래그먼트들이 화면에 그려지면서, 매끄럽게 텍스처가 입혀진 3D 모델을 보게 됨

---

## texturing Process
direct3D에서 텍스처링은 크게 **데이터 준비 → D3D 리소스 생성 → 셰이더에서 샘플링의 3단계로 진행**

**1.데이터 준비**
  - 3D 모델링 및 텍스쳐 제작 후 모델의 정점 정보(위치, 법선 등)와 UV 좌표를 함께 파일(예: .fbx, .obj)로 저장하고 제작한 텍스처 이미지(예: .png, .dds)도 저장

---

**2.D3D 리소스 생성 및 설정 (C++ 코드)**
- **텍스처 파일 로드 및 `ID3D11Texture2D` 생성**
  - **디스크에 있는 이미지 파일(.png, .jpg, .dds 등)을 읽어 GPU 메모리에 올림**
  - 이 결과물로 `ID3D11Texture2D`라는 리소스 객체가 생성
  - 이 과정은 복잡하기 때문에 보통 DirectXTex 라이브러리 같은 도우미 라이브러리를 사용

- **셰이더 리소스 뷰 (`ID3D11ShaderResourceView`, SRV) 생성**
  - GPU가 텍스처 리소스(ID3D11Texture2D)를 **셰이더에서 읽을 수 있도록 "뷰(View)"를 만들어야 함**
  - **SRV는 셰이더에게 "이 텍스처를 이런 방식으로 읽어가라"고 알려주는 역할**
  - 텍스처를 사용하려면 반드시 필요

- **샘플러 상태 (`ID3D11SamplerState`) 생성**
  - 셰이더가 **텍스처의 색상 값을 "어떻게 가져올지(Sampling)"에 대한 규칙을 정하는 객체**
  - **필터링(Filtering)**
    - UV 좌표가 텍스처의 픽셀(텍셀)과 정확히 일치하지 않을 때, 주변 픽셀 색을 어떻게 섞어서 부드럽게 표현할지 결정
    - (예: `LINEAR` 필터링 - 부드럽게, `POINT` 필터링 - 픽셀이 보이게)
  - **주소 지정 모드(Addressing Mode)**
    - UV 좌표가 0.0 ~ 1.0 범위를 벗어났을 때 어떻게 처리할지 결정
    - (예: `WRAP` - 바둑판식으로 반복, `CLAMP` - 가장자리 색으로 채움)

- **GPU에 리소스 전달**
  - 렌더링을 하기 직전에, 지금까지 만든 **SRV와 SamplerState를 픽셀 셰이더에 전달**
  - `context->PSSetShaderResources(...)` 함수로 SRV를 설정
  - `context->PSSetSamplers(...)` 함수로 SamplerState를 설정

---

**3.셰이더에서 텍스처 샘플링 (HLSL 코드)**
- 픽셀 셰이더 (Pixel Shader)
  - 정점 셰이더에서 넘어온 UV 좌표는 **래스터라이저에 의해 삼각형 내부의 모든 픽셀에 대해 보간(interpolated)된 값으로 들어옴**
  - HLSL 코드에 텍스처와 샘플러를 위한 변수를 선언

---

### 전체 흐름 요약
1. (C++) **텍스처 파일을 로드**해 `ID3D11Texture2D`를 만든다
2. (C++) **텍스처를 셰이더에서 읽을 수 있도록** `ID3D11ShaderResourceView`를 만든다
3. (C++) **텍스처를 읽는 규칙**인 `ID3D11SamplerState`를 만든다
4. (C++) 렌더링 전, 위에서 만든 View와 Sampler를 **픽셀 셰이더(PS)에 설정**한다
5. (GPU-PS) 픽셀 셰이더는 전달받은 UV 좌표와 Sample() 함수를 이용해 텍스처에서 색상 값을 "뽑아온다"
6. (GPU-PS) 뽑아온 색상을 최종 픽셀 색상으로 출력한다

---

# Targa Parsing

## Targa Header 설정
Targa(.tga) 이미지 파일의 헤더(header) 정보를 파일에 저장된 바이너리(binary) 형식 그대로 읽어오기 위해 정의

- [TGA Image description](https://paulbourke.net/dataformats/tga/)

```c++
	struct TargaHeader
	{
		unsigned char data1[12];
		unsigned short width;
		unsigned short height;
		unsigned char bpp;
		unsigned char data2;
	};
```

- 현재 필요한 정보(width, bpp 등)만 가져오기 위해 data1, data2로 축약

---

## fopen_s()
Targa 파일을 열고 파일 포인터를 연결

```c++
int error;

// Open the targa file for reading in binary.
	error = fopen_s(&filePtr, filename, "rb");
	if(error != 0)
	{
		return false;
	}
```

- **fopen_s(&filePtr, filename, "rb")**
  - **&filePtr** : 파일을 성공적으로 열었을 때 파일 포인터를 저장할 변수의 주소
  - **filename** : 열고자 하는 파일의 경로와 이름
  - **"rb"**: 파일을 **읽기 전용("r")**, **바이너리 모드("b")**로 염

---

## fread()
파일 스트림에서 지정된 크기의 데이터 블록을 읽어와 메모리에 저장

```c++
unsigned int count;

	// Read in the file header.
count = (unsigned int)fread(&targaFileHeader, sizeof(TargaHeader), 1, filePtr);
if(count != 1)
{
  return false;
}
```

- **fread(&targaFileHeader, sizeof(TargaHeader), 1, filePtr)**
    - **&targaFileHeader**: 읽어온 데이터를 저장할 메모리 버퍼의 포인터
    - **sizeof(TargaHeader)**: 읽어올 데이터 항목 1개의 크기
    - **1**: 위 크기의 데이터 항목을 몇 개 읽을 것인지 지정
    - **filePtr**: 데이터를 읽어올 파일 스트림의 포인터

> - filePtr이 가리키는 파일에서 TargaHeader 구조체 크기만큼 1번 읽어서 targaFileHeader 변수에 저장

---



---

# texture.ps

```c++
//GLOBALS
Texture2D shaderTexture : register(t0);
SamplerState SampleType : register(s0);

//typedefs
struct PixelInputType
{
	float4 position : SV_POSITION;
	float2 tex : TEXCOORD0;
};

//pixel shader
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;

	 // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처의 픽셀 색상을 샘플링
	 textureColor = shaderTexture.Sample(sampleType, input.tex);

	 return textureColor;
}
```

- **Texture2D shaderTexture : register(t0)**
  - HLSL(셰이더 언어)에서 2D 텍스처 리소스를 담을 변수를 선언하는 코드
  - GPU의 특정 리소스 슬롯(slot)에 바인딩(연결)되도록 지정하는 구문
    -  **t** : Texture를 의미
    -  **0** : 0번째 슬롯을 의미
  - C++ 코드에서 `deviceContext->PSSetShaderResources(0, ...)` 함수를 호출할 때, **첫 번째 인자인 `0`이 바로 이 `register(t0)`의 `0`과 일치해야 함**
- **SamplerState SampleType : register(s0)**
  - 텍스처를 어떻게 **샘플링** (텍스처에서 픽셀 색상 값을 읽어오는 방법) 할지에 대한 **규칙(필터링, 주소 지정 모드 등)을 정의하는 객체를 담을 변수**
  - GPU의 샘플러 슬롯 0번에 바인딩하라는 의미
    - **s** : Sampler를 의미
    - **0** : 0번째 슬롯을 의미
  - C++ 코드의 `deviceContext->PSSetSamplers(0, ...)` 함수의 첫 번째 인자인 `0`과 매칭됨
    - 이를 통해 C++에서 설정한 샘플링 방식을 셰이더로 전달

---
# KEYWORD NOTE
textureShaderclass, textureClass에서 모르는 키워드 공부


