---
layout: default
title: "4. Texturing"
parent: "ResterTekTutorial"
nav_order: 5
---

# 4. Texturing

## 프레임 워크 요소
- application class 에 하위 클래스 (`TextureShaderClass`) 추가
- Model Class에 하위 클래스 (`TextureClass`) 추가
- `ColorShaderClass` 제거

- **applicationclass** : 그래픽 코드를 처리하여 렌더링
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리
  - **ModelClass** : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화
    - **TextureClass**
  - **CameraClass** : 씬(Scene)을 바라보는 시점(Viewpoint) 관리
  - **TextureShaderClass**

---

# Texel Coordinate System (텍셀 좌표계)
Texel은 "Texture Element"의 줄임말

- 픽셀(Picture Element)이 화면의 한 점이라면, **Texel은 텍스처 이미지의 한 점을 의미**
- 3D 모델의 위치를 나타내는 XYZ 좌표와 구분하기 위해, **텍스처의 2D 좌표는 일반적으로 U와 V를 사용**

## UV 좌표
- **U축 :** 텍스처의 수평 방향(가로)
- **V축 :** 텍스처의 수직 방향(세로)

**좌표 범위:** 일반적으로 U와 V 좌표는 `0.0`에서 `1.0` 사이의 값으로 정규화(Normalize) 됨
-   `(0.0, 0.0)`: 텍스처의 왼쪽 상단 모서리
-   `(1.0, 1.0)`: 텍스처의 오른쪽 하단 모서리
-   `(0.5, 0.5)`: 텍스처의 정중앙

<br>

```cpp
//       정점 위치(-1, -1, 0)는 텍스처의 왼쪽 하단(0, 1)에 매핑
vertices[0].position = XMFLOAT3(-1.0f, -1.0f, 0.0f);
vertices[0].texture = XMFLOAT2(0.0f, 1.0f);

//       정점 위치(0, 1, 0)는 텍스처의 위쪽 중앙(0.5, 0)에 매핑
vertices[1].position = XMFLOAT3(0.0f, 1.0f, 0.0f);
vertices[1].texture = XMFLOAT2(0.5f, 0.0f);

//       정점 위치(1, -1, 0)는 텍스처의 오른쪽 하단(1, 1)에 매핑
vertices[2].position = XMFLOAT3(1.0f, -1.0f, 0.0f);
vertices[2].texture = XMFLOAT2(1.0f, 1.0f);
```

> - u, v 좌표를 이용해 3D 모델의 특정 정점이 텍스처의 어느 부분에 해당하는지를 매핑(mapping)
> - 매핑을 통해 렌더링 시 삼각형의 각 정점 사이의 공간은 텍스처의 해당 좌표들 사이의 픽셀들로 채워짐

---

# UV Coordinate Interpolation
사용자가 정점(vertex)에 UV 좌표를 지정하면 그 **정점들로 이루어진 면 내부의 공간은 GPU가 텍스처 픽셀(texel)로 채움**

## 렌더링 파이프 라인 단계

---

**1.데이터 준비 (CPU -> GPU)**
- 정점 버퍼(Vertex Buffer): 3D 모델을 구성하는 각 정점의 데이터를 GPU에 보냄
   - 위치 좌표 (X, Y, Z): 3D 공간에서의 정점 위치
   - 텍스처 좌표 (U, V): 2D 텍스처 맵에서의 정점 위치 (U는 가로, V는 세로)

---

**2.버텍스 셰이더 (Vertex Shader)**
- GPU는 모델의 모든 정점에 대해 버텍스 셰이더를 실행
- 이때, **UV 좌표는 계산하지 않고 그대로 다음 단계로 전달**
- 각 정점은 변환된 화면 좌표와 함께 자신의 UV 좌표를 계속 가지고 있음

---

**3.래스터화 (Rasterization) - 핵심 단계!**

- GPU는 3개의 변환된 정점을 보고, 이 **삼각형 내부에 포함될 모든 픽셀(pixel)들을 찾아냄**(Scan Conversion)
  - 이 때 각 픽셀(프래그먼트)에 대해 깊이 값도 함께 계산된다 
- 이렇게 찾아낸 **픽셀 하나하나를 프래그먼트(Fragment)**라고 부름
- 이제 GPU는 이 수많은 프래그먼트 **각각의 색상을 결정**해야 함

---

**4.UV 좌표 보간 (UV Coordinate Interpolation)**
- GPU는 각 프래그먼트의 색상을 결정하기 위해, 해당 **프래그먼트가 삼각형의 세 꼭짓점으로부터 얼마나 떨어져
 있는지를 계산**
- 이때 **무게중심 좌표(Barycentric Coordinates)**라는 기술이 사용됨
  - 예를 들어, 어떤 프래그먼트가 삼각형의 한가운데에 있다면, 세 꼭짓점의 영향을 동일하게(각각 1/3씩) 받음

GPU는 **가중치(weight)**를 그대로 각 꼭짓점의 **UV 좌표에 적용**함

```
   - 프래그먼트의 U = (A정점 가중치 * A정점 U) + (B정점 가중치 * B정점 U) + (C정점 가중치 * C정점 U)
   - 프래그먼트의 V = (A정점 가중치 * A정점 V) + (B정점 가중치 * B정점 V) + (C정점 가중치 * C정점 V)
```

> - 이 계산을 통해, 삼각형 내부의 모든 프래그먼트(픽셀)는 자신만의 고유한 보간된 UV 좌표를 갖게 됨
> - 꼭짓점 사이의 공간이 자연스럽게 연속적인 UV 값으로 채워짐

---

**5.픽셀 셰이더 (Pixel Shader / Fragment Shader)**

- 이제 각 **프래그먼트는 자신만의 보간된 UV 좌표를 가지고 픽셀 셰이더로 전달**됨
- **텍스처 샘플링(Texture Sampling)** 시작
  - 픽셀 셰이더가 **보간된 UV 좌표를 사용하여 텍스처 맵에서 텍셀 (Texel)을 읽어옴**
  - `SamplerState`에서 설정한 필터링 방식(Filtering) (예: `D3D11_FILTER_MIN_MAG_MIP_LINEAR`)에 따라, 주변의 여러 텍셀(760,761번 등)의 색상을 혼합(Blend) 해서 최종 색상을 만들어냄
- 가져온 **텍셀 색상은 조명 등 다른 요소와 결합되어 프래그먼트의 최종 색상이 결정됨**

**6.최종 출력**
- 색상이 결정된 모든 프래그먼트들이 화면에 그려지면서, 매끄럽게 텍스처가 입혀진 3D 모델을 보게 됨

---

# texture.ps

```c++
//GLOBALS
Texture2D shaderTexture : register(t0);
SamplerState SampleType : register(s0);

//typedefs
struct PixelInputType
{
	float4 position : SV_POSITION;
	float2 tex : TEXCOORD0;
};

//pixel shader
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;

	 // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처의 픽셀 색상을 샘플링
	 textureColor = shaderTexture.Sample(sampleType, input.tex);

	 return textureColor;
}
```

- **Texture2D shaderTexture : register(t0)**
  - HLSL(셰이더 언어)에서 2D 텍스처 리소스를 담을 변수를 선언하는 코드
  - GPU의 특정 리소스 슬롯(slot)에 바인딩(연결)되도록 지정하는 구문
    -  **t** : Texture를 의미
    -  **0** : 0번째 슬롯을 의미
  - C++ 코드에서 `deviceContext->PSSetShaderResources(0, ...)` 함수를 호출할 때, **첫 번째 인자인 `0`이 바로 이 `register(t0)`의 `0`과 일치해야 함**
- **SamplerState SampleType : register(s0)**
  - 텍스처를 어떻게 **샘플링** (텍스처에서 픽셀 색상 값을 읽어오는 방법) 할지에 대한 **규칙(필터링, 주소 지정 모드 등)을 정의하는 객체를 담을 변수**
  - GPU의 샘플러 슬롯 0번에 바인딩하라는 의미
    - **s** : Sampler를 의미
    - **0** : 0번째 슬롯을 의미
  - C++ 코드의 `deviceContext->PSSetSamplers(0, ...)` 함수의 첫 번째 인자인 `0`과 매칭됨
    - 이를 통해 C++에서 설정한 샘플링 방식을 셰이더로 전달

---

# KEYWORD NOTE

