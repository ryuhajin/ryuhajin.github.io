---
layout: default
title: "13. FPS Counter, Direct input"
parent: "ResterTekTutorial"
nav_order: 14
---

# 13. FPS Counter, Direct input

- FPS counter : 초당 프레임 카운터
- Direct input : 

---

# FPS
1초 동안 발생하는 프레임 수를 세고 지속적으로 업데이트

## timeGetTime()
Windows 시스템이 **부팅된 후부터 현재까지 경과된 시간을 밀리초(millisecond, 1/1000초) 단위로 반환**

- 리턴값 : DWORD (32비트 부호 없는 정수, unsigned long)

```c++
#include <mmsystem.h>  // 헤더 파일
#pragma comment(lib, "winmm.lib")  // 라이브러리 링크

// 사용 예시
unsigned long endTime = timeGetTime();

std::cout << "작업을 종료합니다... 종료 시간: " << endTime << "ms" << std::endl;
// 작업을 종료합니다... 종료 시간: 1236568ms
```

---

## FPS::Frame()
Frame() 함수는 매 렌더링 프레임마다 호출

> 1초 동안 Frame 함수가 얼마나 불렸나 = 1초 동안 몇 번 화면에 그려졌나 측정

```c++
void FpsClass::Frame()
{
	m_count++;

	if (timeGetTime() >= (m_startTime + 1000))
	{
        // 1초가 경과하면 프레임 수를 fps에 저장
		m_fps = m_count;

        // 카운트 초기화
		m_count = 0;

		m_startTime = timeGetTime();
	}
	
	return;
}
```

---

# Direct input
DirectX 입력 장치용 API(Application Programming Interface)

## 특징
- **다양한 장치 지원**: 키보드, 마우스뿐만 아니라 조이스틱, 게임패드, 레이싱 휠 등 다양한 입력 장치를 지원
- **고급 기능 제공**: 축(axis) 데이터, 버튼 입력, 진동(force feedback) 효과 등 단순한 입력을 넘어선 상세한 제어가 가능
- **높은 반응성**: Windows 메시지(`WM_KEYDOWN` 등)를 통하지 않고 하드웨어에 직접 접근하는 방식을 사용하여 반응 속도가 빠름. 이는 프레임 단위의 정밀한 입력이 중요한 게임에 매우 유리

⚠️ 중요 : DirectInput은 현재 레거시(Legacy) API로 분류
- 최신 게임 개발에서는 키보드/마우스는 **Raw Input (WM_INPUT)**
- 게임패드는 XInput이나 Windows.Gaming.Input을 사용하는 것이 일반적

---

## Direct input 사용

### 1단계: DirectInput 인터페이스 생성
- DirectInput 시스템 전체를 관리하는 최상위 객체(COM 인터페이스)를 생성

```c++
#include <dinput.h>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

// DirectInput8Create 함수를 호출하여 DirectInput의 메인 인터페이스를 생성
result = DirectInput8Create(hinstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&m_directInput, NULL);
if (FAILED(result))
{
    return false;
}
```
**매개변수**
- **hInstance**: 프로그램의 인스턴스 핸들입니다. Windows 프로그래밍의 기본 요소
- **DIRECTINPUT_VERSION**: 사용할 DirectInput의 버전을 지정
- **IID_IDirectInput8**: 생성할 인터페이스의 ID. IDirectInput8 인터페이스 사용
- **(void**)&m_directInput**: 생성된 인터페이스 포인터를 저장할 변수의 주소
- **NULL**: COM 집합(aggregation)에 관련된 것으로, 보통 NULL을 사용

---

### 2단계: 장치 인터페이스 생성
- 사용하고 싶은 특정 장치(예: 키보드)를 제어할 수 있는 인터페이스를 생성

```c++
IDirectInputDevice8* m_keyboard;
HRESULT result;

// CreateDevice 함수로 특정 장치의 인터페이스를 생성
result = m_directInput->CreateDevice(GUID_SysKeyboard, &m_keyboard, NULL);
if (FAILED(result))
{
    return false;
}
```

**매개변수**
- **GUID_SysKeyboard**: 시스템의 기본 키보드를 의미하는 미리 정의된 전역 고유 식별자(GUID)
- **&m_keyboard**: 생성된 키보드 장치 인터페이스 포인터를 저장할 변수의 주소
- **NULL**: COM 집합 관련, 역시 NULL을 사용

---

### 3단계: 데이터 형식 설정
어떤 종류의 데이터를 받을지 알려줘야 함

```c++
HRESULT result;

// SetDataFormat 함수로 장치로부터 어떤 데이터를 받을지 형식을 설정
result = m_keyboard->SetDataFormat(&c_dfDIKeyboard);
if (FAILED(result))
{
    return false;
}
```

**매개변수**
- **&c_dfDIKeyboard**: 이 형식을 지정하면 DirectInput은 256바이트 크기의 배열을 준비
  - 각 바이트는 키보드의 특정 키(예: DIK_A는 'A' 키)에 해당
  - 눌렸을 경우 최상위 비트(0x80)가 1이 됨

---

### 4단계: 협력 수준 설정
내 프로그램이 이 장치를 '어떻게' 사용할지 운영체제에게 알려주는 단계

- 예 : 내 프로그램이 화면 맨 앞에 있을 때만 입력을 받을지, 백그라운드에 있을 때도 받을지 등을 정함

```c++
HRESULT result;

// SetCooperativeLevel 함수로 응용 프로그램이 장치를 어떻게 제어할지 설정
result = m_keyboard->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_EXCLUSIVE);
if (FAILED(result))
{
    return false;
}
```

**매개변수**
- **hWnd**: 입력 처리를 할 윈도우의 핸들
- **DISCL_FOREGROUND**: 창이 활성화(포그라운드) 상태일 때만 입력을 받겠다는 의미
- **DISCL_EXCLUSIVE**: 프로그램이 활성화 상태일 때, 해당 장치에 대한 모든 입력을 온전히 해당 프로그램에게만 전달
- **DISCL_NONEXCLUSIVE**: 다른 응용 프로그램도 이 장치를 사용할 수 있도록 허용

---

### 5단계: 장치 제어권 획득
설정을 끝내고 실제로 장치로부터 데이터를 받기 위해 '제어권'을 획득

```c++
// Acquire 함수를 호출하여 장치에 대한 제어권 얻기
result = m_keyboard->Acquire();
if (FAILED(result))
{
    return false;
}
```

---

### 6단계: 장치 상태 읽기
게임 루프와 같이 반복적으로 호출되는 곳에서 키보드의 현재 상태를 계속해서 읽어오기

```c++
bool InputClass::ReadKeyboard()
{
	HRESULT result;

	// GetDeviceState 함수로 현재 키보드의 상태를 읽어옴
	result = m_keyboard->GetDeviceState(sizeof(m_keyboardState), (LPVOID)&m_keyboardState);
	if (FAILED(result))
	{
		// 만약 다른 창으로 전환되는 등의 이유로 장치의 제어권을 잃었다면
        // 다시 제어권을 획득하려고 시도
		if ((result == DIERR_INPUTLOST) || (result == DIERR_NOTACQUIRED))
		{
			m_keyboard->Acquire();
		}
		else
		{
			return false;
		}
	}

	return true;
}
```

---

### 7단계: 자원 해제
프로그램이 종료될 때는 사용했던 모든 인터페이스를 반드시 해제하여 시스템 자원을 반환한다

```c++

void InputClass::Shutdown()
{
	// Release the keyboard.
	if (m_keyboard)
	{
        // 먼저 제어권 포기
		m_keyboard->Unacquire();

        // 인터페이스 객체 해제
		m_keyboard->Release();
		m_keyboard = 0;
	}

	return;
}

```

---

**링크**
DirectInput을 대체하는 Raw Input(WM_INPUT)에 대한 글
- [Taking Advantage of High-Definition Mouse Movement](https://learn.microsoft.com/en-us/windows/win32/dxtecharts/taking-advantage-of-high-dpi-mouse-movement)

---

# KEYWORD NOTE
