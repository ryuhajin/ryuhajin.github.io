---
layout: default
title: "5. Diffuse Lighting"
parent: "ResterTekTutorial"
nav_order: 6
---

# 5. Diffuse Lighting

- [Introduction to Shading](https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/what-is-shading-light-matter-interaction.html)

## 프레임 워크 요소
- **LightClass 추가**: 장면에 있는 빛의 특성(방향, 색상)을 캡슐화
- **LightShaderClass 추가**: 모델에 조명 셰이딩을 적용하는 역할. 기존의 `TextureShaderClass`를 대체
- **ModelClass 수정**: 정점(vertex) 데이터에 법선(normal) 벡터를 포함하도록 `VertexType` 구조체를 확장
- **ApplicationClass 수정**: `LightClass`와 `LightShaderClass`를 사용하도록 초기화 및 렌더링 로직을 업데이트

---

## 조명을 배우기 전 알아두면 좋은 사전 지식
조명 계산은 본질적으로 벡터 연산

### 벡터 정규화 (Vector Normalization)
**벡터의 방향은 그대로 유지한 채, 길이를 1로 만드는 과정**
- 길이가 1인 벡터를 단위 벡터(Unit Vector)라고 부름
- 조명 계산 시 '방향' 정보만을 원할 때가 많음
  - 벡터의 길이가 계산에 영향을 주면 안 되기 때문
- 정규화된 벡터를 사용하면 아래에 설명할 내적(Dot Product) 계산이 매우 간편해짐

---

### 정점 법선 (Vertex Normal)
**3D 모델의 각 정점(vertex)이 어느 방향을 향하고 있는지를 나타내는 단위 벡터**
- 표면에 수직인 방향을 가리킴
- 법선 벡터가 있어야만 빛과 표면이 이루는 각도를 계산할 수 있음
- 평평한 삼각형 면이라도 각 정점의 법선 벡터 값을 다르게 주면, 픽셀 셰이더에서 보간(interpolate)되어 부드러운 곡면처럼 보이게 할 수 있다

---

### 내적 (Dot Product)
- $$A · B = |A||B| cos(θ)$$

**두 벡터가 얼마나 "같은 방향을 바라보는지"를 나타내는 연산**
- 결과값은 스칼라 (숫자 하나)
- 두 벡터 A와 B가 모두 정규화된 단위 벡터라면, A와 B는 모두 1이 됨
  - 따라서 $$A · B = cos(θ)$$ 가 됨

> cos(θ) 값은 -1에서 1 사이의 값을 가짐
> - 두 벡터가 같은 방향이면 (θ=0°), 결과는 1 (최대 밝기).
> - 두 벡터가 90° 각도이면 (θ=90°), 결과는 0 (빛을 받지 않음).
> - 두 벡터가 반대 방향이면 (θ=180°), 결과는 -1 (빛의 반대편을 향함).

<br>

"표면의 법선 벡터"와 "빛의 방향 벡터"를 내적하면 **표면이 빛을 얼마나 정면으로 받고 있는지를 0~1 사이의 값으로 간단히 계산할 수 있다** <br>

---

# Diffuse Lighting (난반사 조명)
빛이 표면에 닿았을 때, **모든 방향으로 균일하게 흩어지는(scattering) 현상을 모델링** <br>
페인트 벽, 종이처럼 반짝이지 않는 대부분의 물체 표면에서 일어나는 빛의 반사

## 특징
- 어느 각도에서 보아도 반사되는 빛의 양이 동일합니다. 즉, 시점(카메라 위치)에 영향을 받지 않음
- 오직 표면이 빛을 얼마나 정면으로 마주하고 있는지에만 영향을 받음

## 계산법
1. 표면의 법선 벡터(N)를 구함
2. 표면에서 광원(Light)으로 향하는 빛의 방향 벡터(L)를 구함
3. N과 L을 모두 정규화(Normalize)
4. 두 단위 벡터를 내적(Dot Product)함 (`diffuse_intensity = dot(N, L)`)
5. 내적 결과가 음수이면 (즉, 표면이 빛의 반대 방향을 향하고 있으면) 빛을 받지 못하므로, 결과값을 0으로
  처리. (보통 `max(0, dot(N, L))` 함수를 사용)
6. **diffuse_intensity (0~1 사이의 값)에 빛의 색상과 물체의 색상을 곱하면 최종적인 난반사 색상이
  결정**

> Diffuse Lighting은 "이 표면이 빛을 얼마나 직접적으로 받고 있는가?"를 계산하는 것

---

## Directional Lighting (방향성 조명)
아주 멀리 있는 광원을 시뮬레이션 (예 : 태양)

## 특징
- 씬(Scene) 안의 모든 물체에 빛이 동일한 방향에서 평행하게 들어온다고 가정
- 따라서 Directional Light는 **위치(Position)가 없고, 오직 방향(Direction)만 가짐**
- 모든 픽셀 셰이더에서 동일한 빛의 방향 벡터를 사용하므로 계산이 매우 효율적입니다.

## 계산법
1. Diffuse Lighting 계산에 사용되는 빛의 방향 벡터(L)가 씬의 모든 곳에서 상수(constant)가 됨
2. 예를 들어, "하늘 위에서 아래로" 비추는 빛을 만들고 싶다면, 빛의 방향 벡터를 (0, -1, 0)과 같이 하나로
   고정해둠
3. 모든 조명 계산에 사용

> Directional Lighting은 태양처럼 "모든 곳에 동일한 방향으로 내리쬐는 빛"을 표현하는 방법

---

# Radians
각도를 표현하는 단위를 그래픽스 라이브러리(Direct3D, OpenGL)나 수학 함수(sin, cos)는 **라디안(radian)**이라는 단위를 사용

**설명이 잘 되어있는 링크** : [radians](https://www.mathsisfun.com/geometry/radians.html) - 왜 π radians이 180도인지 잘 보여줌

---

- 도(Degree)를 라디안(Radian)으로 변환
  
$$
\text{Radian} = \text{Degree} \times \frac{\pi}{180}
$$

---

- 라디안(Radian)을 도(Degree)로 변환

$$
\text{Degree} = \text{Radian} \times \frac{180}{\pi}
$$

---

```c++
bool ApplicationClass::Frame()
{
	static float rotation = 0.0f;
	bool result;

	// 각 프레임 마다 회전 업데이트
	rotation -= 0.0174532925f * 0.7f;
	if (rotation < 0.0f)
	{
		rotation += 360.0f;
	}

	// 그래픽 장면 렌더링
	result = Render(rotation);
	if (!result)
	{
		return false;
	}

	return true;
}
```

- **rotation -= 0.0174532925f * 0.7f;**
  - `0.0174532925f`는 **PI / 180** 값으로, **1도를 라디안으로 변환한 값**
  - 1도에 0.7f을 곱하여 매 프레임마다 회전하는 속도를 조절
    - 즉 **매 프레임마다 0.7도씩 회전**

---

# rotation direction
**축을 정하는 데 사용한 손과 똑같은 손을 사용해 회전 규칙을 정한다**

**설명이 잘 되어있는 링크**
- [왼손, 오른손 좌표계 설명](https://youtu.be/sSuaJWC60dw?feature=shared)
- [벡터 외적 : '오른손법칙' 정확하게 이해하기](https://youtu.be/9mis_WA-Sy4?feature=shared)

> 외적(Cross Product)에서 a × b와 b × a의 순서에 따라 회전 방향이 결정되는 것이 바로 핵심

---

## 오른손 좌표계의 회전
오른손 좌표계에서는 **'오른손 법칙'**을 사용해 회전의 양(+)의 방향을 정함

1. **오른손 엄지를 회전하려는 축의 양(+)의 방향으로 향하게 함** 
- 예: Z축을 중심으로 회전한다면 엄지를 +Z 방향으로
2. 이때 **나머지 네 손가락이 감기는 방향이 바로 '양(+)의 회전' 방향**
- +Z축 중심 회전: 오른손 엄지를 +Z축으로 향하면, 손가락은 +X축에서 +Y축 방향으로 감김
  - 이것이 바로 Z축에 대한 양(+)의 회전 **(반시계 방향)**
- +X축 중심 회전: 엄지를 +X축으로 향하면, 손가락은 +Y축에서 +Z축 방향으로 감김
- +Y축 중심 회전: 엄지를 +Y축으로 향하면, 손가락은 +Z축에서 +X축 방향으로 감김

## 왼손 좌표계의 회전
**왼손 좌표계에서도 원리는 똑같다. 단지 사용하는 손이 왼손일 뿐**

1. **왼손 엄지를 회전하려는 축의 양(+)의 방향**으로 향하게 함
2. 이때 **나머지 네 손가락이 감기는 방향이 '양(+)의 회전' 방향**

**결과가 어떻게 달라지는지 Z축을 중심으로 살펴보기**
- +Z축 중심 회전: 왼손 엄지를 +Z축으로 향하면, 손가락은 +X축에서 -Y축 방향으로 감김
- 즉, 오른손 좌표계와 회전 방향이 정반대 **(시계 방향)**

---

# mul()
행렬 곱셈(Matrix Multiplication)을 위한 내장 함수

- [dx-graphics-hlsl-mul](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul)

> - **입력으로 어떤 값이 오느냐에 따라 여러 가지 곱셈을 수행** (입력 인자에 따라 동작 방식이 다른 오버로드 함수)

---

### 벡터와 행렬의 곱셈 (좌표 변환)

```c++
mul(vector, matrix);
// vector가 첫번째 인자일 경우 행 벡터(1 x N)로 간주하여 계산
// 수학적 계산: (1 x N) 벡터 * (N x M) 행렬 = (1 x M) 벡터

float3 myVector;      // (1x3) 행 벡터
float3x4 myMatrix;    // (3x4) 행렬

float4 result = mul(myVector, myMatrix); 
// (1x3) * (3x4) = (1x4)
// 결과 벡터의 차원은 행렬의 열 개수인 4가 된다.

mul(matrix, vector);
// matrix가 첫번째 인자일 경우 vector를 열 벡터 ((N x 1)로 간주하여 계산
// 수학적 계산: (M x N) 행렬 * (N x 1) 벡터 = (M x 1) 벡터

float4x3 myMatrix;    // (4x3) 행렬
float3 myVector;      // (3x1) 열 벡터

// (4x3) * (3x1) = (4x1)
// 결과 벡터의 차원은 행렬의 행 개수인 4가 된다.
float4 result = mul(myMatrix, myVector);
```

- **벡터를 행렬과 곱해서 다른 좌표 공간으로 변환(Transform)**하는, 3D 그래픽에서 가장 핵심적인 연산
- 위치 벡터나 방향 벡터(법선 등)를 모델 공간에서 월드 공간으로, 또는 월드 공간에서 뷰 공간 등으로 옮길 때 사용

연산 | 벡터 처리 방식	| 리턴 벡터의 차원 | 
mul(**vector**, matrix)	| 행 벡터 | 입력 matrix의 열(column) 개수
mul(matrix, **vector**)	| 열 벡터 | 입력 matrix의 행(row) 개수

---

### 행렬과 행렬의 곱셈 (변환 결합)
  
```c++
mul(matrixA, matrixB)
```

- 여러 개의 변환을 하나로 합칠 때 사용
- 예를 들어, World * View * Projection 행렬을 미리 계산해서
- WVP라는 최종 행렬 하나를 만들 때 `mul(mul(World, View), Projection)`과 같이 사용

---

# KEYWORD NOTE
lightclass, lightShaderclass에서 모르는 키워드 공부

---

## D3DCompileFromFile()
HLSL 셰이더 코드 파일을 컴파일하여 Direct3D에서 사용할 수 있는 바이트코드로 변환하는 함수

```c++
HRESULT D3DCompileFromFile(
    LPCWSTR pFileName,
    const D3D_SHADER_MACRO *pDefines,
    ID3DInclude *pInclude,
    LPCSTR pEntrypoint,
    LPCSTR pTarget,
    UINT Flags1,
    UINT Flags2,
    ID3DBlob **ppCode,
    ID3DBlob **ppErrorMsgs
);
```

- **pFileName**: 컴파일할 셰이더 파일의 경로 (예: L"./light.vs")
- **pDefines**: 셰이더 매크로 정의. 사용하지 않을 경우 NULL
- **pInclude**: include 처리기 인터페이스. 기본값을 사용하려면 NULL로 설정
- **pEntrypoint**: 셰이더 진입점 함수의 이름
  - **이 이름은 셰이더 파일 내의 함수 이름과 정확히 일치해야 함**
- **pTarget**: 셰이더 모델을 지정
  - "vs_5_0" - Vertex Shader 5.0
  - "ps_5_0" - Pixel Shader 5.0
  - "gs_5_0" - Geometry Shader 5.0
  - "cs_5_0" - Compute Shader 5.0
- **Flags1, Flags2**: 컴파일 옵션 플래그
- **ppCode**: 컴파일된 셰이더 코드를 저장할 ID3DBlob 포인터의 주소
- **ppErrorMsgs**: 오류 메시지를 저장할 ID3DBlob 포인터의 주소

```c++

// 컴파일 : 버텍스 쉐이더 코드
result = D3DCompileFromFile(vsFilename, NULL, NULL, "LightVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, &vertexShaderBuffer, &errorMessage);

if (FAILED(result))
{
    // 셰이더가 컴파일 실패 시 오류 메시지에 해당 내용을 기록
    if (errorMessage)
    {
      OutputShaderErrorMessage(errorMessage, hwnd, vsFilename);
    }
    else
    {
      // 오류 메시지에 아무 내용도 없다면 단순히 셰이더 파일을 찾을 수 없었던 것
      MessageBox(hwnd, vsFilename, L"Missing Shader File", MB_OK);
    }
    return false;
}
```

---

