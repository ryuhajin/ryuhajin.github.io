---
layout: default
title: "5. Diffuse Lighting"
parent: "ResterTekTutorial"
nav_order: 6
---

# 5. Diffuse Lighting

- [Introduction to Shading](https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/what-is-shading-light-matter-interaction.html)

---

## 조명을 배우기 전 알아두면 좋은 사전 지식
조명 계산은 본질적으로 벡터 연산

### 벡터 정규화 (Vector Normalization)
**벡터의 방향은 그대로 유지한 채, 길이를 1로 만드는 과정**
- 길이가 1인 벡터를 단위 벡터(Unit Vector)라고 부름
- 조명 계산 시 '방향' 정보만을 원할 때가 많음
  - 벡터의 길이가 계산에 영향을 주면 안 되기 때문
- 정규화된 벡터를 사용하면 아래에 설명할 내적(Dot Product) 계산이 매우 간편해짐

---

### 정점 법선 (Vertex Normal)
**3D 모델의 각 정점(vertex)이 어느 방향을 향하고 있는지를 나타내는 단위 벡터**
- 표면에 수직인 방향을 가리킴
- 법선 벡터가 있어야만 빛과 표면이 이루는 각도를 계산할 수 있음
- 평평한 삼각형 면이라도 각 정점의 법선 벡터 값을 다르게 주면, 픽셀 셰이더에서 보간(interpolate)되어 부드러운 곡면처럼 보이게 할 수 있다

---

### 내적 (Dot Product)
- $$A · B = |A||B| cos(θ)$$

**두 벡터가 얼마나 "같은 방향을 바라보는지"를 나타내는 연산**
- 결과값은 스칼라 (숫자 하나)
- 두 벡터 A와 B가 모두 정규화된 단위 벡터라면, A와 B는 모두 1이 됨
  - 따라서 $$A · B = cos(θ)$$ 가 됨

> cos(θ) 값은 -1에서 1 사이의 값을 가짐
> - 두 벡터가 같은 방향이면 (θ=0°), 결과는 1 (최대 밝기).
> - 두 벡터가 90° 각도이면 (θ=90°), 결과는 0 (빛을 받지 않음).
> - 두 벡터가 반대 방향이면 (θ=180°), 결과는 -1 (빛의 반대편을 향함).

<br>

"표면의 법선 벡터"와 "빛의 방향 벡터"를 내적하면 **표면이 빛을 얼마나 정면으로 받고 있는지를 0~1 사이의 값으로 간단히 계산할 수 있다** <br>

---

# Diffuse Lighting (난반사 조명)
빛이 표면에 닿았을 때, **모든 방향으로 균일하게 흩어지는(scattering) 현상을 모델링** <br>
페인트 벽, 종이처럼 반짝이지 않는 대부분의 물체 표면에서 일어나는 빛의 반사

## 특징
- 어느 각도에서 보아도 반사되는 빛의 양이 동일합니다. 즉, 시점(카메라 위치)에 영향을 받지 않음
- 오직 표면이 빛을 얼마나 정면으로 마주하고 있는지에만 영향을 받음

## 계산법
1. 표면의 법선 벡터(N)를 구함
2. 표면에서 광원(Light)으로 향하는 빛의 방향 벡터(L)를 구함
3. N과 L을 모두 정규화(Normalize)
4. 두 단위 벡터를 내적(Dot Product)함 (`diffuse_intensity = dot(N, L)`)
5. 내적 결과가 음수이면 (즉, 표면이 빛의 반대 방향을 향하고 있으면) 빛을 받지 못하므로, 결과값을 0으로
  처리. (보통 `max(0, dot(N, L))` 함수를 사용)
6. **diffuse_intensity (0~1 사이의 값)에 빛의 색상과 물체의 색상을 곱하면 최종적인 난반사 색상이
  결정**

> Diffuse Lighting은 "이 표면이 빛을 얼마나 직접적으로 받고 있는가?"를 계산하는 것

---

## Directional Lighting (방향성 조명)
아주 멀리 있는 광원을 시뮬레이션 (예 : 태양)

## 특징
- 씬(Scene) 안의 모든 물체에 빛이 동일한 방향에서 평행하게 들어온다고 가정
- 따라서 Directional Light는 **위치(Position)가 없고, 오직 방향(Direction)만 가짐**
- 모든 픽셀 셰이더에서 동일한 빛의 방향 벡터를 사용하므로 계산이 매우 효율적입니다.

## 계산법
1. Diffuse Lighting 계산에 사용되는 빛의 방향 벡터(L)가 씬의 모든 곳에서 상수(constant)가 됨
2. 예를 들어, "하늘 위에서 아래로" 비추는 빛을 만들고 싶다면, 빛의 방향 벡터를 (0, -1, 0)과 같이 하나로
   고정해둠
3. 모든 조명 계산에 사용

> Directional Lighting은 태양처럼 "모든 곳에 동일한 방향으로 내리쬐는 빛"을 표현하는 방법

---

# mul()
행렬 곱셈(Matrix Multiplication)을 위한 내장 함수

- [dx-graphics-hlsl-mul](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul)

> - **입력으로 어떤 값이 오느냐에 따라 여러 가지 곱셈을 수행** (입력 인자에 따라 동작 방식이 다른 오버로드 함수)

---

### 벡터와 행렬의 곱셈 (좌표 변환)

```c++
mul(vector, matrix);
// vector가 첫번째 인자일 경우 행 벡터(1 x N)로 간주하여 계산
// 수학적 계산: (1 x N) 벡터 * (N x M) 행렬 = (1 x M) 벡터

float3 myVector;      // (1x3) 행 벡터
float3x4 myMatrix;    // (3x4) 행렬

float4 result = mul(myVector, myMatrix); 
// (1x3) * (3x4) = (1x4)
// 결과 벡터의 차원은 행렬의 열 개수인 4가 된다.

mul(matrix, vector);
// matrix가 첫번째 인자일 경우 vector를 열 벡터 ((N x 1)로 간주하여 계산
// 수학적 계산: (M x N) 행렬 * (N x 1) 벡터 = (M x 1) 벡터

float4x3 myMatrix;    // (4x3) 행렬
float3 myVector;      // (3x1) 열 벡터

// (4x3) * (3x1) = (4x1)
// 결과 벡터의 차원은 행렬의 행 개수인 4가 된다.
float4 result = mul(myMatrix, myVector);
```

- **벡터를 행렬과 곱해서 다른 좌표 공간으로 변환(Transform)**하는, 3D 그래픽에서 가장 핵심적인 연산
- 위치 벡터나 방향 벡터(법선 등)를 모델 공간에서 월드 공간으로, 또는 월드 공간에서 뷰 공간 등으로 옮길 때 사용

연산 | 벡터 처리 방식	| 리턴 벡터의 차원 | 
mul(**vector**, matrix)	| 행 벡터 | 입력 matrix의 열(column) 개수
mul(matrix, **vector**)	| 열 벡터 | 입력 matrix의 행(row) 개수

---

### 행렬과 행렬의 곱셈 (변환 결합)
  
```c++
mul(matrixA, matrixB)
```

- 여러 개의 변환을 하나로 합칠 때 사용
- 예를 들어, World * View * Projection 행렬을 미리 계산해서
- WVP라는 최종 행렬 하나를 만들 때 `mul(mul(World, View), Projection)`과 같이 사용

---

