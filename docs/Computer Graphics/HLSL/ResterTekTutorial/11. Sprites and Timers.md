---
layout: default
title: "11. Sprites and Timers"
parent: "ResterTekTutorial"
nav_order: 12
---

# 11. Sprites and Timers

## Data Driven Design 데이터 기반 설계
프로그램의 핵심 로직(알고리즘)과 이 로직이 사용할 데이터를 명확하게 분리하는 소프트웨어 설계 방식

- 렌더링할 객체의 속성 (색상, 크기, 위치 등)을 코드 안에 직접 하드코딩하지 않음
- 텍스트 파일, 슬라이더가 있는 도구 등을 사용하여 프로그램의 내용이나 흐름을 제어

> 예제에서는 스프라이트 작동 방식을 텍스트 파일을 읽어 제어하는 방식으로 구현

---

## Sprite Data

```c++
 // 스프라이트를 구성하는 targa 이미지의 개수
4
// 스프라이트를 구성하는 각 targa 이미지의 파일 경로 및 이름
../texture/sprite01.tga 
../texture/sprite02.tga
../texture/sprite03.tga
../texture/sprite04.tga
// 스프라이트가 이미지를 순환할 속도(밀리초)
250
```

- 해당 텍스트 파일을 읽어 파싱한 뒤 사용

---

# Sprite rendering (스프라이트 애니메이션 렌더링 흐름)
여러 장의 텍스처를 배열에 저장해두고, 일정한 시간마다 다음 텍스처로 교체하여 화면에 그려주는 방식으로 동작

- 전체 흐름은 **초기화 → 프레임 업데이트 → 렌더링** 순서로 진행

## 1. 초기화 및 텍스처 로딩
애플리케이션 시작 시, SpriteClass는 애니메이션에 사용될 모든 텍스처를 미리 로드하여 m_Textures 배열에 저장

```cpp
bool SpriteClass::LoadTextures(ID3D11Device* device, ID3D11DeviceContext* deviceContext, char* filename)
{
    ifstream fin;

    // ...
    // 파일에서 텍스처 개수 읽기
    fin >> m_textureCount;

    // 텍스처 개수만큼 배열 할당
    m_Textures = new TextureClass[m_textureCount];

    // 각 텍스처 파일에 대해 반복하며 로드
    for (i = 0; i < m_textureCount; i++)
    {
        // ... (파일 경로 읽기)
        // m_Textures 배열의 각 요소에 텍스처를 로드
        result = m_Textures[i].Initialize(device, deviceContext, textureFilename);
        // ...
    }

    // 애니메이션 주기(cycle time) 읽기
    fin >> m_cycleTime;
    // ...
    // 정수 밀리초를 부동 소수점 형식으로 변환
    m_cycleTime = m_cycleTime * 0.001f;
    
    return true;
}
```

---

## 2. 프레임 업데이트 및 텍스처 갱신
매 프레임마다 어떤 텍스처를 보여줄지 결정

```cpp
// spriteclass.cpp
void SpriteClass::Update(float frameTime)
{
    // 매 프레임마다 경과 시간을 누적
    m_frameTime += frameTime;

    // 누적 시간이 설정된 주기를 넘었는지 확인
    if (m_frameTime >= m_cycleTime)
    {
        // 누적 시간을 재설정하고 다음 텍스처로 전환
        m_frameTime -= m_cycleTime;
        
        // 다음 텍스처를 가리키도록 인덱스 증가
        m_currentTexture++;

        // 마지막 텍스처였다면 처음으로 되돌림
        if (m_currentTexture == m_textureCount)
        {
            m_currentTexture = 0;
        }
    }
}
```

1. 프레임 간의 경과 시간(`frameTime`)을 `m_frameTime`에 누적 
2. 누적된 시간이 지정된 주기(`m_cycleTime`)를 넘어서면, 현재 텍스처를 가리키는 인덱스 `m_currentTexture`를 1 증가시켜 다음 프레임으로 전환

---

## 3. 렌더링

`Update` 함수에서 갱신된 `m_currentTexture` 인덱스를 사용하여 현재 프레임에 맞는 텍스처를 화면에 그림


```cpp
// applicationclass.cpp
bool ApplicationClass::Render()
{
    // ...
    // 셰이더를 통해 그릴 때, m_Sprite->GetTexture()로 현재 텍스처를 가져옴
    result = m_TextureShader->Render(m_Direct3D->GetDeviceContext(), m_Sprite->GetIndexCount(), worldMatrix, viewMatrix, orthoMatrix, m_Sprite->GetTexture());
    // ...
}
```

---

```cpp
// spriteclass.cpp
ID3D11ShaderResourceView* SpriteClass::GetTexture()
{
    // m_Textures 배열에서 m_currentTexture 인덱스에 해당하는 텍스처를 반환
    return m_Textures[m_currentTexture].GetTexture();
}
```

- 이 텍스처는 최종적으로 `TextureShaderClass`에 의해 픽셀 셰이더에 설정되고, `DrawIndexed` 호출을 통해 화면에 그려짐

---

# Timer
컴퓨터의 CPU는 사람의 심장 박동처럼 일정한 속도로 신호를 만들어내는 내부 시계(Internal Clock)를 가지고 있다

## Crystal Oscillator
특정 모양으로 자른 수정 조각에 전압을 가하면, 수정이 일정한 주파수(Frequency)로 매우 빠르게 떨리는 **압전 효과(Piezoelectric Effect)**가 발생

- 떨림이 바로 규칙적인 전기 신호, 즉 **클럭 신호(Clock Signal)**가 됨

## Clock Speed & Hz (클럭 속도와 헤르츠)
얼마나 빨리 진동하는지 나타내는 단위가 바로 **클럭 속도(Clock Speed)**,  **헤르츠(Hz)**로 측정

```md
- 1 Hz: 1초에 1번 진동하는 속도
- 1 KHz (킬로헤르츠): 1초에 1,000번
- 1 MHz (메가헤르츠): 1초에 1,000,000번 (백만 번)
- 1 GHz (기가헤르츠): 1초에 1,000,000,000번 (십억 번)
```

> - 3.2 GHz CPU는 1초에 32억 번의 클럭 신호를 만들어 냄
> - 이 신호는 0과 1이 반복되는 디지털 파형(Square Wave)의 형태를 가짐

---

## Clock Cycle
CPU가 가장 기본적인 작업을 수행하는 데 걸리는 시간 단위. **진동 한번을 클럭 사이클(Clock Cycle)** 또는 **클럭 틱(Clock Tick)**이라고 부름

- 신호가 한 번 올라갔다가 내려와 제자리로 돌아오는 전체 과정을 1 클럭 사이클이라고 한다
- CPU는 이 클럭 싸이클이 일어날 때 하나의 기본 연산을 처리

## 클럭 사이클과 CPU 연산
클럭 사이클은 CPU가 수행할 수 있는 가장 작고 **원자적인(atomic) 작업의 기준이 됨**

> 명령어(Instruction) 와의 관계: '1 클럭 사이클 = 1 명령어'가 아니라는 것

프로그래밍 언어의 한 줄 `(a = b + c;)` 은 컴파일을 거치면 여러 개의 **기계어 명령어(Instruction)**로 번역된다

그리고 이 **기계어 명령어 하나를 처리하기 위해서는 또다시 여러 번의 클럭 사이클이 필요**하다

1. 1단계 (Fetch): 메모리에서 명령어를 가져온다. (여러 클럭 사이클 소요)
2. 2단계 (Decode): 명령어를 해석한다. (여러 클럭 사이클 소요)
3. 3단계 (Execute): 명령어를 실행한다. (여러 클럭 사이클 소요)

---

## Clock Cycle vs Clock Speed
- 클럭 사이클 (Clock Cycle): 시간의 길이
  - 시간의 단위
  - CPU가 가장 기본적인 작업 하나를 처리하는 데 필요한 시간을 의미
- 클럭 속도 (Clock Speed): 빈도(빠르기)
  - 주파수 빠르기의 단위
  - 1초 동안 클럭 사이클이 몇 번이나 반복되는지를 나타냄. 단위는 헤르츠(Hz)

관점|	클럭 사이클 (Clock Cycle)|	클럭 속도 (Clock Speed)|
의미|	한 번의 진동에 걸리는 시간	|1초당 발생하는 진동의 횟수|
단위|	초 (s), 나노초 (ns)	|헤르츠 (Hz), 기가헤르츠 (GHz)|
비유|	걸음 하나에 걸리는 시간|	1초에 걷는 걸음 수|

**예시**
어떤 CPU의 클럭 속도가 4 GHz 라 가정
- **4 GHz = 4,000,000,000 Hz** (1초에 40억 번 진동)
- 이 CPU의 클럭 사이클 시간은 **1 / 4,000,000,000 초 = 0.00000000025 초**

이것을 읽기 쉽게 나노초(ns, 10억 분의 1초) 단위로 바꾸면 0.25 ns

---

