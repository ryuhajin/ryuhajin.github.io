---
layout: default
title: "1. Creating a Framework and Window"
parent: "ResterTekTutorial"
nav_order: 2
---

# 1. Creating a Framework and Window

## 프레임 워크 요소
- **main.cpp** : 응용 프로그램의 진입점을 처리하기 위해 WinMain 함수
  - 시스템 클래스 포함
- **systemclass** : inputclass, applicaionclass 포함
  - **inputclass** : 사용자 입력 처리
  - **applicationclass** : 그래픽 코드를 처리하여 렌더링

---

# KEYWORD NOTE
systemclass 소스 코드에서 모르는 키워드 공부

---

## MSG structure
Windows 운영체제에서 발생하는 다양한 이벤트 정보를 담는 구조체
- 사용자가 키보드를 누르거나, 마우스를 움직이거나, 창의 크기를 조절하는 등의 모든 행위는
- Windows에 의해 메시지로 변환되어 해당 애플리케이션의 메시지 큐에 쌓임

### MSG 구조체 정보
- hwnd: 메시지가 발생한 Window의 핸들(고유 식별자)
- message: 어떤 종류의 메시지인지 나타내는 정수 값 (예: WM_KEYDOWN, WM_MOUSEMOVE, WM_QUIT)
- wParam, lparam: 메시지에 대한 추가적인 정보
  - 키보드 메시지 : 어떤 키가 눌렸는지
  - 마우스 메시지 : 마우스의 좌표가 무엇인지
- time: 메시지가 발생한 시간
- pt: 메시지 발생 시점의 마우스 커서 위치 (화면 좌표)

> 메시지 루프는 메시지 큐에서 메시지를 하나씩 커내와서 처리하는 역할을 함

---

## Message Queue
메시지 큐 관리

### PeekMessage
메시지 큐에 메시지가 있는지 확인

- `PeekMessage`는 메시지가 없는 동안에도 Frame() 함수를 호출하여 게임 로직이나 렌더링을 계속해서 실행할 수 있음
- 실시간으로 화면이 변해야 하는 게임이나 그래픽 프로그램에서 필수적
 - `PM_REMOVE` 옵션은 메시지를 확인한 후 큐에서 제거하라는 의미

> `GetMessage`와 다른점? : `GetMessage`는 메시지가 올 때까지 프로그램의 실행을 멈추고 기다림


### TranslateMessage
키보드 입력 메시지를 가공

- `WM_KEYDOWN` (키가 눌림)과 `WM_KEYUP` (키가 떨어짐) 같은 저수준 메시지가 발생했을 때, 이를 조합하여
   `WM_CHAR` (문자 입력) 메시지를 생성

> - 예 : 사용자가 'Shift' 키를 누른 상태에서 'a' 키를 누름
> - `TranslateMessage`는 이를 해석해서 대문자 'A'에 해당하는 `WM_CHAR` 메시지를 만든다

### DispatchMessage
메시지를 실제 창의 처리 함수로 "보내는(dispatch)" 역할

- msg 구조체에 담긴 hwnd (창 핸들)를 보고, 해당 창에 등록된 윈도우 프로시저(WndProc) 함수를 호출함
- WndProc 함수는 DispatchMessage에 의해 호출되고, WndProc은 메시지 처리 핸들링을 하게됨

---

## VK_ESCAPE
Virtual-Key Code의 약자로, 키보드의 물리적인 키에 대한 가상 코드


가상 키 코드 (VK) | 키보드 키 | 설명 |
VK_ESCAPE        | Esc      | 이스케이프 키   |
VK_RETURN   | Enter     | 엔터 키   |
VK_SPACE    | Spacebar  | 스페이스 바     |
VK_TAB| Tab | 탭 키     |
VK_SHIFT    | Shift     | Shift 키 (왼쪽, 오른쪽 구분 없음) |
VK_LSHIFT   | Left Shift| 왼쪽 Shift 키   |
VK_RSHIFT   | Right Shift     | 오른쪽 Shift 키 |
VK_CONTROL  | Ctrl| Ctrl 키 (왼쪽, 오른쪽 구분 없음)  |
VK_LCONTROL | Left Ctrl | 왼쪽 Ctrl 키    |
VK_RCONTROL | Right Ctrl| 오른쪽 Ctrl 키  |
VK_MENU     | Alt | Alt 키 (메뉴 키, 왼쪽/오른쪽 구분 없음) |
VK_LMENU    | Left Alt  | 왼쪽 Alt 키     |
VK_RMENU    | Right Alt | 오른쪽 Alt 키   |
VK_CAPITAL  | Caps Lock | Caps Lock 키    |
VK_BACK     | Backspace | 백스페이스 키   |
VK_DELETE   | Delete    | Delete 키 |
VK_UP | ↑ (Up Arrow)    | 위쪽 화살표 키  |
VK_DOWN     | ↓ (Down Arrow)  | 아래쪽 화살표 키|
VK_LEFT     | ← (Left Arrow)  | 왼쪽 화살표 키  |
VK_RIGHT    | → (Right Arrow) | 오른쪽 화살표 키|

---

## DefWindowProc()
Windows가 제공하는 기본 메시지 처리 함수

- 메세지 핸들러에서 `WM_KEYDOWN`과 `WM_KEYUP`처럼 내가 특별히 처리하고 싶은 메시지만을 골라서 처리함
- 그 외에 우리가 신경 쓰지 않는 나머지 모든 메시지들은 `DefWindowProc` 함수을 통해 전달

> DefWindowProc 함수가 창 이동, 크기 조절, 최소화/최대화 등과 같은 기본적인 창의 동작들을 알아서 처리

---

## GetSystemMetrics(SM_CXSCREEN)
시스템(주로 디스플레이)의 다양한 크기나 설정 값들을 얻어오는 함수

- SM_CXSCREEN
  - "System Metrics, C(ount of) X, SCREEN"
  - 주 모니터 화면의 너비(width)를 픽셀 단위로 반환
- SM_CYSCREEN
  - 주 모니터 화면의 높이(height)를 픽셀 단위로 반환

> `GetSystemMetrics(SM_CXSCREEN)` 함수를 통해 현재 사용자의 모니터 해상도가 얼마인지를 알 수 있음

---

## HRESULT
COM(Component Object Model) 에서 사용되는 표준 반환 코드 타입

- "Handle to RESULT" 의 약자
- 함수나 메서드의 실행 결과(성공, 실패, 추가 정보)를 통일된 방식으로 반환하기 위해 설계

## 특징
1. 성공/실패 판단: `SUCCEEDED()`와 `FAILED()` 매크로로 쉽게 확인 가능
2. 풍부한 정보: 오류의 출처, 심각도, 구체적인 원인 포함
3. 표준화: 모든 COM 인터페이스에서 일관되게 사용

## 구조
> 32비트(4바이트) 크기의 부호 있는 정수(long)

```
31  30  29  28  27  26  25 ... 16   15 ... 0
+---+---+---+---+---+---+-------+-----------+
| S | R | C | N | X |  Facility |   Code    |
+---+---+---+---+---+---+-------+-----------+
```

- **S (1비트)**: 심각도 비트 (0 = 성공, 1 = 실패)
- **R, C, N, X**: 예약된 비트 (일반적으로 0)
- **Facility (11비트)**: 오류가 발생한 그룹 또는 기능을 나타내는 11비트 코드
- **Code (16비트)**: 오류의 구체적인 원인을 나타내는 16비트 코드

### 코드 예시

```c++
HRESULT hr = SomeComFunction();

if (SUCCEEDED(hr)) {
    // 성공 처리
    std::cout << "작업 성공!" << std::endl;
} else {
    // 실패 처리
    std::cerr << "오류 발생: 0x" << std::hex << hr << std::endl;
    
    // 구체적인 오류 처리
    if (hr == E_INVALIDARG) {
        std::cerr << "잘못된 인수입니다." << std::endl;
    } else if (hr == E_OUTOFMEMORY) {
        std::cerr << "메모리가 부족합니다." << std::endl;
    }
}
```

**링크**
- [Structure of COM Error Codes](https://learn.microsoft.com/en-us/windows/win32/com/structure-of-com-error-codes)

---

## LRESULT
윈도우 메시지 처리를 위한 반환 값

> WindowProc 메시지를 처리한 후 운영체제(Windows)에게 결과를 돌려줄 때 사용

## 특징
1. 값 자체로는 성공/실패를 알 수 없고, 문맥에 따라 해석해야 함
2. 메시지 종류(WM_XXX)에 따라 의미가 완전히 달라짐
3. WindowProc 함수 내부에서 메시지를 처리하고 반환

### 코드 예시

```c++
LRESULT CALLBACK WndProc(HWND hwnd, UINT umessage, WPARAM wparam, LPARAM lparam)
{
	switch (umessage)
	{
		// 창 파괴 확인
		case WM_DESTROY:
		{
			PostQuitMessage(0);
			return 0;
		}

		// 창 닫히는지 확인
		case WM_CLOSE:
		{
			PostQuitMessage(0);
			return 0;
		}

		// 다른 모든 메시지는 시스템 클래스의 메시지 핸들러로 전달
		default:
		{
			return ApplicationHandle->MessageHandler(hwnd, umessage, wparam, lparam);
		}
	}
}
```

---

## CALLBACK 
이 함수는 특별한 규칙에 따라 호출되어야 한다고 컴파일러에게 알려주는 지시어(매크로)

```c++
#define CALLBACK __stdcall
```
- CALLBACK은 내부적으로 `__stdcall` 이라는 키워드로 정의
- 함수를 호출하고 인자를 전달하는 방식(호출 규약)을 지정

### 호출 규약이 왜 필요할까?
함수가 호출될 때, 컴퓨터 내부에서는 다음과 같은 일이 일어남

 1. 함수에 전달할 인자(파라미터)들을 메모리(스택)에 순서대로 쌓음
 2. 함수의 코드가 있는 곳으로 점프하여 실행
 3. 함수 실행이 끝나면, 스택에 쌓아두었던 인자들을 정리하고 원래 위치로 돌아옴

> 스택을 누가 정리할 것인가? 에 따라 호출 규약이 나뉨
- `__cdecl` (C/C++의 기본 방식) : 함수를 호출한 쪽(Caller)이 스택을 정리
- `__stdcall` (Windows API의 표준 방식) : 함수 자신(Callee)이 스택을 정리

### CALLBACK(__stdcall)을 쓰는 이유
- WndProc의 호출자는 Windows 운영체제
- 내가 WndProc을 직접 호출하지 않았음
- `CALLBACK(__stdcall)` 규약에 따라, 호출당한 함수인 `WndProc`이 스스로 스택을 정리할 책임을 가짐

---

