---
layout: default
title: "3. Buffers, Shaders, and HLSL"
parent: "ResterTekTutorial"
nav_order: 4
---

# 3. Buffers, Shaders, and HLSL

## 프레임 워크 요소
Application Class에 하위 클래스 (`ModelClass`, `CameraClass`, `ColorShaderClass`) 추가

- **applicationclass** : 그래픽 코드를 처리하여 렌더링
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리
  - **ModelClass** : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화
  - **CameraClass** : 씬(Scene)을 바라보는 시점(Viewpoint) 관리
  - **ColorShaderClass** : 특정 셰이더 파일(`color.vs`, `color.ps`)을 사용하여 모델을 렌더링하는 모든 과정을 총괄


## ModelClass
1.  모델을 구성하는 정점(위치, 색상 등)과 인덱스 데이터를 메모리에 정의
2.  이 데이터로 **정점 버퍼(Vertex Buffer)**와 **인덱스 버퍼(Index Buffer)**를 생성하고 GPU에 로드
3.  자신의 버퍼를 렌더링 파이프라인에 설정하여 그릴 수 있도록 `Render()` 함수를 제공

## CameraClass
1.  카메라의 위치(Position)와 회전(Rotation) 값을 추적
2.  카메라 위치와 회전 값을 바탕으로 매 프레임마다 **뷰 행렬(View Matrix)**을 계산하여 제공
    - 뷰 행렬은 월드 공간의 모든 물체를 카메라의 시점으로 변환하는 역할

## ColorShaderClass
1.  HLSL 셰이더 파일을 컴파일하고 GPU에 로드하여 **정점 셰이더와 픽셀 셰이더 객체**를 생성
2.  C++ 코드에서 정점 데이터를 셰이더로 넘겨주기 위한 **입력 레이아웃(Input Layout)**을 생성
3.  월드, 뷰, 투영 행렬을 담을 **상수 버퍼(Constant Buffer)**를 생성
4.  `Render()` 함수를 통해 필요한 행렬들을 상수 버퍼에 업데이트하고, 최종적으로 셰이더를 활성화하여 모델의 `DrawIndexed()`를 호출, 렌더링을 실행

---

# 핵심 개념 정의

## 정점 버퍼 (Vertex Buffer)
3D 모델을 구성하는 모든 **점(Vertex, 정점)**들의 데이터를 담고 있는 GPU 메모리 공간

- 각 정점은 **위치(Position)** 정보(x, y, z)를 필수로 가짐
- 필요에 따라 **색상(Color)**, 법선(Normal), 텍스처 좌표(UV) 등 추가 정보를 가짐
> 이 모든 정점 데이터를 배열 형태로 GPU에 보내기 위한 버퍼입

## 인덱스 버퍼 (Index Buffer)
정점 버퍼에 있는 정점들의 **순서(Index, 색인)**를 저장하여, 어떤 정점들을 연결해서 삼각형을 만들지 알려주는 메모리 공간

- 정점 데이터의 중복을 제거하여 메모리를 절약하고, GPU 캐시 효율을 높여 렌더링 성능을 향상

## HLSL (High-Level Shading Language)
GPU에서 실행되는 프로그램인 **셰이더(Shader)**를 작성하기 위한 C-스타일 프로그래밍 언어

>- 프로그래머가 렌더링 파이프라인의 특정 단계를 직접 제어하여 원하는 그래픽 효과를 만들 수 있게 함

## 정점 셰이더 (Vertex Shader)
정점 버퍼에 있는 **모든 정점 각각에 대해 한 번씩 실행**되는 HLSL 프로그램

- 3D 모델의 정점 좌표를 2D 화면 좌표로 변환하는 **좌표 변환**을 수행

> - **입력:** 단일 정점 데이터 (위치, 색상 등), 월드/뷰/투영 행렬 (상수 버퍼)
> - **출력:** 변환된 정점의 위치 (`SV_POSITION`), 픽셀 셰이더로 전달할 데이터

## 픽셀 셰이더 (Pixel Shader)
화면에 그려질 **모든 픽셀 각각에 대해 한 번씩 실행**되는 HLSL 프로그램

- 픽셀의 **최종 색상을 결정**. 조명, 텍스처 매핑 등 복잡한 효과를 이 단계에서 처리

> - **입력:** 정점 셰이더에서 보간된 데이터 (색상, 텍스처 좌표 등)
> - **출력:** 해당 픽셀의 최종 색상 (`SV_TARGET`)

---

# HLSL keyword

- 자료형 

자료형 | 설명 | 예시 |
`float`, `int`, `bool` | 단일 스칼라 값 (C언어와 유사) | `float time;` |
`float2`, `float3`, `float4` | 2, 3, 4개의 float를 갖는 벡터. GPU는 벡터 연산에 특화되어 있음 | `float4 position;` |
`int2`, `int3`, `int4` | 2, 3, 4개의 int를 갖는 벡터 | `int2 textureCoords;` |
`matrix` | 4x4 크기의 행렬. `float4x4`와 동일하며 좌표 변환에 필수 | `matrix worldMatrix;` |
`sampler`, `Texture2D` | 텍스처 샘플링 및 텍스처 객체를 위한 자료형 | `Texture2D shaderTexture;` |

- 구조

구조 | 설명 | 예시 |
 `struct` | 여러 변수를 묶는 사용자 정의 자료형. 셰이더 스테이지 간 데이터 전달에 사용 | `struct VertexInputType { ... };` |
 `cbuffer` | 상수 버퍼(Constant Buffer). CPU에서 GPU로 데이터를 전달하는 주된 방법 | `cbuffer MatrixBuffer { ... };` |

- 시맨틱

시맨틱 | 설명 | 예시 |
 `: POSITION`, `: COLOR` | 정점 입력 데이터의 용도를 지정하는 꼬리표. C++의 입력 레이아웃과 연결됨 | `float4 pos : POSITION;` |
`: TEXCOORD0`, `: NORMAL` | 텍스처 좌표, 법선 벡터(조명 계산용) 데이터 용도를 지정 | `float2 tex : TEXCOORD0;` |
`: SV_POSITION` | **S**ystem-**V**alue 시맨틱. 정점 셰이더의 필수 '출력'으로, 클립 공간 좌표를 의미 | `float4 pos : SV_POSITION;` |
`: SV_TARGET` | **S**ystem-**V**alue 시맨틱. 픽셀 셰이더의 필수 '출력'으로, 최종 픽셀 색상을 의미 | `float4 color : SV_TARGET;` |

- 내장 함수

함수| 설명 | 예시 |
 `mul(a, b)` | 벡터-행렬, 행렬-행렬 곱셈. 좌표 변환의 핵심 | `mul(pos, worldMatrix)` |
`dot(a, b)` | 두 벡터의 내적(dot product). 조명 계산 시 빛의 각도를 구할 때 사용 | `dot(lightVec, normal)` |
`cross(a, b)` | 두 벡터의 외적(cross product). 법선 벡터를 계산할 때 사용 | `cross(vec1, vec2)` |
`normalize(v)` | 벡터 `v`를 정규화 (길이를 1로 만듦). 방향 벡터 계산에 필수 | `normalize(lightVec)` |
`saturate(x)` | `x`의 값을 0.0 ~ 1.0 사이로 제한. 색상이나 조명 계수를 범위 안에 둘 때 사용 | `saturate(dotResult)` |
`lerp(a, b, x)` | `a`와 `b`를 `x` 비율(0~1)로 선형 보간. 부드러운 전환 효과에 사용 | `lerp(color1, color2, 0.5)` |
`tex2D(sampler, uv)` | 2D 텍스처에서 `uv`좌표의 색상 값을 샘플링(추출) | `tex2D(mySampler, texCoord)` |
