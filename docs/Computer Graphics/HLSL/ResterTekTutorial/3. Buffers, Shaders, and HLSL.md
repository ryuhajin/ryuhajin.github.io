---
layout: default
title: "3. Buffers, Shaders, and HLSL"
parent: "ResterTekTutorial"
nav_order: 4
---

# 3. Buffers, Shaders, and HLSL

## 프레임 워크 요소
Application Class에 하위 클래스 (`ModelClass`, `CameraClass`, `ColorShaderClass`) 추가

- **applicationclass** : 그래픽 코드를 처리하여 렌더링
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리
  - **ModelClass** : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화
  - **CameraClass** : 씬(Scene)을 바라보는 시점(Viewpoint) 관리
  - **ColorShaderClass** : 특정 셰이더 파일(`color.vs`, `color.ps`)을 사용하여 모델을 렌더링하는 모든 과정을 총괄


## ModelClass
1.  모델을 구성하는 정점(위치, 색상 등)과 인덱스 데이터를 메모리에 정의
2.  이 데이터로 **정점 버퍼(Vertex Buffer)**와 **인덱스 버퍼(Index Buffer)**를 생성하고 GPU에 로드
3.  자신의 버퍼를 렌더링 파이프라인에 설정하여 그릴 수 있도록 `Render()` 함수를 제공

## CameraClass
1.  카메라의 위치(Position)와 회전(Rotation) 값을 추적
2.  카메라 위치와 회전 값을 바탕으로 매 프레임마다 **뷰 행렬(View Matrix)**을 계산하여 제공
    - 뷰 행렬은 월드 공간의 모든 물체를 카메라의 시점으로 변환하는 역할

## ColorShaderClass
1.  HLSL 셰이더 파일을 컴파일하고 GPU에 로드하여 **정점 셰이더와 픽셀 셰이더 객체**를 생성
2.  C++ 코드에서 정점 데이터를 셰이더로 넘겨주기 위한 **입력 레이아웃(Input Layout)**을 생성
3.  월드, 뷰, 투영 행렬을 담을 **상수 버퍼(Constant Buffer)**를 생성
4.  `Render()` 함수를 통해 필요한 행렬들을 상수 버퍼에 업데이트하고, 최종적으로 셰이더를 활성화하여 모델의 `DrawIndexed()`를 호출, 렌더링을 실행

---

# 핵심 개념 정의

## 정점 버퍼 (Vertex Buffer)
3D 모델을 구성하는 모든 **점(Vertex, 정점)**들의 데이터를 담고 있는 GPU 메모리 공간

- 각 정점은 **위치(Position)** 정보(x, y, z)를 필수로 가짐
- 필요에 따라 **색상(Color)**, 법선(Normal), 텍스처 좌표(UV) 등 추가 정보를 가짐
> 이 모든 정점 데이터를 배열 형태로 GPU에 보내기 위한 버퍼입

## 인덱스 버퍼 (Index Buffer)
정점 버퍼에 있는 정점들의 **순서(Index, 색인)**를 저장하여, 어떤 정점들을 연결해서 삼각형을 만들지 알려주는 메모리 공간

- 정점 데이터의 중복을 제거하여 메모리를 절약하고, GPU 캐시 효율을 높여 렌더링 성능을 향상

## 상수 버퍼 (Constant Buffer)
월드/뷰/투영 행렬, 빛의 위치, 시간 등 렌더링 시 필요한 부가 정보를 담는 공간

- 상수 버퍼에 담긴 데이터는 매 프레임, 또는 매 오브젝트마다 계속해서 변하는 동적인(Dynamic) 데이터임
  - (예: 카메라가 움직이면 뷰 행렬이 바뀌고, 모델이 움직이면 월드 행렬이 바뀜)

>-  Map/Unmap 함수를 통해 상수 버퍼의 내용을 새로운 행렬 값으로 업데이트

## HLSL (High-Level Shading Language)
GPU에서 실행되는 프로그램인 **셰이더(Shader)**를 작성하기 위한 C-스타일 프로그래밍 언어

>- 프로그래머가 렌더링 파이프라인의 특정 단계를 직접 제어하여 원하는 그래픽 효과를 만들 수 있게 함

## 정점 셰이더 (Vertex Shader)
정점 버퍼에 있는 **모든 정점 각각에 대해 한 번씩 실행**되는 HLSL 프로그램

- 3D 모델의 정점 좌표를 2D 화면 좌표로 변환하는 **좌표 변환**을 수행

> - **입력:** 단일 정점 데이터 (위치, 색상 등), 월드/뷰/투영 행렬 (상수 버퍼)
> - **출력:** 변환된 정점의 위치 (`SV_POSITION`), 픽셀 셰이더로 전달할 데이터

## 픽셀 셰이더 (Pixel Shader)
화면에 그려질 **모든 픽셀 각각에 대해 한 번씩 실행**되는 HLSL 프로그램

- 픽셀의 **최종 색상을 결정**. 조명, 텍스처 매핑 등 복잡한 효과를 이 단계에서 처리

> - **입력:** 정점 셰이더에서 보간된 데이터 (색상, 텍스처 좌표 등)
> - **출력:** 해당 픽셀의 최종 색상 (`SV_TARGET`)

---

# Row-major vs Column-major
C++ 코드(DirectXMath)와 셰이더 코드(HLSL)가 행렬을 메모리에 저장하는 기본 방식이 다르므로 행렬을 전치해야 한다

```c++
[ m11, m12, m13     // 첫 번째 행
  m21, m22, m23     // 두 번째 행
  m31, m32, m33  ]  // 세 번째 행

// c++에서 행렬 생성
XMFLOAT4X4 mat(
    1, 2, 3, 4,
    5, 6, 7, 8,
    9,10,11,12,
    13,14,15,16
);
// 메모리 레이아웃: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
```

```c++
[ m11, m12, m13   // 첫 번째 열
  m21, m22, m23   // 두 번째 열
  m31, m32, m33 ] // 네 번째 열

// 실제 HLSL에서의 행렬:
[1, 5, 9,  13,
 2, 6, 10, 14,
 3, 7, 11, 15,
 4, 8, 12, 16]
```

- DirectXMath (C++)
  - 행렬을 행 우선(Row-major) 순서로 메모리에 저장
  - (즉, 첫 번째 행의 모든 원소가 메모리에 연달아 놓임)
- HLSL (셰이더)
  - 행렬을 열 우선(Column-major) 순서로 다루는 것이 기본값

## 해결 방법
- 전치(Transpose) 사용

```c++
XMMATRIX mat = XMMatrixTranspose(mat); // HLSL에 전달 전에 전치
```

- HLSL에서 행렬 선언 시 row_major/column_major 지정

```c++
row_major float4x4 rMatrix;  // row-major로 해석
column_major float4x4 cMatrix; // column-major로 해석 (기본값)
```

> - `mul(vector, matrix)` 같은 셰이더 내장 함수는 행렬이 열 우선이라고 가정하고 계산함
> - 따라서 행 우선으로 저장된 C++의 행렬을 그대로 셰이더로 보내면 계산 결과가 틀리게 됨
> - 그러므로 셰이더로 보내기 전에 `XMMatrixTranspose` 함수를 호출하여 행과 열을 뒤집어 줌

**참고하면 좋은 링크**
- [Row- and column-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order)
- [row-major (행 우선), column-major(열 우선)가 왜 중요한가?](https://huilife.tistory.com/15)

---

# HLSL keyword

- 자료형 

자료형 | 설명 | 예시 |
`float`, `int`, `bool` | 단일 스칼라 값 (C언어와 유사) | `float time;` |
`float2`, `float3`, `float4` | 2, 3, 4개의 float를 갖는 벡터. GPU는 벡터 연산에 특화되어 있음 | `float4 position;` |
`int2`, `int3`, `int4` | 2, 3, 4개의 int를 갖는 벡터 | `int2 textureCoords;` |
`matrix` | 4x4 크기의 행렬. `float4x4`와 동일하며 좌표 변환에 필수 | `matrix worldMatrix;` |
`sampler`, `Texture2D` | 텍스처 샘플링 및 텍스처 객체를 위한 자료형 | `Texture2D shaderTexture;` |

- 구조

구조 | 설명 | 예시 |
 `struct` | 여러 변수를 묶는 사용자 정의 자료형. 셰이더 스테이지 간 데이터 전달에 사용 | `struct VertexInputType { ... };` |
 `cbuffer` | 상수 버퍼(Constant Buffer). CPU에서 GPU로 데이터를 전달하는 주된 방법 | `cbuffer MatrixBuffer { ... };` |

- 시맨틱

시맨틱 | 설명 | 예시 |
 `: POSITION`, `: COLOR` | 정점 입력 데이터의 용도를 지정하는 꼬리표. C++의 입력 레이아웃과 연결됨 | `float4 pos : POSITION;` |
`: TEXCOORD0`, `: NORMAL` | 텍스처 좌표, 법선 벡터(조명 계산용) 데이터 용도를 지정 | `float2 tex : TEXCOORD0;` |
`: SV_POSITION` | **S**ystem-**V**alue 시맨틱. 정점 셰이더의 필수 '출력'으로, 클립 공간 좌표를 의미 | `float4 pos : SV_POSITION;` |
`: SV_TARGET` | **S**ystem-**V**alue 시맨틱. 픽셀 셰이더의 필수 '출력'으로, 최종 픽셀 색상을 의미 | `float4 color : SV_TARGET;` |

- 내장 함수

함수| 설명 | 예시 |
 `mul(a, b)` | 벡터-행렬, 행렬-행렬 곱셈. 좌표 변환의 핵심 | `mul(pos, worldMatrix)` |
`dot(a, b)` | 두 벡터의 내적(dot product). 조명 계산 시 빛의 각도를 구할 때 사용 | `dot(lightVec, normal)` |
`cross(a, b)` | 두 벡터의 외적(cross product). 법선 벡터를 계산할 때 사용 | `cross(vec1, vec2)` |
`normalize(v)` | 벡터 `v`를 정규화 (길이를 1로 만듦). 방향 벡터 계산에 필수 | `normalize(lightVec)` |
`saturate(x)` | `x`의 값을 0.0 ~ 1.0 사이로 제한. 색상이나 조명 계수를 범위 안에 둘 때 사용 | `saturate(dotResult)` |
`lerp(a, b, x)` | `a`와 `b`를 `x` 비율(0~1)로 선형 보간. 부드러운 전환 효과에 사용 | `lerp(color1, color2, 0.5)` |
`tex2D(sampler, uv)` | 2D 텍스처에서 `uv`좌표의 색상 값을 샘플링(추출) | `tex2D(mySampler, texCoord)` |

---

# KEYWORD NOTE
ModelClass, CameraClass, ColorShaderClass 소스 코드에서 모르는 키워드 공부

---

# colorShaderclass KEYWORD
---

## L"./color.vs"
L은 C++에서 와이드 문자열 리터럴(Wide-Character String Literal)을 의미

```c++
error = wcscpy_s(vsFilename, 128, L"./color.vs");
```

- wchar_t는 2바이트(Windows) 또는 4바이트(Linux) 크기로 유니코드(Unicode) 문자를 저장
- wcscpy_s 함수 이름의 wcs가 "wide character string"의 약자인 것도 같은 이유

> - L 접두사는 컴파일러에게 이 문자열을 char의 배열이 아닌 wchar_t의 배열로 만들라고 알려주는 역할

---

## ID3D10Blob
Blob은 "Binary Large Object"의 약자임. ID3D10Blob (또는 ID3DBlob)은 메모리 블록을 관리하는 범용 데이터 버퍼 객체를 뜻함

```c++
ID3D10Blob* vertexShaderBuffer;

D3DCompileFromFile(vsFilename, NULL, NULL, "ColorVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0,
		&vertexShaderBuffer, &errorMessage);
```

- 특정 형식에 얽매이지 않는 **순수한 데이터 덩어리를 담는 역할**
- 따라서 vertexShaderBuffer에 버텍스 셰이더를 저장한다는 것은, 사람이 읽을 수 있는 HLSL 코드가 아닌,
 컴파일된 기계어 코드를 메모리 버퍼에 담고 있다는 의미
- 이후 이 버퍼의 포인터와 크기를 `CreateVertexShader` 같은 함수에 전달하여 실제 GPU에서 사용할 셰이더 객체를
 생성함

> - D3DCompileFromFile 함수로 셰이더 코드를 컴파일하면, 그 결과물인 GPU가 실행할 수 있는 바이트코드(bytecode)가 생성됨
> - 이 바이트코드가 ID3D10Blob 객체 안에 저장

---

## ID3D11InputLayout
C++ 코드의 정점(Vertex) 데이터 구조를 GPU의 셰이더가 어떻게 해석해야 하는지 알려주는 설명서

1. 버텍스 버퍼에는 **위치, 색상, 노멀** 등 **여러 데이터가 연속된 메모리 덩어리**로 들어있음
2. 입력 레이아웃은 이 메모리 덩어리의 어디부터 어디까지가 위치 정보이고, 그 다음은 색상 정보인지 등을 정의

### 셰이더와 연결 방식

1. C++ 코드의 `VertexType` 구조체로 버텍스 데이터의 메모리 구조를 정의
2. `D3D11_INPUT_ELEMENT_DESC` 배열을 사용해 이 구조체 각 멤버의 의미(Semantic), 형식(Format), 순서 등을
  설명하는 입력 레이아웃을 정의
1. 버텍스 셰이더 코드(color.vs)의 입력 구조체(VertexInputType)에도 동일한 의미(Semantic)를 지정
  (POSITION, COLOR)

```c++
// modelclass.h 모델 클래스 헤더
// 버텍스 타입 구조체
	struct VertexType
	{
		XMFLOAT3 position;
		XMFLOAT4 color;
	};

// color.vs 컬러 버텍스 쉐이더

// typedefs
struct VertexInputType
{
	float4 position : POSITION;
	float4 color : COLOR;
};
```

>  - C++의 데이터 구조와 셰이더의 입력 구조체 사이에 의미(Semantic Name)를 기반으로 연결해주는 다리
  역할을 입력 레이아웃이 수행
> - 이 덕분에 Direct3D는 버텍스 버퍼의 데이터를 셰이더의 올바른 입력 변수로 전달할 수 있음

## D3D11_INPUT_ELEMENT_DESC
단일 버텍스를 구성하는 각 요소(element)를 설명 (입력 레이아웃 정의)

```c++
D3D11_INPUT_ELEMENT_DESC polygonLayout[2];

	polygonLayout[0].SemanticName = "POSITION";
	polygonLayout[0].SemanticIndex = 0;
	polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[0].InputSlot = 0;
	polygonLayout[0].AlignedByteOffset = 0;
	polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[0].InstanceDataStepRate = 0;

  polygonLayout[1].SemanticName = "COLOR";
	polygonLayout[1].SemanticIndex = 0;
	polygonLayout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[1].InputSlot = 0;
	polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[1].InstanceDataStepRate = 0;
```

- **SemanticName**
  - 요소의 의미를 나타내는 문자열
    - (예: "POSITION", "COLOR", "NORMAL")
  - 셰이더의 입력 시맨틱과 일치해야 함
- **SemanticIndex**
  - 같은 시맨틱을 여러 개 사용할 때 구분하기 위한 인덱스
  - (예: 텍스처 좌표가 2개일 때 "TEXCOORD0", "TEXCOORD1")
- **Format**
  - 요소의 데이터 형식
  - (예: 3개의 float 벡터는 DXGI_FORMAT_R32G32B32_FLOAT)
- **InputSlot**
  - 이 데이터를 가져올 버텍스 버퍼 슬롯의 인덱스
  - 보통 버퍼를 하나만 쓰므로 0
- **AlignedByteOffset**
  - 버텍스의 시작점부터 이 요소까지의 거리(byte)
  - `D3D11_APPEND_ALIGNED_ELEMENT`를 사용하면 이전 요소에 맞춰 자동으로 계산해 편리하다
- **InputSlotClass**
  - 데이터가 버텍스별 데이터인지(D3D11_INPUT_PER_VERTEX_DATA)
  - 인스턴스별 데이터인지(D3D11_INPUT_PER_INSTANCE_DATA) 지정
- **InstanceDataStepRate**
  - 인스턴스별 데이터일 경우, 다음 인스턴스 데이터로 넘어가기 전에 몇 개의 인스턴스를 그릴지 지정
  - 버텍스별 데이터는 0

---

## D3D11_BUFFER_DESC
버텍스, 인덱스, 상수 버퍼 등 **모든 종류의 버퍼**를 생성할 때 필요한 정보를 담는 구조체

```c++
D3D11_BUFFER_DESC matrixBufferDesc;

matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType);
matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
matrixBufferDesc.MiscFlags = 0;
matrixBufferDesc.StructureByteStride = 0;
```

- **Usage**
  - 버퍼의 주된 사용 방식을 지정
  - `D3D11_USAGE_DYNAMIC`은 CPU가 내용을 자주 업데이트하는 버퍼임을 의미
- **ByteWidth**
  - 버퍼의 총 크기(byte)
- **BindFlags**
  - 버퍼를 파이프라인의 어느 부분에 연결할지 지정
  - `D3D11_BIND_CONSTANT_BUFFER`는 상수 버퍼로 사용하겠다는 의미
- **CPUAccessFlags**
  - CPU가 이 버퍼에 어떻게 접근할지 지정
  - `D3D11_CPU_ACCESS_WRITE`는 CPU가 버퍼에 데이터를 쓸 수 있어야 함을 의미
- **MiscFlags**
  - 기타 플래그이며, 보통 0으로 설정
- **StructureByteStride**
  - 구조화된 버퍼(Structured Buffer)에서 요소 하나의 크기를 지정
  - 상수 버퍼에서는 0

---

## D3D11_MAPPED_SUBRESOURCE
`D3D11_MAPPED_SUBRESOURCE` 구조체를 통해 매핑된 메모리의 정보를 얻음

```c++
D3D11_MAPPED_SUBRESOURCE mappedResource;

// 상수 버퍼를 잠그어 쓰기 가능하게 만듦
result = deviceContext->Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);

// 상수 버퍼에 있는 데이터의 포인터 얻기
dataPtr = (MatrixBufferType*)mappedResource.pData;

// 행렬을 상수 버퍼에 복사
dataPtr->world = worldMatrix;
dataPtr->view = viewMatrix;
dataPtr->projection = projectionMatrix;

// 상수 버퍼 해제
deviceContext->Unmap(m_matrixBuffer, 0);
```

1.  `ID3D11DeviceContext::Map()` 함수를 통해 맵핑
  - CPU에서 GPU 메모리(버퍼 등)에 데이터를 쓰기 위해서는 `Map()` 함수를 써야함
2. ` D3D11_MAPPED_SUBRESOURCE` 구조체를 통해 맵핑된 데이터 메모리 포인터 얻기
3. 해당 포인터를 통해 쓰기 작업 후 `ID3D11DeviceContext::UnMap()`으로 맵핑 해제

---

## VSSetConstantBuffers()
버텍스 셰이더(Vertex Shader)에 상수 버퍼(Constant Buffer)를 바인딩하는 데 사용되는 함수

```c++
void VSSetConstantBuffers(
  [in] UINT StartSlot,
  [in] UINT NumBuffers,
  [in] ID3D11Buffer *const *ppConstantBuffers
);

  // ... map,unmap으로 constant buffer에 데이터 씀
	// 정수 버퍼의 위치를 버텍스 셰이더에 설정
	bufferNumber = 0;

	// 최종적으로 정점 셰이더에서 업데이트된 값으로 상수 버퍼를 설정
	deviceContext->VSSetConstantBuffers(bufferNumber, 1, &m_matrixBuffer);
```

- **StartSlot**
  - 상수 버퍼를 바인딩하기 시작할 슬롯 인덱스 (0부터 시작)
  - 버텍스 셰이더의 0번 상수 버퍼 슬롯에 연결하겠다는 의미
  - 일반적으로 HLSL의 register(b#) 지시어와 대응됨
    -  HLSL 셰이더 코드의 `cbuffer MatrixBuffer : register(b0)` 에서 `b0`과 일치해야 함 
- **NumBuffers**
  - 바인딩할 상수 버퍼의 개수
- **ppConstantBuffers**
  - n번 슬롯에 연결할 상수 버퍼 객체의 주소 

> - GPU의 셰이더 스테이지(버텍스 셰이더, 픽셀 셰이더 등)는 여러 개의 "입력 슬롯(slot)"을 가지고 있다
> - 상수 버퍼도 이 슬롯에 연결해야만 셰이더가 접근할 수 있다

---

## DrawIndexed()
인덱스 버퍼(Index Buffer)를 사용하여 모델을 그리는 핵심적인 Direct3D 함수

- `Draw()` : 버텍스 버퍼에 있는 정점들을 순서대로 그림
- `DrawIndexed()`
  - **인덱스 버퍼에 정의된 순서**에 따라 버텍스 버퍼에서 정점을 가져와 도형을 그림
  - 정점을 재사용할 수 있어 메모리와 성능이 크게 향상됨

```c++
void ColorShaderClass::RenderShader(ID3D11DeviceContext* deviceContext, int indexCount)
{
	// 버텍스 인풋 레이아웃 설정
	deviceContext->IASetInputLayout(m_layout);

	// 이 삼각형을 렌더링하는 데 사용될 버텍스 셰이더와 픽셀 셰이더를 설정
	deviceContext->VSSetShader(m_vertexShader, NULL, 0);
	deviceContext->PSSetShader(m_pixelShader, NULL, 0);

	// 삼각형 그리기
	deviceContext->DrawIndexed(indexCount, 0, 0);
}
```

- **IndexCount**
  - 그리기에 사용할 인덱스의 개수 (예: 삼각형 하나는 3)
- **StartIndexLocation**
  - 인덱스 버퍼의 몇 번째 인덱스부터 읽을지를 지정. 보통 0
- **BaseVertexLocation**
  - 인덱스 버퍼에서 읽은 값에 이 값을 더해서 실제 버텍스 버퍼의 인덱스를 찾음
  - 하나의 큰 버퍼에 여러 모델을 넣고 특정 모델만 그릴 때 유용. 보통 0

---

# modelclass KEYWORD

---

## D3D11_SUBRESOURCE_DATA
버퍼나 텍스처 같은 리소스를 생성할 때 초기 데이터를 제공하기 위해 사용되는 구조체

- `CreateBuffer`나 `CreateTexture2D` 같은 함수를 호출할 때
- 이 구조체에 초기화할 데이터의 메모리 주소를 담아 전달하면, **Direct3D는 새로 생성하는 GPU 리소스에 해당 데이터를 복사해줌**

```c++
typedef struct D3D11_SUBRESOURCE_DATA {
  const void *pSysMem;
  UINT SysMemPitch;
  UINT SysMemSlicePitch;
} D3D11_SUBRESOURCE_DATA;
```

- pSysMem
  - 초기화할 데이터가 들어있는 시스템 메모리(C++ 코드의 배열 등)의 포인터
  - 실제 리소스 데이터가 저장된 메모리 블록을 가리킴
- SysMemPitch
  - 2D 텍스처 : 데이터의 한 행(row)의 크기(byte)
  - 1D 리소스 : 1D 에서는 사용되지 않음 (버텍스/인덱스 버퍼에서는 0)
- SysMemSlicePitch
  - 3D 텍스처 : 데이터의 한 슬라이스(slice)의 크기(byte)
    - 슬라이스 사이에 패딩이 있을 경우 이를 포함한 값
  - 1D/2D : 1D/2D 에서는 사용되지 않음

### 사용 예시
- 버퍼 생성 시

```c++
// 정점 버퍼 생성 예제
struct Vertex {
    XMFLOAT3 Pos;
    XMFLOAT4 Color;
};

Vertex vertices[] = {
    { XMFLOAT3(0.0f, 0.5f, 0.5f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) },
    { XMFLOAT3(0.5f, -0.5f, 0.5f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
    { XMFLOAT3(-0.5f, -0.5f, 0.5f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) }
};

D3D11_SUBRESOURCE_DATA initData = {};
initData.pSysMem = vertices;
// 버퍼에는 Pitch/SlicePitch가 필요 없음
initData.SysMemPitch = 0;
initData.SysMemSlicePitch = 0;

// ID3D11Device::CreateBuffer 호출 시 사용
```

- 텍스처 생성 시
```c++
// 2D 텍스처 생성 예제
const UINT width = 2, height = 2;
UINT32 pixels[width * height] = {
    0xFFFF0000, 0xFF00FF00,  // 빨강, 초록
    0xFF0000FF, 0xFFFFFF00   // 파랑, 노랑
};

D3D11_SUBRESOURCE_DATA initData = {};
initData.pSysMem = pixels;
initData.SysMemPitch = width * sizeof(UINT32); // 한 행의 바이트 크기
initData.SysMemSlicePitch = 0; // 2D 텍스처에서는 사용 안 함

// ID3D11Device::CreateTexture2D 호출 시 사용
```

> - 리소스 생성 함수: CreateBuffer, CreateTexture1D, CreateTexture2D, CreateTexture3D 등에서 사용
> - 주로 리소스 생성 시 초기 데이터를 한 번에 업로드할 때 사용
> - 리소스 생성 후에는 Map/Unmap 또는 UpdateSubresource를 사용하여 데이터를 업데이트

---

## Stride
그래픽 파이프라인의 IA(Input Assembler, 입력 조립기) 단계에서 버텍스 버퍼에 있는 단일 정점(vertex) 하나의 크기(byte)를 의미

### IA 단계
버텍스 버퍼에서 정점 데이터를 읽어와 조립하는 역할

- Stride 값은 IA에게 **다음 정점으로 이동하기 위해 메모리에서 몇 바이트를 건너뛰어야 하는지** 알려주는 중요한 정보
- Stride 값은 보통 버텍스 데이터를 정의하는 구조체 하나의 크기와 같다

```c++
	//정점 버퍼 스트라이드, 오프셋 설정
	stride = sizeof(VertexType);

  deviceContext->IASetVertexBuffers(0, 1, &m_vertexBuffer, &stride, &offset);
```

- 코드에서는 VertexType 구조체를 사용하므로, stride는 sizeof(VertexType)으로 간단히 계산할 수 있음
- 이 값을 `IASetVertexBuffers` 함수에 전달하여 파이프라인에 버텍스 구조를 알림

---

# Clarity Notes
공부하며 헷갈렸던 부분 명료화 하기

---

## D3DCompileFromFile과 GPU 업로드 시점

{: .new-title}
> ❓D3DCompileFromFile() 함수로 쉐이더를 컴파일 하는 순간 GPU에 올라가나?
>
- D3DCompileFromFile() 함수는 순수하게 컴파일만 수행함
- 즉, 사람이 읽을 수 있는 HLSL 셰이더 코드(.vs, .ps 파일)를 GPU가 이해할 수 있는 기계어(바이트코드)로 번역
- 그 결과를 CPU의 메인 메모리에 ID3D10Blob이라는 버퍼 형태로 저장할 뿐임


그렇다면 GPU에는 언제 올라갈까?
> 바로 ID3D11Device::CreateVertexShader() 또는 CreatePixelShader() 함수를 호출하는 순간

1. D3DCompileFromFile():
  - HLSL 코드를 바이트코드로 컴파일하여 vertexShaderBuffer(CPU 메모리에 있는 임시 버퍼)에 저장
1. device->CreateVertexShader(vertexShaderBuffer->..., &m_vertexShader)
  - vertexShaderBuffer에 담긴 바이트코드를 GPU 드라이버에 전달
  - 드라이버는 이 코드를 받아 GPU 메모리(VRAM)에 실제 셰이더 객체를 생성
  - 우리는 m_vertexShader라는 핸들(포인터)을 통해 이 객체를 제어할 수 있게 됨
1. vertexShaderBuffer->Release()
  - GPU에 셰이더 생성이 완료됨
  - 따라서 원본 바이트코드를 담고 있던 CPU 메모리의 임시 버퍼(vertexShaderBuffer)는 더 이상 필요가 없음
  - Release()를 호출하여 메모리 해제

---

## D3D11_SUBRESOURCE_DATA 구조체 사용 목적

{: .new-title}
> ❓ cpu에 있는 데이터를 gpu 메모리로 전송하기 위해 사용한다 라고 생각하면 되나?
>
- D3D11_SUBRESOURCE_DATA는 CPU 메모리에 있는 데이터를 GPU 리소스로 전송하기 위한 다리 역할을 하는 구조체
- 3D 모델의 버텍스 데이터나 2D 텍스처 픽셀 데이터 등을 GPU가 이해할 수 있는 형태로 전달할 때 사용

```c++
uint32_t pixels[4] = { 0xFF0000FF, 0x00FF00FF, ... }; // RGBA 픽셀 데이터

D3D11_SUBRESOURCE_DATA initData = {};
initData.pSysMem = pixels;
initData.SysMemPitch = 4 * sizeof(uint32_t); // 한 행의 바이트 수 (가로 4픽셀)
initData.SysMemSlicePitch = 0;               // 2D는 SlicePitch 불필요

// 텍스처 생성
device->CreateTexture2D(&textureDesc, &initData, &texture);
```

1. CPU → GPU 데이터 전송의 "설명서"
  - GPU는 데이터의 레이아웃(행/열 정렬, 패딩 등)을 모르기 때문에,
  - `D3D11_SUBRESOURCE_DATA`로 메모리 구조를 명시해야 함
2. 다양한 리소스에 적용 가능
   - 버텍스 버퍼, 인덱스 버퍼, 1D/2D/3D 텍스처, 큐브맵 등 모든 리소스 초기화에 사용
3. 리소스 생성 시 "초기 데이터"로 사용
  - `CreateBuffer()`, `CreateTexture2D()` 등의 함수와 함께 전달됨
    - **위 함수는 GPU 리소스 생성 + 데이터 복사를 동시에 수행함**
    - 따라서 실시간 업데이트가 필요한 데이터는 동적 리소스로 생성하고 Map()/Unmap()을 사용하는 것이 효율적

> 단일 리소스를 생성할 때 그 리소스의 초기 데이터를 지정하는 용도 (초기값 역할)

---

## Input Assembler(입력 조립기) 단계와 함수 역할
 입력 조립기(IA)는 3D 렌더링 파이프라인의 가장 첫 번째 단계
 
- 버텍스 버퍼와 인덱스 버퍼로부터 데이터를 읽어와, 이를 기하학적 기본 단위(Primitive) 즉 점, 선, 삼각형 등으로 조립
- 조립 후 다음 단계(버텍스 셰이더)로 넘겨줌

IA 스테이지 설정 함수

```c++
// colorshaderclass
deviceContext->IASetInputLayout(m_layout);

//modelclass
	deviceContext->IASetVertexBuffers(0, 1, &m_vertexBuffer, &stride, &offset);
	deviceContext->IASetIndexBuffer(m_indexBuffer, DXGI_FORMAT_R32_UINT, 0);
	deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
```

- deviceContext->**IASetInputLayout(m_layout);**
   - **"버텍스 하나가 어떻게 생겼는지" IA에게 알림**
   - layout은 '버텍스는 12바이트짜리 위치 정보와 16바이트짜리 색상 정보로 구성되어 있다' 와 같은 버텍스의 구조 설명서
   - IA는 이 설명서를 보고 버텍스 버퍼 메모리를 올바르게 해석

- deviceContext->**IASetVertexBuffers(0, 1, &m_vertexBuffer, &stride, &offset);**
   - **"버텍스 데이터는 어디에 있는지" IA에게 알림**
   - m_vertexBuffer라는 실제 데이터가 담긴 버퍼를 버텍스 쉐이더의 0번 입력 슬롯에 연결
   - stride(버텍스 하나의 크기)와 offset(버퍼의 어디서부터 읽을지) 정보도 함께 제공

- deviceContext->**IASetIndexBuffer(m_indexBuffer, DXGI_FORMAT_R32_UINT, 0);**
   - **"버텍스들을 어떤 순서로 연결할지" IA에게 알림**
   - m_indexBuffer라는 연결 순서 정보가 담긴 버퍼를 설정
   - IA는 버텍스 버퍼를 순차적으로 읽는 대신, 인덱스 버퍼에 적힌 순서대로 버텍스를 가져옴

- deviceContext->**IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);**
   - **"조립된 버텍스들로 무엇을 만들지" IA에게 알림**
   - TRIANGLELIST는 3개의 정점을 묶어 독립된 삼각형 하나로 만들라는 의미
   - LINE_LIST(선), POINT_LIST(점), TRIANGLE_STRIP(연결된 삼각형) 등 다른 형식으로 설정 가능

