---
layout: default
title: "10. 2D Rendering"
parent: "ResterTekTutorial"
nav_order: 11
---

# 10. 2D Rendering
대부분의 사용자 인터페이스, 스프라이트 시스템, 텍스트 엔진은 2D 이미지로 구성된다
- DirectX 11에서는 2D 이미지를 폴리곤에 매핑한 후 직교 투영 행렬을 사용하여 렌더링할 수 있음

## 프레임 워크 요소
- application class 에 하위 클래스 (`BitMapClass`) 추가
- BitMap Class에 하위 클래스 (`TextureClass`) 추가
- `LightShaderClass` 제거
- `TextureShaderClass` 추가

---

# 2D Screen Coordinates
2D 이미지를 화면에 렌더링하려면 화면의 X 및 Y 좌표를 계산해야 함

## Screen coordinates

```
        (0,0) ----> X+
          |
          |
          v Y+
```
- 원점 (0, 0)이 화면의 왼쪽 위(Top-Left)에 있음
- X값은 오른쪽으로 갈수록 증가
- Y값은 아래쪽으로 갈수록 증가

---

## 3D World Space
- 정점 셰이더로 최종적으로 넘겨줘야 하는 좌표계 (정확히는 직교 투영 후의 월드 공간)
- 원점 (0, 0)이 화면의 정중앙(Center)

**DirectX의 경우**

![](/images/D3D_2DScreenCoordinates.png){: width="40%" height="40%"}

- 화면 중앙이 0.0

```c++
	// Calculate the screen coordinates of the left side of the bitmap.
	left = (float)((m_screenWidth / 2) * -1) + (float)m_renderX;

	// Calculate the screen coordinates of the right side of the bitmap.
	right = left + (float)m_bitmapWidth;

	// Calculate the screen coordinates of the top of the bitmap.
	top = (float)(m_screenHeight / 2) - (float)m_renderY;

	// Calculate the screen coordinates of the bottom of the bitmap.
	bottom = top - (float)m_bitmapHeight;
```

- **(m_screenWidth / 2) * -1**
  - 이 부분은 화면의 가장 왼쪽 끝의 X좌표를 구하는 것
  - 예: 화면 너비가 800이라면, 화면 중앙의 X는 0, 왼쪽 끝의 X는 -400
- **(float)m_renderX**: 위에서 구한 왼쪽 끝 위치에서, m_renderX 값만큼 오른쪽으로 이동

> "일단 화면의 가장 왼쪽 끝으로 이동한 뒤, 거기서부터 m_renderX 픽셀만큼 오른쪽으로 간다."
> - 이 과정은 좌표계 Screen의 X값을 World space의 X값으로 변환한다

- **right = left + (float)m_bitmapWidth**
  - left 에 비트맵의 너비(m_bitmapWidth)를 더하면 오른쪽 변의 위치가 나옴

---

##  예시
- 화면 크기: 800 x 600
- 그리고 싶은 위치: m_renderX = 100, m_renderY = 200
- 비트맵 크기: 50 x 50

1. left = (800 / 2)  -1 + 100 = -400 + 100 = -300
2. top = (600 / 2) - 200 = 300 - 200 = 100
3. right = -300 + 50 = -250
4. bottom = 100 - 50 = 50

---

# Disabling Z buffer in DirectX 11
2D 렌더링은 **Z-버퍼를 비활성화**한다. 즉 깊이 테스트(Depth Test)를 하지 않는다.

## Z-버퍼(깊이 버퍼)의 역할
Z-버퍼는 3D 렌더링에서 사용되는 화면 크기와 동일한 2D 배열(메모리 공간)
- 각 픽셀의 깊이(Depth) 정보, 즉 카메라로부터 얼마나 멀리 떨어져 있는지를 나타내는 Z값을 저장

## Depth Buffering
1. 지금 그리려는 픽셀의 Z값을 계산
2. Z-버퍼에서 같은 위치(x, y)에 이미 저장된 Z값을 읽어옴
3. 새로 그릴 픽셀의 Z값이 기존 Z값보다 작으면 (카메라에 더 가까우면), 해당 픽셀을 화면에 그리고 Z-버퍼의
   값도 새로운 Z값으로 업데이트
4. 그렇지 않으면 (카메라에 더 멀리 있으면), 새로 그릴 픽셀을 그냥 버림 (그리지 않는다)

> 이 과정을 통해 3D 공간에서 물체들이 서로를 올바르게 가리는 현상(Occlusion)을 처리

---

## 2D 렌더링에서 Z-버퍼를 비활성화하는 이유

### 1. 그리는 순서가 곧 레이어 순서
- 일반적인 2D 렌더링(UI, 스프라이트 등)에서는 깊이 개념이 없음
- 배경을 먼저 그리고, 그 위에 캐릭터를 그리고, 마지막으로 점수판 UI를 그리는 것처럼
- **그리는 순서(Draw Call 순서)가 곧 화면에 보이는 레이어 순서가 됨**
- 마지막에 그린 것이 항상 가장 위에 보여야 하므로, Z값을 비교하는 깊이 테스트는 불필요하며 오히려 방해가 될 수 있다

### 2. 성능 향상
- 2D UI처럼 화면 전체를 덮는 요소를 그릴 때 이 기능을 끄면 불필요한 연산을 줄여 약간의 성능 향상을 얻을 수 있음

### 3. Z-파이팅(Z-Fighting) 방지
- 만약 여러 2D 객체를 모두 같은 Z값(예: 0)으로 렌더링하면
- 부동소수점 정밀도 문제로 인해 어떤 픽셀이 그려져야 할지 GPU가 정확히 판단하지 못해
- 화면이 깜빡거리거나 깨지는 Z-파이팅 현상이 발생할 수 있다

---

- 깊이 테스트 상태 변경으로 비활성화 하기

```c++
// D3D11_DEPTH_STENCIL_DESC 구조체를 사용하여 렌더링 상태를 정의
// 구조체의 DepthEnable 멤버를 FALSE로 설정

D3D11_DEPTH_STENCIL_DESC depthDisabledStencilDesc;

ZeroMemory(&depthDisabledStencilDesc, sizeof(depthDisabledStencilDesc));

// 깊이 테스트 off
depthDisabledStencilDesc.DepthEnable = FALSE;

// ... (나머지 설정)

// ID3D11DepthStencilState 객체를 생성 (CreateDepthStencilState 함수 사용)

m_pDeviceContext->OMSetDepthStencilState(m_pDepthDisabledStencilState, 1);
```

---

## Dynamic Vertex Buffers in 2D rendering
2D 렌더링에서 동적 정점 버퍼를 사용하는 이유는 2D 객체들의 특성과 렌더링 최적화 기법인 '배치(Batch) 렌더링' 때문

### 끊임없이 변하는 2D 객체
- **UI 요소**
  - 마우스 커서, 클릭에 반응하는 버튼, 움직이는 창, 바뀌는 텍스트 등
  - 매 프레임 위치나 모양, 내용이 바뀔 수 있다
- 스프라이트
  - 캐릭터나 적들은 계속해서 위치를 바꾸고, 애니메이션에 따라 텍스처 좌표(UV)가 바뀔 수 있다

> 이처럼 매 프레임 정점 데이터(위치, 텍스처 좌표 등)가 바뀌는 객체들을 효율적으로 처리하려면
> - 매번 버퍼를 새로 생성하는 것보다 동적 버퍼의 내용을 Map/Unmap으로 업데이트하는 것이 훨씬 빠름

---

# Batch Rendering
배치 렌더링은 Draw 명령 횟수를 줄이기 위한 기법
- 비슷한 물체들을 한 번에 묶어서 GPU에 그리라고 요청하는 기술

---

## Draw Call
GPU에 그리기 명령(Draw Call)을 한 번 내리는 것은 상당한 비용이 드는 작업이다

- CPU가 GPU에게 명령을 전달할 때마다 다음과 같은 오버헤드(추가 작업)가 발생
1. **상태 변경(State Switching)**: 어떤 셰이더를 쓸지, 어떤 텍스처를 입힐지 등 렌더링 설정을 계속 바꿔야 함
2. **드라이버 오버헤드**: CPU의 명령을 GPU가 이해할 수 있는 형태로 변환하는 과정에서 시간이 소요
3. **CPU 병목 현상**: CPU가 너무 바쁘게 드로우 콜을 보내느라, GPU는 명령을 기다리며 쉬게 되는 현상이 발생할 수 있음

---

## Batch Rendering VS basic Rendering
컴퓨터 그래픽에서 화면에 무언가를 그리려면 CPU가 GPU에게 드로우 콜 명령을 내려야 함

### basic Rendering
만약 화면에 돌멩이 1,000개를 그려야 한다면, 가장 단순한 방법은 다음과 같다

 - CPU: "돌멩이 1번 그려줘!" -> GPU: (그림)
 - CPU: "돌멩이 2번 그려줘!" -> GPU: (그림)
 - ...
 - CPU: "돌멩이 1000번 그려줘!" -> GPU: (그림)

> 이 방식은 드로우 콜을 1,000번이나 발생시킴

### Batch Rendering
만약 1,000개의 돌멩이가 모두 같은 모양과 재질(텍스처, 셰이더)을 사용한다면, 굳이 1,000번씩이나 명령을 내릴 필요가 없음

- 배치 렌더링은 이 비효율을 개선시킴
- CPU: "여기 돌멩이 1,000개 정보가 있는데, 전부 같은 방식으로 한 번에 그려줘!" -> GPU: (1,000개를 한 번의 명령으로 그림)

> 즉, 드로우 콜이 단 1번으로 줄어든다

---

## 배치 렌더링의 조건
보통 아래와 같은 **속성들이 동일한 객체들을 하나의 배치(Batch)로 묶을 수 있음**

- **머티리얼 (Material)**: 동일한 셰이더(Shader)와 텍스처(Texture)를 사용하는 객체들
- **렌더링 상태 (Render State)**: 투명도 설정(Alpha Blending), 깊이 테스트(Depth Test) 등 렌더링 관련 설정이
같은 객체들

---

### 대표적인 배치 렌더링 기법
1. **정적 배치 (Static Batching)**
- 게임 중에 움직이지 않는 건물, 바위, 나무 등을 미리 하나의 큰 메쉬(Mesh)로 합쳐버리는 방식
- 가장 효과적이지만 움직이는 객체에는 쓸 수 없음
1. **동적 배치 (Dynamic Batching)**
- 움직이지만 같은 머티리얼을 쓰는 작은 객체들(총알, 파티클 등)을 매 프레임마다
- CPU에서 하나의 버퍼로 묶어 보내는 방식
1. **GPU 인스턴싱 (GPU Instancing)**
- 최신 기술로, GPU에게 "이 메쉬를 1,000번 그려. 단, 각각의 위치, 크기, 색상은 이 데이터를 참고해" 라고 한 번에 명령하는 방식
- 풀, 나무, 군중 등 똑같이 생긴 객체를 대량으로 그릴 때 매우 효율적

---

## Bitmap Quad
비트맵 쿼드(Bitmap Quad)는 간단하게 말해 **2D 비트맵 이미지를 띄우기 위한 판** 이다

- Direct3D 같은 3D 그래픽스 API는 픽셀로 이루어진 2D 이미지를 직접 화면에 그릴 수 없다
- API는 오직 정점(Vertex)으로 구성된 폴리곤(Polygon), 주로 삼각형(Triangle)만을 그릴 수 있음

> 따라서 2D 이미지를 화면에 보여주려면, 일종의 '꼼수'가 필요

1. 먼저 **3D 공간에 납작한 사각형(Quad) 모양의 판을 하나 만든다**
- 이 사각형은 보통 2개의 삼각형으로 이루어짐
2. **보여주고 싶은 2D 이미지(비트맵)를 이 사각형 판 위에 텍스처(Texture)로 입힌다**

- 즉 GPU는 사각형 plane의 정점 데이터를 바탕으로 비트맵 쿼드를 그리고,
- 픽셀 셰이더가 텍스처 좌표를 이용해 그 위에 이미지를 입혀 최종적으로 우리가 보는 2D 이미지가 화면에 나타나게 됨

---

## 2D rendering loop

매 프레임마다 다음 과정이 반복

1.  **씬 시작**
- `m_Direct3D->BeginScene()`을 호출하여 백 버퍼(Back Buffer)와 깊이 버퍼를 특정 색으로 초기화
2.  **Z-Buffer 비활성화**
- `m_Direct3D->TurnZBufferOff()`를 호출하여 깊이 테스트 끄기.
- 2D 이미지를 화면에 그릴 때는 3D 객체처럼 깊이를 비교할 필요 없이, 그리는 순서대로 화면에 덮어쓰기 위함
3.  **비트맵 렌더링 준비 (`BitmapClass::Render`)**
- `UpdateBuffers()`: 비트맵의 위치나 크기가 변경되었는지 확인
- 만약 변경되었다면, 새로운 위치에 맞는 화면 좌표를 계산하여 정점 버퍼의 내용을 갱신
  - 이 과정은 GPU 메모리에 있는 정점 버퍼를 직접 수정(`Map`, `Unmap`)
- `RenderBuffers()`: 준비된 정점/인덱스 버퍼를 입력 조립기(Input Assembler) 단계에 바인딩하여 GPU가 그릴 수 있도록 설정
4.  **셰이더 실행 및 드로우 콜 (`TextureShaderClass::Render`)**
- `SetShaderParameters()`: 월드, 뷰, 프로젝션(여기서는 직교) 행렬과 비트맵의 텍스처를 셰이더로 전달
- `RenderShader()`: GPU에 최종적으로 그리라는 명령(`DrawIndexed`)을 내림
- 이 호출로 인해 비트맵의 사각형 폴리곤이 렌더링 파이프라인을 통과하고, 픽셀 셰이더에 의해 텍스처가 입혀져 화면에 그려짐
5.  **Z-Buffer 활성화**
- `m_Direct3D->TurnZBufferOn()`를 호출하여 깊이 테스트를 다시 킴
- 이후에 3D 객체를 그릴 경우를 대비하기 위함
6.  **씬 종료**
- `m_Direct3D->EndScene()`을 호출하여 완성된 백 버퍼의 내용을 화면에 표시(Present)

---

