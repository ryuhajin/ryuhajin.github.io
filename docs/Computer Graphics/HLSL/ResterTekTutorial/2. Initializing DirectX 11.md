---
layout: default
title: "2. Initializing DirectX 11"
parent: "ResterTekTutorial"
nav_order: 3
---

# 2. Initializing DirectX 11

## D3DClass 추가
- **applicationclass** : 그래픽 코드를 처리하여 렌더링. d3dclass 포함
  - **D3DClass** : direct3D 시스템 함수의 모든 기능을 처리

---

# KEYWORD NOTE
D3DClass 소스 코드에서 모르는 키워드 공부

---

## pragma comment
C++ 전처리기 지시어 중 하나로, 링커(Linker)에게 특정 라이브러리 파일을 링크하라고 알려주는 역할

- 컴파일이 끝난 후, 최종 실행 파일(.exe)을 만드는 '링크' 단계에서 `d3d11.lib` 같은 라이브러리 파일들을 자동으로 찾아 연결

> `#pragma comment`를 사용하여 소스 코드 내에서 필요한 라이브러리를 명시하면
다른 환경에서 이 코드를 빌드할 때 프로젝트 설정을 다시 만질 필요 없다는 이점이 있다

---

## XMMATRIX
DirectXMath 라이브러리에서 제공하는 4x4 행렬을 다루기 위한 데이터 타입

### 주요 행렬
- **m_worldMatrix (월드 행렬)**
  - 3D 모델(정점들)을 월드 공간의 특정 위치에 배치하고 회전, 확대/축소하는 역할
- **m_projectionMatrix (투영 행렬)**
  - 3D 공간의 물체를 2D 화면에 원근감을 적용하여 그리는 역할
  - 멀리 있는 물체는 작게, 가까이 있는 물체는 크게 보이게 만듦
- **m_orthoMatrix (직교 행렬)**
  - 원근감을 무시하고 3D 공간의 물체를 2D 화면에 그릴 때 사용
  - 주로 UI나 2D 게임을 만들 때 사용

---

## DESC
DESC는 Description(설명)의 약자

```c++
DXGI_SWAP_CHAIN_DESC swapChainDesc;
```

-  DirectX와 같은 복잡한 API에서는 특정 객체(Object)를 생성할 때 수많은 설정값이 필요
-  관련 설정들을 모아놓은 구조체(`DESC`)를 만들고 이 구조체의 포인터를 함수에 한 번에 전달하는 방식을
  사용

---

## Vsync
VSync (Vertical Synchronization, 수직 동기화)는 게임의 프레임 생성률(FPS)을 모니터의 주사율(Refresh Rate, 보통 60Hz)에 강제로 맞추는 기능

- vsync를 켜 화면 찢어짐(Screen Tearing) 현상을 방지
- 프레임이 모니터 주사율 (예: 60FPS)로 고정되며, 경우에 따라 입력 지연(Input Lag)이 발생할 수 있다

```c++
pSwapChain->Present(SyncInterval, Flags);
```
- Vsync는 스왑 체인(SwapChain)의 `Present` 메서드의 `SyncInterval` 매개변수로 설정
    - 0 : Vsync Off
    - 1 : Vsync ON  (모니터 주기와 동기화. 60Hz면 60FPS로 제한)
    - 2~4 : 프레임 스로틀링 (1/n 프레임률로 제한)
      - 예: 60Hz 모니터에서 SyncInterval=2로 설정 시, 모니터의 수직 동기 신호를 두 번에 한 번꼴로 기다리므로 프레임이 30FPS로 제한됨

---

## graphics interface factory
DXGI(DirectX Graphics Infrastructure)의 핵심 컴포넌트로 하드웨어 디스플레이 어댑터(GPU)와 출력 장치(모니터)를 관리하기 위해 사용

```c++
IDXGIFactory* factory;

result = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);

if (FAILED(result))
{
    return (false);
}
```

### 주 사용 목적
1. GPU 어댑터(디바이스) 열거
    - 시스템에 설치된 모든 그래픽 카드(NVIDIA, AMD, Intel 등)를 검색하고 속성(VRAM, 성능 등)을 확인
    - 예: `IDXGIFactory::EnumAdapters()`로 어댑터 목록을 얻어와 특정 GPU를 선택
2. 스왑 체인(SwapChain) 생성
    - 렌더링 결과를 화면에 출력하기 위한 스왑 체인을 생성
    - 예: `IDXGIFactory::CreateSwapChain()`으로 IDXGISwapChain 객체를 생성
3. 다중 모니터 관리
    - 연결된 모니터 정보를 조회하거나 전체 화면(Fullscreen) 모드를 제어
    - 예: `IDXGIOutput`을 통해 해상도, 주사율 등을 설정
4. DXGI 객체 간의 관계 관리
    - 팩토리는 DXGI 리소스(어댑터, 출력 장치, 스왑 체인)의 생명주기를 관리

---

## __uuidof
특정 COM 인터페이스(Interface)의 고유 ID를 가져옴

```c++
// 백 버퍼 포인터 가져오기
result = m_swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&backBufferPtr);
```

---

## Adapter
그래픽 카드(Video Card)나 CPU에 내장된 GPU 같은 물리적인 그래픽 장치를 나타내는 객체

- 어댑터를 통해 연결된 모니터(Output) 정보를 얻거나 장치의 성능(예: 비디오 메모리)을 확인할 수 있다

```c++
factory->EnumAdapters(0, &adapter);
```

- 시스템의 첫 번째 주 그래픽 카드를 가져오는 코드

## adapter vs adapterOutput
adapter(그래픽 카드)는 여러 개의 Output(모니터)를 가질 수 있음

| 구분 | IDXGIAdapter | IDXGIOutput        |
| 개념 | 그래픽 처리 하드웨어     | 화면 출력 장치     |
| 비유 | 그래픽 카드 | 모니터 (또는 연결된 포트)          |
| 역할 | 3D 연산, 메모리 관리     | 화면 표시, 해상도/주사율 정보 제공 |
| 관계 | 1개의 어댑터가 N개의 출력을 가질 수 있음 | 1개의 출력은 1개의 어댑터에 속함   |

---

## GetDisplayModeList()
모니터가 지원하는 디스플레이 모드(해상도, 주사율 등)의 목록을 가져옴

```c++
result = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, NULL);
```

- **DXGI_FORMAT_R8G8B8A8_UNORM**
  - 픽셀 하나를 빨강(R), 초록(G), 파랑(B), 투명도(A) 각각 8비트로 표현하는 32비트 색상 형식을 의미
- **DXGI_ENUM_MODES_INTERLACED**
  - 디스플레이 모드 목록을 가져올 때 '인터레이스' 방식도 포함하라는 플래그
  - 인터레이스는 화면의 홀수 줄과 짝수 줄을 번갈아 그리는 오래된 방식임
  - 현재는 대부분 전체 화면을 한 번에 그리는 '프로그레시브(Progressive)' 방식을 사용

### 호출 패턴

```c++
// 어댑터 출력(모니터)에서 DXGI_FORMAT_R8G8B8A8_UNORM 디스플레이 형식에 맞는 모드 수를 가져오기
result = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, NULL);
```
- 첫 번째 호출: 목록을 저장할 메모리 주소(세 번째 인자)에 **NULL**을 전달
- 함수는 실제 목록을 반환하는 대신, 목록에 몇 개의 항목이 있는지 그 개수(`numModes`)만 알려줌

```c++
// 모니터와 비디오 카드가 조합 가능한 모든 디스플레이 모드 리스트를 생성
displayModeList = new DXGI_MODE_DESC[numModes];
if (!displayModeList)
{
    return (false);
}
```
- 메모리 할당: 알아낸 개수만큼 디스플레이 모드 구조체를 저장할 수 있는 메모리 공간을 동적으로 할당 (`new DXGI_MODE_DESC[numModes]`)

```c++

result = adapterOutput->GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &numModes, displayModeList);
```
- 두 번째 호출: 이번에는 실제로 할당한 메모리의 주소(`displayModeList`)를 전달
- 함수가 그 공간에 디스플레이 모드 목록을 채워 넣도록 함

> 두 번에 나눠서 호출하면 필요한 만큼만 정확하게 메모리를 할당할 수 있음

---

## adapterDesc.DedicatedVideoMemory
adapterDesc.DedicatedVideoMemory가 반환하는 값의 단위는 바이트(Byte)

```c++
m_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024);
```

- 1024 / 1024 두번 나눠서 저장하는 이유?
   - bytes / 1024 = 킬로바이트(KB)
   - KB / 1024 = 메가바이트(MB)

> 그래픽 카드의 전용 비디오 메모리 용량을 우리가 흔히 사용하는 메가바이트 단위로 변환하여 저장

---

## wcstombs_s()
Wide Character String(유니코드, `wchar_t*`)를 Multi-Byte String(`char*`)으로 변환하는 C++ 표준 라이브러리 함수

- `_s` 접미사는 'Secure'를 의미하며, 버퍼 오버플로우를 방지하기 위해 복사할 최대 길이를 지정하는 등 보안이 강화된 버전임
- DirectX/Windows API는 주로 유니코드 문자열을 사용함
  - 코드 내부에서는 일반 char 배열에 저장하고 싶을 때 이 함수를 사용

---

## ScanlineOrdering

```c++
swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
```

- **ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED**
  - 이미지를 그릴 때 위에서 아래로 순차적으로 그릴지(Progressive)
  - 홀수/짝수 줄을 번갈아 그릴지(Interlaced) 등을 선택
  - `UNSPECIFIED`는 **드라이버가 알아서 최적의 방식을 선택하라는 의미**
- **Scaling = DXGI_MODE_SCALING_UNSPECIFIED**
  - 백 버퍼의 해상도와 실제 출력되는 화면의 해상도가 다를 때, 이미지를 어떻게 확대/축소할지 정함
  - `UNSPECIFIED`는 특별한 스케일링을 지정하지 않겠다는 의미
  
---

# Depth Buffer
렌더 타겟 (컬러 버퍼 = 백버퍼) 과 동일한 크기를 가지며, 각 픽셀의 색상(Color) 대신 깊이(Depth) 정보를 저장하는 버퍼

- Z-버퍼(Z-Buffer)라고도 불림
- 깊이는 보통 카메라로부터의 거리를 의미

## 깊이 버퍼가 픽셀에 관여하는 과정
3D 공간에서는 어떤 물체가 다른 물체보다 앞에 있는지, 뒤에 있는지 판단해야 함

 1. 기존에 뎁스 버퍼에 저장된 깊이 값과 새로 그릴 픽셀의 깊이 값을 비교
 2. 새 픽셀의 깊이 값이 더 작으면 (즉, 카메라에 더 가까우면)
    - 컬러 버퍼 = 백버퍼에 새 픽셀의 색을 칠하고 뎁스 버퍼의 값도 새 깊이 값으로 업데이트
 3. 새 픽셀의 깊이 값이 더 크면 (더 멀리 있으면)
    - 해당 픽셀은 다른 물체에 가려진 것이므로 그냥 무시

> 뎁스 버퍼가 없으면, 나중에 그려진 물체가 무조건 앞에 보이게 되어 3D 공간이 제대로 표현되지 않는다

---

## Stencil Buffer
깊이 버퍼와 함께 사용되며, 픽셀 단위로 특정 작업을 제어하기 위한 마스킹 기법을 제공함

```c++
// 뎁스 24bit + 스텐실 8bit 깊이 버퍼 생성
depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
```

- 깊이 테스트와 함께 '스텐실 테스트'를 수행
- 개발자는 특정 조건을 설정하고, 그 조건의 통과 여부에 따라 스텐실 버퍼의 값을 바꾸거나 픽셀을 그릴지 말지 결정함

### 스텐실 버퍼 사용 예
 1. 거울/포탈 : 거울 영역에만 반사된 세계를 그릴 때
   - 거울 모양으로 스텐실 버퍼에 표시
   - 스텐실 버퍼에 표시된 곳에만 반사된 장면을 그림
 2. 평면 그림자(Planar Shadows) : 특정 영역에 그림자 효과를 줄 때
 3. UI 마스킹: 원형 미니맵처럼 사각형이 아닌 UI 영역을 만들 때
 4. 물체 외곽선(Outline) 그리기

---

## FrontFace / BackFace
물체의 앞면과 뒷면을 구분하여 다른 연산을 적용해야 하는 경우 설정

- 스텐실 버퍼 외에도, **래스터라이저 스테이트의 컬링(Culling) 설정**
- **픽셀 셰이더**에서 양면 재질을 다르게 렌더링하는 등 3D 렌더링 전반에서 사용되는 근본적인 개념

```c++
// 픽셀이 앞에 향하는 경우 스텐실 작업
depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

// 픽셀이 뒤에 향하는 경우 스텐실 작업
depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
```

---

## Rasterizer State
3D 정점 데이터로 이루어진 삼각형을 2D 화면의 실제 픽셀들로 변환
- 래스터라이저 스테이트는 이 변환 과정의 규칙을 정하는 설정들의 묶음이다

```c++

rasterDesc.AntialiasedLineEnable = false;
rasterDesc.CullMode = D3D11_CULL_BACK;
rasterDesc.DepthBias = 0;
rasterDesc.DepthBiasClamp = 0.0f;
rasterDesc.DepthClipEnable = true;
rasterDesc.FillMode = D3D11_FILL_SOLID;
rasterDesc.FrontCounterClockwise = false;
rasterDesc.MultisampleEnable = false;
rasterDesc.ScissorEnable = false;
rasterDesc.SlopeScaledDepthBias = 0.0f;

//레스터라이저 스테이트 생성
result = m_device->CreateRasterizerState(&rasterDesc, &m_rasterState);

// 레스터라이저 속성 세팅
deviceContext->RSSetState(m_rasterState);
```

## 주요 속성
- **FillMode = D3D11_FILL_SOLID**
  - 삼각형의 내부를 단색으로 채움
  - `D3D11_FILL_WIREFRAME`으로 바꾸면 선으로만 나옴
- **CullMode = D3D11_CULL_BACK**
  - 카메라의 반대 방향을 보는 (뒷면) 삼각형은 그리지 않고 버림
- **FrontCounterClockwise = false**
  - 정점들이 시계 방향(Clockwise)으로 정의된 삼각형을 앞면으로 간주 (true면 반시계 방향을 앞면으로 봄)
- **DepthClipEnable = true**
  - 너무 가깝거나 너무 멀리 있어 절두체(Frustum)를 벗어나는 픽셀들을 잘라내는 (clip) 여부를 결정

---

## fieldOfView

```c++
fieldOfView = 3.141592654f / 4.0f;
screenAspect = (float)screenWidth / (float)screenHeight;
```
- screenAspect (화면 비율)
  - 화면의 너비 / 높이 값입니다
  - 이 값을 올바르게 설정해야 3D 공간의 물체가 화면에서 찌그러져 보이지 않음
- fieldOfView (시야각, FOV)
  - 카메라 렌즈의 화각
  - 즉, 카메라가 한 번에 얼마나 넓은 범위를 볼 수 있는지 결정
  - 값이 클수록 넓은 영역이 보이지만(광각 렌즈) 화면 가장자리가 왜곡됨
  - 값이 작을수록 좁은 영역이 확대되어 보입니다(망원 렌즈)

### `3.141592654f / 4.0f`를 넣는 이유
- DirectXMath 함수들은 각도를 도(degree)가 아닌 라디안(radian) 단위로 받는다
- 3.141592654f는 원주율(π)의 근사값
   - π 라디안 = 180도
   - 따라서 PI / 4.0 라디안 = 180 / 4.0 = 45도

> 45도는 3D 게임에서 가장 흔하게 사용되는 기본 시야각 중 하나 
> - 너무 왜곡되지도 않고 너무 답답하지도 않은 자연스러운 시야를 제공하기 때문에 표준값처럼 사용됨

---

## swapChain->Present()
`swapChain->Present()` 함수는 실제로 백 버퍼를 화면에 표시하는 역할을 한다

```c++
void D3DClass::EndScene()
{
	// 렌더링이 완료되었으므로 백 버퍼를 화면에 표시
	// vsync가 켜져있다면 (수직 동기화 on)
	if (m_vsync_enabled)
	{
		// 모니터의 수직 동기 신호를 기다렸다가 버퍼를 교체하라
		m_swapChain->Present(1, 0);
	}
	else
	{
		// 즉시 버퍼 교체
		m_swapChain->Present(0, 0);
	}

	return;
}
```

> 이 함수는 즉시 반환되지 않고 시간이 걸릴 수 있는데, VSync 설정 때문에 모니터의 갱신 타이밍을 기다려야 할 수 있기 때문

---


