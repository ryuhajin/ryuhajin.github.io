---
layout: default
title: "9. Multiple Point Lights"
parent: "ResterTekTutorial"
nav_order: 10
---

# 9. Multiple Point Lights
포인트 라이트는 **3D 공간의 특정 한 지점(위치)에서 모든 방향으로 빛을 방출하는 광원**

## 특징
- **위치 기반**: 포인트 라이트는 3D 월드 좌표계에 고유한 위치를 가짐
- **전방향 방출**: 특정 방향 없이 자신의 위치에서 360도 모든 방향으로 빛을 내뿜는다
- **감쇠 (Attenuation)**: 포인트 라이트의 가장 큰 특징 중 하나
  - 빛은 광원으로부터 멀어질수록 세기가 약해짐. 즉, 물체가 광원에서 멀리 떨어져 있을수록 더 어둡게 보임

> 포인트 라이트는 "특정 위치에서 모든 방향으로 빛을 내뿜는 광원"
> - 실내의 램프, 촛불 등을 표현하는 데 아주 유용하게 사용된다

---

## Point Light VS Directional Light

 * 위치 vs 방향: 포인트 라이트는 '위치'가 중요하지만, 방향 조명은 '방향'만 중요합니다. 방향 조명은
     태양광처럼 아주 멀리서 오는 빛으로 간주하여, 씬의 모든 물체에 동일한 각도로 빛이 내리쬔다고 가정합니다.
     따라서 위치 정보가 없습니다.
   * 빛의 방향 벡터:
       * 포인트 라이트: 표면의 각 픽셀마다 '픽셀의 위치'에서 '광원의 위치'를 향하는 벡터를 계산해야 하므로,
         빛의 방향이 픽셀마다 다릅니다.
       * 방향 조명: 모든 픽셀에 대해 빛의 방향 벡터가 동일합니다.
   * 감쇠 (Attenuation): 방향 조명은 감쇠가 없습니다. 씬의 모든 곳에 동일한 세기의 빛이 도달합니다. 하지만
     포인트 라이트는 거리에 따라 빛의 세기가 약해집니다.

---

# Point Light Attenuation (점광원의 감쇠)

빛은 광원으로부터 멀어질수록 세기가 약해지는데, 이를 감쇠(Attenuation)라고 한다

---

## Inverse Square Law (역제곱 법칙)
물리적으로 정확한 빛의 감쇠는 역제곱 법칙을 따른다

{: .new-title}
> ❓ 역제곱 법칙이란?
> - 광원으로부터의 거리가 2배가 되면 빛의 세기는 4배(2의 제곱) 약해지고,
> - 거리가 3배가 되면 9배(3의 제곱) 약해진다는 원리

> 즉, 빛의 세기는 거리의 제곱에 반비례

---

**역제곱 법칙의 수식**

---

$$ \text{Intensity} = \frac{I_0}{d^2}$$

---

- **Intensity**: 특정 거리에서의 빛의 세기
- **I_0**: 광원의 초기 강도 (또는 기준 거리 1에서의 강도)
- **d**: 광원으로부터의 거리

> 이 공식을 컴퓨터 그래픽스에 그대로 적용하면 문제가 발생함
> - 거리가 0에 가까워질수록 빛의 세기가 무한대로 치솟아 비현실적인 밝은 점이 생기기 때문

---

## Attenuation in Computer Graphics
위 문제를 해결하기 위해 컴퓨터 그래픽스에서는 역제곱 법칙을 변형한 다음과 같은 일반적인 감쇠 공식을 사용

---

$$ \text{Attenuation} = \frac{1}{K_c + K_l \cdot d + K_q \cdot d^2}$$

---

- **Attenuation**: 감쇠율 (0과 1 사이의 값). 이 값을 최종 빛의 색상에 곱하여 감쇠 효과를 적용
- **d**: 광원과 물체 표면의 픽셀(또는 정점) 사이의 거리
- **K_c (Constant Attenuation)**
  - 상수 감쇠 계수. 거리에 상관없이 일정한 감쇠를 적용
  - 이 값을 1 이상으로 설정하면 거리가 0일 때 빛의 세기가 무한대가 되는 것을 방지하고, 전체적인 빛의 밝기를 조절하는 역할을 함
- **K_l (Linear Attenuation)**
  - 선형 감쇠 계수. 거리에 비례하여 빛을 선형적으로 감쇠시킴
  - 이 값이 클수록 거리에 따라 빛이 더 빨리 어두워짐
- **K_q (Quadratic Attenuation)**
  - 이차 감쇠 계수. 거리에 제곱에 비례하여 빛을 감쇠
  - 물리적으로 가장 현실적인 감쇠 효과를 내며, 이 값이 클수록 빛이 매우 빠르게 어두워져 광원의 영향 범위가 좁아짐

---

## Point Light 구하기
점광원의 최종 색상은 주변광(Ambient), 난반사광(Diffuse), 정반사광(Specular)을 모두 계산한 뒤
- 위에서 구한 감쇠율(Attenuation)을 곱하여 결정

---

$$ \text{Final Color} = (\text{Ambient} + \text{Diffuse} + \text{Specular}) \cdot \text{Attenuation} $$

---

## Multiple point lights
여러 개의 포인트 라이트를 처리하는 과정

- 각각의 포인트 라이트에 대해 순회하는 반복문을 실행하고 그 결과들을 모두 더하기

### 1. 초기 색상 설정
최종 색상을 저장할 변수를 선언하고, 주변광(Ambient Light)으로 초기화
- finalColor = ambientColor;

### 2. 반복문 (Loop)
모든 포인트 라이트를 순회하는 반복문을 실행
- 픽셀 셰이더에서는 보통 **배열(Array) 형태로 여러 개의 광원 정보(위치, 색상)를 전달받음**

### 3. 개별 광원 계산 및 누적:
반복문 내에서 현재 순서의 포인트 라이트 하나에 대해 위의 공식(난반사, 정반사, 감쇠 계산)을 그대로 적용하여 해당 광원이 기여하는 색상(lightContribution)을 계산
- 계산된 색상을 최종 색상 변수에 더해줌
- finalColor += lightContribution;

### 4. 최종 처리:
모든 포인트 라이트에 대한 반복이 끝나면 finalColor 변수에는 모든 광원의 영향이 합산된 최종 색상 값이 담김
- finalColor = saturate(finalColor)
- 마지막으로, 최종 색상 값이 1.0을 초과하지 않도록 saturate 함수를 이용해 값을 [0, 1] 범위로 클램핑(clamping)

---

## HLSL code sample (감쇠 X)

### Vertex Shader

```c++
// DEFINES //
// 처리할 포인트 라이트의 개수를 4개로 정의
#define NUM_LIGHTS 4

// GLOBALS
// C++ 애플리케이션에서 전달받는 행렬 버퍼

cbuffer MatrixBuffer
{
	matrix worldMatrix;       // 모델의 로컬 좌표를 월드 좌표로 변환하는 행렬
	matrix viewMatrix;        // 월드 좌표를 카메라(뷰) 좌표로 변환하는 행렬
	matrix projectionMatrix;  // 뷰 좌표를 2D 화면에 투영하기 위한 투영 행렬
};

// C++ 애플리케이션에서 전달받는 포인트 라이트의 위치 버퍼
cbuffer LightPositionBuffer
{
    float4 lightPosition[NUM_LIGHTS]; // NUM_LIGHTS 개수만큼의 광원 위치
};


// TYPEDEFS
// 정점 셰이더의 입력 구조체. 3D 모델의 정점 데이터에 해당
struct VertexInputType
{
    float4 position : POSITION;   // 정점의 위치
    float2 tex : TEXCOORD0;       // 텍스처 UV 좌표
	float3 normal : NORMAL;       // 정점의 법선 벡터 (빛의 반사를 계산하는 데 사용)
};

// 정점 셰이더의 출력 구조체이자, 픽셀 셰이더의 입력 구조체
struct PixelInputType
{
    float4 position : SV_POSITION;      // 최종 변환된 정점의 화면 위치
    float2 tex : TEXCOORD0;             // 픽셀 셰이더로 전달될 텍스처 UV 좌표
	float3 normal : NORMAL;             // 월드 공간으로 변환된 법선 벡터
	float3 lightPos[NUM_LIGHTS] : TEXCOORD1; // 각 정점에서 광원까지의 방향 벡터
};


PixelInputType LightVertexShader(VertexInputType input)
{
    PixelInputType output; // 픽셀 셰이더로 보낼 출력 객체
    float4 worldPosition;  // 월드 공간에서의 정점 위치를 저장할 변수
	int i;


	// 행렬 계산을 위해 정점 위치를 4차원 벡터(w=1.0)로 만듦
    input.position.w = 1.0f;

	// 1. 정점 위치 변환
	// 로컬 -> 월드 -> 뷰 -> 투영 공간으로 정점의 위치를 변환
    output.position = mul(input.position, worldMatrix);
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);
    
	// 2. 텍스처 좌표 전달
	// 텍스처 좌표는 변환 없이 그대로 픽셀 셰이더로 전달
	output.tex = input.tex;
    
	// 3. 법선 벡터 변환
	// 법선 벡터를 월드 행렬과 곱하여 월드 공간 기준으로 변환
  output.normal = mul(input.normal, (float3x3)worldMatrix);
	
  // 조명 계산의 정확도를 위해 법선 벡터를 정규화합니다. (길이를 1로 만듦)
  output.normal = normalize(output.normal);

	// 4. 월드 공간에서의 정점 위치 계산
    worldPosition = mul(input.position, worldMatrix);

	// 5. 빛 벡터 계산 (반복문)
	// 각 포인트 라이트에 대해 빛 벡터를 계산합니다.
	for(i=0; i<NUM_LIGHTS; i++)
	{
		// 정점의 위치에서 광원의 위치를 향하는 벡터(빛 벡터)를 계산
		output.lightPos[i] = lightPosition[i].xyz - worldPosition.xyz;

		// 빛의 방향만이 중요하므로 벡터를 정규화
		output.lightPos[i] = normalize(output.lightPos[i]);
	}

    // 계산된 모든 데이터를 담은 output 객체를 픽셀 셰이더로 반환
    // 이 값들은 래스터라이저에 의해 각 픽셀에 맞게 보간(interpolated)
    return output;
}
```

정점 셰이더는 각 정점에 대해 다음의 작업을 수행

- 정점의 위치를 월드, 뷰, 투영 행렬을 이용해 2D 화면 좌표로 변환
- 정점의 법선 벡터(Normal)를 월드 공간으로 변환
- **각 정점에서 여러 개의 포인트 라이트를 향하는 빛 벡터를 계산**하고 정규화
- 위에서 계산된 값들을 픽셀 셰이더로 넘김

---

### Pixel Shader

```c++
// 처리할 포인트 라이트의 개수를 4개로 정의 (정점 셰이더와 일치해야 함)
#define NUM_LIGHTS 4

// GLOBALS
// C++ 애플리케이션에서 전달받는 텍스처와 샘플러
Texture2D shaderTexture : register(t0); // 모델의 표면에 입힐 텍스처
SamplerState SampleType : register(s0); // 텍스처를 샘플링(색상 추출)하는 방법을 정의

// C++ 애플리케이션에서 전달받는 포인트 라이트의 색상 버퍼
cbuffer LightColorBuffer
{
    float4 diffuseColor[NUM_LIGHTS]; // NUM_LIGHTS 개수만큼의 난반사 색상
};


// TYPEDEFS
// 픽셀 셰이더의 입력 구조체. 정점 셰이더의 출력과 동일
// 각 값들은 픽셀 위치에 맞게 보간된 값
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 lightPos[NUM_LIGHTS] : TEXCOORD1; // 보간된 빛의 방향 벡터
};

float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;         // 텍스처에서 읽어온 픽셀의 기본 색상
	float lightIntensity[NUM_LIGHTS]; // 각 광원에 대한 빛의 세기
	float4 colorArray[NUM_LIGHTS];   // 각 광원이 만드는 색상
	float4 colorSum;             // 모든 광원의 색상을 합산한 결과
  float4 color;                // 최종 픽셀 색상
	int i;


	// 1. 텍스처 샘플링
    // 보간된 텍스처 좌표(input.tex)를 사용하여 텍스처의 색상을 가져옴
    textureColor = shaderTexture.Sample(SampleType, input.tex);

	// 2. 각 광원에 대한 조명 계산 (반복문)
    for(i=0; i<NUM_LIGHTS; i++)
    {
      // 3. 난반사(Diffuse) 강도 계산
      // 보간된 법선 벡터(input.normal)와 보간된 빛 방향 벡터(input.lightPos)를 내적(dot)
      // 내적 결과는 두 벡터가 이루는 각도의 코사인 값으로, 빛을 얼마나 정면으로 받는지를 나타냄
      // saturate() 함수는 결과를 0과 1 사이로 제한하여 음수 값이 나오는 것을 방지
      lightIntensity[i] = saturate(dot(input.normal, input.lightPos[i]));

      // 4. 각 광원의 색상 결정
      // 해당 광원의 난반사 색상(diffuseColor)에 빛의 세기를 곱함
      colorArray[i] = diffuseColor[i] * lightIntensity[i];
    }

	// 5. 조명 색상 합산 준비
    // 색상을 더하기 위한 초기값으로 검은색을 설정
    colorSum = float4(0.0f, 0.0f, 0.0f, 1.0f);

    // 6. 모든 광원의 색상 합산
    for(i=0; i<NUM_LIGHTS; i++)
    {
        colorSum.r += colorArray[i].r;
        colorSum.g += colorArray[i].g;
        colorSum.b += colorArray[i].b;
    }

	// 7. 최종 픽셀 색상 계산
    // 합산된 조명 색상(colorSum)과 텍스처의 기본 색상(textureColor)을 곱함
    // saturate()를 통해 최종 결과가 [0, 1] 범위를 벗어나지 않도록 함
    color = saturate(colorSum) * textureColor;

	// 최종 계산된 픽셀의 색상을 반환
	return color;
}
```

- 텍스처에서 현재 픽셀에 해당하는 색상(기본 색상)을 샘플링
- 보간된 법선 벡터와 보간된 빛 벡터를 사용하여 **각 포인트 라이트에 대한 난반사(Diffuse) 조명 강도**를 계산
- 모든 포인트 라이트의 조명 효과를 합산
- **합산된 조명 색상과 텍스처의 기본 색상을 곱하여 최종 픽셀 색상을 결정**

---

# Clarity Notes
공부하며 헷갈렸던 부분 명료화 하기

---

## Call shader
쉐이더가 불리는 횟수가 궁금함

오브젝트 하나가 있다고 할 때, 오브젝트의 버텍스가 300개라면

- 버텍스 셰이더는 300번 호출
- 픽셀 셰이더는 300번보다 훨씬 많이 호출

---

### 버텍스 셰이더 (Vertex Shader)
**버텍스 셰이더는 오브젝트를 구성하는 모든 정점(Vertex)의 개수만큼 정확하게 호출**

- 오브젝트의 버텍스가 300개라면, GPU는 300개의 버텍스 데이터 각각에 대해 버텍스 셰이더를 한 번씩 실행
- 버텍스 셰이더의 역할은 이 300개의 정점 위치를 3D 공간에서 2D 화면으로 옮기는 것이 주된 목적

### 픽셀 셰이더 (Pixel Shader)
픽셀 셰이더는 버텍스 개수와는 직접적인 관련이 없음

- **픽셀 셰이더는 최종적으로 렌더링될 화면에 그려질 픽셀(Pixel)의 개수만큼 호출**

1. 정점 처리: 버텍스 셰이더가 300개의 버텍스를 처리하여 2D 화면상의 위치를 결정
- 예를 들어, 300개의 버텍스가 모여 100개의 삼각형(Triangle)을 이룬다고 가정
2. 래스터화 (Rasterization): GPU는 이 100개의 삼각형이 화면에서 차지하는 영역을 계산
- 그리고 그 영역을 픽셀 단위로 채웁니다. 이 과정을 '래스터화'라고 함
3. 픽셀 처리: 픽셀 셰이더는 바로 이 **래스터화된 모든 픽셀 각각에 대해 한 번씩 호출**

---

- 오브젝트
- 300개의 버텍스
- 오브젝트가 최종 화면에서 가로 200픽셀, 세로 300픽셀 크기의 영역을 차지한다고 가정

> 이 경우, 래스터화 단계에서 이 영역은 약 200 * 300 = 60,000개의 픽셀로 채워짐
> - 따라서 픽셀 셰이더는 약 60,000번 호출되어 각 픽셀의 색상을 계산

---

### 결론
- 버텍스 셰이더 호출 횟수 = 모델의 총 버텍스 개수
- 픽셀 셰이더 호출 횟수 = 모델이 화면에 그려지는 최종 픽셀의 개수

---
