---
layout: default
title: "6. Drawing a Triangle"
parent: "HLSL"
nav_order: 6
---

# 6. Drawing a Triangle
삼각형 그리기 과정

1. GPU에게 기하학을 렌더링하는 방법을 알려주기
2. 삼각형의 세 꼭짓점을 생성하기
3. 이 꼭짓점을 비디오 메모리에 저장하기
4. GPU에게 이 꼭짓점을 읽는 방법을 알려주기
5. 삼각형 렌더링하기

---

## Using Shaders
렌더링 과정은 렌더링 파이프라인에 의해 제어된다
- 하지만 파이프라인은 무엇을 해야할지 자동으로 알지 못한다
- 셰이더 프로그래밍을 통해 파이프라인을 제어할 수 있다

> 셰이더에는 여러 유형이 있고, 렌더링 중 여러 번 실행된다
> - 정점 셰이더 : 렌더링 되는 각 정점에 대해 한번씩 실행되는 프로그램
> - 픽셀 셰이더 : 그려지는 각 픽셀에 대해 실행되는 프로그램

### 셰이더 로딩하기
1. `.shader` 파일에서 두 개의 셰이더를 로드하고 컴파일
2. 두 개의 셰이더를 셰이더 객체로 캡슐화
3. 두 개의 셰이더를 모두 활성 셰이더로 설정하기

---

## `.shader` 파일에서 셰이더 로드
`D3DX11CompileFromFile()` 함수를 통해 셰이더를 로드하고 컴파일 한다

```c++
HRESULT D3DX11CompileFromFile(
    LPCTSTR pSrcFile,                // 코드가 포함된 파일
    D3D10_SHADER_MACRO *pDefines,    // 고급 설정
    LPD3D10INCLUDE pInclude,         // 고급 설정
    LPCSTR pFunctionName,            // 셰이더의 시작 함수 이름
    LPCSTR pProfile,                 // 셰이더 프로파일
    UINT Flags1,                     // 고급 설정
    UINT Flags2,                     // 고급 설정
    ID3DX11ThreadPump *pPump,        // 고급 설정
    ID3D10Blob **ppShader,           // 컴파일된 셰이더를 포함하는 블롭
    ID3D10Blob **ppErrorMsgs,        // 고급 설정
    HRESULT *pHResult);              // 고급 설정
```

- `blob` : Binary Large Object의 약자로, 텍스트 또는 이진 데이터를 포함하는 큰 객체를 의미함
    - 주로 DB나 파일 시스템에서 사용함

- **LPCSTSTR pSrcFile**
  - 컴파일 되지 않은 셰이더 코드가 포함된 파일의 이름
- **LPCSTR pFunctionName**
  -  셰이더의 이름
  -  셰이더는 특정 함수로 시작하며 이 함수가 셰이더의 이름으로 간주됨
- **LPCSTR pProfile**
  - 컴파일러에게 컴파일할 셰이더의 유형과 셰이더 버전을 알려주는 코드
  - 예 : `vs_4_0`
    - v : 정점 (p : 픽셸)
    - s : 셰이더
    - _4_4 : HLSL 버전 4.0 
- **ID3D10Blob **ppShader**
  - 블롭 객체에 대한 포인터
  - 해당 객체에는 셰이더의 컴파일된 코드가 저장됨
  - 데이터 버퍼를 저장하는 COM 객체이다
  - `GetBufferPointer()`와 `GetBufferSize()` 함수를 사용하여 내용에 접근할 수 있다

<br>

```c++

void InitPipeline()
{
	// 셰이더를 로드하고 컴파일
	ID3DBlob* VS = nullptr, * PS = nullptr;
	ID3DBlob* errorBlob = nullptr;

	// 버텍스 쉐이더 컴파일
	HRESULT hr = D3DCompileFromFile(
		L"shaders.shader",
		nullptr,
		nullptr,
		"VShader", // 버텍스 쉐이더
		"vs_4_0",
		D3DCOMPILE_ENABLE_STRICTNESS,
		0,
		&VS,
		&errorBlob
	);

	// 픽셀 쉐이더 컴파일
	hr = D3DCompileFromFile(
		L"shaders.shader",
		nullptr,
		nullptr,
		"PShader", // 픽셀 셰이더
		"ps_4_0",
		D3DCOMPILE_ENABLE_STRICTNESS,
		0,
		&PS,
		&errorBlob
	);

	if (errorBlob) {
		OutputDebugStringA((char*)errorBlob->GetBufferPointer());
		errorBlob->Release();
	}
}
```

---

## 셰이더를 셰이더 객체로 캡슐화
- 각 셰이더는 자체 COM 객체에 저장된다
  - `ID3D11_____Shader`

```c++
// 쉐이더 전역 선언
ID3D11VertexShader* pVS; // 버텍스 셰이더
ID3D11PixelShader* pPS; // 픽셀 셰이더
```

<br>

```c++
void InitPipeline()
{
	// 셰이더를 로드하고 컴파일
	// 버텍스 쉐이더 컴파일
	// 픽셀 쉐이더 컴파일

    // ...

	// 셰이더 객체로 캡슐화
	dev->CreateVertexShader(VS->GetBufferPointer(), VS->GetBufferSize(), NULL, &pVS);
	dev->CreatePixelShader(PS->GetBufferPointer(), PS->GetBufferSize(), NULL, &pPS);
}
```

- 셰이더를 객체로 캡슐화 하기
- `dev->Create_____Shader()` 함수 사용
  - 첫 번째 매개변수 : 컴파일된 데이터의 주소
  - 두 번째 매개변수 : 파일 데이터의 크기
  - 세 번째 매개변수 : 고급 설정이므로 나중에 다루기
  - 네 번째 매개변수 : 셰이더 객체의 주소

---

## 셰이더를 활성 셰이더로 설정하기

```c++
void InitPipeline()
{
	// 셰이더를 로드하고 컴파일
	// 버텍스 쉐이더 컴파일
	// 픽셀 쉐이더 컴파일

    //...

	// 셰이더 객체로 캡슐화

    devcon->VSSetShader(pVS, 0, 0);
	devcon->PSSetShader(pPS, 0, 0);
}
```

- `devcon->___SetShader()` 함수 사용
  - 첫 번째 매개변수 : 설정할 셰이더 객체의 주소
  - 두, 세번째 매개변수 : 고급 설정이므로 나중에 다루기

위 과정을 통해 GPU가 렌더링을 준비하도록 한다

---

## Vertex Buffers
