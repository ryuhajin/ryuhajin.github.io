---
layout: default
title: "1. Toon Shader implementation"
parent: "ToonShader"
nav_order: 1
---

# 1. Toon Shader implementation

---

## Cel Shading
툰 셰이더(Cel Shading)의 핵심은 **빛의 세기를 몇 개의 단계로 단순화(discretize)**하여 만화 같은 느낌을 내는 것

1. **기본 명암 계산**
- 먼저 일반적인 3D 셰이더처럼 빛의 방향과 물체 표면의 방향(법선 벡터)을 내적(dot product)하여 빛의 세기(lightIntensity, 0.0 ~ 1.0 사이)를 계산
2. **명암 단계화** (핵심)
- 계산된 빛의 세기를 연속적인 값(gradient)으로 사용하지 않고, if 문이나 step 함수를 사용해 몇 개의 정해진 값으로 뚝뚝 끊어줌
- 부드러운 명암 대신 만화처럼 경계가 명확한 그림자 덩어리가 생김
3. **최종 색상 조합**
- 단계별로 나뉜 명암 값(lightIntensity)을 이용해 최종 색상을 만듦
- 최종 색상 = (주변광 + 분산광 * 단계명암) * 텍스처 색상

---

## Outline
- outline.vs
  - 모델의 정점들을 각 정점의 법선(normal) 방향으로 살짝 밀어내어 모델을 크게 만든다
- outline.ps
  - 화면에 그려지는 모든 픽셀을 정해진 컬러값으로 칠함

---

## 림 라이팅(Rim Lighting)
모델 뒤에서 조명을 비추는 것처럼, 물체의 가장자리(테두리)를 밝게 빛나게 해서 입체감을 살림

- 프레넬(Fresnel) 효과

---

## 림 라이팅의 원리
림 라이팅은 빛의 방향이 아니라 카메라(시점)와 물체 표면이 이루는 각도를 이용해 계산

- 카메라가 물체의 표면을 정면으로 바라볼 때는 효과가 나타나지 않음
- 카메라가 물체의 가장자리, 즉 둥근 표면이 꺾이는 부분을 비스듬히 바라볼 때 빛이 강하게 나타남

---

## 림 라이트(Rim Light) 구현
림 라이트의 핵심 아이디어

> "표면이 시선 방향과 거의 수직일 때 (즉, 모델의 가장자리 부분일 때) 빛이 나게 한다."

## 림 라이트 요소

### 1. 필요한 벡터들
 - N: 표면의 노멀 벡터 (표면이 바라보는 방향)
 - V: 시선 방향 벡터 (표면에서 카메라(눈)로 향하는 방향)

### 2. 림 라이트 세기(`Rim Intensity`) 계산 공식
노멀 벡터 N과 시선 벡터 V가 얼마나 수직에 가까운지를 계산

- dot(N, V)
  - 두 벡터가 같은 방향일수록 1
  - 수직일수록 0
  - 반대 방향일수록 -1

> 우리는 수직일 때(0) 가장 강한 효과를 원함
> - dot 결과가 0일 때 1이 되고, 1일 때 0이 되도록 만드는 가장 간단한 방법은
> - 1.0 - dot(N, V) 

```hlsl
Rim Intensity = 1.0 - saturate(dot(N, V))
```

- dot(N, V)가 1에 가까우면 (정면을 바라봄) -> Rim Intensity는 0 (빛 없음)
- dot(N, V)가 0에 가까우면 (가장자리에 위치) -> Rim Intensity는 1 (가장 밝은 빛)
- saturate()는 dot 결과가 음수가 되는 뒷면을 0으로 처리

### 3. 림 라이트 두께(`Rim Factor`) 조절 공식
Rim Intensity를 rimPower 값으로 거듭제곱

- rimPower 값이 클수록 림 라이트의 두께는 더 얇고 날카로워짐

```hlsl
Rim Factor = pow(Rim Intensity, rimPower)
```

---

- HLSL 픽셀 셰이더 코드 예시

```hlsl
// --- 입력 변수 (상수 버퍼나 다른 곳에서 미리 계산되어 넘어옴) ---
// float3 input.normal      : 픽셀의 노멀 벡터
// float3 viewDir           : 정규화된 시선 방향 벡터 (표면 -> 카메라)
// float4 rimColor          : 림 라이트의 색상
// float  rimPower          : 림 라이트의 두께/세기 (예: 2.0, 3.0 ...)


// 1. 노멀(N)과 시선(V) 벡터를 내적
float rimDot = dot(input.normal, viewDir);

// 2. 림 라이트의 기본 세기를 계산 (가장자리일수록 1에 가까워짐)
float rimIntensity = 1.0 - saturate(rimDot);

// 3. pow 함수를 이용해 림 라이트의 두께와 세기를 조절
float rimFactor = pow(rimIntensity, rimPower);


// (선택) 툰 스타일처럼 딱딱한 림 라이트를 원한다면 step 함수를 사용할 수 있음
// float rimFactorToon = step(0.5f, rimFactor); // rimFactor가 0.5를 넘으면 1, 아니면 0

// 4. 최종 림 라이트 색상을 계산
float4 finalRimLight = rimFactor * rimColor;

// --- 최종 색상 조합 ---
// 이 finalRimLight 값을 최종 색상에 더해주기
finalColor = baseColor + finalSpecular + finalRimLig
```

---

## 상수 버퍼의 패킹 규칙(Constant Buffer Packing Rules)
GPU는 매우 빠른 병렬 연산에 최적화되어 있어서, 데이터를 어중간한 크기로 가져오는 것보다 **정해진 큰 덩어리(chunk)**로 한 번에 가져오는 것이 훨씬 효율적

- Direct3D에서는 이 '덩어리'의 기본 단위를 16바이트로 약속
- 이는 float4 나 XMFLOAT4 변수 하나의 크기와 같음 (float 하나가 4바이트이므로 4 * 4 = 16).

### C++ 명시적으로 16바이트 규칙 맞춰주기

```c++
// C++ 쪽 구조체 정의
// DirectXMath 라이브러리를 사용하기 위해 헤더를 포함

#include <DirectXMath.h> 
using namespace DirectX;

struct CameraBufferType
{
    // 카메라의 위치를 저장하는 3차원 벡터
    // float가 3개 있으므로 크기는 12바이트 (4 * 3)
    XMFLOAT3 cameraPosition;

    // 패딩(Padding) 변수
    // cameraPosition (12바이트) 다음에 4바이트를 추가하여
    // 전체 구조체의 크기를 16바이트의 배수로 만들어줌
    // 이는 HLSL의 16바이트 정렬 규칙을 맞추기 위함
    float padding;
};
```

만약 padding을 추가하지 않으면 sizeof(CameraBufferType)은 12가 됨

- 데이터를 GPU로 복사할 때, 데이터가 계속 12바이트 간격으로 이어지게 되어
- GPU가 예상한 16바이트 간격과 어긋나게 됨
> 이는 결국 렌더링 깨짐 현상으로 이어짐

---

### HLSL의 경우
HLSL 컴파일러는 이 16바이트 패킹 규칙을 이미 알고 있음
- 따라서 프로그래머가 굳이 padding 변수를 선언하지 않아도, 알아서 다음 변수를 16바이트 경계에 배치

```c++
// HLSL 쪽 상수 버퍼(Constant Buffer) 정의
// cbuffer는 C++에서 보내준 데이터가 담길 공간
// register(b0)는 이 버퍼가 0번 슬롯(slot)에 바인딩됨을 의미

cbuffer CameraBuffer : register(b0)
{
    // C++의 cameraPosition 데이터가 이곳으로 복사
    // float3는 12바이트 크기
    // HLSL 컴파일러는 이 변수 다음에 4바이트의 빈 공간이 있을 것이라고
    // '암묵적으로' 인지하고 있다
    float3 cameraPosition;
};

// 아주 간단한 픽셀 셰이더 예시
float4 main(float4 pos : SV_POSITION) : SV_TARGET
{
    // 상수 버퍼에서 카메라 위치 값을 읽어옵니다.
    // 예를 들어, 카메라의 x좌표 값에 따라 다른 색을 출력할 수 있습니다.
    if (cameraPosition.x > 0)
    {
        return float4(1.0f, 0.0f, 0.0f, 1.0f); // 빨간색
    }
    else
    {
        return float4(0.0f, 0.0f, 1.0f, 1.0f); // 파란색
    }
}
```

**참고 링크**
- [DX : hlsl-packing-rules](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules)

---

# KEYWORD NOTE

---

## lerp
Linear Interpolation. 선형 보간의 줄임말.

- **두 개의 값 사이를 '선형적으로' 보간하여 중간값을 얻는 함수**
- 선형적 = 직선처럼 일정하게 변한다

## lerp 공식 유도 과정

$$ \text{Let } x = \text{시작점, } y = \text{끝점, } s = \text{진행률 (0 to 1)} $$

---

1.시작점에서 끝점까지의 전체 벡터

$$ V_{total} = y - x $$

---

2.진행률 s 만큼 이동한 벡터

$$ V_{progress} = (y - x) \cdot s $$

---

3.최종 위치는 시작점에 진행한 벡터를 더한 값

$$
P_{final} = x + V_{progress} \\
P_{final} = x + (y - x) \cdot s
$$

---

4.식을 전개하여 정리

- 시작하는 식

$$
P_{final} = x + y \cdot s - x \cdot s 
$$

---

- 덧셈의 교환법칙을 이용해 x가 포함된 항들을 옆으로 모음

$$
= x - x \cdot s + y \cdot s \\
$$

---

- x를 x 곱하기 1로 생각하여 명시적으로 표현

$$
= (x \cdot 1) - (x \cdot s) + y \cdot s \\
$$

---

- 분배법칙을 역으로 적용하여 공통 인수 x를 괄호 밖으로 묶음
- 인수분해 과정

$$ (x * 1) - (x * s)  =>  x * (1 - s) \\
= x(1 - s) + y \cdot s $$

---

- 최종적으로 정리된 공식이 유도

$$
\text{lerp}(x, y, s) = x \cdot (1 - s) + y \cdot s 
$$

---

### 코드 예시

```c++
#include <iostream>

// 3차원 벡터를 표현하기 위한 간단한 구조체
struct Vector3 {
    float x, y, z;
};

// float 타입에 대한 lerp 함수
float lerp(float x, float y, float s) {
    // x: 시작 값
    // y: 목표 값
    // s: 보간 계수 (0.0 ~ 1.0)
    return x * (1.0f - s) + y * s;
}

// Vector3 타입에 대한 lerp 함수
Vector3 lerp(const Vector3& x, const Vector3& y, float s) {
    Vector3 result;
    // 각 성분(x, y, z)에 대해 개별적으로 lerp 연산을 수행
    result.x = lerp(x.x, y.x, s);
    result.y = lerp(x.y, y.y, s);
    result.z = lerp(x.z, y.z, s);
    return result;
}

int main() {
    // 빨간색(1, 0, 0)과 파란색(0, 0, 1)을 정의
    Vector3 red = {1.0f, 0.0f, 0.0f};
    Vector3 blue = {0.0f, 0.0f, 1.0f};

    // 두 색상을 50% 비율로 혼합 (s = 0.5)
    float s = 0.5f;
    Vector3 purple = lerp(red, blue, s);

    // 결과 출력 (보라색에 가까운 (0.5, 0, 0.5)가 출력)
    std::cout << "Result: (" << purple.x << ", " << purple.y << ", " << purple.z << ")" << std::endl;

    return 0;
}
```

## step
이름 그대로 '계단'처럼 작동하는 함수.
- 특정 임계값(threshold)을 기준으로 입력값이 그보다 작으면 0
- 크거나 같으면 1을 반환

> 명확한 경계가 필요할 때 `if`문 분기 없이 산술 연산만으로 표현이 가능

---

### 코드 예시

```c++
#include <iostream>
#include <vector>
#include <cmath> // sqrt, pow 함수 사용을 위해 포함

// HLSL의 step 함수를 C++로 구현
float step(float edge, float x) {
    // x가 edge(임계값)보다 작으면 0.0, 크거나 같으면 1.0을 반환
    return x < edge ? 0.0f : 1.0f;
}

// HLSL의 dot 함수(2차원 벡터용)를 C++로 구현
float dot(float x1, float y1, float x2, float y2) {
    // 두 벡터의 내적은 각 성분의 곱의 합
    // 여기서는 벡터와 자기 자신의 내적을 구하여 길이의 제곱을 계산
    return x1 * x2 + y1 * y2;
}

int main() {
    // 셰이더의 렌더링 타겟(화면)을 흉내내는 2D 그리드 크기 설정
    const int width = 40;
    const int height = 20;

    // 원의 반지름 설정
    const float radius = 0.4f;
    // 비교를 위해 반지름의 제곱을 미리 계산. (제곱근 연산을 피하기 위함)
    const float radiusSq = radius * radius;

    // 화면의 모든 픽셀(문자)을 순회
    for (int j = 0; j < height; ++j) {
        for (int i = 0; i < width; ++i) {
            // 현재 픽셀의 좌표를 0.0 ~ 1.0 범위로 정규화 (UV 좌표처럼)
            // 너비에 2.0을 곱해 종횡비를 대략적으로 맞춘다
            float u = static_cast<float>(i) / (width / 2.0f);
            float v = static_cast<float>(j) / height;

            // 좌표의 중심을 (0,0)으로 이동 (범위를 -0.5 ~ 0.5 근처로)
            float centeredU = u - 1.0f;
            float centeredV = v - 0.5f;

            // 중심으로부터 현재 픽셀까지의 거리의 '제곱'을 계산
            float distSq = dot(centeredU, centeredV, centeredU, centeredV);

            // step 함수를 사용하여 원의 내부와 외부를 결정
            // distSq가 radiusSq보다 크면(원의 바깥) 1.0, 작으면(원의 안) 0.0을 반환.
            float outside = step(radiusSq, distSq);

            // 결과가 1.0(바깥)이면 공백을, 0.0(안)이면 '#' 문자를 출력
            if (outside == 1.0f) {
                std::cout << "  ";
            } else {
                std::cout << "##";
            }
        }
        std::cout << std::endl; // 한 줄 출력이 끝나면 줄바꿈
    }

    return 0;
}
```

---

# Clarity Notes
공부하며 헷갈렸던 부분 명료화 하기

---

# Color Operations in HLSL
덧셈과 곱셈은 빛과 색을 다루는 방식의 차이가 있다

---

## Multiplication (곱셈) - 빛의 반사율과 감산 혼합
물체의 색상(텍스처)은 각 색상 채널(R, G, B)의 빛을 얼마나 **반사(Reflect)**하는지를 나타내는 **반사율(Reflectance)**의 집합이다

> 물체 표면의 알베도(Albedo, 기본 색상)가 특정 파장의 빛을 얼마나 반사하는지를 나타냄

---

### Albedo = Diffuse Color = 물체의 고유 색
빛이 물체 표면에 닿았을 때 어떤 색으로 반사되는지를 결정하는 텍스처

- Albedo의 각 component (R, G, B)는 **해당 채널의 빛이 반사되는 비율**이다
- 즉, 그림자, 빛의 강도, 반사광 등 모든 효과가 제거된 **물체의 순수한 색상 정보**

```hlsl
// (순수한 빨간색): 빨간광은 100% 반사, 녹색과 파란광은 0% 반사 (완전 흡수).
albedoColor = (1.0, 0.0, 0.0) 

// (회색): 모든 빛을 50% 반사하고 50% 흡수.
albedoColor = (0.5, 0.5, 0.5)
```

---

### Component-wise Multiplication (성분별 곱셈) 예시
각 채널(R, G, B)끼리 독립적으로 곱셈을 수행

- 백색광 (White Light) : (1.0, 1.0, 1.0)
- 붉은 사과 : 반사율 (1.0, 0.1, 0.1)

---

$$
\text{Final Color} = \text{Incoming Light Color} × \text{Surface Reflectance} \\
$$

---

$$
(1.0,1.0,1.0)×(1.0,0.1,0.1) = (1.0×1.0,1.0×0.1,1.0×0.1) \\
= (1.0,0.1,0.1)
$$

---

우리 눈에는 R 성분이 강한 빛이 들어오므로 사과가 빨갛게 보임

- 물감을 섞는 것과 같은 **감산 혼합(Subtractive Color Model)**의 원리와 유사
- 물감을 섞을수록 특정 파장의 빛이 더 많이 흡수되어 어두워지는 것처럼
> 색상 곱셈은 항상 결과가 입력보다 어두워지거나 같아진다

---

## Addition (덧셈) - 광원의 중첩과 가산 혼합
여러 광원에서 출발한 빛 에너지가 한 지점에 모이면 그 지점의 총 에너지는 각 에너지의 합이 된다

- 한 픽셀이 받는 **총 빛의 양은 각 광원으로부터 오는 빛의 양을 모두 합산한 것과 같음**

```hlsl
float3 totalLighting = ambientLight;
totalLighting += diffuseLight1;
totalLighting += specularLight1;
totalLighting += diffuseLight2;
// ... (다른 광원들 추가)
```

---

$$
\text{Total Illumination} = \text{Ambient Light} + \text{Specular Light} + ... \text{다른 광원들}
$$

---

주변광, 방향광 등 서로 다른 광원들은 서로의 존재에 영향을 주지 않고 장면에 빛을 더해감

- 빛을 섞을수록 밝아지는 **가산 혼합(Additive Color Model)**의 원리와 같다
- 우리 눈이나 모니터의 RGB 픽셀이 빛을 혼합하는 방식

---

## 결론
- 곱셈 (*) = 반사율
- 덧셈 (+) = 광원 중첩

---

**참고 링크**
- [RB Whitaker's Wiki - Creating a Toon Shader](http://rbwhitaker.wikidot.com/toon-shader)
- [Basic Theory of Physically-Based Rendering](https://marmoset.co/posts/basic-theory-of-physically-based-rendering/)