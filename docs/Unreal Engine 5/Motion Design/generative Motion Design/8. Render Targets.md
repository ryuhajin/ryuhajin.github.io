---
layout: default
title: "8. Render Targets"
parent: "generative Motion Design"
nav_order: 8
---

# 8. Render Targets
렌더 타겟으로 실시간 상호작용 구현해보기

## 참고하면 좋은 링크
- [언리얼 엔진 5.1에서 렌더 타겟에 위치 그리기](https://80.lv/articles/drawing-locations-to-a-render-target-in-unreal-engine-5-1)
- [Render Targets Part 1: Painting Mesh Dynamically in Game](https://youtu.be/299LOiYvfi4?si=r0nZt8lnn-8lLhPu)
- [Using Render Targets in Unreal Engine 4](https://dev.epicgames.com/documentation/en-us/unreal-engine/blueprints-and-render-targets?application_version=4.27)


---

## 데이터 흐름
### Viewpost (뷰포트)
1. **정의**
    - 최종적으로 사용자의 모니터에 뿌려지는 "최종 결과물"의 창
2. **특징**
    - 렌더링 파이프라인의 가장 마지막 단계인 **백 버퍼(Back Buffer)**에 해당
3. **의미**
    - "눈으로 보는 화면". 엔진이 모든 연산(포스트 프로세스 포함)을 마친 후 우리에게 보여주는 최종 캔버스

---

### Scene Capture (씬 캡처)
1. **정의**
    - 월드에 배치된 '가짜 카메라'가 특정 장면을 찍어서 텍스처 데이터로 넘겨주는 컴포넌트
2. **특징**
    - 뷰포트와 달리 '출력 장치'가 없음. 대신 찍은 결과물을 바로 **렌더 타겟(Render Target)**이라는 메모리 공간에 쓴다(Write)
3. **의미**
    - "데이터 수집기". 인터랙티브 눈/비 시스템에서는 하늘에서 바닥을 내려다보며 큐브(오브젝트)가 어디 있는지 정보를 수집하는 역할

---

### Render Target (렌더 타겟)
1. **정의**
    - 렌더링 결과가 기록되는 **GPU 메모리 상의 버퍼(Buffer)**이자 텍스처
2. **특징**
    - 일반 텍스처는 '읽기 전용(Read-only)'이지만, 렌더 타겟은 실시간으로 '쓰기(Write)'와 '읽기(Read)'가 동시에 가능한 특수 텍스처
3. **의미**
    - "실시간 도화지". 씬 캡처가 찍은 영상이 기록되는 곳이며, 지형 머티리얼은 이 도화지를 실시간으로 읽어서 "아, 여기가 오브젝트가 지나간 곳이구나"라고 판단

## 요약
> 씬 캡처라는 '카메라'가 찍은 데이터를 렌더 타겟이라는 '메모리'에 담고, 이를 머티리얼이 읽어서 뷰포트라는 '화면'에 최종적으로 그려낸다

---

# Scene Capture vs brush stamp
## SceneCapture2D 방식
카메라(씬캡처)가 실제로 씬을 한 번 렌더링해서 그 결과를 RT에 씀

1. 캡처 카메라를 위에서 아래로(orthographic) 두고
2. Show Only로 **특정 오브젝트**만 보이게 해서
3. 흑백 마스크처럼 나오도록 머티리얼/커스텀뎁스/스텐실을 세팅

> 카메라로 찍은 결과가 RT가 됨

---

### SceneCapture 성능
SceneCapture2D는 본질적으로 **추가 카메라 렌더**
- 캡처 해상도만큼 한 번 더 렌더 패스가 생김
- 캡처 대상이 많아지거나, 머티리얼/후처리/그림자 등이 섞이면 비용이 커짐

---

## SceneCapture2D 장단점
1. **장점**
    - 무엇이 지나갔는지”를 시각적으로 캡처하니 직관적
    - 복잡한 형태(여러 메쉬가 동시에 눌리는 마스크)에도 적용이 쉬움
2. **단점**
    - 추가 렌더링 비용
    - 캡처 설정(ShowOnly, CustomDepth/Stencil, 캡처 소스)이 번거로움
    - 원치 않는 것까지 찍히면 디버깅 난이도 높아짐

---

## brush stamp 방식
카메라 렌더링이 아니라, **특정 위치에 '도장'을 찍듯 렌더 타겟을 업데이트**하는 방식

1. 오브젝트의 월드 좌표 → RT의 UV로 변환
2. 브러시 머티리얼에 (중심 UV, 반경, 회전, 강도) 파라미터를 넣고
3. RT에 한 번 찍기 또는 누적 합성

> 프로그래밍적으로 마스크를 그려 넣는 것이 RT가 됨

### 성능
작은 **브러시 하나를 RT에 합성하는 작업**이 중심
- 보통 RT 전체를 매번 다시 그리는 게 아니라, 그릴 내용이 매우 단순한 머티리얼 1패스로 끝냄
- 언제 찍을지를 완전히 제어 가능 (예: 오브젝트가 일정 거리 이상 이동했을 때만 찍기)

---

## brush stamp 장단점
1. **장점**
    - 성능/제어/디버깅이 좋음 (“어느 좌표에 어떤 브러시를 찍었다”가 명확)
    - 마스크 채널 설계 (R=파임, G=가장자리 융기 등) 자유도 높음
    - 오브젝트 트레일(연속 자국) 같은 규칙적 자국에 특히 잘 맞음
2. **단점**
    - 월드좌표 → RT UV 매핑 로직이 필요
    - 브러시 모양/블렌딩(누적 방식)을 직접 설계해야 함

---

