---
layout: default
title: "8. Render Targets"
parent: "generative Motion Design"
nav_order: 8
---

# 8. Render Targets
렌더 타겟으로 실시간 상호작용 구현해보기

## 참고하면 좋은 링크
- [언리얼 엔진 5.1에서 렌더 타겟에 위치 그리기](https://80.lv/articles/drawing-locations-to-a-render-target-in-unreal-engine-5-1)
- [Render Targets Part 1: Painting Mesh Dynamically in Game](https://youtu.be/299LOiYvfi4?si=r0nZt8lnn-8lLhPu)
- [Using Render Targets in Unreal Engine 4](https://dev.epicgames.com/documentation/en-us/unreal-engine/blueprints-and-render-targets?application_version=4.27)


---

## 데이터 흐름
### Viewpost (뷰포트)
1. **정의**
    - 최종적으로 사용자의 모니터에 뿌려지는 "최종 결과물"의 창
2. **특징**
    - 렌더링 파이프라인의 가장 마지막 단계인 **백 버퍼(Back Buffer)**에 해당
3. **의미**
    - "눈으로 보는 화면". 엔진이 모든 연산(포스트 프로세스 포함)을 마친 후 우리에게 보여주는 최종 캔버스

---

### Scene Capture (씬 캡처)
1. **정의**
    - 월드에 배치된 '가짜 카메라'가 특정 장면을 찍어서 텍스처 데이터로 넘겨주는 컴포넌트
2. **특징**
    - 뷰포트와 달리 '출력 장치'가 없음. 대신 찍은 결과물을 바로 **렌더 타겟(Render Target)**이라는 메모리 공간에 쓴다(Write)
3. **의미**
    - "데이터 수집기". 인터랙티브 눈/비 시스템에서는 하늘에서 바닥을 내려다보며 큐브(오브젝트)가 어디 있는지 정보를 수집하는 역할

---

### Render Target (렌더 타겟)
1. **정의**
    - 렌더링 결과가 기록되는 **GPU 메모리 상의 버퍼(Buffer)**이자 텍스처
2. **특징**
    - 일반 텍스처는 '읽기 전용(Read-only)'이지만, 렌더 타겟은 실시간으로 '쓰기(Write)'와 '읽기(Read)'가 동시에 가능한 특수 텍스처
3. **의미**
    - "실시간 도화지". 씬 캡처가 찍은 영상이 기록되는 곳이며, 지형 머티리얼은 이 도화지를 실시간으로 읽어서 "아, 여기가 오브젝트가 지나간 곳이구나"라고 판단

## 요약
> 씬 캡처라는 '카메라'가 찍은 데이터를 렌더 타겟이라는 '메모리'에 담고, 이를 머티리얼이 읽어서 뷰포트라는 '화면'에 최종적으로 그려낸다

---

# Scene Capture vs brush stamp
## SceneCapture2D 방식
카메라(씬캡처)가 실제로 씬을 한 번 렌더링해서 그 결과를 RT에 씀

1. 캡처 카메라를 위에서 아래로(orthographic) 두고
2. Show Only로 **특정 오브젝트**만 보이게 해서
3. 흑백 마스크처럼 나오도록 머티리얼/커스텀뎁스/스텐실을 세팅

> 카메라로 찍은 결과가 RT가 됨

---

### SceneCapture 성능
SceneCapture2D는 본질적으로 **추가 카메라 렌더**
- 캡처 해상도만큼 한 번 더 렌더 패스가 생김
- 캡처 대상이 많아지거나, 머티리얼/후처리/그림자 등이 섞이면 비용이 커짐

---

## SceneCapture2D 장단점
1. **장점**
    - 무엇이 지나갔는지”를 시각적으로 캡처하니 직관적
    - 복잡한 형태(여러 메쉬가 동시에 눌리는 마스크)에도 적용이 쉬움
2. **단점**
    - 추가 렌더링 비용
    - 캡처 설정(ShowOnly, CustomDepth/Stencil, 캡처 소스)이 번거로움
    - 원치 않는 것까지 찍히면 디버깅 난이도 높아짐

---

## brush stamp 방식
카메라 렌더링이 아니라, **특정 위치에 '도장'을 찍듯 렌더 타겟을 업데이트**하는 방식

1. 오브젝트의 월드 좌표 → RT의 UV로 변환
2. 브러시 머티리얼에 (중심 UV, 반경, 회전, 강도) 파라미터를 넣고
3. RT에 한 번 찍기 또는 누적 합성

> 프로그래밍적으로 마스크를 그려 넣는 것이 RT가 됨

### 성능
작은 **브러시 하나를 RT에 합성하는 작업**이 중심
- 보통 RT 전체를 매번 다시 그리는 게 아니라, 그릴 내용이 매우 단순한 머티리얼 1패스로 끝냄
- 언제 찍을지를 완전히 제어 가능 (예: 오브젝트가 일정 거리 이상 이동했을 때만 찍기)

---

## brush stamp 장단점
1. **장점**
    - 성능/제어/디버깅이 좋음 (“어느 좌표에 어떤 브러시를 찍었다”가 명확)
    - 마스크 채널 설계 (R=파임, G=가장자리 융기 등) 자유도 높음
    - 오브젝트 트레일(연속 자국) 같은 규칙적 자국에 특히 잘 맞음
2. **단점**
    - 월드좌표 → RT UV 매핑 로직이 필요
    - 브러시 모양/블렌딩(누적 방식)을 직접 설계해야 함

---

# Texture data 분류
텍스쳐 카테고리 분류하기

## GPU 출력용
주로 SceneCapture나 셰이더 연산 결과를 **실시간으로 기록하기 위한 버퍼**

- **GPU Write 중심**: 렌더 패스/캡처/드로잉으로 채우는 리소스

| 타입         | 특징                  | 주 사용처                    | 주의점            |
| ---------- | ------------------- | ------------------------ |---------- |
| **2D 렌더 타겟** (Render Target 2D)          | 표준적인 기본 RT (쓰기용 버퍼). 매 프레임 갱신 가능. GPU가 픽셀/프레임을 써 넣고, 이후 텍스처처럼 샘플링 가능  | SceneCapture2D 결과, 포스트/커스텀 패스 결과, 마스크/시뮬 버퍼, UI 합성용 버퍼 | 해상도와 포맷에 따라 VRAM/대역폭 부담 큼. Mip/필터링 정책(필요 여부) 명확히. 매 프레임 갱신 시 GPU 부하 발생|
| **캔버스 렌더 타겟** (Canvas Render Target 2D)  | 2D 렌더 타겟에 Canvas 즉시모드 드로잉 API를 붙인 편의형              | BP/C++에서 텍스트/라인/스프라이트로 마스크·간단 UI·디버그 텍스처 생성 | 고성능 픽셀 연산/대형 해상도에는 부적합. 블루프린트/C++ 업데이트 루프에서만 유효. 호출 빈도/드로우콜 수 관리 필요  |
| **2D 배열 렌더 타겟** (Render Target 2D Array) | 여러 장의 2D RT를 한 리소스(슬라이스 배열)로 관리. 인덱스로 슬라이스 선택 샘플링 | 멀티-뷰/멀티-레이어 마스크, 여러 카메라 결과 묶기, 커스텀 GBuffer 유사 레이어링     | `W×H×Slices×Bpp`로 메모리 직증. 슬라이스 간 보간 개념 없음(인덱스 선택). 머티리얼에서 2DArray 경로 사용 필요 |
| **큐브 렌더 타겟** (Render Target Cube)        | 6면 큐브맵에 렌더링. 동적 환경맵 생성 가능                         | 동적 반사/IBL 업데이트, 360 캡처, 스카이/리플렉션 프로브                   | 2D 대비 6배의 렌더링 비용 발생 (드로우 콜 급증). 빈번한 갱신은 매우 비쌈 |
| **볼륨 렌더 타겟** (Render Target Volume)      | 3D(Width×Height×Depth) 텍셀 그리드에 GPU가 쓰기 가능       | 복셀/볼륨 이펙트용 3D 필드(밀도/온도/속도), 3D LUT 유사 데이터 생성           | 메모리/대역폭 폭증(`W×H×D`). 3D 쓰기 파이프라인 구성 난이도↑ |

---

## 샘플링 중심
저장된 **데이터를 효율적으로 읽어와 렌더링 성능을 높이는 데 특화**

- **GPU Read 중심**: 콘텐츠/데이터 에셋을 머티리얼, 셰이더가 읽는 리소스

| 타입             | 특징     | 주 사용처     | 주의점   |
| ------------ | --------- | ----- | -------- |
| **볼륨 텍스처** (Volume Texture)      | 3D 텍스처 에셋. 머티리얼에서 3D 샘플링          | 연기/구름 밀도 텍스처, 구름/안개용 3D 노이즈 데이터, 미리 구워진 SDF | 3D는 메모리/캐시 효율이 2D보다 나쁠 수 있음. 레이어 간 보간 시 메모리 대역폭 소모가 큼    |
| **텍스처 2D 배열** (Texture2DArray)   | 여러 2D 텍스처를 슬라이스 배열로 묶은 에셋. 인덱스로 선택 | 재질 변형(타일/패턴) 다수, 배열 인덱싱 기반 룩업 | 모든 레이어의 해상도와 포맷이 일치해야 함. 슬라이스 수 증가 시 메모리↑. 머티리얼에서 2DArray 샘플러 사용 |
| **텍스처 큐브 배열** (TextureCubeArray) | 여러 큐브맵을 배열로 묶음. 환경맵을 인덱스로 선택         | 지역/시간대별 IBL, 여러 reflection cubemap 세트 스위칭     | 큐브맵 자체가 무거운데 배열로 더 무거워짐. 일관된 해상도/포맷 요구. 인덱싱/샘플링 경로 확인 필요 |

---

## 특수 시스템
엔진의 특정 서브시스템과 결합하여 복합적인 기능을 수행

| 타입  | 특징           | 주 사용처     | 주의점                                |
| --------| -----------------| -------- | ----------|
| **런타임 버추얼 텍스쳐** (Runtime Virtual Texture, RVT) | 가상 텍스처 타일 캐시 기반. 필요한 영역만 생성/캐시해 대면적 데이터를 효율화          | 대규모 오픈월드 지형 최적화 (Landscape 표면 셰이딩 캐시), 지형-오브젝트 블렌딩 | RT처럼 임의의 프레임버퍼 대체가 아님(용도 특화). 셋업(볼륨/머티리얼 출력/샘플)과 메모리 타일 풀 관리 필요. 디버깅/프로파일링 필수 |
| **미디어 텍스처** (MediaTexture / UMediaTexture)     | 미디어 디코더가 프레임을 텍스처로 공급. 렌더링으로 그려서가 아니라 “재생으로 들어오는” 텍스처 | 영상 재생(스크린/TV/사인), UI에 비디오, 스트리밍 텍스처   | 외부 코덱 의존성 및 오디오 동기화 문제 고려 필요. 색공간/감마(특히 sRGB)와 해상도/비트레이트 관리  |

---

### 정리
어느 단계에서 병목(Bottleneck)이 생기는지를 이해하자!

1. 출력용을 쓸 때는 **드로우 콜(Draw Call)**과 대역폭
    - 기록하는 횟수를 줄여야 함
2. 샘플링 중심을 쓸 때는 **메모리 용량(VRAM)**과 캐시 효율을 고려
    - 한 번에 묶어서 읽는 것이 유리함
3. 특수 시스템은 엔진의 최적화 기능을 빌려 쓰는 것
    - 프로젝트의 플랫폼 타겟(모바일 vs PC) 사양을 먼저 체크

---

