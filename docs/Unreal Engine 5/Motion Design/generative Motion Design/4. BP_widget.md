---
layout: default
title: "4. BP_widget"
parent: "generative Motion Design"
nav_order: 4
---

# 4. BP_widget

- [UE - widget Buleprint](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/widget-blueprints-in-umg-for-unreal-engine?application_version=5.5)

---

# Input Action
언리얼 5.1에 추가된 Enhanced Input(향상된 입력) 시스템

- [언리얼 엔진의 9가지 입력 트리거](https://youtu.be/MN-0otRNmZI?si=twMQ0o1iBJbqs3mu)

---

## Enhanced Input 구조
1. **Input Mapping Context(IMC)**
    - 어떤 키/버튼이 **어떤 Input Action을 트리거할지를 정의**하는 데이터 자산
2. **Input Action(IA)**
    - 논리적인 행동 단위 (예: Pause, Start, ChangeStyle 등)
3. **BP Event**
    - 어떤 Input Action이 들어왔을 때 실행할 로직

### 액션 기준으로 생각하기
논리 행동(Action) 기준으로 설계

- 키는 단지 그 **행동을 트리거하는 여러 입력 장치 중 하나**

```
Pause → ESC, 게임패드 Start, UI 버튼

Start → Enter, 게임패드 A, UI 버튼

ChangeStyle → 키보드 숫자, UI 버튼, 마우스 휠 등
```

> 한 액션에 여러 키를 묶어서 사용하는 것이 향상된 인풋의 기본 철학

---

## 사용 예제
### IA_Pause
1. **IMC**
    - ESC, Gamepad Start 등 여러 키를 이 액션에 묶음
2. **BP**
    - Enhanced Input Action Event: IA_Pause → TogglePause() 한 번만 구현

---

## Input Action 추가
1. **Input Action 생성**
    - 콘텐츠 브라우저에서 우클릭 후 **Input > Input Action**을 선택해 IA_Interact 같은 액션 생성
2. **Input Mapping Context 생성**
    - **Input > Input Mapping Context**를 선택해 IMC_Main 같은 매핑 컨텍스트 생성
    - 액션과 원하는 키(예: 'E' 키)를 매핑

---

## 구성 요소

| 구성 요소 |	설명 |
|---|---|
Input Action (입력 액션)	|	게임 내에서 발생하는 특정 동작을 추상화한 단위 <br> (예: IA_Interact, IA_Move)  <br> 키를 할당하지 않고, 어떤 타입의 값을 처리할지 정의 |	
Value Type (값 타입)	| 입력 액션이 전달할 데이터 형태 <br> Bool(On/Off), Axis1D(float), Axis2D(FVector2D), Axis3D(FVector) 중 선택 |	
Input Mapping Context  (입력 매핑 컨텍스트, IMC)	|	Input Action과 실제 키보드/마우스/게임패드 키를 연결해주는 매핑 테이블 <br> 우선순위를 설정해 상황에 따라 다른 IMC를 활성화할 수 있음 |	
Trigger (트리거)	| 입력이 활성화되는 조건을 정의합니다 <br> (예: 누르는 순간(Pressed), 뗄 때(Released), 길게 누르기(Hold)) |	
Modifier (모디파이어)	|	원시 입력 값을 게임에 맞게 변환 <br> (예: 값 반전, 스무딩, 데드존 적용)|	

---

## Input Action 속성
작동 순서: 입력은 모디파이어(값 전처리) → 트리거(조건 판정) 순서로 처리

---

### Trigger (트리거)
입력이 "언제, 어떤 조건에서" 유효한지 정의하는 조건 필터

### 트리거 배열
하나의 Input Action에 여러 개의 트리거를 **중첩해서 적용**할 수 있게 해주는 기능이다

- **AND 조건처럼 작동**하여, 배열에 추가된 **모든 트리거의 조건을 동시에 만족해야만 해당 입력이 최종적으로 유효하게 판정**됨

---

트리거 | 타입 설명 | 주요 설정 옵션 |
|---|---|---|
Pressed	|	키를 **누른** 순간 한 번만 감지	|	Actuation Threshold: 입력이 유효하기 위한 최소 값|
Released	|	키를 **뗀** 순간 한 번만 감지 |	Value Threshold: 키가 '떼어졌음'으로 판단되는 기준 값|
Hold	|	키를 **일정 시간 이상 누른** 상태에서 감지 |	Hold Time Threshold: 유효로 판단할 최소 누르기 시간|
Hold & Release|		**Hold 조건을 만족한 후 키를 뗄 때** 감지 |	Hold Time Threshold: 최소 누르기 시간|
Tap	|	키를 **아주 짧게 누르고 뗐을 때** 감지 |	Tap Time Threshold: '탭'으로 인정할 최대 시간|
Pulse	|	키를 **누르고 있는 동안 일정 간격으로 반복** 감지 |	Interval: 펄스 발생 간격(초)|
Chorded Action	|	특정 **다른 입력이 이미 눌려 있는 상태에서만 감지** |	Chording Action: 선행 조건이 될 다른 Input Action을 지정|

---

### Modifier (모디파이어)
입력 값을 전달하기 전에 가공하는 전처리기. 적용 순서대로 여러 개를 체인처럼 추가할 수 있음


모디파이어 타입 | 설명 |	주요 설정 옵션|
|---|---|---|
Dead Zone | 조이스틱의 미세 움직임 등 잡음을 제거	| Lower Threshold(무시할 최소 값), Upper Threshold(최대 입력 범위), Type(적용 축)|
Negate | 입력 값의 부호를 반전 (예: W를 +1, S를 -1로 변환) |	Negate X, Y, Z: 반전시킬 축을 개별 선택|
Swizzle | 입력 축(X, Y, Z)을 교환하거나 재배열 |	Order: 축의 새로운 배치 순서를 선택 (예: "YX"는 Y축 입력을 X축 값으로 전달)|
Scale | 입력 값에 일정 배율을 곱함 | Scalar: 곱할 배율 (예: 마우스 감도 2배)|
Smooth | 여러 프레임에 걸쳐 입력 값을 부드럽게 만듦 | Sample Period (Secs): 평균을 구할 시간|
Response Curve | 입력 값과 출력 값의 관계를 커브로 제어 |Curve: 커브 에셋을 연결|
To World Space | 로컬 입력 방향을 월드 공간 방향으로 변환 |	- |

---

## PlayerColntroller 와 연동
PlayerController 블루프린트에서 IMC 활성화

1. **PlayerController 블루프린트 열기**
    - Event BeginPlay 노드를 추가
    - **Get Player Controller -> Get Enhanced Input Local Player Subsystem -> Add Mapping Context 노드를 연결**
    - Add Mapping Context 노드의 첫 번째 핀에 1단계에서 만든 IMC_Main을
    - 두 번째 핀에는 우선순위(기본값 0)를 연결
2. **Input Action 이벤트 연결 및 처리**
    - 이벤트 그래프 우클릭, IA_Interact(또는 생성한 액션 이름)을 검색
    - 검색 결과 중 Enhanced Input Action 타입의 이벤트를 선택해 그래프에 추가
    - 해당 이벤트 노드에는 Started(누른 순간), Triggered(누르고 있는 동안, 매 프레임), Completed(뗀 순간) 등 여러 실행 핀이 있음
    - 원하는 핀(예: Started)에 로직(예: Print String으로 "E Pressed" 출력) 연결

---

## EnhancedInputAction 노드
액션의 현재 스테이트에 바인딩하기

- [UE - enhancedinput](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/enhanced-input-in-unreal-engine)

1. 트리거(Triggered)
    - 액션이 트리거 됨
    - 즉, 모든 트리거 요구 사항 평가를 완료했다는 뜻
    - 예를 들어, 사용자가 키를 놓으면 '키 누르고 떼기(Press and Release)' 트리거가 전송
2. 시작(Started)
    - 트리거 평가를 시작한 이벤트가 발생
    - 예를 들어, '두 번 탭(Double tap)' 트리거를 처음 누르면 '시작됨' 스테이트가 한 번 호출
3. 진행 중 (ongoing)
    - 트리거를 여전히 처리 중
    - 예를 들어, 지정된 기간이 끝나기 전에 사용자가 버튼을 누르고 있는 동안에는 '길게 누르기(Press and hold)' 액션이 진행 중
    - 이 이벤트는 트리거에 따라 입력 값을 수신하면 작업이 평가되는 동안 틱마다 발동
4. 취소(Canceled)
    - 트리거링이 취소
    - 예를 들어, 사용자가 '길게 누르기' 액션이 트리거되기 전에 버튼을 놓는 경우가 있음
5. 완료(Completed)
    - 트리거 평가 프로세스가 완료

---

# UMG (Unreal Motion Graphics)
## Slate
언리얼 엔진의 모든 에디터 인터페이스를 구성하는 선언형(Declarative) **UI 프레임워크**

> 모든 위젯의 크기와 위치를 부모 컨테이너(Parent Container)가 결정한다

- **포토샵** : 디자이너가 객체의 크기들 강제 지정
- **Slate** : 부모 위젯이 전체 레이아웃 상황을 고려하여 크기 할당 과정이 매 프레임 일어남
  - 박스 크기를 임의로 늘리려해도 늘어나지 않는 이유!

---

## Slot
슬롯은 위젯 자체가 아니라, **위젯이 부모 컨테이너에 담길 때 생성되는 '데이터 객체'**

- Button 위젯을 Canvas Panel에 넣으면 Canvas Panel Slot이 생성
- Vertical Box에 넣으면 Vertical Box Slot이 생성

> 사용자가 제어하려는 크기와 위치 속성은 위젯 본연의 속성이 아니라, 바로 이 슬롯의 속성

---

## Flow Panel
Vertical Box나 Horizontal Box는 좌표계가 아닌 **순서와 규칙에 의해 배치됨**

- **Vertical Box**: 위에서 아래로 위젯을 쌓는다
- **Horizontal Box**: 왼쪽에서 오른쪽으로 위젯을 쌓는다

이 패널들은 자식 위젯의 크기를 다음 세 가지 모드로 관리한다

크기 모드	| 설명	| 동작 원리 |  현상 |
|---|---|---|---|
Auto (자동) | 	콘텐츠 크기 우선 |  자식 위젯이 가진 콘텐츠(텍스트 길이, 이미지 원본 크기)만큼만 공간을 차지 | 박스가 내용물 딱 그 크기만큼만 작아져서, 아무리 늘리려 해도 늘어나지 않음 | 
Fill (채움)	|  가용 공간 우선 | 부모 컨테이너의 남은 공간을 모두 차지하도록 늘어남	|  박스 크기를 키우고 싶을 때 사용해야 하는 모드 | 
Fixed (고정) | 픽셀 크기 강제	(일부 레거시 패널) |  특정 픽셀 값을 강제 | 반응형 환경에서 권장되지 않음 | 

---

## 레이아웃 전파(Propagation) 원리
UMG의 **레이아웃 계산은 두 번의 패스(Pass)를 거침**

### Bottom-Up (Desired Size 계산)
커스텀 패널 - 버티컬 박스 - 버튼 - 텍스트 블록 순으로 배치했을 때

1. **가장 안쪽의 자식 위젯 (예: 텍스트 블록)**
    - 자신의 폰트 크기와 글자 수를 바탕으로 필요한 크기를 계산하여 부모(예: 버튼)에게 전달
2. **그다음 자식 위젯 (예: 버튼)**
    - 버튼은 패딩 값을 더해 자신의 크기를 계산
    - 이를 다시 상위 부모 (예: 버티컬 박스)에게 전달

---

### Top-Down (Arrangement)
1. **최상위 부모(예: 전체 화면 루트 위젯)**
    - 가용 화면 크기를 확인
    - 자식들의 요청 사항 (Bottom-up으로 온 Desired Size)과 슬롯 규칙 (Fill/Auto)을 종합
2. **자식들의 최종 크기과 위치를 할당**

---

## box size control
박스 사이즈 컨트롤 예제

## 수직, 수평 박스 안에서 꽉 차게 키우고 싶을 때
1. 계층 구조 확인
    - Hierarchy 패널에서 크기를 키우고자 하는 위젯(예: Border, Button)을 선택
2. 슬롯 속성 변경
    - Details 패널의 우측 상단에 있는 Slot (Vertical Box Slot) 섹션을 찾는다
3. Size 설정을 Fill로 변경
    - 기본값인 Auto를 Fill로 변경

> 결과: 위젯이 부모 박스의 흐름 방향 (수직 박스라면 세로, 수평 박스라면 가로) 으로 가능한 모든 공간을 차지하게 됨

4. Fill Weight 조절
    - 만약 두 개의 박스가 모두 Fill 상태라면, Fill Weight 값(기본 1.0)을 조절하여 비율을 정함
    - **하나를 1.0, 다른 하나를 2.0으로 두면 1:2 비율로 공간을 나눠 가짐**
5. 정렬(Alignment) 확인
    - Fill로 설정했음에도 커지지 않는다면 Horizontal Alignment나 Vertical Alignment 확인
    - 정렬이 Stretch(화살표 양쪽 방향 아이콘)가 아닌 Left/Center/Right로 되어 있는지 체크
    - 꽉 채우려면 반드시 정렬 속성을 Fill(Stretch)로 설정해야 함

---

## 특정 크기 (예: 200x200px)로 강제하고 싶을 때
유동형 패널 안에서도 특정 위젯(예: 아이콘 이미지, 프로필 사진)은 고정된 크기를 가져야 할 때

1. Size Box 활용
    - 크기를 고정하고 싶은 위젯을 Size Box라는 컨테이너 위젯으로 감싼다(Wrap With)
    - 방법: 위젯 우클릭 -> Wrap With... -> Size Box 선택
2. Override 설정
    - Size Box를 선택하고 Details 패널에서 Width Override와 Height Override를 체크
    - 원하는 픽셀 값(예: 200, 200)을 입력
3. 부모 슬롯 설정
    - Size Box 자체가 부모 박스(Vertical Box 등) 안에서 찌그러지지 않도록
    - 부모 슬롯 설정을 Auto로 두거나 정렬을 조절

---

## 이미지 비율을 유지하면서 키우고 싶을 때
이미지를 Fill로 설정하면 이미지가 찌그러지는(Stretched) 현상이 발생할 수 있다

1. Scale Box 활용
    - 이미지를 Scale Box로 감싼다
2. Stretching Rule 설정
    - Scale Box의 속성 중 Stretching을 Scale to Fit으로 설정
3. 레이아웃 배치
    - Scale Box를 부모 패널에 Fill로 배치

> 결과: 부모 패널의 공간이 늘어나거나 줄어들어도, 이미지는 원본 비율을 유지하며 그 공간 안에서 최대 크기로 맞춰짐

---

## 텍스트 주위에 여백을 주어 박스를 키우고 싶을 때
버튼 안의 텍스트가 버튼 테두리에 너무 딱 붙어 있어서 버튼 크기를 키우고 싶은 경우

1. Padding 활용
    - 텍스트 위젯을 선택하고 Details 패널의 Slot 섹션(부모가 Button인 경우) 또는 Padding 속성을 찾음
2. 값 입력
    - 상하좌우(Top, Bottom, Left, Right)에 여백 값(예: 20.0)을 입력

> 원리: 텍스트 위젯의 "Desired Size"에 패딩 값이 더해져 부모에게 전달되므로, 결과적으로 버튼이 커지게 됨

---

# UMG 주요 위젯
## Canvas Panel (캔버스 패널)
1. **특징**
  - 위젯을 절대적인 위치(앵커 기준)에 배치
  - Z-Order(그리기 순서)를 지원하여 위젯을 겹칠 수 있음 
2. **장점**
    - 프로토타이핑이 빠르고, HUD(Head-Up Display)의 최상위 루트 컨테이너로 적합
3. **단점**
    - 반응형 대응이 어렵고, 위젯이 많아질수록 관리가 불가능
    - 중첩된 캔버스 패널 사용은 성능 저하의 주원인

> UI 전체의 가장 바깥쪽 틀로만 사용하고, 내부의 세부 요소들은 다른 패널로 구성하는 것이 바람직

---

## Vertical/Horizontal Box (수직/수평 박스 )
1. 특징
    - 위젯을 선형으로 배열
    - 웹 개발의 Flexbox와 유사
2. 장점
    - 해상도가 변하거나 내용물(텍스트 길이)이 변해도 레이아웃이 깨지지 않음
    - 자동으로 밀려나거나 줄어듦

> - 리스트 아이템, 메뉴 버튼 모음, 스킬 바 등을 만들 때 필수적
> - Spacer 위젯을 중간에 넣어 Fill 속성을 주면, 양쪽 끝으로 위젯을 밀어내는 정렬 효과를 낼 수 있음

---

## Grid Panel (그리드 패널)
1. 특징
    - 행(Row)과 열(Column)을 정의하여 위젯을 배치
    - 엑셀 시트와 유사하지만, 셀 병합(Span)이 가능
2. 장점
    - 캔버스 패널처럼 2차원 배치가 가능하면서도, 유동적인 크기 조절이 가능
    - 특히 Layer 속성을 통해 한 셀 안에 여러 위젯을 겹쳐 놓을 수 있어 캔버스 패널의 대안으로 훌륭

```
[고급 기법]

Nudge 기능을 활용하면 그리드 셀 밖으로 살짝 튀어나가는 연출(예: 선택된 탭이 위로 튀어나오는 효과)을 레이아웃 붕괴 없이 구현할 수 있음
```

---

## Overlay (오버레이)
1. 특징
    - 자식 위젯들을 서로 겹쳐서 배치
    - 포토샵의 레이어 개념과 비슷

```
[활용]

- 배경 이미지 위에 텍스트를 올리기
- 캐릭터 초상화 위에 테두리 장식을 겹치기 등

Align 속성을 통해 오버레이 내부에서 좌상단, 중앙, 우하단 등으로 위치를 잡을 수 있다
```

---

## Wrap Box, Uniform Grid Panel (랩 박스, 유니폼 그리드)
1. Wrap Box
    - 수평으로 위젯을 배치하다가 공간이 부족하면 자동으로 다음 줄로 넘김
    - 인벤토리 아이템 창처럼 아이템 개수가 가변적일 때 유용
2. Uniform Grid Pane
    - 모든 셀의 크기가 동일하게 강제되는 그리드
    - 계산기 키패드나 전화번호부 같은 정형화된 격자 UI에 적합

---

## Anchors
**앵커는 위젯의 위치가 "화면의 어느 지점을 기준으로" 계산될지를 결정**

- 캔버스 패널의 슬롯은 **위젯의 위치를 Position X, Position Y로 저장**
- 이는 **앵커 포인트로부터의 거리(Offset)를 의미**

> 앵커는 뷰포트에 꽃 모양 아이콘으로 표시됨

---

## Min/Max 포인트
앵커는 **두 개의 점(Min, Max)으로 이루어져 있음**

- 보통은 두 점이 겹쳐 있어 하나의 점처럼 보이지만, 이를 **분리(Split)**할 수 있다

### 분리 예시
- **Min(0,0) Max(1,1)**
    - **화면 전체 스트레치**
    - 앵커가 화면의 네 귀퉁이로 찢어지며, **위젯은 화면 전체 크기에 대한 상대적인 여백(Offset)으로 크기가 결정**
    -  배경 이미지를 깔 때 필수적인 설정

---

## DPI Scaling
언리얼 엔진은 다양한 해상도에 대응하기 위해 **DPI 스케일러를 내장**

- 화면 해상도가 변할 때 **UI의 전체적인 스케일(배율)을 자동으로 조절**
- DPI Curve
  - Project Settings > User Interface > DPI Scaling에서 설정할 수 있음
  - 기본적으로 해상도가 높아지면 스케일 값도 커지도록 설정되어 있음 (예: 1080p에서 1.0, 4K에서 2.0)
- 스케일 규칙(Rule)
  - hortest Side(화면의 짧은 변 기준)가 가장 일반적으로 사용
  - 가로로 긴 울트라 와이드 모니터나 세로로 긴 모바일 화면에서도 UI 크기가 일관되게 유지되도록 돕는다

```
[주의사항]

사용자가 위젯을 만들 때 픽셀 단위(예: 100px)로 작업하더라도, 실제 게임에서는 DPI 스케일이 곱해져서 렌더링된다(예: 스케일 1.5면 150px)

따라서 너무 픽셀 퍼펙트(Pixel Perfect)한 수치에 집착하기보다는, 비율과 정렬 위주의 레이아웃을 짜는 것이 중요
```

---

**참고하면 좋은 링크**
- [Tech Art Chronicles: UMG Tips and Tricks](https://joyrok.com/UMG-Layouts-Tips-and-Tricks)
- [Intuitive material building with the UI Material Lab](https://dev.epicgames.com/community/learning/tutorials/Wz8V/unreal-engine-intuitive-material-building-with-the-ui-material-lab-part-1)
