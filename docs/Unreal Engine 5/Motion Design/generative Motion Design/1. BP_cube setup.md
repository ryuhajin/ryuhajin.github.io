---
layout: default
title: "1. BP_cube setup"
parent: "generative Motion Design"
nav_order: 1
---

# 1. BP_cube setup

## 블루프린트 생성
1. Actor BP 생성 : BP_Cube
2. **Cube static mesh를 추가해 씬 루트로 만든다**
3. Cube 모든 축 * 1.2
4. **Scene Components 여러개 추가**
    - 해당 컴포넌트는 **작은 큐브를 스폰할 때 기준점으로 사용**
5. components 배치 (top에서 각각 4군데 가운데에 위치)
    - 큐브 상단 (z: 25) p1 ~ p4
    - 큐브 하단 (z: -25) p5 ~ p8

---

## 이벤트 그래프 생성
1. `Event Actor Begin Overlap`과 `Event Begin Play`는 사용하지 않을 것이므로 삭제
2. 클래스 디폴트(Class Defaults) details 설정
    - **Start with Tick Enabled(틱 활성화된 채로 시작)을 비활성화(disable)**
    - 이벤트 틱 노드를 지워버린다고 해도, 백그라운드에서는 실제로 몰래 이벤트 틱이 실행되고 있다
    - 따라서 클래스 디폴트에서 **명시적으로 비활성화함으로써, 실제로 많은 퍼포먼스를 확보**
3. cube 컴포넌트 가져온 뒤 **get children components** 로 scene Componets 가져오기
4. scene components `ctrl + D`로 복사 -> 이름 : `Spawn Location`으로 변경
5. spawn location : **details에서 변수타입 array로 변경**
6. spawn location **Set : children components와 연결**

---

# event vs custom event
### 일반 이벤트(Event)
언리얼이 미리 정의한 콜백 함수를 블루프린트로 노출한 것

- 예: Event BeginPlay, Event Tick, Event OnOverlap 등
- C++에서 보면 이미 정의된 virtual 함수

```c++
virtual void BeginPlay() override;
virtual void Tick(float DeltaTime) override;
```

> 블루프린트에서는 이를 오버라이드 노드로 구현
> - 즉 시스템이 호출하는 이벤트

---

### 커스텀 이벤트(Custom Event)
사용자가 직접 정의하는 **새로운 실행 진입점(Execution Entry Point)**

> 블루프린트의 “커스텀 이벤트”는 코드 작성 불가, 그래프 노드로만 구성

- 내부적으로는 `UFunction` 하나를 새로 정의하는 것과 같음
- 단, **언리얼 런타임이 자동으로 호출하지 않음**
- 다른 블루프린트나 같은 그래프 내에서 **“이벤트 호출(Call)” 노드로 실행해야 함**

```c++
UFUNCTION(BlueprintCallable)
void MyCustomEvent();
```

> “커스텀 이벤트 노드”는 UFunction 정의를,
> - “이벤트 호출(Call MyCustomEvent)” 노드는 ProcessEvent() 호출을 의미

---

### 요약

| 개념   | 언리얼 내부 구현  | C++ 대응   | 호출 주체  |
| ----- | -------------- | ------| ---------- |
| Event BeginPlay      | 오버라이드 함수       | `virtual void BeginPlay()` | 엔진         |
| Event Tick           | 오버라이드 함수       | `virtual void Tick()`      | 엔진         |
| Custom Event         | 신규 `UFunction` | `void MyCustomEvent()`     | 사용자가 직접 호출 |
| Material Custom Node | HLSL 코드 삽입     | N/A (렌더 파이프라인 코드)  | GPU 셰이더    |

---

# custom event vs function
둘 다 내부적으로는 UFunction이지만, 목적과 제약이 다르다

## 개념적 차이

| 항목          | 커스텀 이벤트 (Custom Event)       | 함수 (Function)   |
| ----------- | ---------------------------- | --------------- |
| 실행 흐름       | **이벤트 핀(Execution Pin)** 기반  | 실행 핀 있음         |
| 반환값         | **없음 (void)**                | 있음. 가능           |
| 호출 시점       | 외부 그래프, 타이머, 딜레이 등에서 호출 가능   | 즉시 동기 실행        |
| 비동기/네트워크 지원 | **RPC 지원 (Run on Server 등)** | 지원 안 됨          |
| 트리거 방식      | `Call Custom Event`로 수동 호출   | 함수 호출 노드로 직접 실행 |
| 목적          | **흐름 제어, 신호 분기**             | **계산, 로직 캡슐화**  |

---

## 내부 구조 차이

- **커스텀 이벤트** : **리턴이 불가능하므로 BlueprintEvent 플래그 중심**
- **함수** : BlueprintCallable 또는 BlueprintPure 속성으로 등록되어 **호출 시 스택 프레임이 바로 반환됨**

```c++
// Custom Event
UFUNCTION(BlueprintCallable)
void MyEvent();  // 반환값 없음, Execution Pin 사용

// Function
UFUNCTION(BlueprintCallable, BlueprintPure = false)
int32 AddValues(int32 A, int32 B);  // 반환값 존재 가능
```

---

## 실행 제어 차이

1. **함수** : “즉시 호출 → 실행 → 리턴” 구조
    - → CPU 한 프레임 내에서 끝남
2. **커스텀 이벤트** : “예약된 실행 흐름”으로 처리
    - → 예: Delay, Timer, Sequence 뒤에서 호출 가능
    - → 그래서 네트워크 RPC나 Delegate Bind 등에 사용

> 함수는 Delay를 포함할 수 없다 (바로 호출되고 리턴되는 흐름)

---

## 제약

| 제약                     | 함수    | 커스텀 이벤트 |
| ---------------------- | ----- | ------- |
| Delay 사용               | ❌ 불가  | ✅ 가능    |
| Timeline, Loop 연결      | ❌ 제한적 | ✅ 자유로움  |
| 반환값                    | ✅ 가능  | ❌ 불가능   |
| 네트워크 RPC               | ❌ 불가능 | ✅ 가능    |
| Blueprint Interface 구현 | ✅ 가능  | ✅ 가능    |

---

## 정리

```
함수(Function) → “값 계산 또는 로직 캡슐화”
(동기, 리턴값 있음, Delay 불가)

커스텀 이벤트(Custom Event) → “실행 흐름 제어 단위”
(비동기 가능, 리턴 없음, 네트워크 호출 가능)
```

---
