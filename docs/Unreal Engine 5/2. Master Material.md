---
layout: default
title: "2. Master Material"
parent: "Material"
nav_order: 3
---

# 2. Master Material
---
## 1. Master Material
마스터 머티리얼을 만들고 이 마스터 머티리얼의 여러 인스턴스만 사용하는 방법을 통해 공간 절약, 씬의 성능 상향이 가능함.

## 2. Albedo vs Diffuse
베이스 컬러에 쓰이는 텍스쳐가 두 가지 용어를 혼합하여 쓰길래 두 키워드의 차이점이 무엇인지 궁금해졌다.

{: .new-title}
> ❓베이스 컬러에 들어가는 알베도와 디퓨즈의 차이점이 뭐지?
>
> - Albedo : 물리 기반 렌더링(PBR)에서 도입. 표면이 반사하는 확산 반사 비율 또는 색상을 의미
> - Diffuse : 전통적인 3D 그래픽스에서 디퓨즈 맵은 표면의 기본 색상을 정의한다. 빛의 영향을 받아 명암이 생기는 재질 표현에 사용

**Albedo vs Diffuse 정리**

|항목| **Albedo**| **Diffuse**|
| ---|---|---|
|정의|순수한 반사율 (빛의 간섭 없음)| 빛의 난반사로 인한 색상 + 명암|
|사용 예| PBR (물리 기반 렌더링)| 전통적 라이팅 모델 (램버트 반사 등)|
|데이터|환경광의 영향이 제거된 순수 색상| 그림자/광택 일부 포함 가능|
|예시| Unreal, Unity등에서 PBR 재질의 Base Color로 사용 | Photoshop 등에서 조명까지 표현한 diffuse map 제작 가능 |

- Diffuse 텍스처에는 실제 광원이 없어도 명암이 들어감.
  - 조명 대응 불가 (광원 위치를 바꿔도 그림자는 바뀌지 않음)

>
- **텍스처에 조명, 그림자, 반사 등을 "베이크"해서 포함시킨 것** = `diffuse map`
- 조명과 독립적인 순수한 색상. 빛은 셰이더에서 계산함 = `Albedo`

## 3. Texture Coordinate
UV 매핑을 제어하는 노드로 머티리얼이 메시 표면에 어떻게 텍스쳐를 투영할지 결정한다.
- 모델의 각 정점(Vertex)에는 UV 좌표(0~1 범위의 2D 좌표)가 할당되어 있으며, 이 노드는 해당 좌표를 조정하거나 변형할 때 사용할 수 있다.
  
>
- 기본 출력: UV 채널의 2D 벡터(X, Y). 각 성분은 일반적으로 0.0 ~ 1.0 범위
  -  X(U): 가로 축 좌표 (좌 → 우)
  -  Y(V): 세로 축 좌표 (하 → 상)
- Coordinate Index: 다중 UV 채널을 선택할 수 있다.
  -  정적 메시의 Lightmap UV(UV1) 등 추가 좌표 계층을 활용할 때 유용

## 4. Vector4
- Vector4 노드의 R,G,B,A에 각각 U tile, V tile, U offset, V offset 이라고 이름을 붙여 텍스쳐 타일링에 사용할 수 있다.
- 타일링 *= multiply
- 오프셋 += add

## 5. static swich parameter
머티리얼 그래프 내에서 **분기를 정의**하고, **머티리얼 인스턴스 에디터에서 체크박스로 설정 가능**하게 해준다.
- 정적(static) 이 붙은 이유 : 런타임에 변경되지 않고 **머티리얼 컴파일 타임에 결정**됨
- 사용되지 않는 쪽의 분기는 완전히 제거되어 실행 시간이 최적화

>
- 입력 A : A 로직 (스위치가 True일 때 적용)
- 입력 B : B 로직 (스위치가 False일 때 적용)
- 출력 : True는 A, False는 B 출력

# Color Control
## RGB 표현

{: .new-title}
> ❓언리얼 엔진에서는 RGB가 0~255 값이 아니라고?
>
> - 언리얼에서는 RGB 표현을 정규화된 0~1 범위로 사용한다.
> - 0~255 와 0~1 두 범위 모두 동일한 색상을 나타내지만, 사용하는 컨텍스트와 시스템에 따라 다른 스케일로 표현된다.

## 왜 언리얼 엔진은 0~1 범위를 사용할까?
1. 수학적 일관성
    - 3D 그래픽스에서는 벡터 연산이 빈번하게 일어남
    - `0~1` 범위는 퍼센트 개념과 연결되며, **모든 계산을 비율 기반으로 통일할 수 있다.**
      - 예: `0.5 = 50% 밝기` -> `0.5 * 2.0 = 1.0 (100%)` 
2. HDR (High Dynamic Range) 지원
    - `0~1` 범위를 벗어나는 값 (예: 2.0) 으로 더 밝은 빛을 표현할 수 있다.
3. GPU 친화적
    - 현대 GPU는 부동소수점(float) 계산에 최적화되어 있어 **0~1 범위가 셰이더 연산과 호환성이 좋다.**

## RGB 정규화 방법
- 0~255 -> 0~1 (정규화) = `값 / 255`

```c++
RGB(255, 127, 0) -> RGB(1.0, 0.498, 0.0)  
```

- 0~1 -> 0~255 (역정규화) = `값 * 255` (반올림 적용)

```c++
RGB(0.5, 0.75, 1.0) -> RGB(128, 191, 255)
```

## 1. 밝기: Brightness
- RGB 값에 1보다 큰 수를 곱하는 것으로 설정 가능.
- RGB는 `0.0 ~ 1.0` 범위로 표현됨
  - `0.0` = 완전한 어둠 (검정)
  - `1.0` = 최대 밝기 (순수한 색상)
- `R * 2` = R의 밝기 2배 증가  
- `R * 0.5` = R의 밝기 50% 감소

## 2. 채도: Satration
## desaturation (탈색)
**특정 색상을 흑백(grayscale)에 가깝게 변환**하는 데 사용되는 노드.
이 노드를 사용하여 채도를 조절한다.

>
- 입력 input (V3) : 일반적으로 텍스쳐의 RGB가 입력됨
- 입력 Fraction (V1) : 채도를 얼마나 줄일지 결정하는 값.
  - `0` : 원본 색상 유지
  - `1` : 완전히 회색
- 출력 (V3) : desaturation 적용 결과

**내부 연산 공식**
```c++
Gray = R * 0.3 + G * 0.59 + B * 0.11
Output = lerp(Input, Gray, Fraction)
```
- `Gray`는 NTSC 표준 기반의 가중 평균. 인간의 눈이 **가장 민감한 녹색에 높은 가중치**를 둠

## 3. 대비: Contrast
## power
입력 값의 **지수 승(power/exponentiation) 을 계산**하는 노드

```c++
Output = Base ^ Exponent
```
>
- 입력 Base (V,V3) : 일반적으로 RGB 텍스쳐 입력
- 입력 Exponent (V) : 지수 값.
- 출력 (V, V3): 계산된 결과 값 (Base의 Exponent 승)

{: .new-title}
> ❓왜 Contrast 조절에 Power를 쓰는거야?
>
> - `power`는 단순 곱셈으로는 할 수 없는 **비선형적인 변화를 제공**하기 때문이다

### 곱셈 (Multiply) vs 지수승 (Power)

|특성|곱셈|지수승|
|---|---|---|
수학적 표현|RGB × Scale|RGB ^ Gamma|
연산 유형|모든 픽셀의 밝기를 균일하게 스케일링<br> 어두운 영역과 밝은 영역이 동일한 비율로 변화|비선형변환으로 밝기 분포를 비균형적으로 조정|
밝기 변화|모든 픽셀 균일하게 스케일링|밝은 픽셀은 더 밝게 <br> 어두운 픽셀은 더 어둡게 (분포 왜곡)|
대비(Contrast) 영향| 대비 유지 | 대비 증가 (Gamma > 1) <br>대비 감소 (Gamma < 1)|
시각적 효과| 전체적으로 밝아지거나 어두워짐|어두운 영역과 밝은 영역의 차이 강조 or 완화|
사용 예시|	밝기 조정, 라이트 강도 증감 | Contrast 조정, 감마 보정|

```c++
RGB (0.2, 0.5, 0.8)
Power(2.0) -> RGB(0.04, 0.25, 0.64)

// 어두운 부분은 급격히 어두워지고 밝은 픽셀은 상대적으로 덜 영향받음. = 대비 강해짐
```

## 4. 색조: Tint
Base color의 RGB에 **다른 색상의 RGB를 곱**해서 얻을 수 있다.

- 채널별 스케일링
  - 곱해지는 색상의 각 채널 값이 원본 색상의 해당 채널을 강화하거나 약화시킴
  - `1.0` : 해당 채널 100% 유지
  - `0.5` : 해당 채널 50% 감소
  - `0.0` : 해당 채널 완전히 제거

```c++
// 원본 색상
RGB(0.8, 0.5, 0.2)  

// Tint 색상
RGB(1.0, 0.3, 0.3)

// 결과 -> R은 유지, G/B는 감소   
(0.8*1.0, 0.5*0.3, 0.2*0.3) = (0.8, 0.15, 0.06)
```

