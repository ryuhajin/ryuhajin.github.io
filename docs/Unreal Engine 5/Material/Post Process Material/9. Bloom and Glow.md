---
layout: default
title: "9. Bloom and Glow"
parent: "Post Process Material"
nav_order: 9
---

# 9. Bloom and Glow
화면에서 밝은 부분이 주변으로 빛을 발산하는 것처럼 보이게 하는 블룸(Bloom) 효과 구현하기

- [Custom Bloom Post-Process in Unreal Engine](https://www.froyok.fr/blog/2021-12-ue4-custom-bloom/)

## Bloom 개념
1. **원본 이미지를 준비**
2. **임계값(Threshold) 처리**
    - 이미지를 복제한 뒤, 'Levels(레벨)' 조정을 통해 **어두운 픽셀을 모두 검은색으로 만든다**
    - **0.5 이하의 값을 모두 제거**
    - 결과: 이미지에서 '가장 밝은 영역'만 흰색/밝은색으로 남고 나머지는 모두 검은색
3. **블러(Blur) 처리**
    - 2번에서 만든 '밝은 영역만 남은 이미지'에 **가우시안 블러(Gaussian Blur)**를 적용
    - 결과: 밝은 점들이 부드럽고 넓게 퍼짐
4. **합성(Composite)**
    - 원본 이미지 위에 3번에서 만든 '흐릿하게 퍼진 밝은 이미지'를
    - **'Add(추가)' (또는 'Linear Dodge') 블렌드 모드로 덮어씌우기**

----

# User Scene Textures
**포스트 프로세스 소재에서 쓰고 읽을 수 있는 사용자 정의 일시적 렌더 타겟**

- 언리얼 엔진 5.5 이상에서 추가되었음

- [UE - User Scene Textures for Post Process Materials](https://dev.epicgames.com/documentation/en-us/unreal-engine/post-process-material-user-scene-textures-in-unreal-engine)
- [Using User Scene Texture](https://medium.com/@nlnnn/using-user-scene-texture-for-multi-pass-post-process-effects-in-unreal-engine-5-90b4614f7122)


## User Scene Textures 역할
1. **User Scene Texture는 포스트 프로세스 머티리얼의 임시 버퍼**이다
    - 포스트 프로세스 머티리얼은 **해당 임시 버퍼에 렌더링**한다
2. **User Scene Texture는 결과를 직접 출력하지 않는다**
    - 씬 텍스처와 병행하여 존재한다

## User Scene Textures 사용하기
포스트 프로세스 머티리얼이 User Scene Textures에 렌더링하게 하기

### 준비 단계
1. **포스트 프로세스 머티리얼 노드의 Details**
2. **임시 버퍼로 사용할 User Scene Texture 이름 설정**
    - 예: test
3. **해당 포스트 프로세스 머티리얼이 test 버퍼에 렌더링 함**

---

### 생성한 임시 버퍼 불러오기
1. user Scene Texture 노드 가져오기
2. **해당 노드의 이름에 가져올 버퍼 입력**
    - 예 : test
3. **가져올 버퍼는 버퍼가 채워진 후에야 사용할 수 있음**
    - **버퍼를 생성하는 소재보다 Blendable Location 위치가 동일하거나 나중에 있어야 함**
    - Blendable Priority 도 같거나 나중에 있어야함
4. **user Scene Texture 노드를 사용하여 original Scene texture도 불러올 수 있음**
    - 예 : SceneColor (SceneTexture:PostProcessInput0 렌더링 불러올 수 있음)

---

### user Scene Texture 설정으로 downsample, upsample 하기
1. **입력 상대 해상도 (Resolution Relative To Input) 설정**
    - User Scene Texture의 이름 지정
    - 업 샘플링, 다운 샘플링의 기본 해상도로 사용됨
    - **설정하지 않으면 화면 해상도를 기반으로 함**
2. **User Texture Divisor 설정**
    - `-1`, `0`, `1` 값은 동일한 출력 해상도 유지
    - **입력값이 (2,2) 일 때 값은 분모로 감 (예 : 1/2, 1/2)**
      - 따라서  (2,2) 입력시 가로, 세로 둘 다 해상도 절반으로 **다운 샘플링**
    - **입력값이 (-2,-2) 일 때 입력 텍스쳐에서 업 샘플링 (화면 해상도 까지만)**

---

### user Scene Texture 노드 옵션
1. **Filtered**
    - **체크** : user Scene Texture를 **샘플링 할 때 이차원 보간 필터링 사용**
      - 속도는 느려짐
      - 업샘플링, 다운샘플링 시 픽셀화 현상이나 앨리어싱 아티팩트 방지됨
    - **비체크** : **포인트 샘플링 사용**
      - 픽셀화된 도트 아트 스타일 구현
2. **Clamped**
    - **필터링이 활성화 된 상태에서 다운 샘플링 할 때 사용**
    - 텍스처 조회 범위를 클램핑하여 가장자리 바깥쪽의 무작위 픽셀이 블렌딩되는 것을 방지

---

### user Scene Texture 머티리얼 인스턴스 설정
1. User Scene Texture의 이름 변경 가능
2. 샘플링 설정 불가능

---

# SceneTextureFetch()
**커스텀 노드에서 Scene Texture를 가져오기 위한 새로운 함수** (UE 5.5에 도입)

> SceneTextureFetch()는 기존 장면 텍스처 샘플링에 사용되던
> - GetDefaultSceneTextureUV() 및 SceneTextureLookup() 함수를 모두 사용

```c++
SceneTextureFetch(ScenetexID, UVoffset);

float4 Sample = SceneTextureFetch(UserTexName.ID, float2(0.0f, 0.0f));
```

---

1. 픽셀 단위의 오프셋 값을 받아 해당 UV를 자동으로 계산함
2. `SceneTextureFetch()` 함수를 사용할 경우 텍스쳐 샘플링이 이차선형 보간법으로 고정됨

> 따라서 포인트 샘플링이 필요한 상황에서는 기존의 방법을 사용해야 함

---

```c++
float2 UV = GetDefaultSceneTextureUV(Parameters, UserTexName.ID);
UV = ClampSceneTextureUV(UV, UserTexName.ID);

float4 Sample = SceneTextureLookup(UV, UserTexName.ID, false); // Filtered = false
```

---

### 참고사항
- User Scene Texture 의 Clamped, Filtered 세팅은 머티리얼 그래프 안에서 유효
- 커스텀 노드에서 작동하지 않음
  - 따라서 필요에 따라 커스텀 노드에 올바른 매개변수를 설정해야 함 

---

# Bloom
user Scene Texture를 사용하여 bloom 효과 만들어보기

- 유니티에서는 MIPMAP 레벨을 선택할 수 있지만 언리얼에서는 불가능
- UE 5.5에서 도입된 user Scene Texture를 사용하면 낮은 해상도 이미지를 얻을 수 있음

```c++
float2 SceneUV = GetDefaultSceneTextureUV(Parameters, SceneTexture.id);

SceneUV += (offset * pixleSize);

float3 SampleColor = SceneTextureLookup(SceneUV, SceneTexture.id, true).rgb;

return SampleColor;
```