---
layout: default
title: "8. Radial Blur"
parent: "Post Process Material"
nav_order: 8
---

# 8. Radial Blur
화면 중앙에서 바깥쪽으로 퍼지는 방사형 블러 효과 만들기

- [What is Gaussian Blur?](https://youtu.be/5xUT5QdkPAU?si=JP2IZ9_BEILpjRP1)


---

## 방사 블러 개념
1. **화면 중앙 좌표에서 현재 픽셀의 uv 좌표를 빼 방향 벡터 계산**
    - 현재 픽셀 UV - 화면 중앙 UV
    - 화면 중앙에서 현재 픽셀을 향해 뻗어 나가는 2D 벡터
    - 이 벡터가 픽셀이 흐려질 방향
2. 방향 벡터를 따라 일직선으로 다중 샘플링
    - Blur 효과는 한 지점의 색상만 사용하는 것이 아니라, 주변 여러 지점의 색상을 가져와 혼합(Blending)하는 방식
    - 현재 픽셀을 중앙(0.0)으로 놓고, 방향 벡터를 따라 양쪽으로 5개씩 샘플링
    - 예: -0.05, -0.04, ..., 0.0, ..., +0.04, +0.05의 오프셋
3. 부드러운 블러를 위한 가우시안 가중 평균 사용
    - 1개의 샘플을 단순히 1/11로 평균 내면 부자연스러움
    - 현재 픽셀 위치(오프셋 0.0)에 가장 높은 가중치를 부여
    - 현재 픽셀에서 멀어질수록(즉, 오프셋이 -0.05나 +0.05에 가까워질수록) 가중치를 급격히 낮춤

## 그래프 예제
머티리얼 그래프 예제로 따라하려면 노드가 너무 많이 들어서 커스텀 노드를 사용하기로 함

- 하지만 SceneTexture 샘플링 하는 방법을 알지 못해 샘플링 방법을 찾아야 했음
- 아래는 도움받은 포럼 글
- [UE Forum - Custom Node Sampling](https://forums.unrealengine.com/t/custom-node-in-postprocessing/18472/3)

---

## 샘플링 함수 정리
SceneTexture를 샘플링 할 때 쓴 함수 정리

### GetDefaultSceneTextureUV(Parameters, SceneTexture.id)
씬 텍스처(Scene Texture)를 올바르게 샘플링하기 위한 UV 좌표를 가져오는 함수

**해당 함수를 사용하는 이유?**
1. 엔진 내부에서 해상도 스케일링(Resolution Scaling)이 적용되거나 뷰포트가 다르게 설정된 경우,
2. TexCoord 노드가 가리키는 위치와 SceneColor 텍스처가 매핑되는 위치가 정확히 일치하지 않을 수 있음

```
`GetDefaultSceneTextureUV` 함수는 이러한 엔진의 모든 내부적인 처리를 고려함

셰이더가 접근하려는 SceneTexture.id 텍스쳐를 샘플링 할 때 정확한 UV 좌표를 계산함
```

### 입력
1. **Parameters**
    - **Parameters라는 키워드를 그대로 사용하기만 하면 됨**
    - 픽셀 셰이더를 실행하기 위해 필요한 모든 정보(현재 픽셀의 UV, 뷰(View) 관련 정보 등)를 담아 암시적으로 전달하는 구조체
2. **SceneTexture.id**
    - **UV를 얻고자 하는 대상 씬 텍스처의 식별자(ID)**
    - uint (정수형 ID), 보통 input0은 ID = 14
    
### 출력
1. **float2 (uv)**
    - SceneTexture.id에 해당하는 **텍스처를 샘플링하는 데 사용해야 할 정확한 UV 좌표**

---

### SceneTextureLookup(SampleUV, SceneTexture.id, true).rgb
특정 씬 텍스처에서 실제로 픽셀 값(데이터)을 샘플링(Sampling), 즉 '조회(Lookup)'하는 함수

```
HLSL의 Texture.Sample() 함수와 본질적으로 동일한 역할을 하지만,
언리얼 엔진의 복잡한 씬 텍스처 관리 시스템(텍스처 배열, 아틀라스 등)에 맞게 추상화된 함수
```

### 입력
1. **SampleUV**
    - **텍스처를 샘플링할 위치의 UV 좌표**
2. **SceneTexture.id**
    - **UV를 얻고자 하는 대상 씬 텍스처의 식별자(ID)**
3. **bool bPointSample**
    - **텍스처 필터링(Filtering) 방식을 지정**
    - **true (Point Sampling)**
      - **보간을 수행하지 않고** SampleUV와 가장 가까운 픽셀의 값을 그대로 반환
      - 뎁스(Depth), 스텐실(Stencil), 모션 벡터(Motion Vector)처럼 정확한 데이터 값이 필요할 때 사용
    - **false (Bilinear Sampling)**
      - SampleUV **주변 4개 픽셀의 값을 선형 보간하여 부드러운 결과를 반환**
      - SceneColor와 같은 일반적인 색상 텍스처에 사용
    
### 출력
1. **float4 (RGBA)**
    - SampleUV 위치에서 읽어온 **텍스처의 픽셀 값**

---

## 커스텀 노드 코드
강의와 다른점 - 센터 좌표 추가, falloff를 추가하여 깨끗하게 자를지 말지 설정

```c++
static const int SAMPLE_COUNT = 11;

static const float Offsets[SAMPLE_COUNT] = {
    -0.05,
    -0.04,
    -0.03,
    -0.02,
    -0.01,
    0,
    0.01,
    0.02,
    0.03,
    0.04,
    0.05
};

static const float Weights[SAMPLE_COUNT] = {
    0.0029304029304029304,
    0.01611721611721612,
    0.05372405372405373,
    0.12087912087912088,
    0.1934065934065934,
    0.22564102564102564,
    0.1934065934065934,
    0.12087912087912088,
    0.05372405372405373,
    0.01611721611721612,
    0.0029304029304029304
};


// 현재 픽셀의 UV 좌표 (0~1)
float2 SceneUV = GetDefaultSceneTextureUV(Parameters, SceneTexture.id);
float3 OriginalColor = SceneTextureLookup(SceneUV, SceneTexture.id, true).rgb;


// 블러 방향 벡터 계산 (입력값 사용)
float2 BlurDirection = (SceneUV - Center) * BlurStrength;

// 가중 합산을 위한 변수
float3 BlurredColor = 0;

for (int i = 0; i < SAMPLE_COUNT; ++i)
{
    // 샘플링할 UV 계산
    float2 SampleUV = SceneUV + (BlurDirection * Offsets[i]);
    SampleUV = saturate(SampleUV); // 0~1 범위로 제한

    // 씬 컬러 샘플링
    float3 SampleColor = SceneTextureLookup(SampleUV, SceneTexture.id, true).rgb;

    // 가중치 적용 및 합산
    BlurredColor += SampleColor * Weights[i];
}

// 현재 픽셀과 Center 사이의 거리 계산
float dist = distance(SceneUV, Center);

// 마스크의 '안쪽' 경계와 '바깥쪽' 경계를 정의
float innerEdge = Radius - Falloff;
float outerEdge = Radius;

// smoothstep으로 경계값 계산
float Mask = smoothstep(innerEdge, outerEdge, dist);

// Mask 값에 따라 원본 컬러와 블러 컬러를 선형 보간
// Mask = 0 이면 OriginalColor, Mask = 1 이면 BlurredColor
return lerp(OriginalColor, BlurredColor, Mask);
```