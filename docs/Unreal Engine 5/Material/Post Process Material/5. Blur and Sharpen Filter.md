---
layout: default
title: "5. Blur and Sharpen Filter"
parent: "Post Process Material"
nav_order: 5
---

# 5. Blur and Sharpen Filter
간단한 블러(blur) 및 샤픈(sharpen) 포스트 프로세스 필터 만들기

---

## 기본 개념

```
화면을 여러 번 샘플링하고 가중 합산해서 이미지를 흐리게 하거나, 역방향으로 적용하여 선명하게 만들기
```

---

## 샘플 오프셋 값

| 샘플 위치 | 오프셋 값 (벡터2) |
| ----- | ----------- |
| 중앙    | (0, 0)      |
| 좌     | (-2, 0)     |
| 우     | ( 2, 0)     |
| 좌상    | (-1, 2)     |
| 우상    | ( 1, 2)     |
| 좌하    | (-1,-2)     |
| 우하    | ( 1,-2)     |

---

## 픽셀 크기 계산

```
화면 해상도: 1920 × 1080
전체 화면 크기: 1.0 × 1.0 (정규화된 UV 좌표)

픽셀 하나의 크기 = 1 / 해상도
```

- 예시

```
// 1920 × 1080 해상도일 때:
픽셀 가로 크기 = 1 / 1920 ≈ 0.0005208
픽셀 세로 크기 = 1 / 1080 ≈ 0.0009259

// 따라서:
1픽셀 이동 = UV (0.0005208, 0.0009259) 만큼 이동
```

---

## 그래프 예제

1. **7개의 샘플 오프셋 사용**: 중앙 1개 + 주변 6개
    - 중앙을 0,0으로 두고 상 2 하 2 좌 1 우 1 샘플링
2. **픽셀 크기 계산**
    - ScreenResolution → (1 / ScreenResolution) = 픽셀 크기
3. **7개의 샘플 오프셋 값 * 픽셀 크기**
    - 화면 해상도 기반 오프셋 계산
4. **UV(texcoord) + 오프셋 = 샘플 위치**
    - 7개의 샘플링 uv 좌표 구하기
5. **각 SceneTexture의 UVs 입력에 4번에서 만든 UV 좌표 연결**
6. **uv 좌표 * 가중치 후 합산**
    - 중앙 = 0.3
    - 나머지 6개 = (0.7 / 6) ≈ 0.11667 (가중 합이 1이 되도록 맞춤)
    - 그 후 결과 add로 합산
7. **Lerp로 블러, 샤픈 제어하기**
    - A: 원본
    - B: 블러
    - Alpha
      - 0 : normal
      - 1 > : blur
      - < 0: sharpen

```
성능 개선 팁

필요시 샘플 수 7개 → 5개로 축소

큰 픽셀 오프셋 값 줄이기 (2 → 1.5)
```

---

# Gaussian blur
블러란? 이미지를 흐릿하게 만드는 것. 즉 **주변 픽셀들의 색상을 가져와 섞는 것**

## Gaussian blur 개념
잉크는 떨어진 지점이 가장 진하고, 멀어질수록 연하게 퍼져나간다

```
가우시안 블러는 이 '퍼짐의 규칙'을 수학자 가우스(Gauss)가 만든 정규 분포(Normal Distribution) 곡선,

즉 종 모양의 곡선(Bell Curve)을 따르게 하는 것
```

- **중심 픽셀 (나)**: 가장 가중치(Weight)가 높음. 자신의 원래 색을 가장 많이 유지.
- **주변 픽셀 (이웃)**: 거리가 멀어질수록 가중치가 급격히 줄어듬. 즉, 멀리 있는 색은 조금만 섞음

**읽어보면 개념 잡는데 좋은 링크**
- [Fast Real-Time GPU-based Image Blur Algorithms](https://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html)

---

## Gaussian blur 수학적 배경
가우스 함수

- x는 중심으로부터의 거리, 시그마 ($$\sigma$$)는 퍼짐의 정도를 나타냄

---

$$
G(x) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{x^2}{2\sigma^2}}
$$

---

- **$$\sigma$$ (표준 편차):** 이 값이 클수록 종 모양이 옆으로 넓게 퍼짐 (더 많이 뭉개짐)
- **$$e$$ (자연 상수):** 자연계의 성장이나 감쇠를 표현하는 수. 여기서는 거리가 멀어질수록 영향력이 '부드럽게' 줄어들게 만든다

---

## 2차원 가우시안과 최적화
이미지는 2차원 (x,y) 평면이기 때문에 위치에 대해 2차원 가우스 함수를 써야함

---

$$
G(x, y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}}
$$

---

하지만 지수법칙에 의해 다음과 같이 쪼갤 수 있음

- 지수 법칙

---

$$
e^{a+b} = e^a \times e^b
$$

---

$$
G(x, y) = G(x) \times G(y)
$$

---

- **Case A (최적화 전):** $$N \times N$$ 크기의 블러를 하려면, 픽셀 하나당 $$N^2$$번 주변을 조회해야 함
  - ($$5 \times 5$$ 블러 $$\rightarrow$$ 픽셀당 25번 연산)
- **Case B (최적화 후 - Two Pass):** 가로로 한 번 $$G(x)$$를 계산하고, 그 결과를 세로로 $$G(y)$$ 계산
  - 픽셀당 $$N + N = 2N$$번만 연산하면 됨 ($$5 \times 5$$ 블러 $$\rightarrow$$ $$5+5=10$$번 연산)

> 이것이 바로 **Two-Pass Algorithm**의 핵심

---

## Two-Pass Gaussian Blur
가우시안 블러는 보통 한 번에 그리지 않고, 두 번에 나눠서 그림

1. **Pass 1 (가로 블러):**
    - **원본 이미지를 가져와 가로 방향으로만 뭉갠다. 그 결과를 임시 텍스처(Render Target)에 저장**
2. **Pass 2 (세로 블러):**
    - **Pass 1에서 만든(가로로 뭉개진) 텍스처를 가져와 세로 방향으로 뭉갠다.** 최종적으로 화면에 그린다

---

### 필요한 매개변수
1.  **Blur Radius (Radius):** 중심 픽셀로부터 몇 칸 옆까지 검사할 것인가? (보통 정수)
2.  **Sigma ($$\sigma$$):** 얼마나 흐릿하게 할 것인가?
3.  **Weights (가중치 배열):** 가우스 공식으로 미리 계산한 가중치 값들
4.  **Texel Size:** 텍스처의 픽셀 하나 크기 (1.0 / 해상도)
    - UV 좌표는 0~1 사이이므로 픽셀 단위 이동을 위해 필요

```c++
#include <vector>
#include <cmath>
#include <iostream>

// 수학 상수 PI 정의
const float PI = 3.14159265359f;

// 가우시안 가중치를 계산하여 반환하는 함수
// sigma: 블러 강도, radius: 블러 범위 (픽셀 수)
std::vector<float> CalculateGaussianWeights(float sigma, int radius) {
    std::vector<float> weights;
    weights.resize(radius * 2 + 1); // -radius ~ +radius 까지 포함하므로

    float sum = 0.0f; // 가중치의 총합을 저장할 변수 (정규화를 위해)

    // 1. 가우스 공식을 이용해 가중치 계산
    // x는 중심(0)으로부터의 거리: -radius ~ +radius
    for (int i = -radius; i <= radius; ++i) {
        float x = static_cast<float>(i);
        
        // 1차원 가우시안 공식 적용
        // 분모의 sqrt(2*PI*sigma^2) 부분은 나중에 어차피 정규화(나눗셈)하므로
        // 여기서는 e^(-x^2 / 2sigma^2) 부분만 계산해도 비율은 같음.
        float weight = expf(-(x * x) / (2 * sigma * sigma));
        
        weights[i + radius] = weight; // 배열 인덱스는 0부터 시작해야 하므로 offset 더함
        sum += weight;
    }

    // 2. 정규화 (Normalization) - 매우 중요!
    // 모든 가중치의 합이 1.0이 되어야 이미지의 전체 밝기가 유지.
    // 합이 1보다 작으면 이미지가 어두워지고, 크면 너무 밝아짐.
    for (int i = 0; i < weights.size(); ++i) {
        weights[i] /= sum;
    }

    return weights;
}
```

---

## Moving Average Blur (박스 블러)
Moving Average(박스 블러)는 중심이든 가장자리든 모든 픽셀의 가중치가 1로 똑같음

### 개념: 슬라이딩 윈도우 (Sliding Window)
가우시안 블러는 픽셀마다 곱하기를 엄청나게 해야 함. 하지만 이동 평균은 계산량을 획기적으로 줄일 수 있음

- 비유

```
10명의 학생의 평균 점수를 구하고 있습니다.

무식한 방법: 매번 10명의 점수를 다 더해서 10으로 나눔
이동 평균: 옆 반으로 이동할 때, 빠지는 학생 점수를 빼고 새로 들어온 학생 점수만 더함
```

- 블러의 반지름이 아무리 커져도(100이든 1000이든), 연산 횟수는 똑같다
- 이것이 박스 블러 알고리즘의 핵심

---

$$
Sum_{new} = Sum_{old} - \text{Pixel}_{out} + \text{Pixel}_{in}
$$

---

### 코드 예시

```cpp
float GetPixel(const std::vector<float>& data, int index) {
    if (index < 0) return data[0];                    // 왼쪽 경계: 첫 번째 픽셀 반복
    if (index >= (int)data.size()) return data[data.size()-1]; // 오른쪽 경계: 마지막 픽셀 반복
    return data[index];
}

void MovingAverageBlur(std::vector<float>& data, int radius) {
    int N = data.size();
    std::vector<float> result(N);
    
    float sum = 0.0f;
    
    // 1. 초기 윈도우 합 구하기 (첫 번째 픽셀 기준)
    // 범위 밖은 0이나 가장자리 값으로 처리한다고 가정
    for (int i = -radius; i <= radius; ++i) {
        sum += GetPixel(data, i); 
    }
    
    // 2. 옆으로 한 칸씩 이동하며 슬라이딩
    for (int x = 0; x < N; ++x) {
        result[x] = sum / (2 * radius + 1); // 평균값 저장
        
        // 핵심: 가장 왼쪽 놈 빼고(-), 오른쪽 새 놈 더하기(+)
        // 루프 안에서 반복문이 사라짐! -> 속도가 엄청 빠름
        float outgoing = GetPixel(data, x - radius);
        float incoming = GetPixel(data, x + radius + 1);
        
        sum = sum - outgoing + incoming;
    }
    
    data = result;
}
```

### 박스 블러 정리
- 장점: 블러를 아무리 넓게 먹여도 속도가 똑같이 빠름
- 단점: 결과물이 네모나게 각져 보임 (품질이 낮음). 그래서 이걸 여러 번 반복해서 가우시안처럼 보이게 흉내 내기도 함

---

## Kawase Blur (카와세 블러)
Xbox 게임 'Wreckless'를 만든 Masaki Kawase가 고안한 방식

- 블룸(Bloom - 빛 번짐) 효과를 만들 때 사실상의 표준처럼 쓰임


## Kawase Blur 개념
작게 줄여서 뭉개자

- 가우시안 블러는 크기가 같은 텍스처끼리 작업하지만, Kawase는 점점 작아지는 텍스처를 사용

1. **Pass 0**: 원본($$W \times H$$) $$\rightarrow$$ 절반 크기($$W/2 \times H/2$$)로 줄이며 4개 픽셀 평균 냄
2. **Pass 1**: ($$W/2 \times H/2$$) $$\rightarrow$$ ($$W/4 \times H/4$$)로 줄이며 블러
3. **Pass 2**: ($$W/4 \times H/4$$) $$\rightarrow$$ ($$W/8 \times H/8$$)로 줄이며 블러
4. **Final**: 다시 확 키워서(Upsample) 원본에 합성

## 예시 코드
Kawase 블러는 픽셀 1개를 칠할 때, 주변 4개를 대각선 방향에서 가져와 섞음

```c++
// Kawase Blur Pixel Shader (HLSL)
// 텍스처 크기가 줄어든 상태에서 호출.

cbuffer Constants : register(b0)
{
    float2 g_TexelSize; // 현재 줄어든 텍스처의 픽셀 크기 (1.0 / Width, 1.0 / Height)
};

float4 KawaseBlurPS(PS_INPUT input) : SV_Target
{
    float4 color = 0;
    
    // 샘플링 오프셋: 중심에서 약간 떨어진 대각선 4방향
    // 0.5 픽셀 같은 애매한 위치를 찍는 것은 GPU의 선형 보간(Linear filtering)을
    // 공짜로 이용하기 위함입니다. (Bilinear Filtering)
    float2 offset = g_TexelSize * 1.5f; // 거리는 조절 가능 (보통 0.5 ~ 2.5)

    color += g_InputTexture.Sample(g_Sampler, input.UV + float2( offset.x,  offset.y)); // 우상
    color += g_InputTexture.Sample(g_Sampler, input.UV + float2(-offset.x,  offset.y)); // 좌상
    color += g_InputTexture.Sample(g_Sampler, input.UV + float2(-offset.x, -offset.y)); // 좌하
    color += g_InputTexture.Sample(g_Sampler, input.UV + float2( offset.x, -offset.y)); // 우하

    return color * 0.25f; // 4개 더했으니 4로 나눔 (평균)
}

// Kawase Blur는 일반적으로 여러 패스로 구성:
//
// 패스 0: 원본 → 1/2 크기, 오프셋 = 0.5
// 패스 1: 1/2 → 1/4 크기, 오프셋 = 1.5  
// 패스 2: 1/4 → 1/8 크기, 오프셋 = 2.5
// ...
//
// 각 패스마다 오프셋을 점점 증가시켜 더 넓은 영역을 블러링.
```

### 카와세 블러 정리

- 장점: 텍스처 크기 자체를 줄여버리기 때문에 메모리 대역폭(Bandwidth) 소모가 극적으로 줄어든다
  - 엄청나게 넓은 빛 번짐을 아주 싼 값에 만들 수 있다
- 단점: 이미지를 줄였다 늘리므로 정밀한 디테일이 사라지고, 반짝이는 점들이 네모난 블록처럼 보일 수 있다(Aliasing)

---

## 결론

이름	| Gaussian Blur (가우시안)	| Moving Average (박스)	| Kawase Blur (카와세) |
|---|---|---|---|
품질	|최상 (매우 부드러움)	|하 (네모낳게 보임)	|중상 (넓게 잘 퍼짐)|
속도	|느림 (최적화해도 무거움)	|매우 빠름 (O(1))	|매우 빠름 (해상도 축소)|
시간복잡도  | O(radius²)    | O(1)           | O(log n)|
메모리 접근 | 중간          | 많음           | 적음  |
수학	|정규 분포 (종 모양)	|단순 평균 (직사각형)	|다운샘플링 + 선형 보간|