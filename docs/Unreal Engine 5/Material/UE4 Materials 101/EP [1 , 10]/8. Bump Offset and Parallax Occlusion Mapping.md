---
layout: default
title: "8. Bump Offset / Parallax Occlusion Mapping"
parent: "EP [1 , 10]"
nav_order: 6
---

# EP 8 : Bump Offset and Parallax Occlusion Mapping

---

# height map
높이 맵(Height Map)과 시선 벡터(View Vector)를 이용 (카메라 눈의 방향)

- 두 정보를 조합하여 비스듬한 각도에서 물체를 볼 때 높이가 높은 부분은 더 많이 이동한 것처럼 보이게 함
- 이를 시차(Parallax) 효과라고 함

**링크**
- [Parallax Mapping](https://learnopengl.com/Advanced-Lighting/Parallax-Mapping)

## Bump offset
가장 기본적인 시차 매핑 기법. 높이 맵 정보를 이용해 UV 좌표를 '살짝 밀어내는(Offset)' 방식

**input**
- Coordinate(Vector2) : 오프셋을 적용할 기준 UV좌표. 기본값 - TexCoord[0]
- Height (Scalar) : Height Map을 샘플링 한 값 연결
- Height Ratio (Scalar) : 깊이 강도 조절 
- ReferencePlane (Scalar) : 높이의 기준이 되는 평면을 설정. 기본값 - 0.5

**output**
- UV (Vector2): 계산이 완료된 최종 UV 좌표 

---

$$
newUV = originalUV + (ViewVector_{tangent} \cdot \text{HeightValue} \cdot \text{Scale})
$$

---

- ViewVector_tangent: **탄젠트 공간(Tangent Space)**에서의 시선 벡터
- HeightValue: 높이 맵에서 샘플링한 값
- Scale: 효과의 강도를 조절하는 상수

> 시선이 표면에 비스듬할수록, 높이맵의 값이 클수록 UV를 더 많이 이동시키라는 의미

---

- 장점
  - 계산이 매우 간단하여 성능 비용이 저렴
- 단점
  - 깊이가 얕은 표면에만 효과적
  - 오브젝트 가장자리에서는 효과가 깨짐
  - 자체 차폐(self-occlusion)나 시차에 따른 부분 가림 효과는 없음

---

## Parallax Occlusion Mapping
시선 방향을 따라 표면을 탐색하고 어디서 가상의 표면과 만나는지 찾아내는지 추적해 UV 좌표 얻기

**input**
- Coordinate (V2) : Bump Offset과 동일하게, 기준이 되는 UV 좌표입니다.
- HeightmapTexture (TextureObject) : 높이 맵 텍스처 자체를 입력받음
- HeightmapChannel (V4) : HeightmapTexture에서 높이 정보가 어느 채널에 저장되어 있는지 지정하는 마스크(Mask)
- HeightRatio (S) : Bump Offset과 동일하게, 효과의 전체적인 강도(깊이)를 조절
- MinSteps (S) : 레이마칭을 수행할 최소 반복 횟수를 지정 (예 : 2)
- MaxSteps (S) : 레이마칭을 수행할 최대 반복 횟수를 지정 (예 : 4)
- ReferencePlane (S) : Bump Offset과 동일하게, 높이의 기준이 되는 평면을 설정
- Shadow (V2) : 표면에 자체 그림자(Self-Shadowing) 효과를 주기 위해 사용

**output**
- PixelUVs (V2) : 레이마칭 계산을 통해 최종적으로 찾아낸 픽셀의 UV 좌표
- PixelDepth (S) : 0과 1 사이의 값으로, 레이가 가상의 표면과 충돌한 깊이
  - 이 값을 머티리얼의 Pixel Depth Offset 입력에 연결하면
  - 반투명 오브젝트나 다른 오브젝트와 교차할 때 훨씬 더 정확한 렌더링 결과를 얻을 수 있음 

---

### 레이 마칭 과정

- 스텝 이동량 $$\Delta \mathbf{uv}$$

$$
\Delta \mathbf{uv} = \frac{\mathbf{v}_t.xy}{\mathbf{v}_t.z} \cdot \frac{\text{HeightScale}}{N}
$$

- $$\mathbf{v}_t$$: 시선 벡터를 탄젠트 공간으로 변환한 것
  - 이 벡터의 x,y를 z로 나눠 기울기(경사)를 구함
- N : 샘플링 스텝 수  
  - 높이 스케일을 곱하고, 스텝 수 N으로 나눠서 한 번 이동할 UV 오프셋량을 얻음

> 시선 기울기에 따라 UV를 얼마나 움직여야 하는지 나타냄

---

- 누적 UV 진행 $$ \mathbf{uv}_k $$

$$
\mathbf{uv}_k = \mathbf{uv}_0 + k \cdot \Delta \mathbf{uv}, \quad k = 1,2,\dots,N
$$

---

- $$\mathbf{uv}_0$$ : 원래의 UV 좌표  
- $$\mathbf{uv}_k$$ : k번째 단계에서의 UV 좌표

UV좌표를 스텝마다 이동시키면서 높이맵을 샘플링

---

- 교차 조건 (높이맵 표면과 시선이 만나는 지점 찾기)

$$
h(\mathbf{uv}_k) \leq 1 - \frac{k}{N}
$$

---

- $$h(\mathbf{uv}_k)$$ : 높이 맵 값 (0~1)
- $$1 - \tfrac{k}{N}$$ : 가상의 직선으로 내려가는 기준선 높이

> 이 두 값이 처음 역전되는 순간, 시선이 실제 가상의 표면과 부딪힌 것으로 간주

---

- 보간 : 교차 조건을 만족하는 두 스텝 사이에 충돌 지점을 정확히 찾기 위해 선형 보간을 사용함

$$
\mathbf{uv}_{hit} = \text{lerp}(\mathbf{uv}_{k-1}, \mathbf{uv}_k, \alpha)
$$

---

### 직관적인 설명
- `k-1`번째 스텝에서는 아직 기준선 위에 있음
- `k`번째 스텝에서는 기준선 아래로 내려감  
- 따라서 실제 충돌 지점은 두 UV 좌표 $$\mathbf{uv}_{k-1}$$ 과 $$\mathbf{uv}_k$$ 사이 어딘가에 있음
- alpha 값 (0~1) 은 그 사이에서 정확히 몇 퍼센트 지점인지 나타냄

$$
\mathbf{uv}_{hit} = (1-\alpha)\,\mathbf{uv}_{k-1} + \alpha\,\mathbf{uv}_k
$$

---

### 정확한 수식 (실제 구현 버전)

$$
\alpha = \frac{h(\mathbf{uv}_{k-1}) - \left(1 - \tfrac{k-1}{N}\right)}
{\big(h(\mathbf{uv}_{k-1}) - (1 - \tfrac{k-1}{N})\big) - \big(h(\mathbf{uv}_k) - (1 - \tfrac{k}{N})\big)}
$$

- $$h(\mathbf{uv})$$: 높이맵 값 (0~1)  
- $$1 - \tfrac{k}{N}$$: 해당 스텝의 기준 높이  
- $$\alpha \in [0,1]$$ 범위  
  
---

> 충돌 지점의 UV를 좀 더 정확히 찾아서, 그 UV 좌표로 색/노멀 등을 샘플링

---

$$
\text{newUV} = \mathbf{uv}_{hit}
$$

---

### 정리
POM의 레이마칭 : UV를 조금씩 이동하며 높이맵과 가상 기준선의 높이를 비교하는 과정
- 지오메트리 교차도 없고 빛의 반사도 계산하지 않음 (레이 트레이싱 축소판)

---

- 장점
  - 깊이감이 큰 표면도 사실적으로 표현 가능
  - 자체 차폐(Self-occlusion)나 시차에 따른 부분 가림 효과까지 구현 가능
- 단점
  - 텍스처 샘플링이 많아 성능 비용이 높음
  - 여전히 실루엣 변화는 불가능

**링크**
- [parallax occlusion mapping details](https://dev.epicgames.com/community/learning/tutorials/kyXK/unreal-engine-creation-of-parallax-occlusion-mapping-pom-in-details)

---

## TextureSample vs Texture Object
텍스처 오브젝트는 GPU에 올라가 있는 텍스처 리소스에 대한 참조 (C++로 치면 `Texture*`)

**TextureSample**
핸들을 이용해 UV 좌표를 지정해 값을 뽑아낸 결과
- 출력은 이미 계산된 float3 또는 float4 값
- 다른 곳에서 재샘플 불가능

**Texture Object**
엔진 내부의 텍스처 리소스를 가리키는 핸들(handle)
- 텍스처 자체에 대한 “참조(Reference)”
- 아직 샘플링하지 않은 원본 리소스
- 다른 노드(예: POM 함수, WorldAlignedTexture 등)가 UV 좌표를 바꿔가며 여러 번 샘플할 수 있음