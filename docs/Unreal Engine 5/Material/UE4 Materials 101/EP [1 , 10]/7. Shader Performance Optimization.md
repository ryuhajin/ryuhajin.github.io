---
layout: default
title: "7. Shader Performance Optimization"
parent: "EP [1 , 10]"
nav_order: 5
---

# EP 7 : Shader Performance Optimization
성능 측정의 대표적인 세가지 방법

### 1. Shader Complexity 뷰 모드
UE의 뷰 모드 설정 : 최적화 보기 모드 -> 라이트 복잡도 or 쉐이더 복잡도
- 씬 전체에서 어떤 머티리얼이 GPU에 부담을 주는지 빠르게 파악
- 녹색: 연산량 적음 (간단한 머티리얼)
- 빨강 ~ 흰색: 연산량 많음 (비싼 머티리얼)

### 2. Shader Compile Stats
특정 머티리얼이 실제로 몇 개의 연산을 수행하는지, 비용이 어디서 오는지 정량적으로 확인
- Shader Graph → HLSL code → Assembly instruction → Graphics Driver
- 명령어 마다 소요 시간이 다름. 따라서 명령어 수로는 절대적인 측정 불가

### 3. 타겟 플랫폼에서 측정 테스트

---

## stats

![](../../../../../images/UE5MaterialStats.png)

| 항목 | 의미 |적정 한도 |
| --- | --- | --- |
| **Base pass shader instructions**| 픽셀 셰이더 명령어 수    | 일반적으로 200~300 이하가 무난. 500 이상이면 최적화 고려 |
| **Stats: Resources Used**| 셰이더에서 사용하는 리소스(상수 버퍼, 텍스처 등) 개수 | 한도는 보통 64. 40 이상이면 주의 |
| **Resource Limit**       | 플랫폼이 지원하는 최대 리소스 개수     | PC/콘솔 보통 64  |
| **Samplers Used**| 사용된 고유 샘플러 개수   | 데스크톱 16~32, 모바일 8. 모바일에서 6 이상이면 부담 |
| **Sampler Limit**| 플랫폼 최대 샘플러 수    | 데스크톱 보통 16 또는 32, 모바일 8      |

| 항목 | 의미 |적정 한도 |
| --- | --- | --- |
| **Base pass vertex shader instructions** | 버텍스 셰이더 명령어 수   | 150~200 이하 보통. 400 이상이면 부담   |
| **Stats: Resources Used (VS)**   | VS에서 사용하는 리소스 개수| 한도는 64. 보통 10 미만이면 안전 |
| **Samplers Used (VS)**   | VS에서 사용하는 샘플러 개수| 대부분 0. 2~3 넘어가면 드문 케이스|

| 항목 | 의미 |적정 한도 |
| --- | --- | --- |
| **Texture samplers**     | 현재 사용 샘플러 수 / 플랫폼 한도    | 데스크톱 16~32, 모바일 8. 모바일에서 6 이상 주의     |
| **Texture Lookups (VS/PS)**      | 텍스처 조회 횟수       | PS 쪽에서 10 이하를 가급적 유지. VS 쪽은 3~4 정도 무난|
| **User interpolators**   | VS→PS로 전달되는 보간 변수 개수    | 한도는 보통 8~10 벡터. 6 이상이면 주의     |
| **Shader Count** | 머티리얼이 생성하는 셰이더 변형 수     | 10 이하 무난. 20 이상이면 컴파일·메모리 부담 |
| **Preshaders**   | 런타임 전 계산되는 연산 수 | 소수 개는 무시 가능. 수십 개 이상이면 로딩 지연 우려  |

### Sampler Used vs Texture Lookups
1. **Sampler Used** → “GPU에 바인딩된 고유한 (Texture + Sampler 상태) 조합 개수”
- 즉, **버퍼에 올라간 텍스처 리소스 슬롯** 개수
- 동일 텍스처라도 **필터링/랩 모드가 다르면 다른 Sampler로 잡힘**
2. **Texture Lookups** → 셰이더 코드 안에서 **Texture.Sample() 같은 샘플링 호출이 일어난 횟수**

---

# Optimization Shader
GPU는 대규모 병렬 연산에 특화된 장치. 쉐이더 최적화의 본질은 이 GPU 코어들이

```
1. 불필요한 연산을 하지 않고
2. 비싼(느린) 연산을 피하며
3. 최대한 한 번에 많은 데이터를 처리하고
4. 데이터 접근(메모리 I/O)을 최소화하도록
```

코드를 개선하는 것

---

## 1. 사용하지 않는 코드 제거
쉐이더 코드에 변수나 연산이 포함되어 있으면, 설령 최종 결과에 영향을 주지 않더라도 컴파일러가 이를 완전히 제거하지 못하는 경우가 있다

- 레지스터 낭비 (Register Pressure)
  - GPU 코어는 연산에 사용할 데이터를 '레지스터'라는 매우 빠른 임시 저장 공간에 보관
  - 사용하지 않는 변수나 중간 계산 결과가 레지스터를 차지하면, 정작 필요한 데이터가 레지스터에 올라오지 못하고 상대적으로 느린 캐시나 메모리를 사용하게 되어 성능 저하를 유발

---

## 2. 수학 공식 재구성
GPU에서 모든 수학 연산의 비용(수행 시간)은 동일하지 않음

```
- 저비용 (Cheap): 덧셈, 뺄셈, 곱셈, dot

- 중간 비용 (Moderate): 나눗셈

- 고비용 (Expensive): sqrt (제곱근), pow, sin, cos, log 등 초월 함수
```

고비용 연산을 간단한 연산으로 대체하면 성능 향상 가능

### 예시

- 최적화 전

```c++
// 나눗셈과 pow는 상대적으로 고비용 연산
float specular = pow(max(0.0, dot(N, L)), 128.0) / 8.0;

float result = pow(x, 3.0);
```

- 최적화 후

```c++
// 나눗셈(/ 8.0)을 곱셈(* 0.125)으로 변경
float specular = pow(max(0.0, dot(N, L)), 128.0) * 0.125;

float result = x * x * x;
```

---

## 3. 파이프라이닝 / 벡터화
GPU는 SIMD (Single Instruction, Multiple Data) 아키텍처를 기반으로 설계
> 하나의 명령으로 여러 데이터를 동시에 처리한다는 의미

```
float4 + float4 = 내부적으로는 4개의 float 덧셈(x, y, z, w 각각)이 거의 동시에 처리
```

따라서 **여러 스칼라 연산을 float4 같은 벡터 연산 하나로 묶으면, 더 적은 명령으로 같은 작업을 수행할 수 있어 효율이 극대화**

### 예시
- 최적화 전

```c++
// 비효율적인 예: 4개의 float에 각각 연산 적용
float r = BaseColor.r * LightColor.r;
float g = BaseColor.g * LightColor.g;
float b = BaseColor.b * LightColor.b;
float a = BaseColor.a * Opacity;

// 최종 색상을 float4로 조합
float4 finalColor = float4(r, g, b, a);
```

- 최적화 후

```c++
// 효율적인 예: float4로 묶어 한 번에 연산
float4 baseColor = float4(baseR, baseG, baseB, baseA);
float4 finalColor = baseColor * float4(lightIntensity, lightIntensity, lightIntensity, 1.0);
```

---

## 4. Texture Channel Packing (텍스처 채널 패킹)
텍스처에서 색상 값을 읽어오는 것(Texture Sampling)은 셰이더 연산 중 비교적 비싼 작업에 속함

- GPU가 메인 메모리(VRAM)에 저장된 텍스처 데이터에 접근해야 하기 때문
- 이 **메모리 접근 시간을 메모리 대역폭(Memory Bandwidth)과 지연 시간(Latency) 문제라고 함**

채널 패킹은 이 **흑백 맵들을 하나의 텍스처에 포장하는 기술**
1. R 채널: Roughness 맵
2. G 채널: Metallic 맵
3. B 채널: Ambient Occlusion 맵
4. A 채널: (필요하다면) 다른 맵 (예: Emissive Mask)

---

### 예시

- 최적화 전

```c++
// 3개의 텍스처를 각각 선언
Texture2D RoughnessMap : register(t0);
Texture2D MetallicMap  : register(t1);
Texture2D AOMap        : register(t2);
SamplerState MySampler : register(s0);

// ... 픽셀 셰이더 내부 ...
// 3번의 메모리 접근 발생
float roughness = RoughnessMap.Sample(MySampler, IN.UV).r;
float metallic  = MetallicMap.Sample(MySampler, IN.UV).r;
float ao        = AOMap.Sample(MySampler, IN.UV).r;
```

- 최적화 후

```c++
// 채널 패킹된 텍스처 하나만 선언 (보통 RMA 또는 ORM 맵이라 부름)
Texture2D PackedMap : register(t0);
SamplerState MySampler : register(s0);

// ... 픽셀 셰이더 내부 ...
// 단 1번의 메모리 접근으로 모든 데이터를 가져옴
float4 packedData = PackedMap.Sample(MySampler, IN.UV);

// 가져온 데이터를 각 변수에 다시 풀어줌 (swizzling)
// 이 연산은 레지스터 내에서 처리되므로 매우 저렴
float roughness = packedData.r; // R 채널 = Roughness
float metallic  = packedData.g; // G 채널 = Metallic
float ao        = packedData.b; // B 채널 = Ambient Occlusion
```

**링크**
- [게임 아티스트를 위한 GPU 성능](http://www.fragmentbuffer.com/gpu-performance-for-game-artists/)