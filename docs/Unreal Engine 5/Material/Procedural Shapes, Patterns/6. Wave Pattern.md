---
layout: default
title: "6. Wave Pattern"
parent: "Procedural Shapes, Patterns"
nav_order: 6
---

# 6. Wave Pattern
웨이브 패턴 만들어보기

- [언리얼 엔진 머티리얼의 사인 및 코사인](https://youtu.be/C_TY65zGdm0?si=lE6JUN9hxoANO-RX)\
- [Wave Pattern Generator in HLSL](https://youtu.be/FDj1q3j8ouE?si=YNbl3JEm1I8Zqo_1)

---

# sin, cos
## 직각 삼각형에서의 비율
어떤 각도 **θ(세타)**가 있을 때

```md
sin(θ) = (높이 / 빗변)

cos(θ) = (밑변 / 빗변)
```

즉, **각도 θ를 만들었을 때 반대편 길이 비율, 옆변 길이 비율**

> 이 정의는 직각삼각형(0~90도) 범위에서만 직관적
> - 그래픽스에서는 보통 아래의 일반적인 정의를 사용함

---

## 단위원에서의 좌표
반지름이 1인 원 (단위원) 위의 점을 생각하면

- **각도 θ만큼 회전한 점의 좌표가 (cos(θ), sin(θ))**

```md
cos(θ) = 그 점의 x좌표

sin(θ) = 그 점의 y좌표
```

> 중요한 성질 : sin/cos의 결과는 항상 -1 ~ +1 범위 (왜? 단위원이니까!)

### 머티리얼에서 sin은 이렇게 쓰인다
**입력값 x를 각도 (라디안)라고 생각**하고, 그에 해당하는 **y 좌표(sin)를 뱉어라**

- 즉 sin(x)에서 x는 ‘각도’로 해석되는 숫자이지, **UV가 자동으로 각도가 되는 건 아님**

---

# 웨이브를 선으로 그린다의 개념
1. 화면 (또는 텍스처) 좌표를 UV (0~1) 로 본다
2. **x축 (u = UV.x) 에 대해 y값 (= waveY) 을 함수로 만든다!**
3. 각 픽셀의 현재 y (v = UV.y) 가 그 **waveY에 얼마나 가까운지로 선을 만든다**

---

## 기본 형태

```c++
u = UV.x

v = UV.y

waveY = CenterY + Amplitude * Waveform(u * Frequency + t * Speed + Phase)
```

- **Waveform** : 사인 / 톱니 / 불규칙 등 “파형 함수”

---

## Waveform이 sine일 때 왜 저런 매개변수들이 필요해?
사인에 넣을 **입력값(=각도 역할)을 원하는 방식으로 만들기 위한 조립 공식**

### u * Frequency = “가로로 몇 번 반복할래?”
1. u는 0 ~ 1
2. Frequency를 2로 주면
    - u가 0 → 1로 갈 때 2번 반복하게 만들고 싶다는 뜻

> 여기서 핵심은 이 값이 각도가 아니라 cycle(주기 횟수) 라는 점

```md
- u = 0.25, Frequency = 2

- u * Frequency = 0.5

이 0.5는 각도 0.5라디안이 아니라, 0.5 cycle = 반 바퀴(반 주기) 진행했다는 뜻
```

---

### t * Speed =  “시간에 따라 얼마나 흐르게 할래?”
Speed를 1로 두면 1초에 1 cycle(한 바퀴) 진행

> t * Speed는 시간에 따른 추가 진행량 (몇 바퀴 더 돌았나)

---

### Phase = “시작점을 얼마나 밀어둘래?”
Phase는 파형의 **시작 위치를 옮기는** 값

- 예를 들어 Phase = 0.25 cycle이면
- 파형이 시작부터 **1/4 주기 만큼 이동한 상태로 시작**

---

### * 2π = 라디안 각도로 만들기
사인(sin)은 입력을 ‘라디안 각도’로 해석하기 때문에

- **1 cycle(한 바퀴) = 360도 = 2π 라디안**
- 그래서 cycle → 라디안 변환이 필요

```md
angle = cycle × 2π
```

---

## 정리
1. **`u*Frequency + t*Speed + Phase`**
    - 현재 몇 바퀴(cycle) 진행했는지를 만드는 조립식 레일
2. **`* 2π`**
    - 사인이 이해하는 각도(라디안)로 변환
3. **`sin(...)` = waveform**
    - 그 각도에서 단위원의 y좌표(= -1~1 파형 값)를 얻음


### 따라서 2π가 꼭 필요한 건 아니다!
**Saw/Frac 파형**은 오히려 2π를 안 곱하는 게 자연스럽다

1. **sin(x)의 입력 단위: 라디안(각도)**
    - 한 주기(1 cycle)가 끝나려면 입력이 2π만큼 변해야 함
    - sin(0) → sin(2π)가 한 바퀴
    - **sin의 한 cycle = 2π**
2. **frac(x)의 입력 단위: 1을 기준으로 반복되는 수**
    - frac(x)는 x의 소수 부분만 남김
    - frac(0.2) = 0.2
    - frac(1.2) = 0.2
    - 입력이 1 증가할 때마다 결과가 다시 0
    - **즉 frac() 자체가 주기 = 1인 반복**

---

## 선을 만드는 마스크
SDF로 선 그리기

```md
u = UV.x
v = UV.y

waveY = CenterY + Amplitude * Waveform(u, t, params...)
```

1. **파형과의 거리**
    - `dist = abs(v - waveY)`
2. **두께(thickness)**
    - 안쪽은 1, 바깥은 0이 되게
3. **하드한 선**
    - `line = 1 - step(thickness, dist)`
4. **부드러운 선**
    - `line = 1 - smoothstep(thickness, thickness + softness, dist)`

---

# PlotFunctionOnGraph 노드
언리얼 엔진이 기본으로 제공하는 그래프 함수

## 개념
1. x축 (가로) 에 대해 어떤 값 f(x)를 계산
2. 그 결과를 y축 (세로) 에 곡선으로 그림
3. 함수의 모양을 눈으로 디버깅 할 수 있음

즉, **머티리얼의 값이 지금 어떤 곡선 형태로 변화하는지 실시간으로 그래프화해주는 도구**

---

## PlotFunctionOnGraph 입력
### X Range Y Range (Vector4)
그래프 표시 범위를 정함

 - X축: R~G (최소~최대)
 - Y축: B~A (최소~최대)

---

### Gradient Height (Scalar)
함수값 프리뷰 (면으로 깔리는 영역)의 높이/비율 같은 것을 조절하는 옵션

---

### Show Grid? (Bool)
그래프의 격자 표시 여부

---

### UVs (Vector2)
그래프를 그릴 좌표 (기본은 TexCoord)

---

### Thickness (Scalar)
그래프 선 두께

---

### Color (Vector3)
그래프 선 색

---

### f(x) (Scalar 입력)
그리고 싶은 함수 값 자체

---

### 출력
- 그래프 + 프리뷰 버전
- x 프리뷰만 같은 디버그 출력

---

# Master wave function 만들기
나만의 웨이브 함수 제작하기

