---
layout: default
title: "5. Rectangle Signed Distance Field"
parent: "Procedural Shapes, Patterns"
nav_order: 5
---

# 5. Rectangle Signed Distance Field
SDF로 사각형(Rectangle) 그리기

---

## 핵심 아이디어
사각형은 **중심을 기준으로 가로/세로 반길이(extent)** 안에 들어오는 점들의 집합

- 원 SDF가 “중심까지의 거리”를 썼다면,  
- 사각형 SDF는 **각 축(x, y) 방향 거리**를 독립적으로 다룬다

---

## Rectangle SDF 기본 개념

### 기준 정의
- 중심: $$c$$
- 반 크기(half size): $$b = (b_x, b_y)$$  
  - 전체 너비 = $$2b_x$$  
  - 전체 높이 = $$2b_y$$

---

### 수식

$$
q = |p - c| - b
$$

---

$$
d = \lVert \max(q, 0) \rVert + \min(\max(q_x, q_y), 0)
$$

---

- `|p-c|` : 중심 기준 절대 좌표
- $$q$$ : 각 축에서 사각형을 얼마나 벗어났는지

---

## Rectangle SDF function

```c++
float sdfRect(vec2 p, vec2 center, vec2 halfSize) {
    vec2 q = abs(p - center) - halfSize;
    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
}
```

- $$\max(q, 0)$$ : 바깥으로 벗어난 거리만 남김
- $$\min(\max(q_x, q_y), 0)$$ : 내부 영역 음수 거리 처리

---

## Aspect Ratio (가로/세로 비율)
사각형은 **원과 달리 가로/세로 비율이 중요**

- 이미 사각형의 **가로 길이(width)**, **세로 길이(height)** 를 알고 있다면  이를 정규화된 비율로 변환해 사용하는 것이 편리

---

### halfSize 직접 사용

```c++
vec2 halfSize = vec2(width * 0.5, height * 0.5); // 전체 사이즈를 절반크기로 변환
float d = sdfRect(p, center, halfSize);
```

---

### 가로/세로 길이로 비율 계산

$$
\text{aspectRatio} = \left( \frac{W}{H},\ 1 \right)
$$

---

또는 반대로

$$
\text{aspectRatio} = \left( 1,\ \frac{H}{W} \right)
$$

> 둘 중 어떤 방식을 쓰든 상대적인 비율만 유지되면 동일한 형태

---

## 정규화된 Aspect Ratio (권장)
한 축을 기준값 1로 두고 비율만 표현하면 이해하기 쉬움

- 가로 기준 정규화 (가로가 더 긴 경우)

$$
a_x = \frac{W}{\max(W, H)}
$$

---

- 세로 기준 정규화 (세로가 더 긴 경우)

$$
a_y = \frac{H}{\max(W, H)}
$$

---

```c++
vec2 aspectRatioFromSize(float width, float height) {
    float m = max(width, height);
    return vec2(width, height) / m;
}
```

- 항상 `(0~1)` 범위
- 비율 유지 + 수치 안정적
- SDF에서 가장 많이 쓰이는 방식

---

### Aspect Ratio → halfSize 변환
- 기준 크기 : s
- 종횡비 : a = (ax, ay)

```c++
vec2 halfSizeFromAspect(
    float baseSize,
    float width,
    float height
) {
    float m = max(width, height);
    vec2 aspect = vec2(width, height) / m;
    return baseSize * aspect;
}

// 사각형 sdf에 적용

float sdfRectWithSize(
    vec2 p,
    vec2 center,
    float baseSize,
    float width,
    float height
) {
    vec2 halfSize = halfSizeFromAspect(baseSize, width, height);
    return sdfRect(p, center, halfSize);
}
```

---

## Rectangle Fill

### Rectangle Hard Fill

```c++
float rectFill(float d) {
    return step(0.0, -d);
}
```

---

### Rectangle Soft Fill (Anti-aliasing)

```c++
float rectSmoothFill(float d, float w) {
    return 1.0 - smoothstep(-w, w, d);
}
```

---

## Rectangle Stroke

### Rectangle Hard Stroke

```c++
float rectStroke(float d, float thickness) {
    return step(abs(d), thickness * 0.5);
}
```

---

### Rectangle Soft Stroke

```c++
float rectSmoothStroke(float d, float thickness, float w) {
    float halfT = thickness * 0.5;
    return 1.0 - smoothstep(halfT - w, halfT + w, abs(d));
}
```

---

## Rounded Rectangle (모서리가 둥근 사각형)
- 사각형에서 **코너 반지름 r만큼 깎는다**
- 내부는 그대로, 코너만 원처럼 처리

---

### 개념 정리
1. 중앙 영역  
  - $$q < 0$$ → 사각형 내부 → 음수 거리
2. 코너 영역  
  - $$q > 0$$ → 원 SDF와 동일하게 처리
3. 경계  
  - $$d = 0$$ → 둥근 사각형의 외곽선

---

## 수식
- p : 평가할 점 (픽셀)
- c : 사각형 중심
- b : 사각형 크기의 반 (halfsize)
- r : 코너 반지름
    - 각 모서리는 반지름 r인 **사분원(quarter circle)** 으로 처리됨

$$
q = ∣p−c∣ − (b − r)
$$

- `|p-c|` : 중심 기준 절대 좌표 **(abs를 함으로써 4분면은 신경쓰지 않는다)**
- b - r : 코너를 제외한 “중앙 직사각형 영역”

> 먼저 b - r로 코너를 제외한 중앙 직사각형 영역에 대해 q를 계산한 뒤
> - 그 q의 양수 부분의 길이에서 r을 빼는 방식으로 원 호를 만든다

---

- 최종 거리 계산

$$
d = ∥max(q,0)∥ − r
$$

---

```c++
float sdfRoundedRect(
    vec2 p,        // 평가할 점
    vec2 c,        // 사각형 중심
    vec2 b,        // 반 크기 (half size)
    float r        // 코너 반지름
) {

    // 안전장치: 코너 반지름이 halfSize를 넘지 않도록
    r = min(r, min(b.x, b.y));

    vec2 q = abs(p - c) - (b - r);
    return length(max(q, 0.0)) - r;
}
```

---

## Rounded Rectangle: vec4(코너별 radius) + 사분면(Quadrant) 선택
점 p를 중심 c 기준 로컬 좌표로 옮긴 뒤

$$
\ell = p - c
$$

- $$x \ge 0$$ 이면 오른쪽 코너(TR/BR)
- $$y \ge 0$$ 이면 위쪽 코너(TL/TR)

---

즉,
- **TL (Top/Left)**: x < 0, y >= 0
- **TR**: x >= 0, y >= 0
- **BR (Bottom / Right)**: x >= 0, y < 0
- **BL**: x < 0, y < 0

---

```c++
// vec4 r: (TL, TR, BR, BL) 순서
float selectCornerRadius(vec2 local, vec4 r) {
    // local = p - c (center 기준 좌표)
    // sx: 0이면 left, 1이면 right
    // sy: 0이면 bottom, 1이면 top   (y-up 기준)
    float sx = step(0.0, local.x);
    float sy = step(0.0, local.y);

    // top row: TL -> TR
    float rTop = mix(r.x, r.y, sx);

    // bottom row: BL -> BR  (주의: (BL, BR) 순으로 mix)
    float rBot = mix(r.w, r.z, sx);

    // bottom -> top
    return mix(rBot, rTop, sy);
}
```

---

# rectangle pattern
## rectangle tiling
반복 사각형 패턴 그리기

```c++
vec4 tiledRects(
    vec2 uv, // 2d 좌표
    float cellSize, // 타일 한 칸 크기
    vec2 halfSize // 각 셀안에 그릴 사각형 절반 크기
) {
    // 좌표를 셀 단위로 접기
    vec2 local = fract(uv / cellSize) * cellSize - cellSize * 0.5;
    
    // 셀 내부 좌표로 사각형 sdf 계산
    float d = sdfRect(local, vec2(0.0), halfSize);

    // sdf -> mask 변환
    //    - d < 0 (도형 내부)면 1에 가깝게, d > 0 (외부)면 0에 가깝게
    //    - smoothstep 범위를 [-w, w]로 쓰면 경계가 부드러워짐(AA)
    //    - 여기서는 예시로 w=1.0을 사용 (픽셀 스케일에 맞게 조절하기)
    float mask = 1.0 - smoothstep(-1.0, 1.0, d);
    return vec4(vec3(mask), 1.0);
}
```

---

## rectangle scale animation
사각형 크기 시간에 따라 변화시키기

```c++
float animatedRect(
    vec2 p, // 점
    vec2 center, // 사각형 중심
    vec2 baseHalfSize, // 사각형 크기 절반
    float amplitude,
    float speed,
    float time
) {
    //  sin으로 크기 변화량 생성
    //    - sin(...) 결과는 [-1, 1]
    //    - amplitude를 곱하면 변화량 범위를 조절
    float s = amplitude * sin(speed * time);

    // halfSize를 애니메이션
    //    - vec2에 스칼라를 더하면 (s, s) 형태로 양 축에 동일 적용된다고 가정 (GLSL 스타일)
    //    - 가로/세로를 따로 애니메이션하고 싶으면 amplitude를 vec2로 받는 방식이 더 명확
    vec2 halfSize = baseHalfSize + s;

    // 현재 점 p에서 사각형 SDF 계산
    float d = sdfRect(p, center, halfSize);

    // SDF -> 부드러운 채움 마스크
    return rectSmoothFill(d, 1.0);
}
```

---

## rounded Radius animation
Rounded Rectangle의 코너 반지름(radius)을 시간에 따라 변화시키는 애니메이션

```c++
float animatedRoundedRect(
    vec2 p,
    vec2 center,
    vec2 halfSize,
    float baseRadius, // 기본 코너 반지름
    float amplitude,
    float speed, // speed: sin 파형 속도(라디안/초)
    float time // 현재 시간 (초)
) {
    // sin으로 radius 변화량 생성
    float dr = amplitude * sin(speed * time);

    // 반지름 애니메이션
    float r = baseRadius + dr;

    // 안전장치(권장):
    //    radius는 반드시 min(halfSize.x, halfSize.y) 이하가 되어야 형태가 깨지지 않음
    r = min(r, min(halfSize.x, halfSize.y));

    // Rounded Rect SDF 계산
    float d = sdfRoundedRect(p, center, halfSize, r);

    // SDF -> 부드러운 채움 마스크
    return rectSmoothFill(d, 1.0);
}
```

---

## 정리
- Rectangle SDF는 축별 거리 계산
- Aspect Ratio = halfSize로 자연스럽게 처리
- Rounded Rectangle = 사각형 + 원 SDF 결합
- Fill / Stroke / Pattern / Animation 모두 Circle SDF와 동일한 사고방식
    - 좌표를 바꾸거나 파라미터를 시간에 넣으면 애니메이션

> Circle SDF를 이해했다면 Rectangle SDF는 자연스러운 확장이다