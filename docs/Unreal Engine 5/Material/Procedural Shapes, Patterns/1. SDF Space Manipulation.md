---
layout: default
title: "1. SDF Space Manipulation"
parent: "Procedural Shapes, Patterns"
nav_order: 1
---

# 1. SDF Space Manipulation
SDF 공간 조작

---

## 핵심 개념
- SDF로 도형을 바꾸는 대신, **SDF에 넣는 좌표(공간)를 바꾼다**
- **도형을 생성하기 전 좌표를 조작**하면 다양한 패턴을 만들 수 있다
  - 반복
  - 대칭
  - 왜곡 

> 도형을 변형하는 대신 입력 좌표를 역변환
> - 도형을 움직인다가 아니라, 샘플링 좌표를 반대로 움직인다로 이해하기

### SDF에서 변환이 왜 “역방향”인가?

```md
원래 도형의 SDF가 `d(p)`라고 할 때,

- 도형을 `T`로 변형한 결과를 알고 싶으면
- 새 위치 p가 원래 어디였는지 (= `T^{-1}(p)`)를 찾아 그 좌표로 원본 SDF를 평가
- 그래서 대부분의 변환이 역으로 들어감
```

---

## 기본 변환 : rotate / translate / scale 관점
직접 도형을 움직이는게 아니라, **샘플링 좌표를 역으로 움직여서 도형이 움직인 것처럼 보이게 만든다**

### 1. translate(p, offset) = p - offset인 이유
도형을 + offset만큼 이동시키려면, 샘플 좌표를 - offset만큼 이동시키는 것과 동치

---

### 2. scale(p, s) = p / s인 이유
위와 동일한 관점 (공간을 반대로 변형)

- 좌표를 p / s로 넣으면 도형 크기는 맞지만, 거리값 스케일이 틀어진다
- SDF는 거리를 반환해야 하므로 거리 보정이 필요

```c++
float opScale(float2 p, float s, float size) {
    // 1. 공간 늘리기 (좌표를 나눔)
    float2 localP = p / s; 
    
    // 2. 늘어난 공간에서 거리 측정
    float d = circle(localP, size); 
    
    // 3. [중요] 실제 월드 거리로 보정 (Distance Correction)
    // 이 과정이 없으면 렌더링 시 그림자가 깨지거나 빛 계산이 틀림
    return d * s; 
}
```

---

### 3. rotate
회전도 동일: 도형을 +a만큼 회전시킨 것처럼 보이게 하려면 입력 좌표를 -a만큼 회전

```c++
float2 rot(float2 p, float aRadians)
{
    float s = sin(aRadians), c = cos(aRadians);
    return float2(c*p.x - s*p.y,
                  s*p.x + c*p.y);
}

// 예) 도형을 +a만큼 회전한 것처럼 보이게:
p = rot(p, -a);
```

---

# Space Repetition (공간 반복)

## Mirror / Fold (대칭)
**공간(좌표)를 접어서 같은 SDF 평가로 여러 위치가 같은 값을 공유하게 만들기**

- 한 번의 SDF 계산으로 좌/우 (또는 상/하) 대칭 형태를 얻는다

---

## 핵심 아이디어
공간을 축에 대해 접기!

> y축 기준 대칭의 핵심 : x를 절댓값으로 바꾸는 것
> - 절댓값이 되면 (-1,1)이 (1,1)과 같은 좌표로 취급됨
- 따라서 SDF를 평가했을 때 동일한 결과 (대칭) 가 나온다

---

## 과정
### 축 기준별 대칭
1. **y축 기준 (세로 축, x = 0) / 좌우**
    - x 성분만 접기 = `x = abs(x)`
2. **x축 기준 (가로 축, y = 0) / 상하**
    - y 성분만 접기 = `y = abs(y)`
3. **x축 + y축 동시**
    - 원점 기준 4분면 반복 = `p = abs(p)`
    - 4개의 4분면이 (+,+) 사분면을 복제한 형태

```c++
// y축 기준 미러(x=0): x를 절댓값으로 접는다
void mirrorY(inout float2 p) {
    p.x = abs(p.x);
}

// x축 기준 미러(y=0): y를 절댓값으로 접는다
void mirrorX(inout float2 p) {
    p.y = abs(p.y);
}

// x축 + y축 동시 미러: 4분면이 모두 (+,+) 사분면으로 접힌다
void mirrorXY(inout float2 p) {
    p = abs(p);
}
```

---

## 임의 각도의 대칭 축 만들기
공간을 회전시켜 대칭 축을 확장할 수 있다

1. 먼저 공간을 회전시킴
2. 대칭을 적용
3. 적용 후 다시 원래 회전 상태로 되돌림

> 이 과정을 통해 어떤 각도로든 대칭을 적용할 수 있다

### 임의 각도의 축 (원점을 지나는 축)
**원점을 지나는 임의 축은 회전만으로 축을 y축(또는 x축)과 정렬**할 수 있음

---

```c++
float2 rotate(float2 p, float rotationTurns) {
    const float PI = 3.14159;
    float angle = rotationTurns * PI * 2 * -1;
    float s, c;
    sincos(angle, s, c);
    return float2(c * p.x + s * p.y, c * p.y - s * p.x);
}

float rotation = _Time.y * 0.25; // 회전할 값

position = rotate(position, rotation); // 공간 회전
mirror(position); // 대칭 (접기)
position = rotate(position, -rotation); // 회전된 공간 다시 되돌림
```

---

### 원점을 지나지 않는 임의 축 (평행 이동 회전)
**원점을 지나지 않는 축(오프셋 축)은, 회전만으로는 정렬 불가**

- 회전이 기본적으로 **원점(0,0)을 중심으로 일어나기 때문**
- 따라서 **축을 원점 위로 옮긴 뒤 (평행 이동) 대칭 후 공간을 되돌린다**

> 예를 들어 축이 x=2 (원점을 안 지나는 세로선)인 경우,
> - 축의 왼쪽/오른쪽은 x의 부호가 아니라 (x-2)의 부호로 결정
> - 즉, x=2를 기준으로 접으려면 먼저 좌표를 x’=x-2로 바꿔야 함

---

```c++
float2 translate(float2 p, float2 offset) {
    // 샘플 좌표를 -offset 이동시키면, 도형이 +offset 이동한 것처럼 보인다
    return p - offset;
}

// 평행 이동 (p - axisPoint) = 즉 축이 원점을 지나도록 만든다
position = translate(p, axisPoint);

p = rotate(p, axisTurns); // 축이 원점을 지나니 회전 가능

mirrorY(p); // 대칭 (접기) (abs(p.x))

p = rotate(p, -axisTurns); // 회전 되돌림!

// 평행 이동 되돌림! 이로써 원래 좌표계로 복귀됨
p = translate(p, -axisPoint);
```

---

## Cell Repetition (격자, 그리드 반복)
SDF를 한 번만 정의해도, **공간 좌표를 주기적으로 접어 같은 도형이 격자(cell)마다 반복되게 만들기**

---

## 핵심 아이디어
좌표를 셀 내부 로컬 좌표로 접어서, 어느 셀에 있든 **같은 상대 위치면 같은 SDF 입력**이 되게 만든다

### 셀 내부 좌표로 바꿔서 SDF 평가하기
목표는 **어느 셀에 있든 같은 상대 위치면 같은 SDF 입력이 되게 만드는 것**

- 1D 에서 셀 크기 (= 주기)가 P일 때, 모든 좌표는 다음처럼 쓸 수 있다

```md
x = k * P + r
```

- **k** : **몇 번째 셀**인지(정수 **인덱스**)
- **r** : **셀 내부에서의 상대 위치** (나머지, `[0, P)` 범위)

```md
SDF를 x가 아니라 r로 평가하면

x = 0.2, x = 3.2는 모두 r = 0.2!

따라서 두 위치에서 SDF가 동일하게 평가되어 패턴이 반복됨
```

> 즉, 도형을 복제하는 게 아니라 공간 좌표를 접어서 같은 입력을 만들기

---

### modulo 음수 보정하기
1. 셀 내부 좌표 r은 항상 `[0, P)`에 있어야 함
2. 셰이더의 fmod(`%`)는 수학적 modulo가 아니라 **remainder(나머지)**에 가까움
3. 즉 **음수 입력에서 결과가 음수가 될 수 있음**

```md
예 : P = 3, x = -0.2일 때 우리가 **원하는 셀 내부 좌표는 r = 2.8**

**fmod(-0.2, 3)는 보통 -0.2**
```

- 이렇게 되면 원점 왼쪽/아래 영역에서 반복이 깨지거나, 셀 기반 패턴(짝/홀 셀 등) 계산이 망가짐

> 따라서 결과를 항상 `[0, P)`로 강제하는 수학적 modulo를 사용

```c++
// 수학적 modulo: 결과를 항상 [0, m)로 만든다
float mod1(float x, float m) {
    return fmod(fmod(x, m) + m, m);
}

float2 mod2(float2 x, float2 m) {
    return fmod(fmod(x, m) + m, m);
}
```

---

## 과정
### 1. 셀 인덱스 계산
셀 인덱스는 “몇 번째 셀인지”를 나타내며, **mod로 접기 전에 계산해야 의미가 있음**

```c++
// period: 셀 크기(주기)
// position: 월드 좌표(또는 샘플 좌표)
float2 cellIndex = floor(position / period); // (접기 전) 어떤 셀에 있는지
```

---

### 2. 셀 내부 좌표로 접기
position을 셀 내부 로컬 좌표로 변환하기

- 어떤 셀에 있든, 같은 상대 위치는 같은 좌표로 매핑 됨

```c++
position = mod2(position, period); // 결과는 항상 [0, period)
```

---

### 3. 셀 경계 아티팩트 (연속성 깨짐)
단순 셀 반복은 셀 경계에서 **좌표가 끝 → 처음으로 점프함**

- 예: 주기가 3일때
  - x = 2.999 → localX = **2.999**
  - x = 3.001 → localX = **0.001 (갑자기 점프)**

---

### 4. 매 2번째 셀 미러로 경계 점프 완화
점프를 줄이기 위해 매 **2번째 셀을 뒤집어 경계 양쪽이 둘 다 경계 근처를 참조**

- 항상 해결되는 건 아니지만, 강의에서 제시하는 대표적 완화책

```c++
// cellIndex의 짝/홀에 따라 0/1 스위치 생성
float2 flip = abs(fmod(cellIndex, 2)); // 짝수=0, 홀수=1

// flip=0: 그대로
// flip=1: period - position 으로 뒤집기
position = lerp(position, period - position, flip);
```

---

## Cell 정리
Cell (격자 반복) - 최종 코드

- 월드 좌표 position을 "셀 내부 로컬 좌표"로 접어서 SDF에 넣는다
  - (같은 로컬 좌표 -> 같은 SDF 입력 -> 모든 셀에 동일 패턴 반복)


```c++
// 수학적 modulo (true modulo)
// - fmod는 음수에서 결과가 음수가 될 수 있으므로
//   항상 [0, m) 범위로 들어오게 보정
float  mod1(float  x, float  m) { return fmod(fmod(x, m) + m, m); }
float2 mod2(float2 x, float2 m) { return fmod(fmod(x, m) + m, m); }

// 셀 반복(접기)
// 1) cellIndex는 "접기 전에" 계산해야 의미가 있음
//    (접고 나면 position이 항상 [0,period)라서 인덱스가 거의 0이 됨)
// 2) position은 셀 내부 로컬 좌표로 변환됨
float2 cells(inout float2 position, float2 period)
{
    float2 cellIndex = floor(position / period); // 어떤 셀에 있는지(정수 격자 인덱스)
    position = mod2(position, period);           // 셀 내부 로컬 좌표 [0,period)
    return cellIndex;
}

// 매 2번째 셀 미러 (경계 점프 완화용 옵션)
// - 단순 modulo 반복은 셀 경계에서 "끝 -> 처음"으로 입력이 점프해 연속성이 깨질 수 있음
// - 홀수 셀은 로컬 좌표를 period - position 으로 뒤집어
//   경계 양쪽이 모두 경계 근처 값을 참조하게 만들어 점프를 완화
void mirrorEverySecondCell(inout float2 position, float2 period, float2 cellIndex)
{
    // 짝수 셀: 0, 홀수 셀: 1 (축별로 독립 적용)
    float2 flip = abs(fmod(cellIndex, 2.0));

    // flip=0 -> 그대로, flip=1 -> 뒤집기
    position = lerp(position, period - position, flip);

    // (선택이지만 권장) 뒤집기 후에도 항상 [0,period) 범위로 고정
    position = mod2(position, period);
}

// scene()에서 "도형 만들기 전"에 position을 셀 로컬로 접기
float scene(float2 position)
{
    float2 period = float2(3.0, 3.0);

    // 1) 셀 로컬 좌표로 접기 + 셀 인덱스 얻기
    float2 cellIndex = cells(position, period);

    // 2) (옵션) 경계 아티팩트 완화
    mirrorEverySecondCell(position, period, cellIndex);

    // 3) SDF는 이제 "셀 내부 좌표" 기준으로 작성
    //    보통 SDF는 원점 중심이 편하므로 셀 중심으로 재배치 (-0.5)
    float2 local = position - 0.5 * period;

    // 예: 셀마다 반복되는 원
    float d = circle(local, 0.8);

    return d;
}
```

---

## Radial Cells (방사형 셀)
공간을 방사형 패턴으로 반복하기

- **원점(또는 특정 중심)을 기준으로 부채꼴(각도 슬라이스) 단위로 공간을 반복**해서 방사형 패턴 만들기

```md
데카르트 좌표 (x, y) → 극좌표 (각도 θ, 반지름 r) 로 변환 후
각도 θ를 N등분 → 각 섹터 내에서 동일한 패턴 반복
```

---

## 핵심 아이디어
### 1. (x,y)를 (angle, radius)로 좌표계를 바꿔 각도를 반복하기
방사형 위치 계산을 위해 중심 기준으로 한 **각도를 x**축에, 중심으로부터의 **거리를 y축**에 인코딩

```c++
// 현재 픽셀의 위치를 극좌표로 변환
float angle = atan2(position.x, position.y);  // -π ~ π 범위의 각도

float radius = length(position);              // 원점으로부터의 거리

float2 radialPosition = float2(angle, radius);
```

### atan2 함수
2D 점 (x, y)가 원점에서 어느 방향(각도)에 있는지 **사분면(Quadrant)까지 고려해서 라디안 각도로 돌려주는 함수**

- **반환값**: θ (라디안), 보통 범위는 `(-π, π]`

---

### 2. 각도 반복 설정
전체 원은 2π, 셀 개수가 cells이라면

- **슬라이스 각도 크기**: cellSize = 2π / cells
- **각도 구간 공유**: 각도를 `[0, cellSize)` 로 접기

```c++
// true modulo (음수 보정): 결과가 항상 [0, m)
float mod1(float x, float m) {
    return fmod(fmod(x, m) + m, m);
}

const float PI = 3.14159;
int cells = 8; // 원을 8등분 (8개의 방사형 셀)

// 각 셀의 각도 크기 계산
float cellSize = (2.0 * PI) / cells; // 2π / 8 = π/4 (45도)

// angle은 atan2 때문에 음수 범위가 나올 수 있으므로 반드시 보정 modulo 권장
radialPosition.x = mod1(angle, cellSize); // angle ∈ [0, cellSize)
```

---

### 3. 방사형 좌표 재구성
- sincos(angle, s, c)로 단위원 방향 벡터 만들기
- radius를 곱해 원래 거리로 복원하기

```c++
sincos(radialPosition.x, position.x, position.y);

// 각도를 셀 내부 상대 위치로 변환 후 다시 데카르트 좌표로 복원
position = position * radialPosition.y;
```

---

## Radial Cell 정리

- 기본

```c++
// true modulo: 결과를 항상 [0, m)로 고정 (음수 보정)
float mod1(float x, float m) {
    return fmod(fmod(x, m) + m, m);
}

// 기본: 방사 반복만 (셀 인덱스/미러 없음)
void radial_cells(inout float2 position, float cells)
{
    const float PI = 3.14159;

    // 1) 슬라이스(셀) 각도 크기: 2π / cells
    float cellSize = PI * 2.0 / cells;

    // 2) 극좌표로 (angle, radius)로 인코딩
    //    - angle: x, radius(length): y
    float2 radialPosition = float2(atan2(position.x, position.y),
                                   length(position));

    // 3) angle만 반복: [0, cellSize)로 접기 (음수 보정 포함)
    radialPosition.x = mod1(radialPosition.x, cellSize);

    // 4) 데카르트 좌표 (x,y)로 복원
    //    튜토리얼: sin -> x, cos -> y 로 기록
    sincos(radialPosition.x, position.x, position.y);
    position *= radialPosition.y;
}
```

---

## Radial Cell Option
**cellIndex, 대칭 (미러) 기능 추가**

- 방사형 위치를 계산한 후, **모듈로 연산을 하기 전에 셀 인덱스 계산**하기
- 셀 인덱스: **방사형 위치의 x 성분을 나누고 그 결과를 내림하여 얻음**
  - **셀의 개수가 홀수**일 경우 문제가 생김
  - **해결 방안** : 내림된 인덱스 값에 셀의 개수를 더한 다음, 그 결과를 셀 크기로 나눈 나머지를 계산

```c++
// true modulo: 결과를 항상 [0, m)로 고정
float mod1(float x, float m) {
    return fmod(fmod(x, m) + m, m);
}

// CellIndex, 매 2번째 슬라이스 미러 옵션 추가
float2 radialCells(inout float2 position, int cellCount, bool mirrorEverySecondSlice)
{
    const float PI  = 3.14159;
    const float TAU = 2.0 * PI; // 2π

    cellCount = max(cellCount, 1);

    // 1) 데카르트 → 극좌표(표준 규약)
    float angle  = atan2(position.y, position.x); // (-π, π]
    float radius = length(position);

    // 2) 각도 정규화: [0, 2π)
    angle = mod1(angle, TAU);

    // 3) 슬라이스 분해: angle = cellIndex * cellSize + localAngle
    float cellSize  = TAU / (float)cellCount;
    float cellIndex = floor(angle / cellSize);       // 0..cellCount-1
    float localAngle = angle - cellIndex * cellSize; // 0..cellSize

    // 4) (옵션) 매 2번째 슬라이스 미러(뒤집기)
    // - 홀수 슬라이스면 localAngle을 반대로 접음: θ -> cellSize - θ
    // - 경계에서 "끝 -> 처음"으로 튀는 점프를 완화하는 데 도움될 수 있음
    if (mirrorEverySecondSlice)
    {
        float isOdd = fmod(cellIndex, 2.0); // 짝수=0, 홀수=1
        localAngle  = lerp(localAngle, cellSize - localAngle, isOdd);
        // 또는 명시적으로:
        // if (isOdd > 0.5) localAngle = cellSize - localAngle;
    }

    // 5) 극좌표 → 데카르트 복원: 한 기본 슬라이스로 접힌 좌표
    position = float2(cos(localAngle), sin(localAngle)) * radius;

    return float2(cellIndex, radius);
}

```

- 사용 예시

```c++
float scene(float2 position)
{
    // 중심을 원점이 아닌 곳으로 바꾸고 싶다면:
    // position -= center;

    float cells = 6.0;

    // 방사 반복 적용 (미러 포함)
    radial_cells(position, cells, true);

    // 이제 position이 "한 슬라이스 내부로 접힌 좌표"가 되었으므로
    // 평소처럼 SDF를 만들면 방사 패턴으로 반복됨
    return circle(position - float2(1.0, 0.0), 0.5);
}
```

---

## Wobbly space (왜곡)
좌표 자체를 주기적으로 흔들어 도형이 출렁이는 왜곡 효과 만들기

- SDF에 넣는 입력 좌표 position을 변형하면 결과가 변한다는 원리 사용

---

## 핵심 아이디어
시간에 따라 변화하는 비결정론적 변위를 공간 좌표에 적용하기

1. **공간 왜곡**
    - 각 픽셀의 위치를 노이즈 함수로 약간씩 변위시킴
2. **시간 변화**
    - 시간 매개변수를 통해 변위가 부드럽게 변화하도록 함
3. **지역적 변형**
    - 변위가 전체 공간에 균일하지 않고 지역적으로 다르게 적용됨

> 각 축을 독립적으로 흔드는 대신, x를 y 기반으로, y를 x 기반으로 흔들면 더 “유기적인” 왜곡이 나온다
> - position.yx : (y, x)로 스왑 → x 변위는 y에 의해, y 변위는 x에 의해 결정

---

## 과정
### 1. 기본 사인 기반 왜곡
시간 기반 좌표 변환

```c++
// 기본적인 사인 파동을 이용한 Wobbly 변환
float2 wobblyTransform(float2 position, float time, float frequency, float amplitude) {
    float2 offset;
    offset.x = sin(position.x * frequency + time) * amplitude;
    offset.y = sin(position.y * frequency + time) * amplitude;
    
    return position + offset;
}
```

- frequency: 파동의 빈도 (값이 클수록 빠르게 변화)
- amplitude: 파동의 진폭 (값이 클수록 변형 강도 증가)
- time: 시간 변수로 애니메이션 효과 생성

---

### 2. 교차 왜곡

```c++
void wobble(inout float2 position, float2 frequency, float2 amount)
{
    // position.yx: (y, x)로 뒤집어서
    // x 변위는 y 기반, y 변위는 x 기반이 되게 만든다.
    float2 delta = sin(position.yx * frequency) * amount;

    // 최종: 흔들린 좌표로 치환
    position += delta;
}
```

---

### 3. 노이즈 기반
자연스러운 유기적 효과를 위해 노이즈 함수를 사용 (다중 주파수)

```c++
// 의사 랜덤 노이즈 함수 (간단한 구현)
float pseudoRandom(float2 position) {
    return frac(sin(dot(position, float2(12.9898, 78.233))) * 43758.5453);
}

// 노이즈 기반 Wobbly 변환
float2 wobblyNoise(float2 position, float time) {
    float2 offset;
    
    // 다양한 주파수의 노이즈를 중첩(옥타브)
    for(int i = 0; i < 3; i++) {
        float freq = pow(2.0, i);
        float amp = 1.0 / freq;
        
        offset.x += sin(position.x * freq * 0.5 + time + i * 10.0) * amp * 0.1;
        offset.y += sin(position.y * freq * 0.5 + time * 1.1 + i * 10.0) * amp * 0.1;
    }
    
    return position + offset;
}
```

---

### 4. 거리 기반
도형의 경계에서 더 강한 변형을 적용하거나, 특정 지점을 중심으로 효과를 제한

```c++
// 거리에 따른 가변적 Wobbly 효과
float2 distanceBasedWobbly(float2 position, float2 center, float time) {
    // 중심점에서의 거리 계산
    float distance = length(position - center);
    
    // 거리에 반비례하는 감쇠 계수
    float attenuation = 1.0 / (1.0 + distance * 2.0);
    
    // 기본 변위 계산
    float2 offset;
    offset.x = sin(position.x * 3.0 + time) * 0.1;
    offset.y = sin(position.y * 3.0 + time * 1.3) * 0.1;
    
    // 감쇠 적용
    offset *= attenuation;
    
    return position + offset;
}
```

---

### 5. 위치 변경 흔들기
위치를 변경하고 오프셋 위치에 흔들림 적용. 다시 원래 위치로 되돌리기

```c++
const float PI = 3.14159;
float frequency = 5.0;

// 시간이 계속 커지면 float 정밀도 이슈 → 주기(2π/frequency)로 감기
float offset = _Time.y;
offset = fmod(offset, (PI * 2.0) / frequency); // 사인파가 2π 주기로 반복됨

// 이동 -> 흔들기 -> 역이동
position = translate(position, offset);
wobble(position, frequency, 0.05);
position = translate(position, -offset);
```

- 이 변형은 엄밀한 SDF 성질(거리의 정확도)을 깨뜨릴 수 있음
- amount를 과하게 키우지 말기
