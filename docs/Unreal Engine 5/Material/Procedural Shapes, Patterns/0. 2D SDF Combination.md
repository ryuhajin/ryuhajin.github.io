---
layout: default
title: "0. 2D SDF Combination"
parent: "Procedural Shapes, Patterns"
nav_order: 0
---

# 0. 2D SDF Combination
두 도형의 SDF를 d1, d2라 할 때, **조합 함수 combine(d1, d2)를 정의하면 복합 도형의 SDF를 만들 수 있다**

## 조합 종류
1. **불리언(Boolean) 조합 (min/max 기반)**
   - 합집합(Union)
   - 교집합(Intersection)
   - 차집합(Subtraction)
2. **Interpolation(보간)**
   - 두 SDF를 `lerp`로 섞어 **도형이 서로 morph(연속 변형)** 되게 함
3. **불리언 조합의 변형/확장 (접합부/경계 효과)**
   - Round(라운드 / rounded boolean)
   - Chamfer(챔퍼)
   - Border/Groove(경계 홈 등)

---

# Boolean 조합
전제: SDF는 **내부 < 0**, **외부 > 0**

## Union (합집합)
- 두 도형 중 **더 가까운 표면을 경계로 삼으면 합집합** → `min`

```c++
d_union = min(d1, d2)
```

---

## Intersection (교집합)
- 교집합은 **둘 다 내부인 영역만 내부**여야 하므로 더 **바깥으로 판정하는 쪽(=값이 큰 쪽) 을 선택** → max

```c++
d_intersection = max(d1, d2)
```

---

## Subtraciont (차집합)
- **차집합은 A ∩ (not B)**
- SDF에서 **부호반전은 내부/외부를 뒤집는 연산**이므로
  - `A ∩ (not B)`는 **max(A, -B)**로 표현된다

```c++
float subtract(float base, float subtraction){
    return intersect(base, -subtraction); // intersect = max(a,b)
}

d_subtract = subtract(d_base, d_sub);
```

1. **base 내부**
  - base < 0
2. **subtraction 내부**
   - subtraction < 0 → -subtraction > 0 (음수가 양수로 바뀜. 즉 subtraction의 외부처럼 동작)
3. **max(base, -subtraction)**
   - **base 내부이면서 subtraction 외부일 때만 음수(내부)로 남음**
   - subtraction 내부에서는 -subtraction이 양수로 올라가 결과가 양수가 되어 **깎임이 생김**

---

# Interpolation (보간) 조합
두 SDF 값을 선형 보간하면 도형이 서로 연속적으로 morph(변형) 됨

```c++
d_mix = lerp(d1, d2, t); // t ∈ [0,1]
```
- 선형 보간은 **거리장 자체를 섞는 것**
- 불리언 연산처럼 형태가 보존되는 게 아니라 **위상 변화/두께 변화 같은 현상이 자연스럽게 발생**

---

# Round 
두 도형이 **만나는 부분을 둥글게(필렛/라운딩) 만드는 조합**

---

## Round Union (라운드 합집합)
두 도형 (d1, d2)를 좌표로 보고 length를 취한다

1. 두 도형의 SDF를 shape1=d1, shape2=d2라고 할 때
2. 점 P = (d1, d2)를 만든 뒤 원점까지 거리 length(P)를 구한다

> 하지만 그대로 쓰면 outside가 깨지므로, 우선 내부(음수) 쪽만 보도록 제한한다

```c++
// 두 도형의 표면을 좌표계의 x축과 y축으로 해석
float round_merge(float shape1, float shape2, float radius){
    float2 intersectionSpace = float2(shape1, shape2);
    intersectionSpace = min(intersectionSpace, 0); // min: 양수(외부)는 0으로 클램프
    return length(intersectionSpace); //  항상 >=0 → 아직 SDF로는 불완전
}
```

### 왜 min(vec, 0)을 하나?
min(d1,0)은 외부(양수)를 0으로 잘라서 내부 (음수)만 남김

> 어떤 도형이 외부(양수)이면 그 축은 0으로 클램프되고, **내부(음수)**인 축만 음수 그대로 남음

- **한 도형만 내부인 경우**: (d1,0) 또는 (0,d2)가 되어 **length가 그 도형의 내부 거리 크기를 반영**
- **둘 다 내부인 경우**: (d1,d2) **둘 다 음수이므로 length가 접합부를 둥글게 만드는 형태를 만들기 시작**

```md
둘 다 외부면 d1>0, d2>0 → min 이후 (0,0)
→ length = 0이 되어 완전히 깨진 값 (부호/외부가 틀어짐)
```

따라서 개선이 필요하다

---

### 첫 번째 개선: 도형을 r만큼 팽창시킨 뒤 length 계산
위 방법으로는 거리가 0인 경계를 바꿀 수 없음

- 따라서 **두 도형을 radius만큼 팽창시켜 (rounding을 만들 여유를 확보) 결합**

### 도형을 키우는 (offset) 전형적인 방법
```md
d' = d - r (경계 0이 바깥으로 r만큼 이동)
```

---

```c++
float round_merge(float shape1, float shape2, float radius){
    float2 intersectionSpace = float2(shape1 - radius, shape2 - radius);
    intersectionSpace = min(intersectionSpace, 0);
    return length(intersectionSpace);
}
```

- 위 방법은 **접합부가 둥글게 만들어짐**, 하지만 **도형 자체도 같이 커짐**

---

### 두 번째 개선: -r로 대부분 원래 크기 복원
전체를 키우고 싶은게 아니라 접합부만 둥글게 만들고 싶으니 

- **사이즈를 키운 만큼 다시 `-radius`를 해서 원래 위치로 되돌림**

```c++
float round_merge(float shape1, float shape2, float radius){
    float2 intersectionSpace = float2(shape1 - radius, shape2 - radius);
    intersectionSpace = min(intersectionSpace, 0);
    return length(intersectionSpace) - radius; // offset 크기만큼 다시 되돌리기
}
```

- 코너는 둥글지만, 여전히 outside/부호가 올바른 SDF가 아님.

---

## 최종 : inside/outside 항 분리 + 상쇄(cancellation)로 라운드 + 정상 거리장 동시 만족
1. **insideDistance**
    - 내부의 라운드 전이(필렛)를 만드는 로컬 항
2. **outsideDistance**
    - 먼 외부는 원래 union SDF를 유지하는 글로벌 항
3. 둘을 더할 때 **경계 근처에서 -r/+r가 상쇄되도록 구성**

---

## 결과

```c++
float round_merge(float d1, float d2, float r){
    // inside (라운드 형태 생성)
    float2 q = float2(d1 - r, d2 - r); // offset 확장
    q = min(q, 0); // 외부 (양수) 무시
    float insideDistance = -length(q);  // length는 양수 → -를 붙여 내부를 음수로

    // outside (정상 union 거리장 유지 + r로 바닥(clamp))
    float simpleUnion = min(d1, d2); // 일반 합집합

    // 경계를 0으로 복원
    float outsideDistance = max(simpleUnion, r);
    // 의미: simpleUnion을 r로 clamp → inside의 -r 성분과 상쇄
    //(1) 경계/한 면 근처는 원래 거리로 복원
    // (2) 멀리 외부는 union 유지

    // 결합
    return insideDistance + outsideDistance;
}
```

---

## Round Intersection (라운드 교집합)
**Round Union과 반대**로, intersection은 겹친 영역의 바깥 코너가 날카로움

- 라운딩도 **외부(양수) 쪽을 대상**으로 만든다

### outside
- **도형을 반지름 만큼 축소하기**
- 벡터의 성분이 **0보다 큰지 확인하고 길이 반전하지 않기**

> 이렇게 하면 바깥 부분이 만들어 짐

---

### inside
- 일반적인 교집합 연산 수행
- 결과값은 반지름의 음수 값보다 작아지지 않게 함

---

## 결과

```c++
float round_intersect(float shape1, float shape2, float radius){
    // outside (라운드 외부 코너 생성)
    float2 q = float2(d1 + r, d2 + r); // 유니온과 반대로 더하기
    q = max(q, 0);// 반대로 max값 가져오기 (양수만 남김, 외부 값만 사용)
    float outsideDistance = length(q); // 길이 반전 안함 (외부 거리 생성)

    // inside (정상 intersection 유지 + 외부에서 -r로 고정되어 상쇄되게 함)
    float simpleIntersection = max(d1, d2); // max (a,b) 일반 교집합
    float insideDistance = min(simpleIntersection, -r); // -radius 이하 값 사용
    // 의미: 도형 "밖"에서는 insideDistance가 -r로 고정 → outsideDistance와 합쳐질 때
    //       면 근처에서는 원래 거리로 복원되고, 코너는 둥글게 변형됨

    // 결합
    return outsideDistance + insideDistance;
}
```

---

## Round Subtract (라운드 차집합)
차집합은 A ∩ (not B)이므로 round도 같은 패턴 확장

1. **도형 반전**
    - `-subtraction`으로 빼려는 도형의 내부/외부 반전
2. **라운드 교집합**
    - 반전된 도형과 기본 도형의 라운드 교집합 계산

```c++
float round_subtract(float base, float subtraction, float radius){
    return round_intersect(base, -subtraction, radius);
}
```

---

## 정리

| 연산              | Boolean SDF    | 라운드에서 라운딩되는 쪽                     | `q` 구성(오프셋)                                        | 클램프(사분면 선택)      | `length`가 들어가는 항      | 다른 항(정상 거리장 유지 + 상쇄)            |
| --------------- | -------------- | --------------------------------- | -------------------------------------------------- | ---------------- | --------------------- | ------------------------------- |
| Union (merge)   | `min(d1,d2)`   | **내부 코너**(두 도형이 안에서 만나는 부분)       | `q = (d1 - r, d2 - r)`                             | `min(q,0)` (음수만) | `inside = -length(q)` | `outside = max(min(d1,d2), r)`  |
| Intersection    | `max(d1,d2)`   | **외부 코너**(겹친 영역의 바깥 모서리)          | `q = (d1 + r, d2 + r)`                             | `max(q,0)` (양수만) | `outside = length(q)` | `inside = min(max(d1,d2), -r)`  |
| Subtraction A−B | `max(dA, -dB)` | **잘려나간 경계**쪽 라운딩 | `q = (dA + r, (-dB) + r)` (round_intersect에 넣는 형태) | `max(q,0)`       | `outside = length(q)` | `inside = min(max(dA,-dB), -r)` |

---

# Champfer
접합부를 사선으로 깎기

## 핵심 아이디어
- 두 SDF `shape1`, `shape2`를 더하면(= `shape1 + shape2`) 두 표면이 직교(orthogonal)로 만난다고 가정했을 때,
- 접합점 근처에 **대각선 경계**가 생기는 챔퍼 후보 shape를 만들 수 있다
- 단, 단순 합은 거리 스케일이 틀어지므로 **`1/sqrt(2)`로 정규화**가 필요하다
  - `1/sqrt(2) = sqrt(0.5) ≈ 0.70710678118` 를 상수로 사용한다

---

## Chamfer Union (챔퍼 합집합)

