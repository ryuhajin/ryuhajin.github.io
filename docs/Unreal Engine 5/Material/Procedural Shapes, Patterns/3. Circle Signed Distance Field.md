---
layout: default
title: "3. Circle Signed Distance Field"
parent: "Procedural Shapes, Patterns"
nav_order: 3
---

# 3. Circle Signed Distance Field
SDF로 원 그리기

---

## 핵심 아이디어
원 : 중심에서 반지름만큼 떨어진 점들의 집합

### 어떤 점 p가 원 경계에서 얼마나 떨어져 있는가?
- 중심 c와의 거리: $$\lVert p-c\rVert$$
- 반지름 r을 빼면 경계 기준 거리가 됨

---

## circle SDF

$$
d = \lVert p-c\rVert - r
$$

---

- $$\lVert p-c\rVert > r$$ 이면 원 밖 → $$d>0$$
- $$\lVert p-c\rVert = r$$ 이면 경계 → $$d=0$$
- $$\lVert p-c\rVert < r$$ 이면 원 안 → $$d<0$$

---

## Circle SDF function

```c++
// 2D 원의 SDF 함수
float sdfCircle(vec2 point, vec2 center, float radius) {
    return length(point - center) - radius;
}
```

- point - center: 점에서 원의 중심까지의 벡터
- length(): 그 벡터의 길이(거리) 계산
- radius: 원의 반지름만큼 빼기

---

## Circle Fill
SDF의 거리(d)를 계산한 뒤, 픽셀 색을 정하는 규칙을 적용

---

### Hard Fill
딱 잘린 경계

$$
\mathrm{fillMask} = \mathbb{1}(d \le 0)
$$

---

- $$\mathbb{1}$$은 조건이 참이면 1, 거짓이면 0
- 이렇게 하면 경계가 **계단(앨리어싱)**처럼 보일 수 있어, 보통 경계를 부드럽게 함 (안티 앨리어싱)

---

```c++
// 기본 채우기
float fill(float sdfValue) {
    // sdfValue < 0 이면 1.0, 아니면 0.0 반환
    return step(0.0, -sdfValue);
}
```

---

### Soft Fill
부드러운 경계

$$
\mathrm{fillMask} = 1 - \mathrm{smoothstep}(-w, +w, d)
$$

---

- $$d=0$$ 근처가 경계
- $$[-w, +w]$$ 구간에서 천천히 변화
- 밖은 0, 안은 1에 가깝게

---

```c++
// 부드러운 채우기 (안티앨리어싱)
float smoothFill(float sdfValue, float smoothness) {
    //SDF 부호(안 음수/밖 양수)와 마스크 기대값(안 1/밖 0)의 방향이 반대라서 뒤집기 (one - x)
    return 1.0 - smoothstep(-w, w, d);
}
```

---

## Circle Stroke
경계 주변 일정 두께만 출력하기

- 경계 : $$ d=0 $$
- 경계로부터의 절대거리 : $$ \left\vert d \right\vert$$

> 두께가 $$t$$인 스트로크를 만들려면
> - 보통 “반두께” $$t/2$$를 사용해 경계 양쪽으로 띠를 만든다

---

### hard stroke

$$
\mathrm{strokeMask} = \mathbb{1}(|d| \le t/2)
$$

---

```c++
float stroke(float d, float thickness) {
    return step(abs(d), thickness * 0.5);
}
```
---

### soft stroke

$$
\mathrm{strokeMask} = 1 - \mathrm{smoothstep}(t/2-w,\ t/2+w,\ |d|)
$$

---

- $$\left\vert d \right\vert$$가 0에 가까울수록 경계에 가깝다
- $$\left\vert d \right\vert = t/2$$ 근처에서 마스크가 떨어지며 두께가 정해진다

---

```c++
float smoothStroke(float d, float thickness, float w) {
    float halfT = thickness * 0.5;
    return 1.0 - smoothstep(halfT - w, halfT + w, abs(d));
}
```

---

# Circle pattern
## Circle Tiling
여러 개의 원을 반복 배치하기 위해 점 p를 셀 단위로 접기

### 핵심 아이디어
1. 월드 좌표 $$p$$를 타일 크기 $$s$$로 나눈다  
2. 소수 부분만 취해 셀 내부 좌표로 만든다  
3. 셀 중앙 기준으로 이동해 원 SDF 적용

---

$$
p' = \mathrm{fract}\left(\frac{p}{s}\right)\cdot s - \frac{s}{2}
$$

---

- p/s 를 한 뒤 `fract`로 **소수부만 남기면** 각 축이 `[0,1)` 범위로 반복
- 다시 $$\cdot s$$ 하면 `[0,s)` 범위의 **셀 내부 좌표**가 되고,
- -s/2 하면 셀 중앙이 원점인 `[-s/2, s/2)` 범위로 이동

---

```c++
vec4 gridCircles(vec2 uv, float cellSize, float radius) {
    // 셀 내부 좌표로 접기 // uv를 셀 크기로 나누고 소수 부분만 취하기
    // vec2 local = fract(uv / cellSize) * cellSize - cellSize * 0.5;
    // mod(uv, s) == fract(uv/s) * s (uv >= 0 가정)
    vec2 local = mod(uv, cellSize) - cellSize * 0.5;

    // 원 SDF // 각 셀 안에서 원 그리기
    float d = sdfCircle(local, vec2(0.0), radius);

    // 부드러운 채우기
    float mask = 1.0 - smoothstep(0.0, 1.0, d);

    return vec4(vec3(mask), 1.0);
}
```

---

# Circle Animation
## Circle Pulse
시간 t에 따라 반지름 변화

- 원이 커졌다 작아졌다 하는 맥동 효과

---

$$
r(t) = r_0 + A\sin(\omega t)
$$

---

$$
d(t) = \lVert p-c\rVert - r(t)
$$

---

- $$r_0$$ : 기본 반지름  
- $$A$$ : 진폭  
- $$\omega$$ : 속도(각속도)  
- $$t$$ : 시간  

---

```c++
float animatedCircle(
    vec2 p,  // 픽셀 좌표
    vec2 center, // 원 중심
    float baseRadius, // 기본 반지름 (픽셀)
    float amplitude, // 맥동 진폭 (픽셀)
    float speed, // 속도 (라디안/초)
    float time  // 현재 시간 (초)
) {
    float r = baseRadius + amplitude * sin(speed * time);
    float d = sdfCircle(p, center, r);
    return smoothFill(d, 1.0);
}
```

## Circle Translation Animation
원 중심을 시간에 따라 이동시켜 화면 위를 움직이는 원 애니메이션 생성

```c++
float movingCircle(
    vec2 p,
    vec2 center,
    vec2 velocity,
    float radius,
    float time
) {
    vec2 animatedCenter = center + velocity * time;
    float d = sdfCircle(p, animatedCenter, radius);
    return smoothFill(d, 1.0);
}
```

---

## Circle Scrolling Tiling
좌표 자체를 시간에 따라 이동시켜 반복된 원 패턴이 흐르는 듯한 애니메이션 생성

```c++
vec4 scrollingGrid(
    vec2 uv,
    vec2 velocity,
    float cellSize,
    float radius,
    float time
) {
    vec2 animatedUV = uv + velocity * time;

    // 셀 내부 좌표로 접기
    vec2 local = mod(animatedUV, cellSize) - cellSize * 0.5;

    float d = sdfCircle(local, vec2(0.0), radius);
    float mask = 1.0 - smoothstep(0.0, 1.0, d);

    return vec4(vec3(mask), 1.0);
}

```

---

## Circle Wave / Warp
좌표를 사인 함수로 왜곡한 뒤 SDF를 계산하면 원이 물결처럼 흔들리는 효과를 만들 수 있다

```c++
float warpedCircle(
    vec2 p,
    vec2 center,
    float radius,
    float amplitude,
    float frequency,
    float speed,
    float time
) {
    vec2 warpedP = p;
    warpedP.x += amplitude * sin(frequency * p.y + speed * time);

    float d = sdfCircle(warpedP, center, radius);
    return smoothFill(d, 1.0);
}
```

---

### 정리
- 반지름을 시간에 넣으면 → 맥동 애니메이션
- 중심을 시간에 넣으면 → 이동 애니메이션
- 좌표를 시간에 넣으면 → 흐르는 패턴
- 좌표를 왜곡한 뒤 SDF 계산 → 파동 / 워프 효과