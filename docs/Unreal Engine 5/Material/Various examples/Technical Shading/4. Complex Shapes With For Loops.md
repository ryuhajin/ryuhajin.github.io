---
layout: default
title: "4. Complex Shapes With For Loops"
parent: "Technical Shading"
nav_order: 4
---

# 4. Complex Shapes With For Loops

### 기본 원 그리기

```c++
float result = 0;
result = length(position - UV) < size;
return result;
```

---

### for 루프를 이용한 원형 패턴 생성

```c++
float result = 0;

for (int i = 0; i < n_sides; i++)
{
    float angle = i / float(n_sides) * 2 * 3.14;
    float2 pos = center + radius * float2(cos(angle), sin(angle));
    result += length(pos - UV) < size;
}

return result;
```

1. n_sides 개수의 **점을 원주상에 균등하게 배치**
2. 각 점에 작은 원을 그림
3. **result += 으로 누적하여 모든 원을 합성**

---

### 2중 for 루프를 이용한 원형 패턴 생성

```c++
float result = 0;

for (int i = 0; i < n_sides; i++)
{
    for (int j = 0; j < n_copies; j++)
    {
        float angle = (i / n_sides) * 2 * 3.14;
        float2 pos = center + (j / n_copies) * radius * float2(cos(angle), sin(angle));
        result += length(pos - UV) < size; // draw circle
    }
}

return result;
```

1. **(j / float(n_copies))* radius**
    - j가 증가할수록 원의 반지름이 점점 커지는 것처럼 **점들이 바깥으로 퍼져나감**

---

### size 계산

```c++
result += length(pos - UV) < size;
```

### 1. 거리 계산
```
// pos: 원의 중심 좌표 (예: (0.5, 0.3))
// UV: 현재 픽셀의 좌표 (예: (0.6, 0.4))

float distance = length(pos - UV);
```

1. **pos - UV**
    - 두 점 사이의 벡터
2. **length()**
    - 벡터의 길이(거리) 계산

> 결과: 현재 픽셀이 원의 중심으로부터 떨어진 거리

### 2. 원 내부 확인
```
bool isInsideCircle = (distance < size);
```

1. **distance < size**
    - 거리가 설정한 size보다 작으면 true(1)
    - 크면 false(0)

---

### 호도법

<br>

![](/images/radians.png)

> θ가 2π까지 돌면 원을 한 바퀴 완성

---

# 코드 살펴보기

## 각도로 원 표현하기
2D 평면에서 원 위의 점은 **중심에서 일정 반지름 r만큼 떨어져 있고, 각도 θ로 위치가 결정**

---

### 1. 단위원 개념
반지름이 1인 원 (단위원)에서 각도 0일 때 점의 좌표

---

$$
(x,y) = (\cos \theta, \sin \theta)
$$

---

- θ = 0 → (1, 0) → 오른쪽 끝
- θ = π/2 → (0, 1) → 위쪽
- θ = π → (−1, 0) → 왼쪽
- θ = 3π/2 → (0, −1) → 아래쪽

---

### 2. 반지름 r인 원으로 확장
반지름이 r이라면 좌표는

---

$$
(x,y) = (r \cos \theta, r \sin \theta)
$$

- **단위원 좌표에 r을 곱해 원을 확장한 것**

---

### 3. 중심이 (cx, cy)인 원으로 이동
중심을 옮기면 원 전체가 평행이동

---

$$
(x,y) = (cx + r \cos \theta, cy + r \sin \theta)
$$

---

## HLSL 이해하기

```c++
float2 pos = center + radius * float2(cos(angle), sin(angle));
```

1. **float2(cos(angle), sin(angle))**
    - 단위원 위 점
2. **radius** 
    - 반지름 확장
3. **center**
    - 원 중심 이동

> (pos.x, pos.y)는 angle 각도에서 반지름 radius를 가진 원의 둘레 위 좌표

```
float2(cos(angle), sin(angle)) 의 각도를 변경하여 다양한 애니메이션 표현 가능!

예 : cos(1-angle), sin(3*angle) 
```

---

## 원주를 각도로 균등 분할하기
**원 둘레에 점을 균일하게 배치**하기 위해 **전체 각도(2π)를 점 개수로 나눈다**

---

$$
\theta_i = \frac{i}{\text{점 개수}} * 2\pi
$$

---

### HLSL 이해하기

```c++
float angle = i / float(sides) * 2 * 3.14;
```

1. **i / float(sides)**
    - i는 0부터 sides-1까지의 정수
    - **sides로 나누면 0~1 사이의 비율 생성**
    - 예: sides=4 → i=0:0.0, i=1:0.25, i=2:0.5, i=3:0.75
2. **`* 2 * 3.14` (2π)** 
    - 0 ~ 1 비율을 **0~2π (360°) 범위의 각도로 변환**
    - 2π = 6.28 ≈ 2 * 3.14 (π 근사값)
    - 예: 0.25 * 6.28 ≈ 1.57 rad (90°)

```
2 * 3.14 를 수정하여 다양한 원 표현 가능!

(time) * 3.14 : 시계 방향으로 회전

1 * 3.14 : 반원

0.5 * 3.14 : 1/4 원
```

---

```c++
float result = 0;

for (int i = 0; i < circleCount; i++)
{
    for (int j = 0; j < expand; j++)
    {
        float angle = (i / circleCount) * 2 * 3.14;
        float2 pos = center + (j / expand) * radius * float2(cos(angle), sin(angle));
        result += length(pos - UV) < size; // draw circle
    }
}

return result;
```