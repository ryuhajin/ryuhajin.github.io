---
layout: default
title: "10. View, World, Object, & Tangent Space"
parent: "EP [1, 10]"
nav_order: 7
---

# EP 10 : View, World, Object, & Tangent Space
같은 벡터라도 어떤 기준 좌표계에서 보느냐에 따라 값이 달라지고, 연산하려면 같은 스페이스로 맞춰야 함

---

## 좌표계 정리
### 1. World Space (세계 좌표계)
- 원점: 월드(씬)의 (0,0,0)
- 축: 씬 전체에서 고정(X, Y, Z)
- 오브젝트, 카메라가 움직여도 불변

```
예: “이 나무는 월드 좌표 (300, 100, 0)에 있다.”
```

### 2. Object Space (로컬 / 오브젝트 좌표계)
- 원점: 오브젝트의 pivot
- 축: 오브젝트의 방향에 따라 함께 회전/이동

```
- 예: 캐릭터 pivot이 발바닥에 있으면, (0,1,0)은 캐릭터의 “머리 위쪽”을 가리킴
```

### 3. View Space (카메라 좌표계, Eye Space)
- 원점: 카메라 위치
- 축: 카메라 방향에 종속

```
예: “카메라에서 바라봤을 때 앞에 있는 픽셀이 Z+ 방향 10만큼 떨어져 있다.”
```

### 4. Tangent Space (탄젠트 공간)
- 원점: 각 버텍스마다 다름
- 축:
  - Normal(법선) → 보통 Z
  - Tangent(탄젠트) → 보통 X
  - Bitangent(또는 Binormal) → 보통 Y
- UV 좌표계를 기반으로 정의됨

```
노멀맵의 RGB는 Tangent Space 벡터로 인코딩되어 있다
```

- Bitangent 계산이 왼손 기준 (언리얼) 이냐 오른손 기준 (유니티) 이냐에 따라 다름
> 따라서 Unity에서 만든 노멀맵을 Unreal에 그대로 쓰면 Y(Green) 채널을 반전해야 함

---

**링크**

외적으로 얻는 벡터 방향 설명 링크
- [How to do the Right Hand Rule for Cross Products](https://youtu.be/zGyfiOqiR4s?si=uY0Qz_NWGw2Fb9Km)

---

## Unreal Engine vs Unity의 주요 좌표계 차이

| 항목  | **Unreal Engine** | **Unity** | **차이 요약 / 주의점**   |
| --- | ---- | --- | --- |
| **좌표계 유형**     | 왼손좌표계 (Left-handed)| 왼손좌표계 (Left-handed)| 동일한 손잡이이지만 축 정의가 다름    |
| **월드 좌표(World Vector)**  | +X: Forward<br>+Y: Right<br>+Z: Up| +X: Right<br>+Y: Up<br>+Z: Forward| Forward와 Up 축이 다름 (Unreal의 +X = Unity의 +Z) |
| **카메라 좌표(Camera Vector)**| Forward = +X<br>Up = +Z<br>Right = +Y  | Forward = +Z<br>Up = +Y<br>Right = +X  | 카메라 전방축 차이 존재|
| **뷰 좌표(View Vector)**    | 카메라 원점, Forward = +X    | 카메라 원점, Forward = +Z    | 카메라 좌표계와 동일한 차이   |
| **오브젝트(Local/Object Vector)** | 모델의 로컬축 정의에 따름| 모델의 로컬축 정의에 따름| 엔진 차이 없음. FBX 등에서 정의된 로컬축에 의존    |

---

| 항목 | Unreal Engine | Unity | 주의사항 |
|---|---|---|---|
| **TBN 구조** | T: U 방향, B: V 방향, N: 버텍스 노멀 벡터 | 동일 | 개념적 구조는 동일 |
| **노멀맵 스타일** | DirectX (Y 아래+) | OpenGL (Y 위+) | G 채널 반전 필요 |
| **Bitangent 계산** | cross(N, T) | cross(N, T) * tangent.w | Handness 처리 방식 다름 |

- TBN은 절대적인 축 값이 아니라 상대적인 방향 관계
- Unity: OpenGL 스타일 - Y축 위쪽이 양수
- Unreal: DirectX 스타일 - Y축 아래쪽이 양수

```
// Unity: tangent.w로 handness 제어 (탄젠트 공간 내에서 Bitangent 방향 조정)
B = cross(N, T) * tangent.w; // tangent.w가 ±1 값 가짐

// Unreal: 왼손좌표계 기준 일관적 계산  
B = cross(N, T);
```

---

# Vertex Normal vs Tangent Space
## Vertex Normal data

```
Position: (x, y, z)
Normal:   (nx, ny, nz)     // 표면이 바라보는 방향
UV:       (u, v)
Tangent:  (tx, ty, tz, w)  // w는 handedness(+1/-1)
```

## Tangent Space basis vector
탄젠트 스페이스의 기저 벡터

```
N (Normal): 버텍스 노멀 자체

T (Tangent): 버텍스의 탄젠트 벡터 (텍스처 U 방향)

B (Bitangent): N과 T의 외적으로 계산 (B = N × T)
```

---

## Tangent 계산 원리
버텍스 노멀 데이터의 탄젠트가 어떻게 계산되어 들어가는지 설명

### 1. 버텍스 노멀 데이터에서 기본 노멀(N)을 얻는다
삼각형의 세 정점 위치를 이용해 외적 계산

$$
N = \frac{(v_2 - v_1) \times (v_3 - v_1)}{\|(v_2 - v_1) \times (v_3 - v_1)\|}
$$

---

### 2. Tangent (T) 계산
Tangent는 **텍스처 U축이 3D 공간상에서 가리키는 방향**

**링크**

링크의 그림 참조
- [Normal-Mapping](https://learnopengl.com/Advanced-Lighting/Normal-Mapping)

- 세 버텍스의 위치: p₁, p₂, p₃
- 세 버텍스의 UV: (u₁, v₁), (u₂, v₂), (u₃, v₃)

---

$$
E_1 = P_2 - P_1,\quad E_2 = P_3 - P_1
$$

- 삼각형 한 변을 따라가는 3D 접평면 내 방향벡터 두 개

---

$$
\Delta UV_1 = UV_2 - UV_1,\quad \Delta UV_2 = UV_3 - UV_1
$$

- E1, E2에 대응하는 UV 평면에서의 이동

---

$$
T = \frac{E_1 \cdot \Delta V_2 - E_2 \cdot \Delta V_1}{\Delta U_1 \Delta V_2 - \Delta U_2 \Delta V_1}
$$

---

### 3. Bitangent 계산
Tangent와 Normal의 외적으로 얻음

$$
B = \text{normalize}(\text{cross}(N, T) \times w)
$$

---

- Handedness
    - Tangent, Bitangent, Normal 세 축이 만드는 좌표계가 오른손인지 왼손인지 판단해, w에 ±1을 저장
    - 이게 나중에 Bitangent를 재구성할 때 사용됨

---

### 4. TBN 구성
각 버텍스에 대해 직교 기저행렬 구성

---

## Normal Map 생성 과정
3D 툴에서 노멀맵을 베이킹할 때 일어나는 일

1. **준비**
    - 하이폴리 모델과 로우폴리 모델을 정확히 같은 위치에 겹쳐 놓음
2. **기준 설정**
    - 로우폴리 모델의 각 픽셀 위치에서, **그 지점의 버텍스 노멀(N)과 탄젠트(T), 바이탄젠트(B)를 이용해 탄젠트 공간 좌표계를 설정**
    - 여기서 버텍스 노멀(N)이 탄젠트 공간의 Z축이 됨
3. **정보 추출**
    - 해당 픽셀 위치에서 하이폴리 모델의 표면은 어떤 방향을 향하고 있는지 계산
4. **기준 변환 및 저장**
    - **하이폴리 모델의 노멀 방향을 방금 설정한 로우폴리 모델의 탄젠트 공간 좌표계로 변환**
    - 즉, "로우폴리 표면 기준에서 봤을 때 하이폴리 표면은 어느 방향이지?"를 계산
5. **결과**
    - 만약 하이폴리 표면의 방향이 로우폴리 표면의 버텍스 노멀 방향과 완전히 똑같다면
    - "방향 변화 없음"을 의미하는 `(0, 0, 1)` 벡터가 노멀맵에 저장
    - 이것이 바로 노멀맵의 기본 색상인 **연한 보라색(R:128, G:128, B:255)**이 됨

### 실제 좌표 예시
노멀 벡터는 좌표 변환을 두번 거침

1. [-1,1] → [0,1] 범위 변환
    - `(v + 1.0) * 0.5`
    - -1 → (-1 + 1) × 0.5 = 0.0
    - 0 → (0 + 1) × 0.5 = 0.5
    - 1 → (1 + 1) × 0.5 = 1.0
2. [0,1] → [0,255] 정수 변환 (RGB)
    - `value * 255.0`
    - 0.75 → 0.75 × 255 = 191.25 ≈ 191

- 평평한 표면 (기본 상태)

```
월드 좌표계 노멀: (0, 0, 1)
탄젠트 스페이스 노멀: (0, 0, 1)

R: (0 + 1) × 127.5 = 128

G: (0 + 1) × 127.5 = 128

B: (1 + 1) × 127.5 = 255

노멀맵 RGB 값: (128, 128, 255)
```

- 오른쪽으로 기울어진 표면

```
월드 좌표계 노멀: (0.5, 0, 0.866)
탄젠트 스페이스 노멀: (0.5, 0, 0.866)

R: (0.5 + 1) × 127.5 = 191.25 ≈ 191

G: (0 + 1) × 127.5 = 128

B: (0.866 + 1) × 127.5 = 238.0


노멀맵 RGB 값: (191, 128, 238)
```

### 쉐이더에서의 역변환
노멀맵에서 읽은 RGB 값을 원래 벡터로 복원

```c++
vec3 normalFromMap = texture(normalMap, texCoord).rgb;
vec3 tangentNormal = normalFromMap * 2.0 - 1.0;
```

```
RGB(128, 128, 255) → 벡터 복원:

R: 128/255 = 0.502 → 0.502×2 - 1 = 0.004 ≈ 0
G: 128/255 = 0.502 → 0.502×2 - 1 = 0.004 ≈ 0  
B: 255/255 = 1.0 → 1.0×2 - 1 = 1.0

결과: (0, 0, 1)
```

---

## HLSL 코드 예시

- VS

```c++
// 버텍스 입력 (모델 데이터로부터 받음)
struct VS_INPUT
{
    float4 Pos : POSITION;
    float2 Tex : TEXCOORD0;
    float3 Norm : NORMAL;    // N (버텍스 노멀)
    float3 Tan : TANGENT;    // xyz=T, w=handedness(+1/-1)
};

// 픽셀 셰이더로 전달될 데이터
struct PS_INPUT
{
    float4 Pos : SV_POSITION;
    float2 Tex : TEXCOORD0;
    // T, B, N 벡터를 월드 공간으로 변환하여 전달
    float3 WorldTangent : TEXCOORD1;
    float3 WorldBitangent : TEXCOORD2;
    float3 WorldNormal : TEXCOORD3;
};

PS_INPUT VS(VS_INPUT input)
{
    PS_INPUT output = (PS_INPUT)0;
    
    // ... 위치 변환 코드 생략 ...

    // 1. T, B, N을 월드 공간으로 변환
    output.WorldNormal = normalize(mul(input.Norm, (float3x3)World));
    output.WorldTangent = normalize(mul(input.Tan, (float3x3)World));
    
    // 2. Bitangent는 N과 T의 외적으로 계산
    // (모델 데이터에 포함되어 있기도 하지만, 보통은 메모리 절약을 위해 실시간 계산)
    float3 bitangent = cross(output.WorldNormal, output.WorldTangent);
    output.WorldBitangent = normalize(bitangent);

    return output;
}
```

---

- PS

```c++

// 픽셀 셰이더
float4 PS(PS_INPUT input) : SV_Target
{
    // 1. 노멀맵에서 탄젠트 공간 노멀을 샘플링
    // Texture2D NormalMap; SamplerState Sampler;
    // .rgb 값을 [-1, 1] 범위의 벡터로 변환
    float3 tangentNormal = NormalMap.Sample(Sampler, input.Tex).rgb * 2.0 - 1.0;
    
    // 2. TBN 행렬을 구성 (행 기준)
    float3x3 tbnMatrix = float3x3(
        input.WorldTangent,
        input.WorldBitangent,
        input.WorldNormal
    );

    // 3. 탄젠트 공간 노멀을 월드 공간으로 변환! ★★★
    float3 finalWorldNormal = normalize(mul(tangentNormal, tbnMatrix));
    
    // 4. 최종 월드 노멀로 조명 계산 수행
    // ... Light Calculation using finalWorldNormal ...
    
    return finalColor;
}
```
