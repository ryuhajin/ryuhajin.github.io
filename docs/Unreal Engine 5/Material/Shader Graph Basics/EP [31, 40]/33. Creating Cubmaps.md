---
layout: default
title: "33. Creating Cubmaps"
parent: "EP [31, 40]"
nav_order: 3
---

# EP 33 : Creating Cubmaps
큐브맵 만들기

## Cubmap Capture
1. **6면 이미지 준비**
    - 장면 **중심에 카메라를 놓고 FOV 90°**
    - 정사각 해상도로 X/−X, +Y/−Y, +Z/−Z 여섯 장을 캡처
2. **사용하는 엔진용 레이아웃으로 6면 재배치 하기**
    - 언리얼, 유니티 레이아웃 각각 다름 (x,y,z 축 방향이 달라서)
    - 아래 링크 참조

- [Unreal : Creating Cubemaps](https://dev.epicgames.com/documentation/en-us/unreal-engine/creating-cubemaps?application_version=4.27)
- [Unity : Creating Cubemaps](https://docs.unity3d.com/Manual/class-Cubemap-create.html)

---

## NVIDIA Texture Tools Exporter
포토샵 플러그인으로 exporter 사용하기

1. Photoshop에 NVIDIA Texture Tools Exporter 플러그인 설치
2. Photoshop 파일 → 다른 이름으로 저장 → DDS 선택
3. 설정
    - **Format**: 8888 ARGB 32-bit unsigned (비압축)
    - **Texture Type**: Cube Map
    - **Mips**: No MIP maps (임포트 후 언리얼이 자체 압축(DXT1/BC1 등)과 Mip 생성 처리)

**다운로드 링크**
- [NVIDIA Texture Tools Exporter](https://developer.nvidia.com/texture-tools-exporter)

---

## unreal import setting
1. 위에서 만든 DDS 파일 임포트
2. Details에서 자동 인식이 TextureCube인지 확인

```
cubeMap을 텍스쳐 샘플로 사용할 경우 UV에 uv 좌표(V2)가 아니라 reflection Vector를 줘야 에러가 안남 (V3)
```

---

## Cubmap Sample
GPU가 큐브맵을 샘플링하라는 명령을 받으면, float3 방향 벡터를 가지고 내부적으로 다음 두 단계를 처리함

### 1단계 : 면 선택 (Face Selection)
1. 입력된 3D 벡터 v = (x, y, z)를 받음
2. 세 개의 축 값 x, y, z 중에서 **절대값(magnitude)**이 가장 큰 축을 찾음
3. 이 축이 벡터가 "가장 많이" 향하고 있는 주 방향
    - 예: 만약 v = (0.2, -0.8, 0.3) 이라면, |-0.8|이 가장 크므로 Y축을 선택
4. 이제 그 축의 **부호(sign)**를 봄
    - 예: `-0.8`은 음수(-)이므로, Y축의 음수 방향 면, 즉 **-Y 면 (바닥)**을 최종적으로 선택

가장 큰 축	| 부호	| 선택되는 면 (DirectX 기준)|
x	| +	| +X (오른쪽) |
x	| -	| -X (왼쪽) |
y	| +	| +Y (위) |
y	| -	| -Y (아래) |
z	| +	| +Z (앞) |
z	| -	| -Z (뒤) |

---

### 2단계 : 2D UV 계산 (UV Calculation)
1. 면(예: -Y 면)이 선택되면, GPU는 해당 면을 2D 평면처럼 취급
2. 선택된 축(Y)을 제외한 나머지 두 축의 값 (예: x = 0.2, z = 0.3)을 사용
3. 이 값들을 아까 찾은 가장 큰 절대값 (예: |-0.8| = 0.8) 으로 나누어, [-1, 1] 범위의 2D 좌표로 정규화
    - s = `x / |-y| = 0.2 / 0.8 = 0.25`
    - t = `z / |-y| = 0.3 / 0.8 = 0.375`
4. 이 [-1, 1] 범위의 좌표를 최종적으로 텍스처의 [0, 1] UV 범위로 변환하여, -Y 면 텍스처의 정확한 픽셀 색상을 가져옴
    - **U 좌표**: `u = 0.5 × (s_normalized + 1)`
    - **V 좌표**: `v = 0.5 × (1 - t_normalized)` ⚠️ *V 좌표는 반전됨*

> V 좌표 반전 이유: 3D 좌표계에서는 일반적으로 위쪽이 +Y이지만, 텍스처 좌표계에서는 위쪽이 V=0, 아래쪽이 V=1이기 때문에 방향을 맞추기 위해 반전이 필요함

---