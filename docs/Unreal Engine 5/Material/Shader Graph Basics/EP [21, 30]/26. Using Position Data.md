---
layout: default
title: "26. Using Position Data"
parent: "EP [21, 30]"
nav_order: 6
---

# EP 26 : Using Position Data
위치 데이터 활용하기

### **Local Space (객체 공간)**
- 모델의 피벗(pivot) 지점을 원점(0,0,0)으로 하는, 모델 자신만의 독립적인 좌표계
  - **픽셀, 버텍스 모두 모델 피벗을 중심으로 두고 좌표 데이터를 가짐**
  - 모델의 로컬 포지션 축을 움직이면 픽셀, 버텍스 값이 같이 변화하여 따라감
- **모델 이동** : **로컬 좌표 값 자체는 변하지 않음. 월드 상에서는 피벗이 움직이므로 전체가 이동한 것처럼 보임**
- **모델 회전** : **피벗이 회전함으로 픽셀, 버텍스 값 모두 같이 변화함**

### **World Space (월드 공간)**
- 게임 월드 전체가 공유하는 절대적인 공용 좌표계. 월드의 중심이 원점(0,0,0)
- **모델 이동** : **월드 공간상 다른 위치를 지나가므로 위치 데이터가 변함**
- **모델 회전** : 월드 좌표계는 고정되어 있으므로 위치 데이터는 변하지 않음

### **Object Position (월드 공간 상의 모델 좌표)**
- 모델 피벗의 월드 공간 상 좌표 값
  - **이 값은 모델의 버텍스와 픽셀에서 모두 동일하다**
  - 예 : 월드 공간의 (100, 50, 0) 위치에 있으면 모든 픽셀이 (100, 50, 0)
- **모델 이동** : **월드 공간상 다른 위치를 지나가므로 위치 데이터가 변함**
- **모델 회전** : 월드 좌표계는 고정되어 있으므로 위치 데이터는 변하지 않음

---

# 그래프 예제

## Vertical Gradient (수직 그라데이션)
캐릭터의 발 쪽은 어둡게, 머리 쪽은 밝게 만드는 효과

1. `Local Position` 노드 가져옴
2. '위쪽' 방향에 해당하는 축의 채널만 분리 (유니티: Y축(G), 언리얼: Z축(B))
3. Add, Multiply 노드를 이용해 그라데이션의 시작 위치와 범위를 조절
4. Power 노드로 그라데이션의 감쇠 곡선을 조절하여 더 자연스럽게 만든다

> Local Position을 사용하여 캐릭터가 월드 어디를 돌아다니든 아래 방향은 어둡게 보임

---

## Texture Projection (텍스쳐 투영)
Position의 일부 축(XY, XZ 등)을 UV처럼 사용하여 텍스처 샘플링

1. `world Position` 노드를 가져옴
2. world Position 노드에 0.01 곱하여 스케일 조정
3. Mask R/G (X/Y) → UV로 사용
4. Texture Sample 연결

> world Position을 사용하여 월드 고정으로 투영됨

### ❓ 투영하고 싶은 텍스처 채널을 다르게 쓰는 이유
UV는 2차원 (U,V) 좌표이기 때문에 Position의 3D(X,Y,Z) 중에서 어떤 2축을 선택할지가 중요

> Position 기반 텍스처 투영에서는 어떤 축을 “깊이 방향”으로 삼느냐에 따라 UV 채널 선택이 달라짐

| 투영 방향 | 깊이축 | UV 채널 | 설명 |
| --- | --- | --- | --- |
| 위에서 아래 (Top)  | Z   | X,Y   | 땅에 수평 투영 |
| 앞에서 뒤 (Front) | X   | Y,Z   | 정면 투영    |
| 옆에서 (Side)    | Y   | X,Z   | 측면 투영    |

---

## Instance Variation (인스턴스 별 변화주기)
월드에 배치된 모델의 위치에 따라 조금씩 다른 색상이나 모양을 갖게 하여 반복적인 느낌을 줄임

1. `Object Position` 노드를 가져옴
2. Object Position 노드에 0.01을 곱하여 스케일 조정
3. X, Y, Z 값을 모두 더해 하나의 값으로 만든다
4. Sine 함수에 이 값을 입력
5. Sine 함수 출력 값에 * 0.5, + 0.5 하여 [0 ~ 1] 범위로 바꿈

- Lerp 노드의 알파 값으로 사용하면, 각 오브젝트의 위치에 따라 두 가지 색상이나 텍스처를 다르게 섞을 수 있다

### ❓ X, Y 따로 더하고 그 뒤 Z를 더하는 이유
X, Y, Z를 합치면 “공간상 어떤 한 축”에 종속되지 않고, 위치에 따라 고유한 스칼라 값을 만들 수 있어서

- X만 썼다면 Y축이나 Z축으로 이동할 때 값이 변하지 않음
- 어떤 방향으로 오브젝트를 배치하든 좌표값에 따라 일정하게 증가하는 값을 가져야 함

```
오브젝트 A: (10, 20, 0)  → 10 + 20 + 0 = 30
오브젝트 B: (15, 25, 0)  → 15 + 25 + 0 = 40
오브젝트 C: (0, 0, 0)    → 0 + 0 + 0 = 0
```

---

### ❓ 사인(Sine) 노드가 왜 필요한가
`X + Y + Z`는 좌표에 따라 무한히 커질 수 있음

- 하지만 **우리가 원하는 건 색상 변화처럼 0~1 범위 내의 값**
- 따라서 사인 함수를 통해 [0 ~ 1] 사이의 범위로 맵핑한다

> 주기적으로 반복되는 패턴이 생김 → 오브젝트 위치가 멀어지면 색이 주기적으로 바뀜

---

# scale factor
언리얼 좌표 단위와 텍스처 좌표 단위의 차이

1. 언리얼 엔진의 기본 단위: 1 Unreal Unit = 1 cm
2. 대부분의 텍스처 UV 좌표: 0 ~ 1 범위
    - (0,0)은 텍스처의 왼쪽 아래
    - (1,1)은 텍스처의 오른쪽 위

예를 들어, 오브젝트가 월드에서 100cm(1m) 떨어져 있다고 가정

- 이 값을 텍스처 샘플러의 UV로 바로 쓰면?

```
World Position X = 100.0
UV = 100.0
```

👉 텍스처 좌표가 0~1인데 100을 넣었으니 텍스처는 100번 반복되어 버리거나 (타일링), 완전히 무의미한 값이 됨

> 즉, **언리얼의 월드 좌표(센티미터)**를 UV 좌표계(0~1)로 매핑하려면 스케일 조정이 필요

---

## 0.01을 곱하는 이유
**1m 단위로 텍스처를 1번 반복**하겠다는 의미.

- 1m : 100cm
- 100cm * 0.01 = 1.0

```
곱하는 값 = 1 / (원하는 타일 길이 cm)
```

> 월드 단위를 1m 단위로 나누어 UV 단위(1.0)에 맞추는 역할

### 예시

```
World Position (X,Y) = (350, 120)

Tile Size = 100cm (1m)

Scale = 0.01

UV = (350 * 0.01, 120 * 0.01)
   = (3.5, 1.2)
```

- 텍스처가 X방향으로 3번, Y방향으로 1번 반복됨


### cm 단위를 200cm로 바꾸면

```
World Position (X,Y) = (350, 120)

Tile Size = 200cm (2m)

Scale = 0.005

UV = (350 * 0.005, 120 * 0.005)
   = (1.75, 0.6)
```

- 반복 횟수가 줄어들고 타일이 커짐

---

## 언리얼 vs 유니티 단위 비교

| 항목    | 유니티 | 언리얼 |
| 기본 단위 | 1 unit = **1 m** | 1 unit = **1 cm** |
| 1 m   | 1                | 100               |
| 1 cm  | 0.01             | 1                 |

- 언리얼 좌표 100은 유니티 좌표로 1
- 언리얼 좌표 1은 유니티 좌표로 0.01

따라서

```
✅ 언리얼의 값을 유니티 기준으로 환산하려면 × 0.01

✅ 반대로 유니티 값을 언리얼로 변환하려면 × 100
```

---




