---
layout: default
title: "28. Triplanar Projection"
parent: "EP [21, 30]"
nav_order: 8
---

# EP 28 : Triplanar Projection

- [언리얼 엔진 5.3 - 스티키 3면 투영/매핑](https://youtu.be/Yh79GlCT644?si=5URZ54RUaRIg1_k-)

Tri-Planar Projection (삼중 방향 투영) 기법

- Directional Mask를 기반으로 한 텍스처 투영 기법
- 지형, 바위, 건축물 등에서 UV 맵이 없거나 UV 왜곡을 피하고 싶을 때 사용

---

## Tri-Planar Projection 이란?
X, Y, Z — 세 방향에서 텍스처를 투영하고, 노멀 방향을 기반으로 자연스럽게 블렌딩하는 방식

- 기존의 단일 방향 Projection은 측면에서 stretching(늘어짐) 문제가 있었음
- 이걸 3방향에서 동시에 투영하고 블렌딩하면 자연스러운 표면 표현이 가능

---

## Directional Mask 를 이용한 블렌딩
앞에서 만들었던 Directional Mask를 사용하여 3방향 블렌딩

| 축 | Mask 채널 | 역할  |
| X | R       | 앞/뒤 방향 마스크  |
| Y | G       | 왼쪽/오른쪽 방향 마스크  |
| Z | B       | 위/아래 방향 마스크 |

- 이 마스크를 이용해 각 투영 방향의 기여도를 가중치로 사용

---

# 그래프 예제

## Cheap projection

1. X/Y/Z projection 좌표 생성
2. Lerp로 좌표를 blending
   - Lerp(X, Y, MaskG)
   - Lerp(X + Y, Z, MaskB)
3. 최종 좌표를 Texture Sample에 넣기 (1회 샘플링)
4. Power(64)의 결과를 Round 노드를 사용해 경계 끊기

- 장점 : 텍스처 샘플링이 1회라 매우 빠름
- 단점 :방향 경계에 seam (이음선) 생김

---

## Expensive projection
1. X/Y/Z projection 좌표 생성
2. **각 projection 별 Texture Sample 3회**
3. Lerp로 좌표를 blending
   - Lerp(X, Y, MaskG)
   - Lerp(X + Y, Z, MaskB)
4. Power(8) 결과값에는 round 안씀

- 장점 : Mask의 부드러운 블렌딩으로 seam 제거
- 단점 : 고비용. 텍스처 샘플링 3회

---

# Triplanar Projection Improvements
삼중 투영 개선하기

### 개선점
1. **반전 문제 수정** : 삼중 투영 중 X, Y 투영에서 텍스처가 뒤집히거나 반전된 것 보정하기
2. **재사용성 강화** : Material Function을 사용하여 캡슐화

---

## 상하 반전 수정하기
X, Y축에서 투영된 텍스처의 숫자가 상하로 뒤집혀 보임 (z축 뒤집힘)

1. **X, Y 투영의 Absolute World Position에 float (1, 1, -1) 곱셈**
    - Multiply( WorldPos , **float3(1, 1, -1)** )
    - 두 투영에서 UV의 두 번째 성분이 뒤집혀 보이는 문제 해결

---

## 좌우 반전 수정하기
오브젝트의 한쪽 면에서는 제대로 보이지만, 정확히 반대쪽 면에서는 글자가 좌우로 뒤집혀 보임

```
[원인]

텍스처를 빔 프로젝터처럼 '관통'하여 투영했기 때문에
오브젝트의 앞면과 뒷면이 동일한 투영 데이터를 공유하고, 이로 인해 뒷면은 거울상처럼 보이게 됨
```
- 오브젝트의 뒷면을 감지해서, 그 부분만 수평 좌표를 뒤집어줘서 해결

---

## Sign (부호) 함수
Sign(부호) 함수는 입력된 숫자가 양수이면 1을, 음수이면 -1을 반환하는 함수이다

- World Normal Vector를 Sign 함수에 입력하면
- 표면이 각 축의 양(+)의 방향을 보는지, 음(-)의 방향을 보는지를 1과 -1로 명확하게 알려줌

> '뒷면'을 감지하는 스위치 역할

---

1. VertexNormalWS 을 Sign 노드에 연결
    - 결과는 각 축별 +1 / -1
2. X축만 부호 보정
    - **Sign * float3(-1, 1, 1)**
3. 각 축별 수평 성분만 뒤집도록 Append 노드를 사용해 ( signX , 1 ) 형태로 2D 스케일 벡터 생성
4. X/Y/Z 투영 좌표 각각에 해당 **flip 벡터를 곱해 반대쪽 면에서 가로가 뒤집히도록 함**

> 방향성 없는 텍스처(돌, 흙 등)는 이 교정 연산을 생략해도 됨

---

