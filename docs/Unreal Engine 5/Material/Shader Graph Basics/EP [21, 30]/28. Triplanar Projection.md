---
layout: default
title: "28. Triplanar Projection"
parent: "EP [21, 30]"
nav_order: 8
---

# EP 28 : Triplanar Projection

- [언리얼 엔진 5.3 - 스티키 3면 투영/매핑](https://youtu.be/Yh79GlCT644?si=5URZ54RUaRIg1_k-)

Tri-Planar Projection (삼중 방향 투영) 기법

- Directional Mask를 기반으로 한 텍스처 투영 기법
- 지형, 바위, 건축물 등에서 UV 맵이 없거나 UV 왜곡을 피하고 싶을 때 사용

---

## Tri-Planar Projection 이란?
X, Y, Z — 세 방향에서 텍스처를 투영하고, 노멀 방향을 기반으로 자연스럽게 블렌딩하는 방식

- 기존의 단일 방향 Projection은 측면에서 stretching(늘어짐) 문제가 있었음
- 이걸 3방향에서 동시에 투영하고 블렌딩하면 자연스러운 표면 표현이 가능

---

## Directional Mask 를 이용한 블렌딩
앞에서 만들었던 Directional Mask를 사용하여 3방향 블렌딩

| 축 | Mask 채널 | 역할  |
| X | R       | 앞/뒤 방향 마스크  |
| Y | G       | 왼쪽/오른쪽 방향 마스크  |
| Z | B       | 위/아래 방향 마스크 |

- 이 마스크를 이용해 각 투영 방향의 기여도를 가중치로 사용

---

# 그래프 예제

## Cheap projection

1. X/Y/Z projection 좌표 생성
2. Lerp로 좌표를 blending
   - Lerp(X, Y, MaskG)
   - Lerp(X + Y, Z, MaskB)
3. 최종 좌표를 Texture Sample에 넣기 (1회 샘플링)
4. Power(64)의 결과를 Round 노드를 사용해 경계 끊기

- 장점 : 텍스처 샘플링이 1회라 매우 빠름
- 단점 :방향 경계에 seam (이음선) 생김

---

## Expensive projection
1. X/Y/Z projection 좌표 생성
2. **각 projection 별 Texture Sample 3회**
3. Lerp로 좌표를 blending
   - Lerp(X, Y, MaskG)
   - Lerp(X + Y, Z, MaskB)
4. Power(8) 결과값에는 round 안씀

- 장점 : Mask의 부드러운 블렌딩으로 seam 제거
- 단점 : 고비용. 텍스처 샘플링 3회

---

# Triplanar Projection Improvements
삼중 투영 개선하기

### 개선점
1. **반전 문제 수정** : 삼중 투영 중 X, Y 투영에서 텍스처가 뒤집히거나 반전된 것 보정하기
2. **재사용성 강화** : Material Function을 사용하여 캡슐화

---

## 상하 반전 수정하기
X, Y축에서 투영된 텍스처의 숫자가 상하로 뒤집혀 보임 (z축 뒤집힘)

1. **X, Y 투영의 Absolute World Position에 float (1, 1, -1) 곱셈**
    - Multiply( WorldPos , **float3(1, 1, -1)** )
    - 두 투영에서 UV의 두 번째 성분이 뒤집혀 보이는 문제 해결

---

## 좌우 반전 수정하기
오브젝트의 한쪽 면에서는 제대로 보이지만, 정확히 반대쪽 면에서는 글자가 좌우로 뒤집혀 보임

```
[원인]

텍스처를 빔 프로젝터처럼 '관통'하여 투영했기 때문에
오브젝트의 앞면과 뒷면이 동일한 투영 데이터를 공유하고, 이로 인해 뒷면은 거울상처럼 보이게 됨
```
- 오브젝트의 뒷면을 감지해서, 그 부분만 수평 좌표를 뒤집어줘서 해결

---

## Sign (부호) 함수
Sign(부호) 함수는 입력된 숫자가 양수이면 1을, 음수이면 -1을 반환하는 함수이다

- World Normal Vector를 Sign 함수에 입력하면
- 표면이 각 축의 양(+)의 방향을 보는지, 음(-)의 방향을 보는지를 1과 -1로 명확하게 알려줌

> '뒷면'을 감지하는 스위치 역할

---

1. VertexNormalWS 을 Sign 노드에 연결
    - 결과는 각 축별 +1 / -1
2. X축만 부호 보정
    - **Sign * float3(-1, 1, 1)**
3. 각 축별 수평 성분만 뒤집도록 Append 노드를 사용해 ( signX , 1 ) 형태로 2D 스케일 벡터 생성
4. X/Y/Z 투영 좌표 각각에 해당 **flip 벡터를 곱해 반대쪽 면에서 가로가 뒤집히도록 함**

> 방향성 없는 텍스처(돌, 흙 등)는 이 교정 연산을 생략해도 됨

---

# MF_Triplanar 만들기

## Inputs
1. Position (Vector3)
    - 월드 또는 로컬 등 좌표 공간 선택
2. Normal (Vector3)
    - Position과 동일 공간의 노멀
    - `pixelNormalWS`
    - `vertexNormalWS` 등 노드 사용
3. Tiling (Scalar)
    - 반복 스케일
4. Sharpness (Scalar)
    - 블렌딩 선명도 (보통 1~8)
    - seem 보정에 사용

---

## Outputs
1. UV_X (Vector2)
    - X축 투영용
2. UV_Y (Vector2)
    - y축 투영용
3. UV_Z (Vector2)
    - z축 투영용
4. W (Vector3)
    - wX, wY, wZ

---

# 노드 과정
## UV 만들기 (투영)
1. UV_X = (P.y, P.z) * Tiling
2. UV_Y = (P.x, P.z) * Tiling
3. UV_Z = (P.x, P.y) * Tiling

---

## 왜 X 투영은 (Y,Z)를 써? (투영의 정확한 의미)
Triplanar에서 X 투영은 **X축 방향으로 ‘쏜다(project)’**는 뜻

### X축 방향으로 투영
**점 P = (x,y,z)를 X축 방향으로 쭉 밀어붙여서 YZ 평면에 떨어뜨린다는 의미**

- **YZ 평면은 좌표가 (y,z)로 표현**되니까 **UV가 (y,z)**가 됨
- X 방향으로 쏘면 **X 위치는 ‘깊이’가 되어서 2D 표면 좌표로 쓸 수 없다**

```md
X projection → YZ plane → UV = (y,z)

Y projection → XZ plane → UV = (x,z)

Z projection → XY plane → UV = (x,y)
```

> 따라서 축 하나를 버리고 (투영 방향), 남은 두 축으로 2D를 만든다라고 이해하자!

### 실전 예시
어떤 점 P = (x, y, z)가 있을 때

- 만약 P = (1,2,3) 이라면

1. **UVx** = (2,3) = (y, z)
2. **UVy** = (1,3) = (x, z)
3. **UVz** = (1,2) = (x, y)

> 월드 X/Y/Z로 고정된 triplanar에서는 그냥 해당 성분을 뽑는 것이 곧 투영

---

## Tiling 스칼라 값?
WorldPos 단위는 1 = 1cm

- UV처럼 0~1 정도 범위에서 패턴을 반복시키는 로직
- 텍스처 샘플, frac, sin 등은 입력 값이 너무 크면
- 타일이 너무 촘촘해 지거나 과도하게 빨라짐

```md
Tiling = 0.001은 월드 1000cm(=10m)를 1.0으로 보는 스케일
```

---

## 투영 가중치 개념
Triplanar는 **하나의 투영만 쓰는 게 아니라 3개 투영을 동시에 만들고 섞는다**

1. **3개 투영 계산하기**
    - X투영으로 만든 UVx로 어떤 값을 샘플/계산한다
    - Y투영으로 만든 UVy로 값을 샘플/계산한다
    - Z투영으로 만든 UVz로 값을 샘플/계산한다
2. **각 투영의 결과 값**
     - 텍스쳐 샘플 = Color (V3, V4)
     - 마스크 = Scalar
3. **결과 값을 섞을 때 어느 방향의 투영을 더 사용할 지 결정하는 것 = Weight**
    - 투영 가중치 = weight (w.x, w.y, w.z) (V3)

---

## 가중치 만들기 (노멀 기반)
1. A = **abs(N)** (Absolute)
    - 예시 : Normal = (0.2, 0.5, 0.8)
      - 노멀은 표면이 어느 바향을 바라보는지 나타내는 방향 벡터이다
      - 노멀 x,y,z의 제곱의 합은 1이다 
    - abs(N) = +든 -든 동일 취급하기 위해 절대값 취하기
2. M = **pow(A, Sharpness)** (Power)
    - Power로 대비(contrast)를 올려 더 확실히 한 축을 선택
      - Sharpness를 올리면 큰 값은 상대적으로 덜 줄고, 작은 값은 급격히 0에 가까워짐 
3. Sum = **M.x + M.y + M.z** (ComponentMask + Add + Add 또는 Dot(M, (1,1,1)))
    - 세 투영을 섞을 때 결과가 면 방향에 따라 튀지 않게, 항상 같은 스케일로 섞기
4. W = **M / max(Sum, 1e-5)** (Divide + Max 안전장치)
    - 합을 1로 정규화 시키기

> 가중치는 겹쳐서 밝아지는 문제를 해결해줌

### 상수 예시

```md
[예시 1]
m = (0.64, 0.04, 0.0) (Sharpness=2에서 나옴)

- Sum   = *M.x + M.y + M.z
        = 0.64 + 0.04 + 0 = 0.68

- W = M / Sum
    = 0.64/0.68, 0.04/0.68, 0

- W ≈ (0.941, 0.059, 0)

> 결과는 거의 X투영만 씀
```

```md
[예시 2]
m = (0.577, 0.577, 0.577) (Sharpness=1, 대각선)

- Sum   = *M.x + M.y + M.z
        = 0.577, 0.577, 0.577
        = 1.731

- W     = M / Sum
        = 0.577/1.731, 0.577/1.731, 0.577/1.731

- w = (0.333, 0.333, 0.333)

> 결과 : 세 투영을 동일 비중으로 섞는다
```

---

