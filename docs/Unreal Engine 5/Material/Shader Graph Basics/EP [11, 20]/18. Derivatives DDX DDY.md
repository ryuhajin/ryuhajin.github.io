---
layout: default
title: "18. Derivatives DDX DDY"
parent: "EP [11, 20]"
nav_order: 8
---

# EP 18 : Derivatives DDX DDY
**DDX, DDY는 화면 공간에서 인접 픽셀 간의 값 차이를 빠르게 구하는 하드웨어 명령어**이다

- **GPU 파이프라인의 픽셀 처리 방식(2×2 타일 처리)을 직접 활용**함

---

## DDX, DDY 기본 개념

| **노드**  | **기능** | **의미**  |
| DDX | X축(가로) 방향으로 인접 픽셀 값의 차이를 계산 | 현재 픽셀과 오른쪽 픽셀의 값 차 |
| DDY | Y축(세로) 방향으로 인접 픽셀 값의 차이를 계산 | 현재 픽셀과 위쪽 픽셀의 값 차  |

- GPU는 픽셀을 1개씩이 아니라 2×2 블록(quad) 단위로 처리
- **DDX는 현재 픽셀과 오른쪽 픽셀의 값 차, DDY는 위쪽 픽셀의 값 차를 반환**
- 이 값은 **미분 또는 기울기(derivative)로 해석 가능**

**읽어보면 좋은 링크**
- [derivative functions](https://www.aclockworkberry.com/shader-derivative-functions/)

---

## Smooth Shading vs Flat Shading
두 쉐이딩의 차이는 정점 데이터를 어떻게 구성하느냐에 따라 다르다. ddx/ddy 계산이 쓰이진 않음

### Smooth Shading
부드러운 곡면을 표현

1. **원리**
    - 하나의 정점(Vertex)은 자신을 공유하는 모든 면(Face)의 법선 벡터(Normal)를 평균냄
    - **'고유한 평균 법선(Averaged Vertex Normal)'**을 갖는다
2. **데이터 구조**
    - 정육면체의 한 **꼭짓점은 3개의 면이 만나지만, 정점 데이터는 딱 하나만 존재**
    - 이 정점은 3개 면의 법선을 평균낸 값을 자신의 법선 값으로 가짐
3. **결과**
    - 각 정점마다 서로 다른 법선 값을 가지게 되므로
    - GPU의 래스터라이저 단계에서 이 법선 값들이 면 전체에 걸쳐 부드럽게 보간됨

### Flat Shading
각 면의 각진 형태를 그대로 표현

1. **원리**
    - 한 면(Face)을 구성하는 모든 정점들은 **'동일한 면 법선(Face Normal)'**을 갖는다
2. **데이터 구조**
    - **스무스 쉐이딩에서는 하나의 정점이었지만, 플랫 쉐이딩에서는 이 꼭짓점에 해당하는 정점이 3개로 복제**
    - 각 복제된 정점은 자신이 속한 면의 법선 벡터를 각각 따로 가짐
    - 즉, **정점을 공유하지 않게 만든다**
3. **결과**
    - 한 삼각형을 이루는 3개의 정점이 모두 똑같은 법선 벡터를 가지고 있음
    - 따라서 래스터라이저가 보간을 하더라도 면 전체의 모든 픽셀은 결국 동일한 법선 값을 갖게 되어 평평하게 보이게 됨

---

### DDX, DDY  vs Flat Shading
**플랫 쉐이딩**
- 모델 데이터 자체에 미리 계산된 면 법선을 정점 데이터로 넣어줌
- 쉐이더는 그저 주어진 데이터를 사용함

**DDX, DDY**
- 모델 데이터에는 없는 픽셀 법선을 ddx, ddy를 이용해 계산하는 것
- 픽셀 쉐이더에서 실시간으로 계산하여 새로운 법선 생성

---

## DDX, DDY 계산 과정
DDX, DDY는 해당 픽셀이 속한 2×2 쿼드 내에서의 값의 차이(기울기)를 반환한다

⚠️ 화면 좌표가 0~100이든 0~1이든 상관없이, **이웃 간의 간격이 기준이 됨**

---

**0~1 범위의 UV 좌표 기준** 계산 과정

## 조건
- UV 좌표 범위: 0.0 ~ 1.0
- 텍스처 해상도: 1024 × 1024
- 현재 픽셀 위치: UV = (0.5, 0.5) 텍스처의 정중앙

---

$$
\Delta uv = \frac{1}{\text{TextureResolution}} = \frac{1}{1024} \approx 0.0009765625
$$

---


## DDX 계산 (X 방향 차이)

오른쪽 픽셀 UV

---

$$
uv_{\text{right}} = (0.5 + \Delta uv,\ 0.5)
$$

---

현재 픽셀 UV

---

$$
uv_{\text{current}} = (0.5,\ 0.5)
$$

---

DDX

---

$$
ddx(uv) = uv_{\text{right}} - uv_{\text{current}}
= (0.5 + \Delta uv,\ 0.5) - (0.5,\ 0.5)
= (\Delta uv,\ 0)
$$

---

결론

---

$$
ddx(uv) = (0.0009765625,\ 0)
$$

---

## DDY 계산 (Y 방향 차이)

위쪽 픽셀 UV

---

$$
uv_{\text{top}} = (0.5,\ 0.5 + \Delta uv)
$$

---

현재 픽셀 UV

---

$$
uv_{\text{current}} = (0.5,\ 0.5)
$$

----

DDY

---

$$
ddy(uv) = uv_{\text{top}} - uv_{\text{current}}
= (0.5,\ 0.5 + \Delta uv) - (0.5,\ 0.5)
= (0,\ \Delta uv)
$$

---

결론

---

$$
ddy(uv) = (0,\ 0.0009765625)
$$

---

## Gradient 행렬

DDX, DDY는 2×2 픽셀 블록에서 기울기 행렬로 표현 가능

---

$$
\text{Gradient} =
\begin{bmatrix}
ddx_x & ddx_y \\
ddy_x & ddy_y
\end{bmatrix}
=
\begin{bmatrix}
0.0009765625 & 0 \\
0 & 0.0009765625
\end{bmatrix}
$$

---

> 이 값은 텍스처의 MIP맵 LOD 계산, 노멀 계산, 파라락스 보정 등에 직접 활용

---

# 그래프 예제
예제 보면서 이해 안가는 것 미리 공부하고 정리

---

## PixelNormalWS
**현재 픽셀에서의 표면 법선을 World Space 기준으로 반환하는 노드**
- 보통 모델의 노멀은 Tangent Space에서 계산되지만
- 월드 공간에서 반사 방향을 계산해야 하므로 이 노드를 사용

## Reflection Vector
뷰 벡터와 표면 노멀을 사용해 이용해 반사 방향을 계산하는 노드
- 화면에서 픽셀이 어느 방향으로 반사되는지 알려줌
- 환경 맵(라이트맵, Lat-Long HDRI)에 반사 방향을 전달해 샘플링에 활용

Custom Reflection Vector와 차이점
사용자가 직접 지정한 법선 벡터(Normal)와 카메라 벡터(Camera Vector)를 기반으로 반사 벡터를 계산해주는 노드

## LongLatToUV (Latitude-Longitude → UV 변환)
**3D 방향 벡터(보통 반사 벡터)를 2D UV 좌표로 변환하는 노드**

- LatLong(위도-경도) 환경 맵은 **구면 좌표계를 평면으로 펴서 저장한 텍스처**
- **3D 방향을 이 위도·경도 평면에 투영해야 올바른 위치를 샘플링**할 수 있음
- Reflection Vector와 함께 쓰임

---

# Environment Mapping (환경 매핑)
주변 환경을 3D 모델 표면에 반사된 것처럼 보이게 하는 것

- **환경맵** : 장면 전체를 둘러싼 구형 또는 큐브형 텍스처
- **샘플링** : 모델 표면에서 계산된 반사 벡터로 환경 맵의 특정 방향을 찾아 색상을 가져오는 과정

**링크**
- [Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps)

---

## LatLong 환경 반사 예제
모델 표면에 환경 HDRI를 반사시켜 출력하기

