---
layout: default
title: "18. Derivatives DDX DDY"
parent: "EP [11, 20]"
nav_order: 8
---

# EP 18 : Derivatives DDX DDY
**DDX, DDY는 화면 공간에서 인접 픽셀 간의 값 차이를 빠르게 구하는 하드웨어 명령어**이다

- **GPU 파이프라인의 픽셀 처리 방식(2×2 타일 처리)을 직접 활용**함

---

## DDX, DDY 기본 개념

| **노드**  | **기능** | **의미**  |
| DDX | X축(가로) 방향으로 인접 픽셀 값의 차이를 계산 | 현재 픽셀과 오른쪽 픽셀의 값 차 |
| DDY | Y축(세로) 방향으로 인접 픽셀 값의 차이를 계산 | 현재 픽셀과 위쪽 픽셀의 값 차  |

- GPU는 픽셀을 1개씩이 아니라 2×2 블록(quad) 단위로 처리
- **DDX는 현재 픽셀과 오른쪽 픽셀의 값 차, DDY는 위쪽 픽셀의 값 차를 반환**
- 이 값은 **미분 또는 기울기(derivative)로 해석 가능**

**읽어보면 좋은 링크**
- [derivative functions](https://www.aclockworkberry.com/shader-derivative-functions/)

---

## Smooth Shading vs Flat Shading
두 쉐이딩의 차이는 정점 데이터를 어떻게 구성하느냐에 따라 다르다. ddx/ddy 계산이 쓰이진 않음

### Smooth Shading
부드러운 곡면을 표현

1. **원리**
    - 하나의 정점(Vertex)은 자신을 공유하는 모든 면(Face)의 법선 벡터(Normal)를 평균냄
    - **'고유한 평균 법선(Averaged Vertex Normal)'**을 갖는다
2. **데이터 구조**
    - 정육면체의 한 **꼭짓점은 3개의 면이 만나지만, 정점 데이터는 딱 하나만 존재**
    - 이 정점은 3개 면의 법선을 평균낸 값을 자신의 법선 값으로 가짐
3. **결과**
    - 각 정점마다 서로 다른 법선 값을 가지게 되므로
    - GPU의 래스터라이저 단계에서 이 법선 값들이 면 전체에 걸쳐 부드럽게 보간됨

### Flat Shading
각 면의 각진 형태를 그대로 표현

1. **원리**
    - 한 면(Face)을 구성하는 모든 정점들은 **'동일한 면 법선(Face Normal)'**을 갖는다
2. **데이터 구조**
    - **스무스 쉐이딩에서는 하나의 정점이었지만, 플랫 쉐이딩에서는 이 꼭짓점에 해당하는 정점이 3개로 복제**
    - 각 복제된 정점은 자신이 속한 면의 법선 벡터를 각각 따로 가짐
    - 즉, **정점을 공유하지 않게 만든다**
3. **결과**
    - 한 삼각형을 이루는 3개의 정점이 모두 똑같은 법선 벡터를 가지고 있음
    - 따라서 래스터라이저가 보간을 하더라도 면 전체의 모든 픽셀은 결국 동일한 법선 값을 갖게 되어 평평하게 보이게 됨

---

### DDX, DDY  vs Flat Shading
**플랫 쉐이딩**
- 모델 데이터 자체에 미리 계산된 면 법선을 정점 데이터로 넣어줌
- 쉐이더는 그저 주어진 데이터를 사용함

**DDX, DDY**
- 모델 데이터에는 없는 픽셀 법선을 ddx, ddy를 이용해 계산하는 것
- 픽셀 쉐이더에서 실시간으로 계산하여 새로운 법선 생성

---

## DDX, DDY 계산 과정
DDX, DDY는 해당 픽셀이 속한 2×2 쿼드 내에서의 값의 차이(기울기)를 반환한다

⚠️ 화면 좌표가 0~100이든 0~1이든 상관없이, **이웃 간의 간격이 기준이 됨**

---

**0~1 범위의 UV 좌표 기준** 계산 과정

## 조건
- UV 좌표 범위: 0.0 ~ 1.0
- 텍스처 해상도: 1024 × 1024
- 현재 픽셀 위치: UV = (0.5, 0.5) 텍스처의 정중앙

---

$$
\Delta uv = \frac{1}{\text{TextureResolution}} = \frac{1}{1024} \approx 0.0009765625
$$

---


## DDX 계산 (X 방향 차이)

오른쪽 픽셀 UV

---

$$
uv_{\text{right}} = (0.5 + \Delta uv,\ 0.5)
$$

---

현재 픽셀 UV

---

$$
uv_{\text{current}} = (0.5,\ 0.5)
$$

---

DDX

---

$$
ddx(uv) = uv_{\text{right}} - uv_{\text{current}}
= (0.5 + \Delta uv,\ 0.5) - (0.5,\ 0.5)
= (\Delta uv,\ 0)
$$

---

결론

---

$$
ddx(uv) = (0.0009765625,\ 0)
$$

---

## DDY 계산 (Y 방향 차이)

위쪽 픽셀 UV

---

$$
uv_{\text{top}} = (0.5,\ 0.5 + \Delta uv)
$$

---

현재 픽셀 UV

---

$$
uv_{\text{current}} = (0.5,\ 0.5)
$$

----

DDY

---

$$
ddy(uv) = uv_{\text{top}} - uv_{\text{current}}
= (0.5,\ 0.5 + \Delta uv) - (0.5,\ 0.5)
= (0,\ \Delta uv)
$$

---

결론

---

$$
ddy(uv) = (0,\ 0.0009765625)
$$

---

## Gradient 행렬

DDX, DDY는 2×2 픽셀 블록에서 기울기 행렬로 표현 가능

---

$$
\text{Gradient} =
\begin{bmatrix}
ddx_x & ddx_y \\
ddy_x & ddy_y
\end{bmatrix}
=
\begin{bmatrix}
0.0009765625 & 0 \\
0 & 0.0009765625
\end{bmatrix}
$$

---

> 이 값은 텍스처의 MIP맵 LOD 계산, 노멀 계산, 파라락스 보정 등에 직접 활용

---

# Environment Mapping (환경 매핑)
환경 매핑은 **주변 환경을 3D 모델 표면에 반사된 것처럼 보이게 하는 기법이다**

- **환경맵** : 장면 전체를 둘러싼 구형 또는 큐브형 텍스처
    - 환경 맵은 “무한”하게 간주된다
    - 반사 방향 R로 단순히 텍스처를 샘플링할 뿐 거리 개념이 없음
    - 환경 맵은 **단위 구(반지름 1)**를 가정하고 샘플링
- **샘플링** : 모델 표면에서 계산된 반사 벡터로 **환경 맵의 특정 방향을 찾아 색상을 가져오는 과정**
    - 반사 방향 R로 단순히 텍스처를 샘플링할 뿐 거리 개념이 없음
    - 반지름 1이나 1000이나 방향 벡터만 같으면 uv도 동일 → 픽셀 색상도 동일

## Environment Mapping 좌표
환경 맵은 무한 원거리로 가정되며, **방향 벡터의 기준 공간을 일관되게 사용해야 한다**

- **스카이박스** : 카메라 회전만 반영(이동 무시)
- **오브젝트 반사** : 월드 공간에서 Reflection Vector 계산, 환경 맵도 월드 기준으로 샘플

## Environment Mapping 과정 
1. 환경 맵 로드
2. 픽셀 셰이더(fragment shader)에서 표면 반사 벡터 계산
3. 환경 맵에서 색상 샘플
4. 샘플 값을 오브젝트 픽셀 색상에 반영

**환경 매핑을 이해하기 좋은 링크**
- [Cubemaps](https://learnopengl.com/Advanced-OpenGL/Cubemaps)
- [Reflections with Environment Mapping](https://youtu.be/Wgy48IYYHzw?si=uMDUgBk207QOOKWa)
- [Environment Mapping](https://youtu.be/PeAvKApuAuA?si=J0tPVNs8GrJPt9C8)

---

# 그래프 예제

## LatLong 환경 반사 예제
모델 표면에 환경 HDRI를 반사시켜 출력하기

1. PixelNormalWS 노드
2. 1번의 노드를 Reflection Vector 노드에 연결
3. 2번의 노드를 LongLatToUV 노드에 연결
4. 텍스쳐 샘플러에 HDRI 텍스쳐 넣고 3번을 UVs 인풋으로 입력
5. 텍스쳐 샘플러에 Mip Value Mode Derivative로 변경
    - 안그러면 seam (흰색 선) 생김
6. 텍스쳐 coordinate -> DDY, DDX -> TextureSample(Derivative)의 ddx/ddy에 입력

---

## PixelNormalWS
**현재 픽셀에서의 표면 법선을 World Space 기준으로 반환하는 노드**
- 보통 모델의 노멀은 Tangent Space에서 계산되지만
- 월드 공간에서 반사 방향을 계산해야 하므로 이 노드를 사용

## Reflection Vector
**카메라(view vector) 방향과 픽셀 법선을 이용해 반사 벡터를 계산**

- 카메라 위치 기준으로 월드 좌표계에서 반사 벡터 방향 출력 

```
I = normalize(P - C)                  // 입사 벡터 (카메라 → 표면)
R = normalize(I - 2*dot(N, I)*N)      // 반사 벡터
```

- 화면에서 픽셀이 어느 방향으로 반사되는지 알려줌
- 환경 맵(라이트맵, Lat-Long HDRI)에 반사 방향을 전달해 샘플링에 활용

---

{: .new-title}
> ❓ Custom Reflection Vector는 그냥 Reflection Vector랑 뭐가 달라?
> - Custom Reflection Vector는 사용자가 법선 벡터(Normal)와 카메라 벡터(Camera Vector)를 직접 지정함
> - 그 두개로 반사 벡터를 계산함

---

## LongLatToUV (Latitude-Longitude → UV 변환)
**월드 반사 벡터를 경위도 좌표로 변환해  LatLong 환경 맵의 UV 좌표를 얻음**

- LatLong(위도-경도) 환경 맵은 **구면 좌표계를 평면으로 펴서 저장한 텍스처**

```
입력: 반사 벡터(float3)
출력: UV(float2)
    - 이 UV로 LatLong HDRI 텍스처를 샘플링 
방향만 사용하며 위치·거리 개념 없음
```

---

## LatLong에서 seam이 생기는 이유
1. LatLong의 U좌표는 **0과 1에서 경계가 맞닿음**
   - u = 0.9999, 바로 옆 픽셀이 u = 0.0001이라면
   - `ddx(u) = 0.0001 − 0.9999 ≈ −0.9998`
   - 실제 공간에서는 서로 거의 붙어 있는 점인데, 수학적으로는 **1에 가까운 큰 변화량으로 계산**
   - **GPU는 이걸 급격한 변화로 오해하고 LOD를 아주 낮은 레벨 (블러된 mipmap) 로 샘플**
2. 반대편 픽셀은 정상적인 LOD를 샘플한다
3. LOD 불일치 → 경계선에 한 픽셀 두께의 seam (흰 줄 또는 흐림)이 생김

> 따라서 Texture Sampler의 Mip Value Mode를 바꿔줘야 함

---

### LOD (Level of Detail)
카메라에서 픽셀까지의 ‘화면상 크기’에 따라 어떤 해상도의 텍스처를 샘플링할지 결정하는 것

> 화면 공간(screen space) 에서의 UV 변화량(미분) 을 이용해서 적절한 Mipmap 레벨을 선택하는 과정

```
Level 0: 1024x1024 (원본)

Level 1: 512x512

Level 2: 256x256

...

Level 10: 1x1
```

---

## Mip Value Mode
텍스처 샘플러에서 옵션으로 LOD (MIP 레벨) 설정 가능

- 4가지 옵션이 있음

### None
GPU가 완전히 자동으로 최적의 밉 레벨을 계산하고 선택

1. 현재 렌더링 중인 픽셀과 바로 옆(x축) 및 바로 아래(y축) 픽셀의 텍스처 좌표(UV)를 비교
2. 이 좌표들의 차이를 통해 화면 공간에서 UV가 얼마나 빠르게 변하는지, 즉 **변화율(Derivative)**을 계산
3. 이 변화율이 크면 (카메라에서 멀거나 비스듬히 놓인 표면) 더 높은 밉 레벨(저해상도)
4. 변화율이 작으면 (카메라에 가깝거나 정면을 보는 표면) 더 낮은 밉 레벨(고해상도)을 선택

- 가장 기본적인 텍스처 샘플링 함수인 Sample이 바로 이 None 모드에 해당

```c++
// MyTexture: 텍스처 객체
// MySampler: 샘플러 상태 객체
// UV: 텍스처 좌표 (float2)

// GPU가 내부적으로 UV의 ddx, ddy를 계산하여 최적의 밉 레벨을 선택해 샘플링
float4 OutputColor = MyTexture.Sample(MySampler, UV);
```

---

### MipLevel
GPU의 자동 계산 기능을 완전히 끄고, 사용자가 MipLevel 입력 핀에 제공한 값으로 밉 레벨을 강제로 고정

1. 거리 변화에 적응하지 않음
2. 디버그 / 특수효과용

```c++
// MipLevelValue: 사용자가 직접 지정한 밉 레벨 (예: 2.0f)
float4 OutputColor = MyTexture.SampleLevel(MySampler, UV, MipLevelValue);
```

---

### MipBias
None 모드의 자동 계산을 기반으로 하되, 그 결과에 약간의 조작을 가하는 방식

1. None 모드와 마찬가지로 자동 계산
2. 사용자가 원하는 값을 입력 (예: `-1.0`)
3. 자동 계산 값 + 사용자 입력 값으로 Mip 레벨 정해짐

- GPU : 밉 레벨 3.5로 계산
- 사용자 : MipBias에 -1.0 입력
- 최종 : 2.5 레벨

```c++
// MipBiasValue: 자동 계산된 밉 레벨에 더할 값 (예: -1.0f 로 더 선명하게)
float4 OutputColor = MyTexture.SampleBias(MySampler, UV, MipBiasValue);
```

---

### Derivative
GPU가 밉 레벨을 계산하는 '판단의 근거' 자체를 사용자가 제공

- GPU의 자동 변화율 계산을 막고, DDX, DDY 핀으로 입력된 값을 사용해 밉 레벨을 결정하게 만든다

```c++
// ddx_uv, ddy_uv: 사용자가 직접 계산해서 제공하는 UV의 변화율 벡터
float4 OutputColor = MyTexture.SampleGrad(MySampler, UV, ddx_uv, ddy_uv);
```

---

❓**None도 ddx,ddy로 계산하는데 왜 seam이 생길까?**
- 계산 시점의 차이 때문!

| **구분** | **None (기본)**  | **Derivative (수동)**   |
| ddx/ddy 계산 주체 | GPU (자동)   | 사용자가 계산해서 넘김 |
| 계산 시점  | LatLong 변환 **후**     | LatLong 변환 **전**  |
| 경계 처리  | 0↔1 불연속값으로 계산됨 → 큰 값 | 연속좌표에서 계산됨 → 작은 값 |
| 결과 | seam 발생  | seam 없음  |

---

## Bump Map with DDX, DDY 예제
Bump Map에서 파생된 노멀 벡터를 DDX/DDY로 빠르게 계산하는 기법

1. **전통적인 방식**
   - 노멀 벡터를 얻기 위해 bump map을 3~4회 샘플링해서 기울기 계산 → 연산 비용 높음
2. **DDX/DDY 방식**
   - 한 번의 샘플 + ddx/ddy(미분값)으로 기울기(slope) 계산
   - 이 slope를 **법선 벡터(normal)**로 변환해 머티리얼에 전달
   - 저비용, 실시간 효과에 적합

---

## Bump Map with DDX, DDY 구현 과정
1. **Bump Map(Height Map) 텍스처 준비**
   - 흑백 이미지
   - 검정 = 낮은 곳 / 흰색 = 높은 곳
2. **Bump Map에서 높이 값 샘플링**
   - Texture Sample로 1회 샘플링
   - 높이값 h를 얻음
3. **DDX, DDY 계산**
   - DDX(h) → u방향 미분
   - DDY(h) → v방향 미분
   - 인접 픽셀의 높이 차로 기울기 계산
4. **Slope → Normal 변환**
   - x = -ddx(h), y = -ddy(h), z = 1
   - Normalize → World Space Normal 근사값
5. **공간 변환**
   - 출력은 월드 공간 법선
   - 머티리얼 Root의 Normal 입력은 보통 Tangent Space이므로
   - Transform Vector (World → Tangent) 노드로 변환
6. **강도 조정**
   - 기본 값은 매우 부드럽고 약한 bump
   - Flatten Normal 노드로 강도(contrast)를 올려 시각적 효과 강화
7. **결과 연결**
   - 변환 및 강화된 normal을 머티리얼의 Normal 핀에 연결

---

## Flatten Normal 노드
bump map이나 normal map에 디테일을 추가할 경우 X, Y가 커질수록 Z는 작아지고 표면이 “더 거칠게” 보임

- Flatten Normal은 노멀 벡터의 **XY 성분의 비중을 조절해서 표면의 기울기를 강화하거나 약화한다**

### 사용 목적
1. **Bump/Normal 강도 조절**
   - XY 기울기가 약한 경우 → Flatness를 낮춰 강도 강화
   - XY 기울기가 강한 경우 → aliasing 우려 시 Flatness를 높여 완화
2. **Detail Normal Blending 전 처리**
   - 여러 노멀을 블렌딩하기 전에 강도를 통일
3. **Alias/Shimmering 완화**
    - 강한 bump는 원근 시 aliasing이 발생하기 쉬움 → 적절히 flatten해서 안정화
4. **Shader Optimization**
    - 별도의 normal map scale 연산 없이 간단히 강도 조절 가능

> 이 노드는 XY만 조정하고 Z를 재계산하기 때문에 방향은 유지하지만 “경사 각도”는 변함

- Flatten Normal의 Flatness 값이 음수가 되면

```
(1 − Flatness) = ( 1 − (−0.5)) = 1.5
```

- 평탄화 강도별 예시

```
Flatness = 0
→ XY 유지

Flatness = 0.5
→ XY × 0.5 → 부드러움 증가

Flatness = -0.5
→ XY × 1.5 → XY가 커짐 → Z가 작아짐
→ 각도가 더 기울어짐
```

적당한 음수 (예: **-0.1 ~ -0.5**) 정도는 bump 강도를 높이는 데 쓸 수 있지만 너무 크면 법선이 깨짐

---

### 입력
Normal Map 텍스처가 아니라 이미 법선 벡터로 변환된 값을 입력으로 받는다

1. **Normal**
    - float3
    - Tangent 또는 World Space의 법선 벡터
2. **Flatness**
    - float
    - 평탄화 강도 (0 = 그대로, 1 = 완전히 평탄하게)

### 출력
출력 길이는 항상 1에 가깝게 정규화됨

- Tangent Space 입력이면 Tangent Space 출력
- World Space 입력이면 World Space 출력

1. **Flattened Normal**
   - float3
   - XY 기울기가 조정된 법선 벡터

---

## Perturb Normal LQ 노드
Unreal에 기본 내장된 함수 노드

- 위 과정을 직접 만들 필요 없이 한 번에 bump map → normal 계산
- LQ = Low Quality
    - DDX/DDY로 인접 픽셀만 참조
    - 고품질 필터링 불가능 → 블록 노이즈나 거친 결과 가능
- Perturb Normal HQ 버전도 있음 (고비용)

```
[경로]

Engine Content → Functions → Engine Material Functions 3 → Procedurals → Perturb Normal Low Quality
```
