---
layout: default
title: "42. UV Transform"
parent: "EP [41, 50]"
nav_order: 2
---

# 42. UV Transform
uv 회전, 스케일, 이동

```
42 ~ 44 한번에 적음
```

---

# UV Rotation

각도 사용해 uv 회전하기

- 2D 좌표를 중심점(pivot)을 기준으로 회전시키는 기본적인 2×2 회전 행렬을 적용
- 회전 입력값 : 0–1 범위를 기준으로 전체 360°(2πrad) 회전
    - 예: 0.25 → 90°, 0.5 → 180°, 1.0 → 360°
- 해당 입력값을 **도(degrees)로 받게끔 변경 (DegreesToRadians노드 사용)**

---

## 기본으로 제공되는 rotation 노드

### rotator
UV 좌표 회전. 내부적으로 cos·sin 수식이 이미 구현되어 있음

**입력**
1. Coordinate (UVs)
    - 회전시킬 입력 좌표
2. Time
    - 회전 속도 제어용
3. Center
    - x,y 회전축 중심점

**출력**
회전된 uv 좌표

---

### custom rotator
고정된 각도(Scalar 입력)로 UV를 회전시키기 위한 노드

**입력**
1. Coordinate (UVs)
    - 회전시킬 입력 좌표
2. Rotation Angle
    - 회전각도 라디안 (0~1)
3. Center
    - x,y 회전축 중심점

**출력**
회전된 uv 좌표

---

## 그래프 예제

1. Texcoord - (0.5, 0.5)
    - **uv 중심축을 데카르트 좌표계와 맞추기**
2. texcoord 를 마스크로 각각 u,v 나눔
2. scalar(degrees) → DegreesToRadians → 각각 cosine(x), sine(y)에 입력
3. 회전 계산
    - 회전 행렬 공식에 적용
    - **(cosine * u) + (sine * v)**
    - **(cosine * v) - (sine * u)**
4. 회전 계산 각각의 값을 append + (0.5, 0.5)
    - **중심축 다시 원래 좌표로 옮겨놓기**

> 회전은 원점 기준이기 때문에 좌표계를 맞추는 보정 절차가 필요


### 예시

| 단계 | 설명  | 수식 표현  | 목적  |
| -- | --- | --- | --- |
| 1  | 데카르트 좌표계 기준 (0,0)이 중심   | 기준 원점                   | 회전 수학의 기본         |
| 2  | UV 원점은 좌상단 (0,0)        |                         | 좌표계 차이 인식         |
| 3  | UV 중심(0.5,0.5)을 원점으로 이동 | `UV - (0.5, 0.5)`       | 회전 중심을 UV 중앙으로 이동 |
| 4  | 이동된 좌표를 원점 기준으로 회전      | `R(θ) * (UV - 0.5)`     | 데카르트 회전 수식 적용     |
| 5  | 다시 UV 공간으로 복귀           | `R(θ)*(UV - 0.5) + 0.5` | 좌표계 재정렬           |

---

# 43. UV Transform
uv를 변환하기 위해서는 순서와 좌표 중심처리가 중요하다

> UV 좌표는 0,1 범위이므로, 스케일이 먼저 들어가면 Pivot의 상대적 위치가 달라짐
> - 스케일을 먼저 하면 회전 전에 UV 공간 자체가 찌그러지므로 회전 축이 어긋남

```
1. 피벗 빼기 // 좌표축 데카르트 좌표계로 이동
2. 회전 변환
3. 스케일 변환
4. 피벗 더하기 // 좌표축 원점으로 돌림
5. 이동 // 좌표축 원점으로 돌아온 뒤 이동
```

따라서

1. 회전 변환
2. 1번 결과 * (mul(scale))
3. 2번 결과 + add(pivot)
4. 3번 결과 + add (offset.x, offset.y)

---

# 44. MF_RandomTransformUV
머리티얼 그래프에는 random 노드 존재 x

- **noise, vector noise (perlin 등) 으로 난수 패턴 제공됨**

### 그래프 예제
예전에 만든 hash32를 uv random seed로 사용하여 min~max 조절

1. randomSeed input (V2)를 mf_hash23과 연결
2. splitComponents로 3개의 랜덤 난수 사용가능
3. offset(hash23.x, hash23.y)
4. scale(lerp(scaleMin, scaleMax, hash23.z))
5. 3개 난수는 이미 사용했으므로 T = (hash23.x * 6 / frac)으로 4번째 난수 생성
6. rotation(lerp(rotationMin, rotationMax, hash23.T))

> randomSeed 값에 noise 텍스쳐 사용 가능
> - texCoord도 타일링 하기

7. noise텍스쳐 * scalar
8. 7번 결과 round로 정수화
9. randomSeed로 넣기

---

## 기본으로 제공되는 noise 노드

### noise
좌표 기반 2D 노이즈 생성

**입력**
1. world position
    - 노이즈를 샘플링할 공간 좌표
2. filter width
    - 1이면 검정
    - 0에 가까울수록 흰색 노이즈 더 많이 생성

**출력**
0~1 범위의 스칼라 노이즈 값

---

### vector noise
좌표 입력(Position) → 벡터 출력(float3). UV 왜곡, 흐름장, 방향성 마스크에 사용

**입력**
1. Position(float3)
    - 노이즈를 샘플링할 공간 좌표
2. Noise Type, Quality, Tiling
    - 퀄리티, 타일링의 경우 높을수록 비용 증가
    - 타일링 < 0 이면 주기적 패턴

**출력**
float3 벡터. 보통 XY 또는 XY * strength를 UV에 더해 왜곡에 사용

---
