---
layout: default
title: "1. Quick Asset Actions"
parent: "Create Custom Editor Tools"
nav_order: 2
---
# 1. Quick Asset Actions
---

# 모듈
모듈은 언리얼 엔진의 구성 블록이다.
에디터를 만들려면 자신만의 모듈을 만들어야 한다.

## 모듈에서 알아야 할 세가지 주요 포인트

- 모듈은 코드 분리를 강제한다.
    - 여러 개의 무작위 코드들이 서로 소통해야 할 때 매우 유용하다
- **모든 모듈은 Build.cs 파일이 필요**하다.
  -  새 프로젝트 자체도 하나의 모듈이다.
  -  모듈은 자신의 빌드 파일을 가진다.
```
[ModuleName].Build.cs
[ProjectName].Build.cs
```
- 모듈은 Build.cs 파일에 추가하여 포함할 수 있다.
  - 다른 모듈에 위치한 헤더 파일을 포함해야 할 때 해당 헤더의 모듈 이름을 Build.cs 파일에 추가한다.
  - 보통  `PublicDependencyModuleNames`에 모듈 이름을 추가하는 경우가 많다

## 플러그인 생성하기
1. 언리얼 상단 메뉴  Edit > Plugins 클릭
2. 왼쪽 상단의 +ADD 버튼 클릭
3. 여러가지 템플릿 목록에서 선택 (현재는 Blank 선택)
  - 플러그인 이름이 곧 모듈 이름이다.
  - 한번 정하면 변경할 수 없다.
4. Create Plugin 버튼 클릭
5. 비주얼 스튜디오로 돌아가 모두 로드 버튼 클릭
- 프로젝트 소스 폴더 위에 플러그인 폴더 생성된 것 확인

```c++
// .uplugin
	"Modules": [
		{
			"Name": "BackgroundTool",
			"Type": "Editor", // 만들 기능은 에디터 전용이므로 Runtime(게임 동작시 실행되는 타입) -> Editor로 변경
			"LoadingPhase": "PreDefault" // 플러그인이 언제 로드될지 결정함. PreDefault: 게임 모듈보다 먼저 로드됨
		}
	]
```

## 액터와 에셋
- **에셋** : 콘텐트 브라우저 안에 존재하는 것 (머티리얼, 스태틱 매시 등)
  -  에셋은 `AssetActionUtility`라는 내장 클래스를 사용
- **액터** : 레벨(뷰) 안에 존재하며 클릭할 수 있는 것
  -  액터는 `ActorActionUtility`라는 클래스를 사용

## Public/Private
- 모듈을 하나 생성할 때 Pubilc, Private 폴더를 나눠서 생성할 수 있음
  - **Pubilc** : 헤더
  - **Private** : cpp 소스 코드 

## build.cs
- 인클루드 된 헤더에 빨간 밑줄 : 현재 모듈이 이 헤더 파일에 **접근할 권한 없음**

**접근권한 해결하기**  
1. 솔루션 탐색기에서 해당 헤더 검색 후 헤더가 들어있는 모듈 찾기
2. 해당 모듈의 build.cs 소스 코드에 각각 private, pubilc 모듈 경로를 찾을수 있음
3. 내가 쓸 build.cs에 private, pubilc에 해당하는 경로 붙여넣기

## 테스트용 에셋 함수 구동하기 (5.3 이상)
**함수 준비하기 : 플러그인 콘텐트**
1. 플러그인의 콘텐트 폴더로 이동
2. 플러그인 콘텐트 브라우저에서 마우스 오른쪽 버튼 클릭
3. 에디터 유틸리티 -> 에디터 유틸리티 블루 프린트 -> 에셋 액션 유틸리티 선택하여 생성성
4. 더블 클릭하여 해당 에셋을 열고 우측 상단의 파일 클릭
5. 부모 블루프린트 -> 내가 만든 c++ 클래스 입력
6. 컴파일 및 저장 클릭

**함수 사용하기**
1. 메인 콘텐트에서 Blueprint 폴더 생성
2. Blueprint 클래스 생성
3. 해당 클래스 우클릭 -> Scripted Asset Actions
4. 플러그인 콘텐트에서 추가한 c++ 클래스가 보임
5. 클릭하여 동작 확인 가능  

## 디버그 헤더 만들기
1. 플러그인 안의 폴더를 오른쪽 버튼으로 클릭
2. 새 항목 추가 선택
3. 추가 창이 뜨면 위치를 플러그인 -> 모듈 -> public 폴더로 선택
4. 만들 유형 헤더로 선택하고 Debug.h 이름 지정
5. Debug.h의 함수를 사용할 cpp 파일에 #include "Debug.h" 추가

```c++
void PrintMessage(const FString& Message, const FColor& Color)
{
	if (GEngine)
	{
		GEngine->AddOnScreenDebugMessage(-1, 8.f, Color, Message); // 화면 좌상단에 출력
	}
}

void PrintLog(const FString& Message)
{
	UE_LOG(LogTemp, Warning, TEXT("%s"), *Message); // 콘솔 로그창에 출력
}
```

# Scripting Libraries
### 1. UEditorUtilityLibrary::
에디터에서 에셋(Asset) 관련 작업을 자동화하기 위한 기능 제공
  - **에셋의 로드, 저장, 복사, 이동, 삭제 등 파일 시스템 수준의 작업**
  - **에셋 메타데이터(metadata) 접근 및 수정**
  - 에셋 의존성(dependencies) 분석
  - 에셋 브라우저(Content Browser)와 연동된 작업

### 메소드
  - GetSelectedAssetData() : `TArray<FAssetData>`를 반환
  - GetSelectedAssets() :  `TArray<UObject*>`를 반환
    - FAssetData는 UObject* 보다 더 많은 정보를 포함
  - 모두 static 함수임

### 2. UEditorAssetLibrary:: 클래스
에디터 UI 및 일반 유틸리티 작업을 지원
   - **선택된 객체(Selected Actors/Assets)에 접근**
   - 에디터 UI(알림, 다이얼로그) 제어
   - 월드/레벨 편집과 관련된 작업
   - 블루프린트/파이썬 스크립트와의 연동 용이

### 정리
- 에디터 상호작용 (선택된 객체 제어, 알림 표시, 다이얼로그 생성) → UEditorUtilityLibrary
- 에셋 작업 (일괄 임포트, 이름 변경, 메타데이터 편집) → UEditorAssetLibrary

>
- UEditorUtilityLibrary로 선택한 에셋을 가져온 후 UEditorAssetLibrary로 해당 에셋을 수정

# .uasset
Unreal Engine이 **에디터에서 사용하는 에셋(데이터) 저장 파일 포맷 (파일 확장자)**
- 모든 에셋은 UObject를 상속한 특정 클래스(예: UMaterial, UStaticMesh 등)로 만들어진다
- **에디터에서 만드는 에셋은 각기 다른 UObject 파생 클래스의 인스턴스가 디스크에 .uasset으로 저장된 것**
  - BP_NewBlueprint.uasset
  - MyMaterial.uasset

## 객체 식별
  - **Asset Name**: 에셋(객체) 이름. 에디터에서 보이는 에셋의 이름
    - (예: BP_NewBluePrint)
  - **Package Path**: 에셋이 저장된 폴더 경로 + 에셋 이름
    - (예:/Game/MyFolder/BP_NewBluePrint)
    - **'패키지'란 언리얼에서 하나의 저장 단위**
    -  **하나의 .uasset 파일 = 하나의 패키지**
       - 패키지 파일(.uasset) 안에는 여러 객체(에셋)가 저장 될 수 있음 
    -  패키지 경로는 항상 /로 시작
    -  패키지 경로에는 .uasset 확장자가 포함되지 않음
  - **Object Path**:  패키지 경로 + `.에셋(객체) 이름`
    - (예: /Game/MyFolder/BP_NewBluePrint.BP_NewBlueprint)
    - 패키지 내부에는 여러 객체가 있을 수 있으므로, 반드시 객체 이름까지 명시해야 객체를 특정할 수 있다

## duplicate 함수 구현에 사용한 메서드
### 1..ToString()
  - FString, FName, FText, FVector, FGuid 등 일부 엔진 주요 클래스에서 각 타입에 맞는 방식으로 문자열 변환

### 2.FString::FromInt()
- 정수형 값을 FString 객체로 변환하는 정적(static) 메서드

- 매개변수
  - int32 Value: 변환할 정수 값
- 반환값
  - FString: 정수를 문자열로 변환한 결과

```c++
int32 Number = 42;
FString Str = FString::FromInt(Number); // "42"
```
### 3.FPaths::Combine()
- 여러 개의 경로 문자열을 OS별로 올바른 구분자로 결합해 하나의 경로 문자열로 만듦.
	- 내부적으로 /, \ 자동 정리

- 매개변수
  - 오버로드가 많으나, 대표적으로 다음과 같은 버전
  -  const FString& PathA, const FString& PathB
- 반환값
  - FString: 결합된 경로 문자열

```c++
FString FullPath = FPaths::Combine(TEXT("C:/Project"), TEXT("Content"), TEXT("Textures"));
// "C:/Project/Content/Textures"
```

### 4.UEditorAssetLibrary::DuplicateAsset()
- 에디터 전용 라이브러리 함수. Content Browser에서 특정 자산(에셋)을 **지정 경로로 복제(복사)**함

- 매개변수
  -  const FString& SourceAssetPath: 원본 자산의 경로
     -  (예: "/Game/StarterContent/Textures/T_Wood")
  -  const FString& DestinationAssetPath: 복제될 위치의 경로
     -  (예: "/Game/MyFolder/T_Wood_Copy")
- 반환값
  -  UObject*: 복제된 자산의 포인터
     -  (복제 실패 시 nullptr 반환)

```c++
UObject* Duplicated = UEditorAssetLibrary::DuplicateAsset(TEXT("/Game/AssetA"), TEXT("/Game/Folder/AssetB"));
if (Duplicated) { /* 성공 */ }
```

### 5.UEditorAssetLibrary::SaveAsset()
- 에디터에서 지정한 자산(에셋)을 디스크에 저장

- 매개변수
   - const FString& AssetPath: 저장할 자산의 경로 (예: "/Game/MyFolder/AssetB")
- 반환값
	- bool (true: 저장 성공 / false: 저장 실패)

```c++
bool bSaved = UEditorAssetLibrary::SaveAsset(TEXT("/Game/MyFolder/AssetB"));
```

### 6.TEXT()
- C++의 **문자열 리터럴을 엔진 내부 문자 타입(TCHAR)**로 변환하는 매크로 
   - TEXT() 매크로는 C++의 매크로 전처리 기능을 사용

```c++
FString MyString = TEXT("Hello");
// ↓ 매크로 확장 후
FString MyString = L"Hello";  // C++ 컴파일러가 처리할 코드 생성
```
- L"Hello" :  UTF-16/유니코드 문자열 리터럴로 컴파일

# Custom Editor Message
- FMessageDialog를 사용해 메시지 대화 상자 출력하기 (모달)
- FNotificationInfo를 사용해 알림 정보 출력하기 (오른쪽 하단에 나타나는 비동기 알림)

## FMessageDialog
- 에디터 환경에서 사용자에게 메시지 박스(모달 대화상자)를 띄울 때 사용하는 유틸리티 클래스
- core 소속
- **블로킹(Blocking) 방식으로, 다이얼로그가 닫히기 전까지 다음 코드가 실행되지 않음**
- 정적(static) 메서드로만 구성

### 1. FMessageDialog::Open(EAppMsgType::Type MsgType, const FText& Message)
- 지정한 메시지 유형과 메시지 텍스트로 다이얼로그 표시

### 2. EAppReturnType::Type
```c++
EAppReturnType::Type ShowMsgDialog(
    EAppMsgType::Type MsgType, 
    const FString& Message, 
    bool bShowMsgAsWarning = true
)
```
- MsgType: 메시지 박스 버튼 조합(Ok, YesNo 등) 지정
- Message: 출력할 메시지 문자열
- bShowMsgAsWarning: 경고(Warning) 스타일로 메시지를 띄울지 여부, 기본값 true
   - true면 경고 스타일(노란색 경고 아이콘, "Warning" 타이틀 등)로 표시
   - false면 일반 정보 스타일(파란색 info 아이콘, "Message" 또는 "Info" 타이틀 등)로 표시

**EAppMsgType::Type 정리**

| 타입| 다이얼로그 버튼 조합  | 대표적 사용 상황 |
|---|---|---|
| `Ok`     | OK   | 단순 확인, 정보 알림  |
| `YesNo`  | Yes / No   | 선택(이행/거부)  |
| `YesNoCancel`  | Yes / No / Cancel| 저장 여부 등 3분기 선택|
| `OkCancel`     | OK / Cancel| 진행/중단   |
| `CancelRetryContinue`| Cancel / Retry / Continue     | 재시도 여부(예: 파일 저장 실패) |
| `YesNoYesAllNoAll`   | Yes / No / Yes to All / No to All   | 여러 작업에 대해 일괄 처리 |
| `YesNoYesAllNoAllCancel`   | Yes / No / Yes to All / No to All / Cancel| 여러 파일 작업에서 개별/일괄/취소 |
| `YesNoCancelContinue`| Yes / No / Cancel / Continue  | 드문 복합적 분기     |
| `YesNoYesAllNoAllCancelContinue` | Yes / No / Yes to All / No to All / Cancel / Continue | 매우 복잡한 결정     |


## FNotificationInfo
- 에디터 하단 (주로 오른쪽 아래)에 잠시 나타나는 비동기 알림(Notification Toast) 정보를 정의하는 구조체
- `FSlateNotificationManager`를 통해 **실제 알림을 생성/표시**
- slate 소속

```c++
FNotificationInfo Info(FText::FromString(TEXT("작업이 완료되었습니다.")));
Info.bFireAndForget = true;
Info.ExpireDuration = 2.0f; // 2초 후 자동 닫힘
Info.bUseThrobber = false; // 스피너 비표시

FSlateNotificationManager::Get().AddNotification(Info);
```

# Add Prifixes To Assets
- TMap<UClass*, FString> PrefixMap 에 Prifixes 목록 작성
  - 예: `{UBlueprint::StaticClass(),TEXT("BP_")}` 

## add Prifixes 함수 구현에 사용한 메서드
### 1. UObject* S->GetClass()->GetName()
- **클래스 이름**을 반환
  -  **(예: "AActor", "UMyComponent")**
- 해당 오브젝트가 어떤 클래스로 생성되었는지 알 수 있음


### 2. UObject* S->GetName()
- **오브젝트 인스턴스의 이름을 반환**
  - **(예: "Player_123", "Weapon_Sword")**
- 에디터에서 부여한 이름이나 동적으로 생성된 이름이 반환

```c++
AActor* MyActor = GetWorld()->SpawnActor<AActor>(...);
FString ClassName = MyActor->GetClass()->GetName();  // "AActor"
FString InstanceName = MyActor->GetName();           // "MyActor_42"
```

### 3. FString::StartsWith()
- 문자열이 **특정 문자열로 시작하는지 여부를 bool로 반환**
- 대소문자 구분 여부 선택 옵션 존재
- 주의 : InPrefix가 **빈 문자열이면 항상 true를 반환**

### 함수 시그니처
```c++
bool StartsWith(
    const FString& InPrefix, 
    ESearchCase::Type SearchCase = ESearchCase::IgnoreCase
) const;
```
### 사용 예시
```c++
FString FilePath = "Content/Textures/PlayerTexture.png";

// 대소문자 무시 (기본값)
bool bIsContent = FilePath.StartsWith("Content"); // true

// 대소문자 구분
bool bIsExact = FilePath.StartsWith("content", ESearchCase::CaseSensitive); // false

// 실제 활용 예시
if (FilePath.StartsWith("Content/Textures/"))
{
    UE_LOG(LogTemp, Warning, TEXT("텍스처 경로가 유효합니다."));
}
```

### 4. FString::RemoveFromStart
- 대상 문자열의 앞부분이 특정 문자열로 시작할 경우, 해당 부분을 제거

```c++
bool RemoveFromStart(const FString& InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase);
```
- 매개변수
  - InPrefix: 앞에서 제거하고자 하는 문자열(접두사, Prefix)
  - SearchCase: 대소문자 구분 여부 (ESearchCase::IgnoreCase 또는 ESearchCase::CaseSensitive)
- 반환값
  - 제거 성공 true / 실패 false 

### 5. FString::RemoveFromEnd
- 대상 문자열의 끝이 특정 문자열로 끝날 경우, 해당 부분을 제거
- 위 메서드와 동일하게 뒤에서 제거하고자 하는 문자열과 대소문자 구분 여부를 받는다.

```c++
FString Str = TEXT("HelloWorld");
bool bRemoved = Str.RemoveFromEnd(TEXT("World")); // Str은 "Hello"가 되고, bRemoved는 true

FString Str2 = TEXT("HelloWorld");
bool bRemoved2 = Str2.RemoveFromEnd(TEXT("Hi"));  // Str2는 그대로 "HelloWorld", bRemoved2는 false
```

### 6. UObject::IsA<T>()
- 해당 오브젝트가 **특정 클래스 타입이거나 그 클래스의 자식 클래스인지를 확인하는 메서드**
- 비슷한 경우로 `IsA(UClass*)` 가 있다

### 예시
```c++
// IsA<T>()
template<typename T>
FORCEINLINE bool IsA() const
{
    return IsA(T::StaticClass());
}

if (SelectedObject->IsA<UMaterialInstanceConstant>()) 
{
    // UMaterialInstanceConstant 타입일 때 실행
}

// IsA()
bool IsA(const UClass* TargetClass) const;

if (SelectedObject->IsA(AActor::StaticClass())) 
{
    UE_LOG(LogTemp, Warning, TEXT("이 오브젝트는 Actor입니다!"));
}
```

{: .new-title}
> ❓ 왜 머티리얼 인스턴스 클래스를 찾으려면 `UMaterialInstanceConstant`를 사용해야 할까?

- 계층구조
```
UMaterialInterface (베이스)
├─ UMaterial (실제 마테리얼 에셋)
└─ UMaterialInstance (인스턴스 베이스)
            ├─ UMaterialInstanceDynamic (런타임 생성 인스턴스)
            └─ UMaterialInstanceConstant (에디터에서 생성된 인스턴스)
```

>
- **UMaterialInstance**
  - **추상 베이스 클래스.** 직접 인스턴스화되지 않음
- **UMaterialInstanceConstant**
  - **에디터에서 미리 생성해 놓은 정적 마테리얼 인스턴스**
  - 런타임 중 파라미터 변경이 불가능
- **UMaterialInstanceDynamic (MID)**
   - **런타임에 동적으로 생성되며, 파라미터를 실시간으로 변경할 수 있음**

# Asset Referencers
- 레벨에서 사용된 에셋의 경우 Asset References(에셋 참조)가 존재함
- 즉 미사용 상태의 에셋의 경우 참조 개수 = 0

## AssetRegistry
모든 프로젝트 에셋의 메타 데이터를 인덱싱/검색/관리하는 중앙 관리 모듈

- 에디터 구동 시 **모든 프로젝트 에셋(.uasset, .umap 등)**을 빠르게 탐색/관리할 수 있도록 내부적으로 모든 에셋의 **메타데이터를 스캔**
- 에셋 인덱싱: 실제 에셋 객체(UObject 등)는 메모리에 로드하지 않고, 각 에셋의 메타 데이터를 메모리에 인덱싱 (`FAssetData 생성`)
- 빠른 검색: 이름, 클래스, 태그 등 다양한 조건으로 에셋을 빠르게 조회
- 런타임/에디터 지원: 런타임 자동화, 에디터 UI, 플러그인 등에서 활용

## FAssetData
에셋에 대한 "경량 메타데이터"를 저장하기 위해 설계된 구조체

- Asset Registry는 FAssetData의 집합
- 실제 에셋의 전체 데이터나 객체는 아님
- `AssetRegistry`를 통해 조회 시 `TArray<FAssetData>`로 반환됨

## Remove Unused Assets 함수 구현에 사용한 메서드
### 1. UEditorAssetLibrary::FindPackageReferencersForAsset
- 특정 에셋(Asset)을 참조하는 모든 패키지(Package)의 목록을 찾아 반환
- 에셋 의존성 분석에 사용. 특히 **에셋을 삭제하거나 수정할 때 어떤 다른 에셋들이 영향을 받을지 확인**
- 에이터 전용 기능

```c++
static TArray<FString> UEditorAssetLibrary::FindPackageReferencersForAsset(
    const FString& AssetPath,
    bool bLoadAssetsToConfirm = false
);
```
- 매개변수
  - AssetPath (필수): 분석할 대상 에셋의 경로 (Object path)
  - bLoadAssetsToConfirm (옵션, 기본값 false)
    - true: 참조하는 패키지를 메모리에 로드하여 정확성을 확인 (느리지만 정확하다)
    - false: 에셋 레지스트리(Asset Registry)의 메타데이터만 사용하여 빠르게 검색 (빠르지만 간접 참조 누락 가능)
- 반환 값
  - 참조하는 패키지의 경로 문자열(FString) 배열 (TArray<FString>)
  - 에셋이 사용되지 않으면 빈 배열 반환

### 2. Num()
- 컨테이너에 저장된 **요소의 개수(길이)**를 반환
- c++의 .Size()와 같음

### 3. ObjectTools::DeleteAssets(UnusedAssetsData);
Asset들을 안전하게 일괄 삭제하는 유틸리티

```c++
// UnrealEd 모듈 내 ObjectTools.h 선언부
static bool DeleteAssets(const TArray<FAssetData>& AssetDataList, bool bShowConfirmation = true, bool bForceDelete = false);
```
- 대표적으로 FAssetData 배열을 인자로 받음 (다른 타입 매개변수 사용 가능)

### 동작과정
1. 입력 받은 FAssetData 리스트에서 **실제 에셋 객체(UObject)를 찾아옴**
2. **에셋이 참조되는지 (Reference Graph) 검사**
  - 다른 에셋이나 오브젝트에서 참조하고 있는 경우, 경고 대화창을 띄워 사용자에게 확인 받음
  - 옵션에 따라, 강제 삭제(bForceDelete) 가능
3. 사용자에게 **삭제 확인(Confirmation) 요청**
  - bShowConfirmation 인자가 true일 경우, 실제 삭제 전에 "정말 삭제할까요?"와 같은 확인창 표시
4. **트랜잭션 생성 및 삭제 실행**
  - **삭제 과정 전체를 에디터 트랜잭션(Undo/Redo)에 등록 → 실수 시 실행 취소 가능**
  - 내부적으로 FScopedTransaction을 사용하여 트랜잭션 단위로 관리
5. 실제 삭제
  - 에셋을 Content Browser 및 파일 시스템(디스크)에서 제거
  - 참조된 경우, 일부 삭제가 제한되거나, 사용자가 강제 삭제시 후처리(레퍼런스 클린업 등) 발생
6. 결과 반환
  - 성공적으로 삭제된 경우 true, 실패 또는 취소시 false 반환

## ObjectTools.h
에디터 환경에서 UObject 관련 유틸리티 함수 집합을 정의한 헤더 파일
- 삭제/이동/복사 동작과 관련해, **사용자에게 경고 및 결과 알림 대화창을 띄워줌**
- UnrealEd 모듈에 소속
  - 런타임 환경(게임 실행)에서는 사용 불가. 에디터에서만 사용하는 기능

# Redirector
에셋이 이동하거나 이름이 변경되었을 때 기존 참조를 유지하기 위해 사용
- 에디터의 콘텐트 브라우저에서 이동하거나 변경하면 자동으로 생성함
- 탐색기나 터미널을 사용하여 에셋 이동 시 리다이렉터가 생성되지 않음
  - 에디터 API 를 사용하는 경우는 리다이렉터 정상 생성 
- 리다이렉터가 많아지면 빌드/로딩 속도가 느려짐 -> 정리 필요
- 콘텐츠 브라우저에서 우클릭 → '레퍼런스 뷰어'로 참조 관계 확인

## 리다이렉터가 필요한 이유
1. 언리얼 엔진 프로젝트는 에셋 간의 참조(Reference) 관계가 복잡하게 얽혀 있음
2. 만약 어떤 블루프린트, 머티리얼, 레벨 등이 특정 에셋을 참조하고 있는데, 그 에셋의 위치나 이름이 바뀌면 기존 참조가 모두 깨짐
3. 이 문제를 방지하기 위해, 기존 위치(예전 경로)에 ‘리다이렉터’ 에셋을 생성함
4. 이 리다이렉터 에셋은 “이 에셋은 이제 새로운 위치에 있습니다”라고 알려줌으로써, 예전 참조들이 새 위치의 에셋을 계속 사용할 수 있게 해줌

## 리다이렉터 작동 방식
### 1. 디스크(파일) 저장
리다이렉터는 ObjectRedirector 타입의 `.uasset` 파일로 저장
  - 자신이 원래 위치했던 경로(Original Path)
  - 참조해야 하는 대상 오브젝트(DestinationObject, 새 경로의 에셋에 대한 소프트 참조) 가 저장됨
  - 이 상태의 리다이렉터는 그냥 하나의 "Proxy" 에셋(패키지)일 뿐이며, 실제 오브젝트 인스턴스(UObject 인스턴스)는 생성되어 있지 않음

### 리다이렉터 에셋 개념적 구조

```c++
// ObjectRedirector.uasset (실제 파일은 바이너리이지만, 개념적으로 다음과 같은 정보를 저장)
{
    "OriginalObjectPath": "/Game/Characters/OldCharacter",  // 원본 경로
    "DestinationObjectPath": "/Game/Heroes/NewCharacter",   // 새 경로 (SoftObjectPath)
    "Flags": RF_Public | RF_Standalone,                     // 객체 플래그
    "DestinationObject": "Soft Reference"                   // 실제로는 포인터가 아니라 소프트 참조(경로 정보) 형태
}
```

### 2. 메모리 로드(에디터/엔진에서 참조할 때)
1. 리다이렉터가 메모리로 로드됨
  - 어떤 에셋이 리다이렉터 경로를 참조하고 있을 때, 언리얼은 먼저 리다이렉터(.uasset) 파일을 로드해서 UObjectRedirector 인스턴스로 메모리에 올림
2. DestinationObject로 즉시 변환
  - 엔진은 리다이렉터를 참조하는 순간, DestinationObject(실제 에셋)를 메모리로 로드하고 참조를 자동으로 대체함

## Fix Redirectors 함수 구현에 사용한 메서드
Fix 과정의 핵심
- 모든 리다이렉터를 탐색
- 각 리다이렉터의 DestinationObject를 메모리에 로드
- 예전 참조(리다이렉터 경로)를 새 참조(DestinationObject 경로)로 교체
- 리다이렉터 파일 삭제

### 1. IAssetRegistry& AssetRegistry
에셋 레지스트리 가져오기

{: .new-title}
> ❓ 왜 인터페이스 레퍼런스 타입으로 가져오는거야?
>
- `AssetRegistry`는 엔진 내부적으로 이미 생성되어 관리되는 객체
- new로 직접 인스턴스를 만들면, **엔진의 전역 에셋 DB와 분리된 “쓸모 없는 객체”**가 만들어짐
- 즉, 반드시 엔진이 소유/관리하는 인스턴스를 사용해야 하며, 이를 제공받는 공식 경로는 아래와 같다.

```c++
FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get()
```

## 함수명에 붙은 Checked란?
함수명에 "Checked"가 붙었을 때는 무조건 성공해야 하며, 실패 시 프로그램을 즉시 중단(Assert/Crash)한다는 의미
- CastChecked (타입 불일치 → 크래시)
- LoadModuleChecked (모듈 없음/실패 → 크래시)

### 비교 예시

| 함수  | 동작   | 실패 시 |
|---|---|---|
| LoadModule<T>()      | 모듈 로드, 실패 시 nullptr 반환             | 안전         |
| LoadModuleChecked<T>() | 모듈 로드, 실패 시 Assertion Failure(크래시) | 위험 (강제 중단) |
| GetModule<T>()       | 이미 로드된 모듈만 반환, 없으면 nullptr         | 안전         |


### 2. FModuleManager::LoadModuleChecked<T>
엔진/에디터 모듈을 런타임에 안전하게 로드

- FModuleManager::
  - 모듈 동적 로딩 시스템을 관리하는 핵심 클래스
- LoadModuleChecked<T>()
  - 템플릿 함수로, 지정된 모듈 타입(T)을 강제로 로드하고 검증 후 반환
  - 모듈이 존재하지 않으면 크래시

### 동작
1. ModuleName에 해당하는 모듈이 이미 로드되어 있으면
  - → 바로 그 모듈의 레퍼런스(포인터/레퍼런스)를 반환
2. 아직 로드되지 않았다면
  - 모듈을 로드(동적 DLL 또는 엔진 플러그인 로딩) 시도
  - 성공하면 인스턴스 반환
  - 실패시 크래시
3. 반환 타입은 T& (예: FAssetRegistryModule&)

### 3. CastChecked<T>()
주어진 포인터가 실제 런타임에 T 타입(혹은 그 하위 타입)인지 체크한 뒤, 맞으면 T로 변환해서 반환
- 틀리면 **에디터 빌드(Development/Debug)**에서는 **강제로 크래시(Assertion 실패)**를 일으킴

### CastChecked<T>와 Cast<T>의 차이

| 함수| 타입 체크 실패 시 동작 | 주로 사용하는 상황 |
|---|---|---|
| `Cast<T>()`        | 실패 시 `nullptr` 반환          | 타입이 확실하지 않을 때, if문으로 분기 필요할 때  |
| `CastChecked<T>()` | 실패 시 크래시/Assertion Failure | 타입이 **반드시** T여야 할 때 (논리 오류 방지) |


### 3. FARFilter
AssetRegistry 모듈에서 사용하는 에셋 검색 조건을 표현하는 구조체
- AssetRegistry API (GetAssets 등) 호출 시, 이 구조체를 넘겨주면 조건에 맞는 에셋만 결과로 반환

### FARFilter 주요 멤버

| 필드 | 역할 |
|---|---|
|`TArray<FName> PackagePaths` | 검색할 폴더 경로(예:/Game, /Game/MyFolder)|
|`TArray<FName> ClassPaths`   | 검색할 클래스 유형(예: Blueprint, ObjectRedirector) |
|bool bRecursivePaths       | 하위 폴더까지 검색할지 여부 |
|`TArray<FName> ObjectPaths`  | 특정 오브젝트 경로 지정(옵션) |
| ...  | 이 외에도 Tag, Metadata 등 다양한 조건 가능 |


### FARFilter 사용 예시

```c++
// AssetRegistry 모듈 참조 얻기
IAssetRegistry& AssetRegistry =
    FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();

// FARFilter 구조체 생성
FARFilter Filter;

// 검색할 폴더 지정 (여러 개 가능)
Filter.PackagePaths.Add(FName("/Game/MyFolder")); // 예시: /Game/MyFolder 폴더만 검색

// 하위 폴더까지 재귀적으로 검색할지 여부
Filter.bRecursivePaths = true;

// 검색할 클래스 지정 (여러 개 가능)
Filter.ClassPaths.Add(UStaticMesh::StaticClass()->GetClassPathName());  // 스태틱 메시만 대상
// Filter.ClassPaths.Add(UMaterial::StaticClass()->GetClassPathName()); // 필요하면 다른 클래스도 추가

// 특정 태그 기반 검색 예시 (선택 사항)
// Filter.TagsAndValues.Add(FName("MyTag"), TEXT("MyValue"));

// 결과 저장할 배열
TArray<FAssetData> AssetList;

// 실제 검색 수행
AssetRegistry.GetAssets(Filter, AssetList);

// 결과 사용 예시
for (const FAssetData& Asset : AssetList)
{
    UE_LOG(LogTemp, Log, TEXT("Asset found: %s"), *Asset.AssetName.ToString());
}
```

### 4. AssetRegistry.GetAssets(Filter, AssetList)
Filter에 지정된 조건(폴더, 클래스, 태그 등)에 맞는 에셋의 메타데이터 목록을 OutAssetData(배열)에 추가

```c++
virtual bool GetAssets(
    const FARFilter& InFilter, 
    TArray<FAssetData>& OutAssetData, 
    bool bSkipARFilteredAssets
) const = 0;
```
- 매개변수
  - const FARFilter& Filter
    - 에셋 검색 조건
  - TArray<FAssetData>& OutAssetData
    - 검색 결과가 담길 배열 (에셋 메타데이터(FAssetData) 객체)
  - bool bSkipARFilteredAssets 
    - AssetRegistry에 이미 “숨김(Filtered Out)” 처리된 에셋을 결과에서 제외
    - 기본값 true (숨김 에셋 제외)

## AssetViewUtils
콘텐츠 브라우저(에셋 뷰)에서 에셋의 표시, 로딩, 정렬, 필터링 등과 관련된 작업 유틸리티
- ContentBrowser 모듈에 포함

- 에셋을 실제로 메모리로 로드(Load)
- 에셋 목록을 정렬(Sort), 필터(Filter)
- 콘텐츠 브라우저에서 사용할 다양한 유틸리티 제공

### 5. AssetViewUtils::FLoadAssetsSettings
에셋 로딩 동작을 세부적으로 제어하는 옵션 구조체
- 위에서 설명한 Filter와 마찬가지로 설정 옵션을 정의하는 용도로 쓰임

### FLoadAssetsSettings 주요 맴버

| 필드 | 역할  |
|---|---|
| bFollowRedirectors | 에셋 경로가 리다이렉터인 경우, **자동으로 실제 에셋을 따라갈지** 여부<br> - true면 리다이렉터를 따라가 실제 에셋을 로딩<br> - false면 리다이렉터 그 자체만 로드 |
| bAllowCancel      | 로딩 도중 **사용자가 취소(Interrupt/Cancel)할 수 있는 UI**가 노출될지 여부<br> - 에디터에서 대량 에셋 로딩시 “취소” 가능 |

### 6. AssetViewUtils::FLoadAssetsSettings
에셋의 오브젝트 경로(ObjectPath) 리스트를 받아, 실제로 필요한 에셋만 메모리로 로드하는 에디터 유틸리티 함수
- 이미 메모리에 로드된 에셋은 재로드하지 않음
- 콘텐츠 브라우저 및 에디터 툴에서 대량 에셋 로딩에 특화

```c++
// 매개변수 설명
    ELoadAssetsResult LoadAssetsIfNeeded(
        const TArray<FString>& AssetObjectPaths, // 오브젝트 경로 문자열 리스트
        TArray<UObject*>& LoadedAssets,          // 실제 로딩된 에셋 객체가 저장될 배열
        const FLoadAssetsSettings& Settings      // 로딩 옵션(구조체)
    );

    AssetViewUtils::LoadAssetsIfNeeded(AssetObjectPaths, LoadedAssets, Settings);
```

### 반환값

| 값   | 의미  |
|---|---|
| ELoadAssetsResult::Succeeded | 모든 에셋 정상 로드 |
| ELoadAssetsResult::Cancelled | 로딩 중 사용자 취소 |
| ELoadAssetsResult::Failed   | 로딩 자체 실패    |


### 7. AssetToolsModule.Get().FixupReferencers()
FixupReferencers()는 깨진 참조를 수정하는 핵심 함수이다

- 깨진 참조 자동 복구
  - 에셋 경로 변경으로 인해 깨진 참조를 검색하고 자동으로 수정
  - 리다이렉터가 존재할 경우 대상 경로로 참조를 업데이트
- 대상 범위
  - 선택한 에셋(들)을 참조하는 모든 다른 에셋을 검사
  - 블루프린트, 머티리얼, 레벨 등 모든 에셋 타입의 참조 처리 가능
- 리다이렉터 처리
  - 기존 리다이렉터를 제거하고 직접 참조로 변환할 수 있음

```c++
virtual void FixupReferencers(
    const TArray<UObjectRedirector*>& Redirectors,
    bool bCheckoutDialogPrompt = false,
    ERedirectFixupMode FixupMode = ERedirectFixupMode::DeleteFixedUpRedirectors
) = 0;
```
- 매개변수
  - Redirectors: UObjectRedirector*의 배열로, 참조를 갱신할 리다이렉터 목록
  - bCheckoutDialogPrompt: true로 설정하면, 소스 컨트롤 사용 시 체크아웃 다이얼로그를 표시
  - FixupMode: 리다이렉터 처리 방식을 지정
    - ERedirectFixupMode::DeleteFixedUpRedirectors: 참조가 갱신된 리다이렉터를 삭제
    - ERedirectFixupMode::LeaveFixedUpRedirectors: 참조가 갱신되더라도 리다이렉터를 유지

## 단축키
- UE 상단에서 툴 -> visual studio 새로고침 선택
- Ctrl + B : vs studio 빌드
- Ctrl + F5 : 편집기 (엔진) 실행
- Ctrl + Alt + F11 : 라이브 코딩 실행
- Alt + F12(피킹 정의) : Quick Info 주석 보기
- Ctrl + ` : 터미널