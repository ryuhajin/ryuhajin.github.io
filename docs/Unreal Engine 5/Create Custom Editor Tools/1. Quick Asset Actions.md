---
layout: default
title: "1. Quick Asset Actions"
parent: "Create Custom Editor Tools"
nav_order: 2
---
# 1. Quick Asset Actions
---

# 모듈
모듈은 언리얼 엔진의 구성 블록이다.
에디터를 만들려면 자신만의 모듈을 만들어야 한다.

## 모듈에서 알아야 할 세가지 주요 포인트

- 모듈은 코드 분리를 강제한다.
    - 여러 개의 무작위 코드들이 서로 소통해야 할 때 매우 유용하다
- **모든 모듈은 Build.cs 파일이 필요**하다.
  -  새 프로젝트 자체도 하나의 모듈이다.
  -  모듈은 자신의 빌드 파일을 가진다.
```
[ModuleName].Build.cs
[ProjectName].Build.cs
```
- 모듈은 Build.cs 파일에 추가하여 포함할 수 있다.
  - 다른 모듈에 위치한 헤더 파일을 포함해야 할 때 해당 헤더의 모듈 이름을 Build.cs 파일에 추가한다.
  - 보통  `PublicDependencyModuleNames`에 모듈 이름을 추가하는 경우가 많다

## 플러그인 생성하기
1. 언리얼 상단 메뉴  Edit > Plugins 클릭
2. 왼쪽 상단의 +ADD 버튼 클릭
3. 여러가지 템플릿 목록에서 선택 (현재는 Blank 선택)
  - 플러그인 이름이 곧 모듈 이름이다.
  - 한번 정하면 변경할 수 없다.
4. Create Plugin 버튼 클릭
5. 비주얼 스튜디오로 돌아가 모두 로드 버튼 클릭
- 프로젝트 소스 폴더 위에 플러그인 폴더 생성된 것 확인

```c++
// .uplugin
	"Modules": [
		{
			"Name": "BackgroundTool",
			"Type": "Editor", // 만들 기능은 에디터 전용이므로 Runtime(게임 동작시 실행되는 타입) -> Editor로 변경
			"LoadingPhase": "PreDefault" // 플러그인이 언제 로드될지 결정함. PreDefault: 게임 모듈보다 먼저 로드됨
		}
	]
```

## 액터와 에셋
- **에셋** : 콘텐트 브라우저 안에 존재하는 것 (머티리얼, 스태틱 매시 등)
  -  에셋은 `AssetActionUtility`라는 내장 클래스를 사용
- **액터** : 레벨(뷰) 안에 존재하며 클릭할 수 있는 것
  -  액터는 `ActorActionUtility`라는 클래스를 사용

## Public/Private
- 모듈을 하나 생성할 때 Pubilc, Private 폴더를 나눠서 생성할 수 있음
  - **Pubilc** : 헤더
  - **Private** : cpp 소스 코드 

## build.cs
- 인클루드 된 헤더에 빨간 밑줄 : 현재 모듈이 이 헤더 파일에 **접근할 권한 없음**

**접근권한 해결하기**  
1. 솔루션 탐색기에서 해당 헤더 검색 후 헤더가 들어있는 모듈 찾기
2. 해당 모듈의 build.cs 소스 코드에 각각 private, pubilc 모듈 경로를 찾을수 있음
3. 내가 쓸 build.cs에 private, pubilc에 해당하는 경로 붙여넣기

## 테스트용 에셋 함수 구동하기 (5.3 이상)
**함수 준비하기 : 플러그인 콘텐트**
1. 플러그인의 콘텐트 폴더로 이동
2. 플러그인 콘텐트 브라우저에서 마우스 오른쪽 버튼 클릭
3. 에디터 유틸리티 -> 에디터 유틸리티 블루 프린트 -> 에셋 액션 유틸리티 선택하여 생성성
4. 더블 클릭하여 해당 에셋을 열고 우측 상단의 파일 클릭
5. 부모 블루프린트 -> 내가 만든 c++ 클래스 입력
6. 컴파일 및 저장 클릭

**함수 사용하기**
1. 메인 콘텐트에서 Blueprint 폴더 생성
2. Blueprint 클래스 생성
3. 해당 클래스 우클릭 -> Scripted Asset Actions
4. 플러그인 콘텐트에서 추가한 c++ 클래스가 보임
5. 클릭하여 동작 확인 가능  

## 디버그 헤더 만들기
1. 플러그인 안의 폴더를 오른쪽 버튼으로 클릭
2. 새 항목 추가 선택
3. 추가 창이 뜨면 위치를 플러그인 -> 모듈 -> public 폴더로 선택
4. 만들 유형 헤더로 선택하고 Debug.h 이름 지정
5. Debug.h의 함수를 사용할 cpp 파일에 #include "Debug.h" 추가

```c++
void PrintMessage(const FString& Message, const FColor& Color)
{
	if (GEngine)
	{
		GEngine->AddOnScreenDebugMessage(-1, 8.f, Color, Message); // 화면 좌상단에 출력
	}
}

void PrintLog(const FString& Message)
{
	UE_LOG(LogTemp, Warning, TEXT("%s"), *Message); // 콘솔 로그창에 출력
}
```

# Scripting Libraries
### 1. UEditorUtilityLibrary:: 클래스
- 에디터 **유틸리티 작업을 위한 편의 함수**들을 제공하는 클래스

  - GetSelectedAssetData() : `TArray<FAssetData>`를 반환
  - GetSelectedAssets() :  `TArray<UObject*>`를 반환
    - FAssetData는 UObject* 보다 더 많은 정보를 포함
  - 모두 static 함수임

### 2. UEditorAssetLibrary:: 클래스
에디터에서 에셋을 **관리하기 위한 함수**들을 제공하는 클래스

- **에셋 로드/저장**
	- LoadAsset(): 에셋 로드
	- SaveAsset(): 에셋 저장

- **에셋 정보**
	- DoesAssetExist(): 에셋 존재 여부 확인
	- GetMetadataTag(): 에셋 메타데이터 읽기
	- SetMetadataTag(): 에셋 메타데이터 설정

- **에셋 작업**
	- DuplicateAsset(): 에셋 복제
	- DeleteAsset(): 에셋 삭제

### 에셋 이름
  - **Asset Name**: BP_NewBluePrint
  - **Object Path**: /Game/MyFolder/BP_NewBluePrint.BP_NewBlueprint
    - `{Package Path}/{Asset Name}.{Class Name}`
  - **Package Path**: /Game/MyFolder/ 

## duplicate 함수 구현에 사용한 메서드
### 1..ToString()
  - FString, FName, FText, FVector, FGuid 등 일부 엔진 주요 클래스에서 각 타입에 맞는 방식으로 문자열 변환

### 2.FString::FromInt()
- 정수형 값을 FString 객체로 변환하는 정적(static) 메서드

- 매개변수
  - int32 Value: 변환할 정수 값
- 반환값
  - FString: 정수를 문자열로 변환한 결과

```c++
int32 Number = 42;
FString Str = FString::FromInt(Number); // "42"
```
### 3.FPaths::Combine()
- 여러 개의 경로 문자열을 OS별로 올바른 구분자로 결합해 하나의 경로 문자열로 만듦.
	- 내부적으로 /, \ 자동 정리

- 매개변수
  - 오버로드가 많으나, 대표적으로 다음과 같은 버전
  -  const FString& PathA, const FString& PathB
- 반환값
  - FString: 결합된 경로 문자열

```c++
FString FullPath = FPaths::Combine(TEXT("C:/Project"), TEXT("Content"), TEXT("Textures"));
// "C:/Project/Content/Textures"
```

### 4.UEditorAssetLibrary::DuplicateAsset()
- 에디터 전용 라이브러리 함수. Content Browser에서 특정 자산(에셋)을 **지정 경로로 복제(복사)**함

- 매개변수
  -  const FString& SourceAssetPath: 원본 자산의 경로
     -  (예: "/Game/StarterContent/Textures/T_Wood")
  -  const FString& DestinationAssetPath: 복제될 위치의 경로
     -  (예: "/Game/MyFolder/T_Wood_Copy")
- 반환값
  -  UObject*: 복제된 자산의 포인터
     -  (복제 실패 시 nullptr 반환)

```c++
UObject* Duplicated = UEditorAssetLibrary::DuplicateAsset(TEXT("/Game/AssetA"), TEXT("/Game/Folder/AssetB"));
if (Duplicated) { /* 성공 */ }
```

### 5.UEditorAssetLibrary::SaveAsset()
- 에디터에서 지정한 자산(에셋)을 디스크에 저장

- 매개변수
   - const FString& AssetPath: 저장할 자산의 경로 (예: "/Game/MyFolder/AssetB")
- 반환값
	- bool (true: 저장 성공 / false: 저장 실패)

```c++
bool bSaved = UEditorAssetLibrary::SaveAsset(TEXT("/Game/MyFolder/AssetB"));
```

### 6.TEXT()
- C++의 **문자열 리터럴을 엔진 내부 문자 타입(TCHAR)**로 변환하는 매크로 
   - TEXT() 매크로는 C++의 매크로 전처리 기능을 사용

```c++
FString MyString = TEXT("Hello");
// ↓ 매크로 확장 후
FString MyString = L"Hello";  // C++ 컴파일러가 처리할 코드 생성
```
- L"Hello" :  UTF-16/유니코드 문자열 리터럴로 컴파일

# Custom Editor Message
- FMessageDialog를 사용해 메시지 대화 상자 출력하기 (모달)
- FNotificationInfo를 사용해 알림 정보 출력하기 (오른쪽 하단에 나타나는 비동기 알림)

## FMessageDialog
- 에디터 환경에서 사용자에게 메시지 박스(모달 대화상자)를 띄울 때 사용하는 유틸리티 클래스
- core 소속
- **블로킹(Blocking) 방식으로, 다이얼로그가 닫히기 전까지 다음 코드가 실행되지 않음**
- 정적(static) 메서드로만 구성

### 1. FMessageDialog::Open(EAppMsgType::Type MsgType, const FText& Message)
- 지정한 메시지 유형과 메시지 텍스트로 다이얼로그 표시

### 2. EAppReturnType::Type
```c++
EAppReturnType::Type ShowMsgDialog(
    EAppMsgType::Type MsgType, 
    const FString& Message, 
    bool bShowMsgAsWarning = true
)
```
- MsgType: 메시지 박스 버튼 조합(Ok, YesNo 등) 지정
- Message: 출력할 메시지 문자열
- bShowMsgAsWarning: 경고(Warning) 스타일로 메시지를 띄울지 여부, 기본값 true
   - true면 경고 스타일(노란색 경고 아이콘, "Warning" 타이틀 등)로 표시
   - false면 일반 정보 스타일(파란색 info 아이콘, "Message" 또는 "Info" 타이틀 등)로 표시

**EAppMsgType::Type 정리**

| 타입| 다이얼로그 버튼 조합  | 대표적 사용 상황 |
|---|---|---|
| `Ok`     | OK   | 단순 확인, 정보 알림  |
| `YesNo`  | Yes / No   | 선택(이행/거부)  |
| `YesNoCancel`  | Yes / No / Cancel| 저장 여부 등 3분기 선택|
| `OkCancel`     | OK / Cancel| 진행/중단   |
| `CancelRetryContinue`| Cancel / Retry / Continue     | 재시도 여부(예: 파일 저장 실패) |
| `YesNoYesAllNoAll`   | Yes / No / Yes to All / No to All   | 여러 작업에 대해 일괄 처리 |
| `YesNoYesAllNoAllCancel`   | Yes / No / Yes to All / No to All / Cancel| 여러 파일 작업에서 개별/일괄/취소 |
| `YesNoCancelContinue`| Yes / No / Cancel / Continue  | 드문 복합적 분기     |
| `YesNoYesAllNoAllCancelContinue` | Yes / No / Yes to All / No to All / Cancel / Continue | 매우 복잡한 결정     |


## FNotificationInfo
- 에디터 하단 (주로 오른쪽 아래)에 잠시 나타나는 비동기 알림(Notification Toast) 정보를 정의하는 구조체
- `FSlateNotificationManager`를 통해 **실제 알림을 생성/표시**
- slate 소속

```c++
FNotificationInfo Info(FText::FromString(TEXT("작업이 완료되었습니다.")));
Info.bFireAndForget = true;
Info.ExpireDuration = 2.0f; // 2초 후 자동 닫힘
Info.bUseThrobber = false; // 스피너 비표시

FSlateNotificationManager::Get().AddNotification(Info);
```

# Add Prifixes To Assets
- TMap<UClass*, FString> PrefixMap 에 Prifixes 목록 작성
  - 예: `{UBlueprint::StaticClass(),TEXT("BP_")}` 

## add Prifixes 함수 구현에 사용한 메서드
### 1. UObject* S->GetClass()->GetName()
- 클래스 이름을 반환
  -  (예: "AActor", "UMyComponent")
- 해당 오브젝트가 어떤 클래스로 생성되었는지 알 수 있음


### 2. UObject* S->GetName()
- 오브젝트 인스턴스의 이름을 반환
  - (예: "Player_123", "Weapon_Sword")
- 에디터에서 부여한 이름이나 동적으로 생성된 이름이 반환

```c++
AActor* MyActor = GetWorld()->SpawnActor<AActor>(...);
FString ClassName = MyActor->GetClass()->GetName();  // "AActor"
FString InstanceName = MyActor->GetName();           // "MyActor_42"
```

### 3. FString::StartsWith()
- 문자열이 **특정 문자열로 시작하는지 여부를 bool로 반환**
- 대소문자 구분 여부 선택 옵션 존재
- 주의 : InPrefix가 **빈 문자열이면 항상 true를 반환**

### 함수 시그니처
```c++
bool StartsWith(
    const FString& InPrefix, 
    ESearchCase::Type SearchCase = ESearchCase::IgnoreCase
) const;
```
### 사용 예시
```c++
FString FilePath = "Content/Textures/PlayerTexture.png";

// 대소문자 무시 (기본값)
bool bIsContent = FilePath.StartsWith("Content"); // true

// 대소문자 구분
bool bIsExact = FilePath.StartsWith("content", ESearchCase::CaseSensitive); // false

// 실제 활용 예시
if (FilePath.StartsWith("Content/Textures/"))
{
    UE_LOG(LogTemp, Warning, TEXT("텍스처 경로가 유효합니다."));
}
```

### 4.
### 5.

### 6. UObject::IsA<T>()
- 해당 오브젝트가 특정 클래스 타입이거나 그 클래스의 자식 클래스인지를 확인하는 메서드
- 비슷한 경우로 `IsA(UClass*)` 가 있다

### 예시
```c++
// IsA<T>()
template<typename T>
FORCEINLINE bool IsA() const
{
    return IsA(T::StaticClass());
}

if (SelectedObject->IsA<UMaterialInstanceConstant>()) 
{
    // UMaterialInstanceConstant 타입일 때 실행
}

// IsA()
bool IsA(const UClass* TargetClass) const;

if (SelectedObject->IsA(AActor::StaticClass())) 
{
    UE_LOG(LogTemp, Warning, TEXT("이 오브젝트는 Actor입니다!"));
}
```

{: .new-title}
> ❓ 왜 머티리얼 인스턴스 클래스를 찾으려면 `UMaterialInstanceConstant`를 사용해야 할까?

- 계층구조
```
UMaterialInterface (베이스)
├─ UMaterial (실제 마테리얼 에셋)
└─ UMaterialInstance (인스턴스 베이스)
            ├─ UMaterialInstanceDynamic (런타임 생성 인스턴스)
            └─ UMaterialInstanceConstant (에디터에서 생성된 인스턴스)
```

>
- UMaterialInstance
  - 추상 베이스 클래스. 직접 인스턴스화되지 않음
- UMaterialInstanceConstant
  - 에디터에서 미리 생성해 놓은 정적 마테리얼 인스턴스
  - 런타임 중 파라미터 변경이 불가능
- UMaterialInstanceDynamic (MID)
   - 런타임에 동적으로 생성되며, 파라미터를 실시간으로 변경할 수 있음


## 단축키
- UE 상단에서 툴 -> visual studio 새로고침 선택
- Ctrl + B : vs studio 빌드
- Ctrl + F5 : 편집기 (엔진) 실행
- Ctrl + Alt + F11 : 라이브 코딩 실행
- Alt + F12(피킹 정의) : Quick Info 주석 보기