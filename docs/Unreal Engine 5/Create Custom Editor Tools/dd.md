이전 강의에서는 이번 과정에서 우리가 다룰 다양한 액션 유형에 대해 살펴보았습니다.
그리고 Action Utility를 상속받은 클래스를 생성했죠.

지금까지 우리가 만든 것을 보면, 콘텐츠 브라우저에서 이 에셋을 클릭하면
TestFunc를 클릭할 수 있고, 그러면 화면에 메시지가 출력됩니다.

나중에 함수가 더 많아지면 각각의 함수마다
if (GEngine) { GEngine->AddOnScreenDebugMessage(...); }
이런 식으로 매번 작성하는 게 번거로워질 겁니다.

그래서 이번 강의에서는 이런 작업을 간단하게 처리할 수 있도록
작은 디버그 헤더 파일을 만들겠습니다.

먼저 에디터를 닫고 플러그인 폴더로 이동합니다.
여기서 SuperManager 폴더 아래 Public 폴더를 우클릭해서 새 항목을 추가합니다.

먼저 Intermediate 폴더가 아닌 플러그인 폴더에 저장되도록 위치를 변경해야 합니다.
Browse를 클릭하고 Plugins/SuperManager/Source/SuperManager/Public 폴더를 선택합니다.

여기에 헤더 파일을 만들 겁니다.
파일 형식을 Header File로 변경하고 이름은 DebugHeader로 설정한 뒤 Add를 클릭합니다.

그런 다음 즉시 이 헤더 파일을 .cpp 파일에 포함합니다.
자동 완성 기능을 빠르게 복구할 수 있기 때문입니다.

cpp
복사
편집
#include "DebugHeader.h"
이렇게 입력하고 Ctrl + P를 눌러 컴파일합니다.

컴파일이 성공했습니다.
다시 DebugHeader.h 파일로 돌아갑니다.

여기에 Print 함수를 하나 만들겠습니다.

이 함수는 두 개의 파라미터를 받습니다.
첫 번째는 const FString& 형식의 메시지이며,
두 번째는 const FColor& 형식의 색상입니다.

이렇게 참조로 전달하면 불필요한 복사를 방지할 수 있습니다.

이제 기존 코드에서 메시지 출력 코드를 복사해와서 이 함수에 붙여 넣습니다.
하드코딩된 문자열과 색상 대신 함수 파라미터를 사용하도록 수정합니다.

이것이 첫 번째 디버그 출력 함수입니다.

두 번째 함수는 로그 출력 함수로,
메시지 하나만 입력받고 로그로 출력합니다.

cpp
복사
편집
UE_LOG(LogTemp, Warning, TEXT("%s"), *Message);
이렇게 하면 로그에 메시지가 출력됩니다.

이제 두 가지 출력 함수가 준비되었습니다.

다시 기존 TestFunc로 돌아가 기존 출력 코드를 지우고
새로 만든 Print 함수와 PrintLog 함수를 호출합니다.

cpp
복사
편집
Print(TEXT("Working"), FColor::Cyan);
PrintLog(TEXT("Working"));
이렇게 작성하고 Ctrl + P를 눌러 컴파일합니다.

컴파일이 성공했으니 Ctrl + F5를 눌러 에디터를 실행합니다.

테스트해보죠.
TestFunc를 클릭하면

화면에 메시지가 출력되고,

출력 로그에도 메시지가 출력됩니다.

디버그 헤더가 잘 동작합니다.

이제 여러분이 똑같이 해볼 차례입니다.

도전 과제

Public 폴더에 작은 헤더 파일을 만드세요.

로그와 화면 출력 함수를 만드세요.

만든 함수가 정상 동작하는지 테스트해보세요.

도움이 필요하면 이전 영상을 참고하세요.

돌아오신 걸 환영합니다.

잘 하셨나요?

이제 이런 글로벌 함수를 통해 간편하게 디버그 메시지를 출력할 수 있게 되었습니다.

지금까지는 컴파일이 잘 되었지만,
나중에 이 디버그 헤더를 다른 파일에서 포함해서 컴파일하면
링크 에러가 발생할 수도 있습니다.

하지만 걱정하지 마세요.
그 문제는 나중에 다룰 겁니다.

이번 강의에서는
디버그 메시지를 출력하는 작은 함수 모음을 만들었습니다.

잘 하셨습니다.
다음 강의에서 뵙겠습니다.