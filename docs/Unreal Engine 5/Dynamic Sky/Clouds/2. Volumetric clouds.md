---
layout: default
title: "2. Volumetric clouds"
parent: "Clouds"
nav_order: 1
---

# 2. Volumetric clouds
볼류메트릭 구름이 작동하기 위한 세 가지

1. 2D Texture Mask
2. 3D Volume Texture
3. Volumetric Advance Output
 
---

# Volumetric Rendering
## volume 개념
그래픽스에서 볼륨(Volume) 은 **3차원 공간 안의 모든 점에 어떤 값이 정의된 데이터**

> 3D 공간상의 스칼라 필드 혹은 벡터 필드
> - “ 3D 안의 점 → 값 ”을 대응시키는 구조가 볼륨 데이터

### 예시
- 어떤 점에서의 밀도(density)
- 온도(temperature)
- 속도 벡터(velocity field)
- Signed Distance Field(SDF): 점 → 표면까지의 거리


### 구름은 왜 볼륨?
구름은 “표면(surface)”이 명확히 없다. 

- 경계가 딱 잘린 고체가 아님
- 어떤 위치에서는 조금 흐리고
- 더 깊이 들어가면 다른 부분에 비해 밀도가 더 높고
- 또 어떤 곳은 구멍이 있음

```
따라서 구름을 표현하려면 어느 지점이 구름인지가 아니라

그 지점의 구름 밀도(= density) 를 저장해야 함
```

---

## Density Field
공간상의 각 위치에서의 밀도 값을 담은 스칼라 필드

```
density(x, y, z) → [0, 1] 같은 스칼라 값
```

### density에 따른 렌더링 차이
구름의 렌더링은 기본적으로 다음 질문을 반복하여 렌더링 됨

**이 위치(x)에서의 구름 밀도는 몇인가?**
1. 밀도가 높으면 더 불투명하고 더 빛을 산란
2. 밀도가 낮으면 통과시키거나 흐릿하게 보임

### Density 성질
일반적 구현에서 density는 다음 성질을 갖는다

1. 0.0 → 공기 (완전 투명)
2. 0.2 → 아주 희미한 수증기
3. 0.5 → 중간 구름
4. 1.0 → 매우 진한 구름 (거의 불투명)

---

## 3D texture (Volume Texture)
3축(u, v, w)으로 인덱싱되는 3차원 이미지. XYZ 전체에 대해 값이 존재

- density field를 직접 표현 가능
- tri-linear 필터링이 적용됨
- 메모리와 샘플링 비용이 2D보다 훨씬 큼

| 항목    | 2D Texture   | 3D Texture     |
| ----- | ------------ | -------------- |
| 차원    | (u, v)       | (u, v, w)      |
| 용도    | 표면 텍스처, UI 등 | 볼륨, 노이즈 필드, 밀도 |
| 메모리   | 낮음           | 높음             |
| 샘플 비용 | 낮음           | 높음             |
| 구름 표현 | 단독으로는 부족     | 가장 정확          |

---

## 3D Noise
구름, 연기, 안개처럼 진짜 3차원적인 형태를 자연스럽게 생성

### 그래프/HLSL에서 노이즈를 이용해 density 계산
```
float d = FBM_3DNoise(pos * baseScale);
d += smallNoise(pos * detailScale) * 0.3;
d = saturate(d - threshold);
```

- 장점: 절차적(Procedural), 무한 변화 가능
- 단점: 계산 비용이 높을 수 있음
- 언리얼 머티리얼 그래프/Custom HLSL에서 주로 이 방식 사용

### 3D 텍스처로 density field 저장
- 외부 툴(예: Houdini)에서 만든 3D 볼륨 데이터를 저장
- 언리얼 Volume Texture로 가져다 쓰기
- 장점: 고품질, 예측 가능
- 단점: 고용량, 수정 어려움

---

## Volumetric Rendering 과정
기본적으로 카메라에서 픽셀 단위로 광선을 쏘고(ray), 그 레이가 볼륨을 통과하는 동안 여러 지점을 샘플링하여 누적 적분하는 과정

### 핵심
1. 볼륨 데이터에서 밀도(density)를 읽기
2. 레이마칭(Ray Marching)으로 구름의 색과 투과율을 적분

---

### 1. 레이 생성 (Ray Setup)
픽셀마다 카메라에서 출발하는 레이(ray)가 정의

- Ray Origin: Camera Position
- Ray Direction: View Direction (정규화)
- 클라우드 볼륨(보통 큐브 또는 박스)의 경계와 레이가 교차하는 입구/출구 지점을 계산

> 이를 통해 레이가 볼륨을 지나는 총 거리(rayLength)를 얻음

---

### 2. 볼륨 데이터 샘플링 (Density Sampling)
레이가 일정 간격 (stepSize)로 전진하며 다음을 반복

**1.현재 샘플 위치 p 계산**

```
p = rayOrigin + rayDir * t
```

**2. density field 읽기**

```
volume texture 샘플링

density = VolumeTex.Sample(p)

---

또는 3d 노이즈 기반 계산

density = Noise3D(p * scale)
```

**3.밀도 후처리**
- threshold 적용
- height curve 적용
- detail noise 추가
- domain warping 적용 등

---

### 3. 광선 적분 (Optical Integration)
각 샘플에서 구름을 통한 빛의 소멸(Absorption) 과 산란(Scattering) 을 누적 계산

- 투과율 감소
- 산란 기여도 계산
- 최종 색 누적 등

---

### 4. 루프 종료 및 픽셀 출력
루프가 exit 지점에 도달하거나 Transmittance가 거의 0에 도달하면(불투명해지면) 종료

- 마지막 color가 픽셀 색이 됨

---