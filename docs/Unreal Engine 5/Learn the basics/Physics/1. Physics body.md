---
layout: default
title: "1. Physics body"
parent: "Physics in UE"
nav_order: 1
---

# 1. Physics body
물리 연산은 **Physics Body라고 불리는 스태틱 메쉬의 더 단순화된 표현에 대해 수행된다**

## Physics body 확인
1. 오브젝트 메쉬를 더블 클릭하여 스태틱 메쉬 에디터 열기
2. show 메뉴의 Simple Collision 켜기
3. 녹색으로 된 Physics Body 윤곽선 확인 가능

> Physics Body도 버텍스와 삼각형으로 구성된 자신만의 메쉬를 가지고 있다 (= 콜리전)
> - Physics Body를 위한 메쉬는 Collision Volumes 또는
> - 간단히 Collisions 라고 불리는 기본 3D 도형들의 집합으로 정의된다

---

## Rigid Body (강체)
물리 시뮬레이션에서 일반적으로 사용되는 용어

- 실제 세계의 물체와 달리, 어떤 방식으로도 구부러지거나 압축되지 않는다는 사실을 의미
- **바디 위의 어떤 두 지점 사이의 거리는 가해지는 힘의 크기와 상관없이 항상 일정하게 유지**

```
이러한 '100% 단단함(Rigidness)'은 시뮬레이션을 실행하는 데 필요한 수학적 복잡성을 크게 줄여줌

결론적으로 'Rigid Body'와 'Physics Body'는 같은 것을 의미한다
```

---

## Physics body 속성
1. **Mass (질량)**
    - **기본적으로 콜리전의 부피를 기반으로 자동 계산**
    - 체크박스로 직접 설정 가능
    - 질량이 높으면 밀기 어려워짐
2. **Linear Damping (선형감쇠)**
    - 물체의 움직임에 얼마나 많은 **마찰이나 저항(Drag)**을 적용할지 정의
    - **힘을 받아 움직이기 시작한 물체가 다시 멈추는 데 걸리는 시간을 정의**
3. **Angular Damping (각 감쇠)**
    - 물체의 **회전** 움직임에 대한 **마찰**을 정의
    - **이 값을 높이면 Physics Body의 회전이 더 빨리 멈추게 됨**
4. **Constraints (제약 조건)**
    - Physics Body의 **움직임을 특정 축(Axis)으로 잠글 수 있음**
    - 집라인이나 트랙 위를 움직이는 시뮬레이션을 할 때 유용 (예: 회전을 모두 잠금, 이동 x축만 허용)

---

## Rigid Body Simulation Loop (Per Frame)
물체가 찌그러지지 않는다고 가정하면 (강체), 물체의 질량 중심(Center of Mass) 하나만 추적하면 됨

> 즉 물리 엔진이 매 프레임 하는 일은 뉴턴의 제 2법칙 (F = ma)을 계산하는 것

## 물리 계산 과정

### 1. 힘의 누적 (Force Accumulation)
**한 프레임 동안 물체에 작용하는 모든 힘(중력, 바람, 플레이어가 미는 힘 등)을 더함**

- $$\vec{F}_{total}$$ : 물체에 작용하는 모든 힘의 합 (Net Force)

---

$$
\vec{F}_{total} = \vec{F}_{gravity} + \vec{F}_{wind} + \vec{F}_{collision} + \dots
$$

---

### 2. 가속도 계산 (Calculate Acceleration)
뉴턴의 제2법칙 ($$F=ma$$)을 이용하여 **현재 프레임의 가속도를 구함**

- **중요:** 가속도는 보통 누적되지 않고, 이번 프레임의 힘에 의해서만 결정
- $$m$$ : 물체의 질량 (Mass)

---

$$
\vec{a} = \frac{\vec{F}_{total}}{m}
$$

---

### 3. 속도 갱신 (Update Velocity)
**이전 속도에 '가속도 $$\times$$ 시간'을 더하여 현재 속도를 구함 (속도는 계속 누적됨)**

- 마찰력 처리는 여기서 $$\vec{v}_{t}$$에 감쇠 계수를 곱해주는 식으로 추가된다
- $$\vec{v}_{t-1}$$ : 이전 프레임의 속도
- $$\vec{a}$$ : 가속도 (Acceleration)
- $$\Delta t$$ : 한 프레임의 시간 (Delta Time, 예: 0.016s)

---

$$
\vec{v}_{t} = \vec{v}_{t-1} + \vec{a} \cdot \Delta t
$$

---

### 4. 위치 갱신 (Update Position)
**이전 위치에 '방금 갱신된 속도 $$\times$$ 시간'을 더하여 현재 위치를 구함**

- $$\vec{P}_{t}$$ : 현재 프레임의 위치 (Position)
- $$\vec{P}_{t-1}$$ : 이전 프레임의 위치
- $$\vec{v}_{t}$$ : 현재 프레임의 속도 (Velocity)
- $$\Delta t$$ : 한 프레임의 시간 (Delta Time, 예: 0.016s)

---

$$
\vec{P}_{t} = \vec{P}_{t-1} + \vec{v}_{t} \cdot \Delta t
$$

---

### 5. 힘 초기화 (Reset Force)
다음 프레임의 계산을 위해 **누적된 힘을 0으로 만든다**

---

$$
\vec{F}_{total} \leftarrow 0
$$

---

## 코드 예시
```c++
void UpdatePhysics(float dt) {
    // 1. 힘 누적 (Force Accumulation)
    // 예: 중력은 매 프레임 새로 가해짐
    ForceAccumulator += Gravity; 
    
    // 2. 가속도 계산 (F = ma)
    // 가속도는 이번 프레임의 힘에 의해서만 결정 (이전 프레임 가속도 누적 X)
    Vector3 acceleration = ForceAccumulator / Mass;

    // 3. 속도 갱신 (Velocity Integration)
    // 속도는 '누적' (어제 빨랐으면 오늘도 빠름)
    Velocity += acceleration * dt;

    // 4. 위치 갱신 (Position Integration)
    // 위치도 '누적'
    Position += Velocity * dt;

    // 5. [매우 중요] 힘 리셋
    // 이걸 안 하면 다음 프레임에 중력이 2배, 3배로 계속 쌓임
    ForceAccumulator = Vector3(0, 0, 0); 
}
```

- **위치/속도**: 이전 프레임의 상태를 계승 (누적됨)
- **힘/가속도**: 매 프레임 새로 계산하고, 프레임 끝에서 **폐기(0으로 초기화)** (누적 X)

---

**✨참고하면 좋은 링크**
- [Game Physics](https://gafferongames.com/post/integration_basics/)