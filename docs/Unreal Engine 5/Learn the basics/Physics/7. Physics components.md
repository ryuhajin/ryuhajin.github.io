---
layout: default
title: "7. Physics components"
parent: "Physics in UE"
nav_order: 7
---

# 7. Physics components
이 물체를 어떻게 움직일 것인가(속도, 중력, 마찰, 회전 등)를 계산하여 최종적으로 PrimitiveComponent에 반영하는 보조 컴포넌트들

```
MovementComponent 계열은 단순 트랜스폼 변경이 아니라  
MoveUpdatedComponent() → Sweep 이동 + 충돌 보정 + 슬라이딩 처리와 같은 안정적인 Kinematic 이동 시스템을 제공
```

---

- **UMovementComponent 계열**
  - `CharacterMovementComponent`
  - `ProjectileMovementComponent`
  - `RotatingMovementComponent` 등
  - → Kinematic 방식(직접 위치 갱신)으로 액터를 정교하게 이동

---

- **UPrimitiveComponent 기반의 물리 바디**
  - `StaticMeshComponent`, `SkeletalMeshComponent`, `CapsuleComponent` 등  
  - 질량, 시뮬레이션 여부, 콜리전, 물리 머티리얼 등을 직접 가짐  
  - Simulate Physics ON 시 Dynamic rigid body로 동작

---

## node(함수) vs Components movements

| 특징노드 | 함수 이용 (Nodes/Functions)  | 컴포넌트 이용 (Movement Components)  |
| --- | --- | --- | 
| 비유  | 직접 운전하기" (매 순간 핸들을 돌림) | 자율 주행 모드 (목적지만 입력함) | 
| 작동 방식 | Tick마다 매 프레임 직접 호출해야 함 | 설정만 하면 엔진이 알아서 매 프레임 업데이트 | 
| 제어권 | 프로그래머가 100% 제어 (수학 공식 직접 구현) | 컴포넌트 내부 로직에 위임 (파라미터만 조절) |
| 상태  |  관리속도, 위치 변수를 직접 선언하고 관리해야 함  |  내부적으로 속도, 가속도, 상태를 캡슐화하여 관리함 |
| 주요 용도  | 특정한 조건에 따른 일회성/커스텀 움직임  | 총알, 회전하는 아이템, 캐릭터 이동 등 표준화된 움직임  |

---

### 언제 노드(함수)를 쓰는가?
- 플레이어의 입력(W, A, S, D)에 따라 순간적으로 움직일 때
- 특정 이벤트(예: 문이 열림) 발생 시에만 움직일 때
- 움직임의 패턴이 불규칙하여 정형화된 컴포넌트로 표현할 수 없을 때

```
1. 장점
    - 정확하게 원하는 순간에 원하는 값으로 제어 가능
    - 상황별 다르게 처리하기 쉬움

2. 단점
    - 매 Tick 호출해야 하는 경우가 많아 유지보수 부담
    - 직접 컨트롤하기 때문에 실수가 많아짐
    - 물리적 안정성이 떨어질 수 있음(특히 강제 이동과 물리 전환 혼합 시)
```

### 언제 컴포넌트를 쓰는가?
- 총알, 미사일 (Projectile Movement)
- 계속 도는 아이템, 팬, 풍차 (Rotating Movement)
- 엘리베이터 (InterpToMovement)
- 캐릭터의 걷기/점프 (Character Movement)

```
1. 장점
    - 안정적, 구조적
    - 물리·이동 관련 복잡한 기능을 엔진이 자동 처리
    - 네트워크 복제, 프레임 보정, 충돌 처리 등이 훨씬 자연스럽다

2. 단점
    - 일부 고급 행동은 노드로 직접 제어하는 것보다 제약이 있을 수 있음
    - 시스템 설계에 맞춰야 하므로 예외적 움직임은 추가 구현이 필요할 때 있음
```

---

# Movement Components
액터에 이동 관련 컴포넌트 추가

## Rotating Movement Component
계속 회전하는 물체를 만들기 위한 간단한 MovementComponent

- `RotationRate` (Yaw/Pitch/Roll 도/초)를 기준으로 매 Tick 회전량을 계산
- `UpdatedComponent` (대상 컴포넌트)의 `AddLocalRotation` 등으로 회전
- 기본적으로 물리 시뮬레이션 없이 **Kinematic 방식**으로 회전시킴

---

### 주요 속성

| 프로퍼티 | 설명 |
|---------|------|
| `RotationRate` | 초당 회전 속도 (FRotator) |
| `PivotTranslation` | 회전 중심을 오프셋 (원형 궤도 회전 등) |
| `bRotationInLocalSpace` | 로컬 회전 기준 여부 |

---

### 사용 예시
- 간판, 프로펠러, 회전 플랫폼 등  
- **물리 반응이 필요 없고, 그냥 일정 속도로 돌아가면 되는 오브젝트**에 적합  
- Simulate Physics가 꺼진 StaticMesh에도 잘 동작

---

## Projectile Movement Component
**투사체(총알, 화살, 미사일, 마법탄 등)**의 이동을 담당하는 MovementComponent

- `Velocity` 벡터를 기준으로 매 Tick 위치 갱신
- 중력, 공기 중 감속, 반사(Bounce) 등을 옵션에 따라 적용
- `UpdatedComponent`의 Sweep Move로 충돌을 체크

---

### 주요 속성

| 프로퍼티 | 설명 |
|---------|------|
| `InitialSpeed` / `MaxSpeed` | 초기/최대 속도 |
| `ProjectileGravityScale` | 중력 스케일 (0 = 중력 없음) |
| `bShouldBounce` | 충돌 시 튕김 여부 |
| `Bounciness` | 튕길 때 반사 계수 |
| `Friction` | 표면 마찰 |
| `HomingTargetComponent` + `bIsHomingProjectile` | 추적(Homing) 투사체 설정 |
| `bRotationFollowsVelocity` | 속도 방향을 기준으로 메쉬 회전 |

---

### 사용 예시
- 간단한 중력, 튕김/마찰
- 추적 기능 등이 필요할 때 가장 많이 쓰는 방식

---

# Physics simulate component

##  Physics Thruster Component
특정 방향으로 **지속적인 힘(Force)** 을 가해주는 컴포넌트

- 컴포넌트의 “Forward” 방향(보통 X) 또는 설정된 방향으로  
  - `ThrustStrength`만큼 Force를 매 Tick 적용
- Force를 받는 대상은 같은 Actor 안의 “Simulate Physics = true”인 PrimitiveComponent

---

### 주요 속성

| 프로퍼티 | 설명 |
|---------|------|
| `ThrustStrength` | 힘의 크기 (뉴턴에 상응하는 값) |
| `bAutoActivate` | 시작하자마자 활성화 여부 |
| `bApplyLocalForce` | 로컬 기준 힘 적용 여부 |

---

### 사용 예시
- Dynamic 바디를 **Force 기반으로 계속 밀고 싶은** 경우  
  - 우주선, 보트, 에어쉽, 물 위 부력 시뮬레이션
- AddForce를 코드로 직접 반복 호출할 필요 없이 컴포넌트 하나로 깔끔하게 캡슐화할 수 있다

---

## Radial Force Component
특정 위치를 중심으로 **반경 내 모든 물체에 Force/Impulse** 를 가하는 컴포넌트

- `FireImpulse()`를 호출하거나, 지속 모드로 설정하면  
  - 중심 위치에서 `Radius` 안에 있는 모든 Dynamic 바디를 검색
  - Falloff(선형, 제곱 등)에 따라 Force 또는 Impulse를 적용

---

### 주요 속성

| 프로퍼티 | 설명 |
|---------|------|
| `Radius` | 영향 범위 반경 |
| `ForceStrength` | Force 모드 시 힘의 크기 |
| `ImpulseStrength` | Impulse 모드 시 충격 크기 |
| `bImpulseVelChange` | 질량 무시하고 속도만 바꿀지 여부 |
| `Falloff` | 거리 감쇠 방식 (None, Linear 등) |
| `bAutoActivate` | 자동 활성화 여부 |

---

### 사용 예시
- 폭발 / 넉백 효과 구현
- Hit된 위치에 RadialForceComponent를 두고 `FireImpulse()`만 해도 주변 물체가 튀어오르는 효과 구현 가능

---

## 정리
컴포넌트도 마찬가지로 dynamic과 kinematic에 따라 사용해야 할 컴포넌트가 다르다

| 물체 유형  | 이동 방식| 사용해야 할 것  |
| **Dynamic**   | 물리 엔진이 움직이는 방식 | Physics Thruster Component  / Radial Force Component / AddForce / AddImpulse / Velocity  |
| **Kinematic** | 트랜스폼을 직접 갱신    | MovementComponent / RotatingMovement / ProjectileMovement / AddOffset / SetLocation |
