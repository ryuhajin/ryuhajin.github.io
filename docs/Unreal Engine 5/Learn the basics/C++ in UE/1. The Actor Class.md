---
layout: default
title: "1. The Actor Class"
parent: "C++ in UE"
nav_order: 2
---

# 1. The Actor Class
---

## 클래스 생성
1. 에디터 상단의 도구 (Tools) 클릭
2. New C++ Class 클릭
3. 엔진에서 제공하는 클래스 선택 가능

## 언리얼 모듈 Public/Private 폴더
New C++ Class 를 통해 생성할 때 어디에 클래스를 생성할지 선택하게 된다

폴더명 |	용도 및 특징|
Public	|다른 모듈(외부)에서 사용할 수 있게 공개하려는 헤더 파일 <br>
        |즉, '외부에 노출'되는 API/클래스/함수의 헤더(.h) 파일을 여기에 둠|
Private	|모듈 내부에서만 사용할 클래스/구현 파일 <br>
        |보통 소스(.cpp) 파일, 혹은 외부에 노출하지 않아도 되는 헤더(.h) 파일을 둠|

- Public 폴더 : 다른 모듈에서 `#include` 가능
- Private 폴더 :  원칙적으로 해당 모듈 외부에서 `#include` 할 수 없음

## Super::
**상위 클래스의 함수를 호출할 때 사용되는 접두사**

- 부모(상위) 클래스의 함수, 생성자, 멤버 등에 접근할 때 사용

```c++
void AMyActor::BeginPlay()
{
    Super::BeginPlay(); // 부모 클래스의 BeginPlay() 호출
    // 이 아래에 자식에서의 추가 동작 구현
}
```

---

## Blueprint Creation
생성한 C++ 기반 클래스를 블루 프린트로 가져오기

1. 에디터 우클릭 -> 블루 프린트 클래스 클릭
2. ALL Classes에 가져오고 싶은 클래스 검색
3. 선택 후 `BP_` 붙여 네이밍하기
4. 클래스 기반 블루 프린트 생성

---

# Drawing Debug
디버그 메서드를 블루프린트와 C++로 어떻게 구현하는지 알아보자

## Drawing Debug Spheres
디버그용 구 그리기

### DrawDebugSphere() 함수 원형

```c++
void DrawDebugSphere(
    const UWorld* InWorld,
    const FVector& Center,
    float Radius,
    int32 Segments,
    FColor Color,
    bool bPersistentLines = false,
    float LifeTime = -1.f,
    uint8 DepthPriority = 0,
    float Thickness = 0.f
);
```

- 매개변수
  - InWorld: 월드 객체 포인터
  - Center: 구의 중심 좌표
  - Radius: 반지름
  - Segments: 구 세그먼트 수
  - Color: 색상
  - bPersistentLines: 지속적으로 표시할지 여부
  - LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속)
  - DepthPriority: 렌더링 우선순위
  - Thickness: 선 두께

- **bPersistentLines**
  - true: 엔진 내부에서 해당 디버그 요소를 지속성 목록(Persistent List)에 등록하여 관리
    - `FlushPersistentDebugLines()`로 수동 제거 가능 
    - 지속적인 메모리 사용이 발생하지만 매 프레임 재생성 비용 절감
  - false: 프레임 임시 배열에만 저장
    - 매 프레임 생성/삭제 반복

- **LifeTime**

|값|예시|
|LifeTime = -1|무한 지속|
|LifeTime = 0|1 프레임만 출력되고 사라짐|
|LifeTime > 0| 지정된 시간(초) 동안 지속 후 사라짐| 

### BP
- Draw Debug Sphere
  - Get Actor Location : 디버그용 구의 Center 지정에 사용

### C++
```c++
#include "DrawDebugHelpers.h" // 디버그 헤더 인클루드

void AItem::BeginPlay()
{
        Super::BeginPlay();

        UWorld* World = GetWorld();
        FVector Location = GetActorLocation();

        if (World)
        {
                DrawDebugSphere(World, Location, 25.f, 24, FColor::Red, false, 30.f);
        }
}
```

- `define` 사용하기

```c++
#define DRAW_SPHERE(Location) if (GetWorld()) DrawDebugSphere(GetWorld(), Location, 25.f, 12, FColor::Red, true);

AItem::AItem()
{
	FVector Location = GetActorLocation();
	DRAW_SPHERE(Location)
}
```

## Drawing Debug Lines
디버그용 벡터 라인 시각화하기

### Drawing Debug Lines() 함수 원형
```c++
void DrawDebugLine(
    const UWorld* InWorld,
    const FVector& LineStart,
    const FVector& LineEnd,
    FColor Color,
    bool bPersistentLines = false,
    float LifeTime = -1.f,
    uint8 DepthPriority = 0,
    float Thickness = 0.f
);
```

- 매개변수
  - InWorld: 월드 객체 포인터
  - LineStart: 시작 좌표
  - LineEnd: 끝 좌표
  - Color: 색상
  - bPersistentLines: 지속적으로 표시할지 여부
  - LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속)
  - DepthPriority: 렌더링 우선순위
  - Thickness: 선 두께

### BP
- Draw Debug Line
  - Get Actor Location : 디버그용 라인의 Start 지정에 사용
  - Get Actor Foward Vector : 전방 벡터 불러오기
    - 위 두개를 ADD 해 Line End에 잇는다
    - 벡터 단위는 `cm`
      - 따라서 Foward Vector 크기 곱셈 필요

### C++
```c++
void AItem::BeginPlay()
{
        Super::BeginPlay();

        UWorld* World = GetWorld();
        FVector Location = GetActorLocation();

        if (World)
        {
                FVector Forward = ForwardVector();
                DrawDebugLine(World, Location, Location + Forward * 100.f, FColor::Red, true);
        }
}
```


- `define` 사용하기

```c++
#define DRAW_LINE(StartLocation, EndLocation) if (GetWorld()) DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f);

AItem::AItem()
{
	FVector Location = GetActorLocation();
        FVector Forward = GetActorForwardVector();

	DRAW_LINE(Location, Location + Forward * 100.f)
}
```

## Drawing Debug Point
디버그용 포인트 찍기 

- 벡터의 처음과 끝을 표시하기에 좋음
- 포인트 크기는 거리에 따라 변하지 않음 (고정)

### DrawingDebugPoint() 함수 원형
```c++
void DrawDebugPoint(
    const UWorld* InWorld,
    FVector const& Position,
    float Size,
    FColor const& Color,
    bool bPersistentLines,
    float LifeTime,
    uint8 DepthPriority
);
```
- 매개변수
  - InWorld: 디버그 포인트를 그릴 월드 컨텍스트
  - Position: 포인트의 위치 (FVector)
  - Size: 포인트의 크기 (float)
  - Color: 포인트의 색상 (FColor)
  - bPersistentLines: 지속적으로 표시할지 여부
  - LifeTime: 디버그 포인트가 화면에 유지될 시간(초)
  - DepthPriority: 렌더링 우선순위

### BP
- Draw Debug Point
  - Get Actor Location : 디버그용 포인트 찍을 Position

### C++
```c++
void AItem::BeginPlay()
{
        Super::BeginPlay();

        UWorld* World = GetWorld();
        FVector Location = GetActorLocation();

        if (World)
        {
                FVector Forward = ForwardVector();
                DrawDebugPoint(World, Location + Forward * 100.f, 15.f, FColor::Red, true);
                // 벡터 끝에 점찍기
        }
}
```

- `define` 사용하기

```c++
#define DRAW_POINT(Location) if (GetWorld()) DrawDebugPoint(GetWorld(), Location, 15.f, FColor::Red, true);

AItem::AItem()
{
	FVector Location = GetActorLocation();
        FVector Forward = GetActorForwardVector();

	DRAW_POINT(Location + Forward * 100.f)
}
```

## Line + Point 로 벡터 그리기

- `\` 사용해 매크로 계속 이어갈 수 있음

```c++
#define DRAW_VECTOR(StartLocation, EndLocation) if (GetWorld()) \
	{ \
		DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f); \
		DrawDebugPoint(GetWorld(), EndLocation, 15.f, FColor::Red, true); \
	};

AItem::AItem()
{
	FVector Location = GetActorLocation();
        FVector Forward = GetActorForwardVector();

	DRAW_VECTOR(Location, Location + Forward * 100.f)
}
```

## 사용한 메서드 정리
### GetWorld()
```c++
UWorld* UObject::GetWorld() const;
```
- 매개변수: 없음
- 리턴값: 현재 객체가 속한 월드의 포인터를 반환
  - 대부분의 Actor, Component 등에서 사용 가능

### GetActorLocation()
```c++
FVector AActor::GetActorLocation() const;
```
- 매개변수: 없음
- 리턴값: FVector (액터의 월드 공간 위치)
  - 액터가 현재 월드에서 어느 좌표에 있는지 반환

### GetActorForwardVector()
```c++
FVector AActor::GetActorForwardVector() const;
```

- 매개변수: 없음
- 리턴값: FVector (액터의 앞 방향 벡터(Forward), 정규화됨)
  - 로컬 Z축이 아닌, 로컬 X축 기준 (언리얼은 X가 Forward)


# Custom Header Files
매크로 전용 헤더 파일 만들기

1. Visual Studio 로 사용자 모듈 열기
2. Games/사용자모듈/Source/사용자모듈이름 우클릭
3. Add -> New item 클릭
4. 만들 종류로 헤더 파일 선택 -> 헤더 이름 정하기
5. 헤더가 들어갈 폴더 지정해주기
   - 예: `사용자 모듈\Source\사용자 모듈 이름`
