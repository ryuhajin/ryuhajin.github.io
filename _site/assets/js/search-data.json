{"0": {
    "doc": "1. GPU 특성",
    "title": "1. GPU 특성",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html"
  },"1": {
    "doc": "1. GPU 특성",
    "title": "1. Design: GPU vs. CPU",
    "content": ". GPU는 원래 그래픽 렌더링을 위해 설계되었다. 3D 객체를 구성하는 수천 개의 독립적인 폴리곤을 셰이딩, 텍스처링, 렌더링하는 데 매우 효과적이다. | Core (녹색 영역) : 명령어 실행 및 계산 처리 (연산, 레지스터 조작 등) | Control (금색 영역) : 명령어 해석 및 실행 제어 (제어 신호 생성, 흐름 제어 등) | L1 Cache (보라 영역) : 데이터 / 명령어 저장 (코어에 가장 가까운 고속 캐시 메모리) | L2/L3 chache (파랑 영역) : L1 보다 느리지만 더 큼. L3는 여러 코어 간 공유되는 경우가 많음 | . ☑️ 위 그림으로 알수 있는 점 . | CPU는 GPU만큼 산술 논리 장치나 부동 소수점 장치가 많지 않다. (Core 녹색 영역) . | 하지만 CPU 코어의 ALU와 FPU는 더 많은 기능을 갖추고 있다. | . | CPU는 GPU보다 캐시 메모리가 더 많다. | GPU는 병렬화 될 수 있는 워크로드를 위해 설계되었다. | core의 각 행마다 Control이 하나씩 있는 것으로 나타난다. | . | . | 특징 | CPU | GPU | . | 목적 | 범용 컴퓨팅 (다양한 작업 처리) | 병렬 컴퓨팅 (그래픽 및 대량 데이터 처리) | . | 코어 수 | 적음 (일반적으로 2~64개) | 매우 많음 (수백 ~ 수천 개의 코어) | . | 작업 유형 | 직렬 처리에 최적화 | 병렬 처리에 최적화 | . | 사용 사례 | 운영체제, 일반 소프트웨어, 논리 연산 | 그래픽 렌더링, 머신러닝, 과학 계산 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu"
  },"2": {
    "doc": "1. GPU 특성",
    "title": "2. Performance: GPU vs. CPU",
    "content": ". 아래의 그림은 연산 능력을 초당 수십억 번의 부동 소수점 연산( Gflop/s )으로 측정하여 보여준다. | Single Precision (단정밀도) : 부동 소수점 수의 32비트 표현 | Double Percision (배정밀도) : 부동 소수점 수의 64비트 표현 | . 단정밀도는 배정밀도보다 두 배 빠르게 처리될 수 있는 경우가 많다. ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu"
  },"3": {
    "doc": "1. GPU 특성",
    "title": "3. Threads, Cores 재정의",
    "content": ". GPU는 그래픽 파이프라인의 두 가지 핵심 속성을 통해 속도가 가속화된다. | 렌더링은 일반적으로 많은 독립적인 오브젝트 (예:표면을 근사화하는 작은 삼각형 메시)로 구성된다. | 각 오브젝트를 렌더링하는데 필요한 단계의 순서는 기본적으로 모든 오브젝트에 동일하다. | 따라서 계산 단계가 모든 오브젝트에 대해 한번번에 병렬로 수행될 수 있다. | . | . GPU와 CPU 간의 용어 비교 . | GPU 용어 | GPU에서의 간단한 정의 | CPU에서의 대응 개념 | . | Thread | 하나의 CUDA 코어에서 실행되는 명령어와 데이터의 흐름. SIMT 모델에서 실행됨. | 일반적으로 명시적 대응 없음. | . | CUDA Core | SIMT 명령어의 일부를 처리하는 단일 연산 유닛. | 벡터 유닛 내의 벡터 레인 | . | Warp | 32개의 스레드로 구성된 그룹. 서로 다른 데이터에 동일한 명령어 스트림을 함께 실행한다. | 벡터 연산에서의 벡터 | . | Kernel | GPU에서 실행되는 함수. 커널은 여러 스레드 블록으로 구성될 수 있다. | CPU의 스레드 | . | Streaming Multiprocessor (SM) | 스레드 블록을 실행할 수 있는 단위. GPU의 물리적 유닛. | CPU의 코어 | . ❓ 스레드 블록 . | 스레드 블록 (Thread Block) . | 여러 스레드가 모여 하나의 논리적 단위로 구성되는 실행 단위 | . | CUDA 프로그래밍에서 스레드는 블록 단위로 묶여 실행된다. | 하나의 블록은 n ~ n백개의 스레드를 포함할 수 있다. | 블록은 SM(Streaming Multiprocessor)에 배정된다. | . ❓ 명령어 스트림 . | 명령어 스트림 (Instruction Stream) . | 스레드들이 공유하는 명령어의 흐름 (제어 흐름 분기(조건문)가 영향을 줌) | . | 스트림(stream)이라는 말은 일련의 명령어가 순차적으로 흐르는 데이터 흐름을 의미 | SIMT 모델에서 말하는 “명령어 스트림”은 모든 스레드가 따르는 동일한 명령어 흐름 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-%EC%9E%AC%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-재정의"
  },"4": {
    "doc": "1. GPU 특성",
    "title": "4. SIMT (Single Instruction, Multiple Threads)",
    "content": ". | 한 명령어를 여러 스레드가 동시에 실행하는 GPU 실행 모델 | . __global__ void add(int *a, int *b, int *c) { int idx = threadIdx.x; c[idx] = a[idx] + b[idx]; } . | 위 함수가 32개의 스레드에서 실행되면 모든 스레드가 같은 c[idx] = a[idx] + b[idx] 명령어 수행. | 각 스레드는 자신만의 idx 값을 사용해서 다른 데이터에 접근함. | . SIMT에서 제어 흐름 분기 예시 . | SIMT에서는 선택한 스레드를 활성화 또는 비활성화할 수 있다 | . | 활성 스레드: 명령과 데이터 처리. | 비활성 스레드: 아무런 작업도 수행하지 않음. 로컬 데이터가 변경되지 않은 상태로 유지됨. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads"
  },"5": {
    "doc": "1. GPU 특성",
    "title": "5. Warps",
    "content": ". | 런타임 시, 스레드 블록은 SIMT 실행을 위해 워프로 나뉜다. | 하나의 완전한 워프는 연속된 스레드 인덱스를 가진 32개의 스레드 묶음으로 구성된다. | 워프에 포함된 스레드들은 32개의 CUDA 코어 집합에 의해 함께 처리된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps"
  },"6": {
    "doc": "1. GPU 특성",
    "title": "6. Kernels (in software)",
    "content": ". 연결된 GPU 에서 병렬로 실행되도록 설계된 함수를 커널이라고 한다. | C++ 함수 선언 앞에 __global__ 지정자가 있는 것으로 식별된다. | . | 커널은 한 번만 실행되는 것이 아니라, GPU의 N개의 서로 다른 스레드 에 의해 N번 병렬로 실행된다. | 각 스레드에는 메모리 주소를 계산하고 제어 결정을 내리는 데 사용할 수 있는 고유 ID(실제로는 인덱스)가 할당된다. | . CUDA 커널이 스레드 배열에 의해 실행되는 방식 . 커널 호출은 GPU에서 사용할 스레드 수를 지정하는 특수 인수를 제공해야 한다. 특수 인수는 아래와 같다. func&lt;&lt;&lt;1, N&gt;&gt;&gt;(x, y, z) . // 커널 함수 정의: 두 벡터를 더해서 결과 저장 __global__ void addVectors(int *a, int *b, int *c, int N) { int idx = threadIdx.x; if (idx &lt; N) { c[idx] = a[idx] + b[idx]; } } int main() { const int N = 256; // 커널 호출: 블록 1개, 스레드 256개로 구성 addVectors&lt;&lt;&lt;1, N&gt;&gt;&gt;(d_a, d_b, d_c, N); } . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software"
  },"7": {
    "doc": "1. GPU 특성",
    "title": "7. Streaming multiprocessors (in hardware)",
    "content": ". GPU에서 커널 호출은 하나 이상의 스트리밍 멀티프로세서에 의해 실행된다. 각 SM의 CUDA 코어는 항상 32개 세트로 배열되어 SM이 스레드의 전체 워프를 실행하는 데 사용할 수 있다. | GPU가 커널 호출을 실행하는 데 실제로 사용하는 SM의 수는 호출에 지정된 스레드 블록 수로 제한된다. | 예를 들어 fun&lt;&lt;&lt;M, N&gt;&gt;&gt;(x, y, z) 이 있을 때, 각 SM에 할당할 수 있는 블록은 최대 M개이다. | 스레드 블록은 여러 SM으로 분할될 수 없다. | 사용 가능한 SM보다 블록이 많은 경우, 동일한 SM에 여러 블록을 할당할 수 있다. | . | . | 매 사이클 마다 각 SM의 스케줄러 는 사용 가능한 32개의 CUDA 코어 세트에서 실행될 스레드의 전체 워프를 할당한다. | SM에는 레지스터 , L1 캐시 , 상수 캐시, 공유 메모리가 포함된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware"
  },"8": {
    "doc": "1. GPU 특성",
    "title": "☑️ 정리",
    "content": "[Kernel] ↓ [Grid] (커널의 전체 작업 공간 = 스레드 블록 집합) ┌─────────────────┐ │ Thread Block 1 │ → SM 0 (리소스 여유 있을 시 SM 1에도 할당 가능) │ Thread Block 2 │ → SM 0 or 다른 SM │ ... │ (한 SM이 여러 블록을 동시에 실행 가능) │ Thread Block N │ → SM m (m ≤ n, SM 수 ≤ 블록 수) └─────────────────┘ ↓ ↓ [Warp 0] [Warp 1] ... (각 32스레드) ↓ ↓ CUDA Cores (SIMT 방식으로 워프 단위 병렬 처리 실행) ↓ ALU/FPU/Tensor Cores (실제 연산) . | 하나의 커널(GPU 함수)은 수많은 스레드 블록으로 구성 | 각 스레드 블록은 SM에 할당되어 실행된다. | SM이 스레드 블록을 실행한다 = SM은 워프 스케줄링, 메모리, 명령어 분배 등 전체 실행을 관리한다 | 한 SM이 여러 블록을 동시에 실행 가능 (SM의 자원이 충분하다면 여러 블록을 동시에 수용 가능) | . | 스레드 블록 내부의 스레드들은 32개 단위로 워프로 나뉨 | 각 스레드는 CUDA 코어에서 개별적으로 연산을 수행한다. | CUDA Core가 연산을 수행한다 = 각 스레드의 연산은 CUDA 코어에서 처리된다. 각 스레드의 명령은 워프 단위로 동기화(SIMT)되어 CUDA Core에 할당되며, 워프 내 스레드의 명령어를 ALU/FPU에 전달해 연산을 수행한다. | CUDA Core 자체가 ALU나 FPU를 내장하고 있거나, 복합적으로 연결되어 있다. | . | Tensor Core는 행렬 곱 연산(Matrix Multiply) 등에 최적화된 특수 연산 유닛으로, 워프 단위에서만 활성화되며 CUDA Core와 독립적으로 존재 | . | 구성 요소 | 설명 | 예시 용어 | . | Kernel | GPU에서 실행되는 함 | myKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...) | . | Grid | 모든 스레드 블록의 집합 | 논리적 실행 단위 | . | Thread Block | 스레드의 집합, SM에 할당됨 | blockDim.x, blockIdx.x 등으로 접근 | . | SM | Streaming Multiprocessor. 블록을 실행하는 하드웨어 유닛 | Warp Scheduler, CUDA Cores 포함 | . | Warp | 32개 스레드로 구성된 실행 단위 | SIMT 방식 실행 | . | CUDA Core | 실제 산술/논리 연산을 수행하는 유닛 | ALU/FPU로 구성된 연산 유닛의 논리적 집합 | . | Tensor Core | 고속 행렬 곱셈 (AI 특화) | SM 내부에 있는 별도 유닛으로 워프 단위 처리 | . FPU vs ALU vs Tensor Core . | 유닛 | 연산 타입 | 주요 용도 | 예시 | . | FPU | 부동소수점 (실수) | 물리 시뮬레이션, 3D 렌더링 | float x = y * 1.5; | . | ALU | 정수/논리 연산 | 인덱스 계산, 조건문 | int i = j + 1; | . | Tensor Core | 행렬 연산 | AI 학습/추론, DLSS | A = B × C (행렬 곱셈) | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#%EF%B8%8F-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#️-정리"
  },"9": {
    "doc": "1. Material Basic",
    "title": "1. Material Basic",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html"
  },"10": {
    "doc": "1. Material Basic",
    "title": "1. Data Types",
    "content": "constant - 1 float . constant2Vector - 2 floats . constant3Vector - 3 floats . 어떤 포지션과 묶느냐에 따라 floats 값이 RGB or XYZ 가 될 수 있다. | Base Color에 1 vector, 2 vector 를 넣어도 엔진에서 자동으로 입력을 처리한다. | (r 1, g 0, b 0) 이런 식 | . | Color에서 constant value 값 . | 0 : black | 1 : white | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types"
  },"11": {
    "doc": "1. Material Basic",
    "title": "2. Roghness",
    "content": "표면의 반사 정도를 제어 . | 0 : 거울 반사 (정반사) | 1 : 완전 무광 (난반사) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness"
  },"12": {
    "doc": "1. Material Basic",
    "title": "3. Lerp",
    "content": "Linear Interpolation (선형 보간법) 약어 . | 입력 A : 시작 포인트 | 입력 B : 끝 포인트 | 알파 : 보간 계수 (두 값 사이에서 어느 지점에 위치하는지를 나타내는 비율이자 가중치) | 리턴 : 보간된 값 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp"
  },"13": {
    "doc": "1. Material Basic",
    "title": "UV Mapping",
    "content": "2D 이미지를 3D 모델 표면에 투영하는 것 . | u : 수평 | v : 수직 | . | Texture coordinate Node . | tiling : 크기가 커질수록 텍스쳐는 작아지고 반복됨 | mutilply 사용으로도 타일링 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping"
  },"14": {
    "doc": "1. Material Basic",
    "title": "component mask",
    "content": "벡터 배열 중 가져오고 싶은 인덱스만 마스킹 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask"
  },"15": {
    "doc": "1. Material Basic",
    "title": "append",
    "content": "값1, 값2 합쳐서 매개변수로 사용하고 싶을때 쓰임 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append"
  },"16": {
    "doc": "1. Material Basic",
    "title": "4. Opacity",
    "content": "투명도를 주고싶으면 블렌드 모드를 바꿔야 함. (디폴트 Opaque(불투명)) . | material blend mode -&gt; Translucent(반투명) 변경 -&gt; Opacity 속성 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity"
  },"17": {
    "doc": "1. Material Basic",
    "title": "5. moving texture",
    "content": ". | speed (음수로 두면 -&gt; 방향으로 감) | time | distance = speed * time | subtract . | -로도 검색 가능 | append를 쓰면 speed에 음수로 방향 | subtract를 쓰면 speed는 늘 양수 (subtract가 뺄셈처리) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture"
  },"18": {
    "doc": "1. Material Basic",
    "title": "6. Panner",
    "content": "위 무빙 텍스쳐를 쉽게 하나로 만든 형태 . | 입력 coordinate : 텍스쳐 UV 좌표 | 입력 Time : UV 이동에 사용할 시간 값 | 입력 Speed : UV 좌표의 이동 속도를 설정하는 2D vector | 출력 UV : 입력된 UV 좌표를 시간과 속도에 따라 변형한 결과를 출력 | . ❓ 왜 speed 를 양수로 하면 왼쪽으로 가는것 처럼 보일까? . | Speed X 값이 양수일 때, 위의 계산에 따라 UV 좌표의 U 값이 증가 | 이는 텍스처의 샘플링 위치가 오른쪽으로 이동함을 의미 | 따라서 실제로 화면에서 보이는 텍스처는 왼쪽으로 이동하는 것처럼 보임 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner"
  },"19": {
    "doc": "1. Material Basic",
    "title": "7. Material Instance",
    "content": ". | M_material | MI_materialInstance | . | 머티리얼 인스턴스를 만들고 머티리얼 파라미터를 추가해 빠르게 머티리얼을 수정할 수 있다. | 머티리얼 인스턴스는 창이 다름 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance"
  },"20": {
    "doc": "1. Material Basic",
    "title": "8. Comment",
    "content": ". | 노드 클릭 / 드래그 후 C 버튼 눌러서 주석 달기 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment"
  },"21": {
    "doc": "1. Material Basic",
    "title": "9. Sine 표현식",
    "content": "사인 함수를 호출하는 노드 . | 입력 : 라디안 단위 각도 | 출력 : 입력의 라디안 사인을 계산한 결과 (-1 ~ 1) | . | 객체를 상하로 흔들거나 파도, 진동 등 주기적 변동 구현에 사용 | 입력값을 라디안 단위로 해석하여 사용함 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-%ED%91%9C%ED%98%84%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-표현식"
  },"22": {
    "doc": "1. Material Basic",
    "title": "10. Saturate",
    "content": "0 ~ 1 범위로 한정 시킴 = 클램핑 . 클램핑이 뭐야 ❓Clamp wiki Link . | 입력 : 클램핑할 값 | 출력 : 0 이하 = 0 / 1 이상 = 1 / 그 외 = 원본값 유지 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate"
  },"23": {
    "doc": "1. Material Basic",
    "title": "11. Sine_Remapped",
    "content": ". | 입력 sine Phase : 보간 계수 | 입력 Value1 (V3) : 0으로 맵핑될 때 반환할 시작 벡터 | 입력 Value2 (V3) : 1로 맵핑될 때 반환할 목표 벡터 | 출력 Remapped Sine (Vec3) : lerp(val1, val2, (sin(Sine Phase) + 1) / 2) 로 선형보간한 결과 | . | Sine Phase(실수)를 사인파로 계산한 뒤 [-1,1] 범위의 출력을 Value 1 (V3)와 Value 2 (V3) 사이의 벡터로 선형 보간하여 반환 | 내부적으로 sin(Sine Phase)의 결과에 +1을 더해 0~2로 이동시킨 뒤 0.5로 스케일링 하여 0~1 범위로 remap | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped"
  },"24": {
    "doc": "1. Material Basic",
    "title": "12. world position offset",
    "content": ". | 입력 World Position Offset (V3) : 오브젝트 버텍스에 더해질 월드 공간 오프셋 벡터 | 출력 (V3): 최종 버텍스 위치 | . | 간단한 이동 애니메이션이나 주기적 바운스 효과(Sind_Remapped 사용) 를 줄 때 사용한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset"
  },"25": {
    "doc": "1. Material Basic",
    "title": "13. CheapContrast",
    "content": ". | 입력 in (Scalar) : 대비를 조정할 입력 채널 (흑백 값) | 입력 Contrast (Scalar) : 대비 증가 강도. 값이 커질수록 대비 강도 증가 | . | 흑백 마스크 대비 보정할 때 사용 | 내부 동작 수식 Remapped = ( (In – 0.5) * (1 + Contrast) ) + 0.5 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast"
  },"26": {
    "doc": "1. Material Basic",
    "title": "Texture Sample UVs 혼합하기",
    "content": "❓ 흑백 텍스쳐 샘플 노드가 2개 있을 때, 1번 텍스쳐 샘플의 R 채널과 0을 2번 텍스쳐 샘플의 UV로 넣는 과정은 어떤 결과가 나올까? . | (R, 0)은 “2번 텍스쳐의 수평 위치를 1번 택스쳐의 R값으로 조정”한다는 뜻! | 예: R = 0.3 → 2번 텍스쳐의 30% 위치의 색상을 가져옴. | 수직은 0으로 고정이므로 R 값에 따라 수평으로만 왜곡시키는 효과를 냄 | . 과정 상세 설명 . | 1번 텍스쳐 (흑백) / R 채널만 사용 (흑백이므로 R=G=B). 값은 0 ~ 1 사이 | Append 노드로 (R, 0) 생성 / 예 픽셀 R은 0.7 → (0.7, 0) | 2번 텍스쳐에 (R, 0)을 UV로 입력 | 원래 UV가 (0.5, 0.5)라면, 새 UV는 (0.5 + 0.7, 0.5 + 0) = (1.2, 0.5) 같은 식으로 계산. | . 결과 . | 1번 텍스쳐의 밝은 부분(R≈1) → 2번 텍스쳐가 오른쪽으로 밀림. | 어두운 부분(R≈0) → 2번 텍스쳐가 왼쪽으로 수축. | 수직(V) 방향은 0으로 고정되므로 위아래 왜곡은 없음. | . UV 혼합은 그라데이션 왜곡, 노이즈 패턴 변형, 동적 텍스쳐 오프셋 등에 활용 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-%ED%98%BC%ED%95%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-혼합하기"
  },"27": {
    "doc": "1. Material Basic",
    "title": "14. Name Reroute Node",
    "content": "Material Editor 전용으로 제공되는 노드. 와이어가 얽히지 않도록 중앙 리루트 지점을 만들어 그래프를 깔끔하게 유지 할 수 있다. | Declaration (선언) 노드 : 오직 입력(Input) 만 갖고, 값을 ‘이름’으로 보관 | Usage: 오직 출력(Output) 만 갖고, 해당 이름의 값을 그래프 전역에 사용 가능. | . 사용방법 . | 와이어 두번 클릭 | 마우스 오른쪽 버튼 클릭 | 이름을 가진 경유 노드로 변환 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node"
  },"28": {
    "doc": "1. Material Basic",
    "title": "15. 1-x / OneMinus",
    "content": "색상 반전, 마스크 반전에 쓰임 . | 입력 input (float) : 연산 대상 X의 값. 스칼라일 경우 단일 채널, 벡터일 경우 각 채널별로 처리 | 출력 float : 계산 결과 1 - Input을 각 채널에 적용한 값 출력 | . | 출력 예시 : OneMinus((0.2, 0.5, 1.0)) → (0.8, 0.5, 0.0) | . 📌 단축키 . | 단축키 | 동작 | . | 숫자 1, 2, 3, 4 키 + 좌클릭 | 해당 constant vector 노드 생성 | . | T + 좌클릭 | texture sample | . | L + 좌클릭 | lerp | . | m + 좌클릭 | multiply | . | alt -&gt; 기즈모 이동 | 오브젝트 복사 | . | ctrl + D | 이전 행동 다시 반복 | . | 좌클릭 + f2 | 파일 이름 변경 | . | S + 좌클릭 | 머티리얼 파라미터 추가 | . | c + 좌클릭 | comment 주석달기 | . | Alt + 핀 클릭 | 모든 연결 끊기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus"
  },"29": {
    "doc": "2. GPU 메모리",
    "title": "2. GPU 메모리",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html"
  },"30": {
    "doc": "2. GPU 메모리",
    "title": "1. Memory Levels",
    "content": " ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels"
  },"31": {
    "doc": "2. Master Material",
    "title": "2. Master Material",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html"
  },"32": {
    "doc": "2. Master Material",
    "title": "1. Master Material",
    "content": "마스터 머티리얼을 만들고 이 마스터 머티리얼의 여러 인스턴스만 사용하는 방법을 통해 공간 절약, 씬의 성능 상향이 가능함. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material"
  },"33": {
    "doc": "2. Master Material",
    "title": "2. Albedo vs Diffuse",
    "content": "베이스 컬러에 쓰이는 텍스쳐가 두 가지 용어를 혼합하여 쓰길래 두 키워드의 차이점이 무엇인지 궁금해졌다. ❓베이스 컬러에 들어가는 알베도와 디퓨즈의 차이점이 뭐지? . | Albedo : 물리 기반 렌더링(PBR)에서 도입. 표면이 반사하는 확산 반사 비율 또는 색상을 의미 | Diffuse : 전통적인 3D 그래픽스에서 디퓨즈 맵은 표면의 기본 색상을 정의한다. 빛의 영향을 받아 명암이 생기는 재질 표현에 사용 | . Albedo vs Diffuse 정리 . | 항목 | Albedo | Diffuse | . | 정의 | 순수한 반사율 (빛의 간섭 없음) | 빛의 난반사로 인한 색상 + 명암 | . | 사용 예 | PBR (물리 기반 렌더링) | 전통적 라이팅 모델 (램버트 반사 등) | . | 데이터 | 환경광의 영향이 제거된 순수 색상 | 그림자/광택 일부 포함 가능 | . | 예시 | Unreal, Unity등에서 PBR 재질의 Base Color로 사용 | Photoshop 등에서 조명까지 표현한 diffuse map 제작 가능 | . | Diffuse 텍스처에는 실제 광원이 없어도 명암이 들어감. | 조명 대응 불가 (광원 위치를 바꿔도 그림자는 바뀌지 않음) | . | . | 텍스처에 조명, 그림자, 반사 등을 “베이크”해서 포함시킨 것 = diffuse map | 조명과 독립적인 순수한 색상. 빛은 셰이더에서 계산함 = Albedo | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse"
  },"34": {
    "doc": "2. Master Material",
    "title": "3. Texture Coordinate",
    "content": "UV 매핑을 제어하는 노드로 머티리얼이 메시 표면에 어떻게 텍스쳐를 투영할지 결정한다. | 모델의 각 정점(Vertex)에는 UV 좌표(0~1 범위의 2D 좌표)가 할당되어 있으며, 이 노드는 해당 좌표를 조정하거나 변형할 때 사용할 수 있다. | . | 기본 출력: UV 채널의 2D 벡터(X, Y). 각 성분은 일반적으로 0.0 ~ 1.0 범위 . | X(U): 가로 축 좌표 (좌 → 우) | Y(V): 세로 축 좌표 (하 → 상) | . | Coordinate Index: 다중 UV 채널을 선택할 수 있다. | 정적 메시의 Lightmap UV(UV1) 등 추가 좌표 계층을 활용할 때 유용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate"
  },"35": {
    "doc": "2. Master Material",
    "title": "4. Vector4",
    "content": ". | Vector4 노드의 R,G,B,A에 각각 U tile, V tile, U offset, V offset 이라고 이름을 붙여 텍스쳐 타일링에 사용할 수 있다. | 타일링 *= multiply | 오프셋 += add | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4"
  },"36": {
    "doc": "2. Master Material",
    "title": "5. static swich parameter",
    "content": "머티리얼 그래프 내에서 분기를 정의하고, 머티리얼 인스턴스 에디터에서 체크박스로 설정 가능하게 해준다. | 정적(static) 이 붙은 이유 : 런타임에 변경되지 않고 머티리얼 컴파일 타임에 결정됨 | 사용되지 않는 쪽의 분기는 완전히 제거되어 실행 시간이 최적화 | . | 입력 A : A 로직 (스위치가 True일 때 적용) | 입력 B : B 로직 (스위치가 False일 때 적용) | 출력 : True는 A, False는 B 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter"
  },"37": {
    "doc": "2. Master Material",
    "title": "RGB 표현",
    "content": "❓언리얼 엔진에서는 RGB가 0~255 값이 아니라고? . | 언리얼에서는 RGB 표현을 정규화된 0~1 범위로 사용한다. | 0~255 와 0~1 두 범위 모두 동일한 색상을 나타내지만, 사용하는 컨텍스트와 시스템에 따라 다른 스케일로 표현된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-표현"
  },"38": {
    "doc": "2. Master Material",
    "title": "왜 언리얼 엔진은 0~1 범위를 사용할까?",
    "content": ". | 수학적 일관성 . | 3D 그래픽스에서는 벡터 연산이 빈번하게 일어남 | 0~1 범위는 퍼센트 개념과 연결되며, 모든 계산을 비율 기반으로 통일할 수 있다. | 예: 0.5 = 50% 밝기 -&gt; 0.5 * 2.0 = 1.0 (100%) | . | . | HDR (High Dynamic Range) 지원 . | 0~1 범위를 벗어나는 값 (예: 2.0) 으로 더 밝은 빛을 표현할 수 있다. | . | GPU 친화적 . | 현대 GPU는 부동소수점(float) 계산에 최적화되어 있어 0~1 범위가 셰이더 연산과 호환성이 좋다. | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%99%9C-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84%EC%9D%80-01-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#왜-언리얼-엔진은-01-범위를-사용할까"
  },"39": {
    "doc": "2. Master Material",
    "title": "RGB 정규화 방법",
    "content": ". | 0~255 -&gt; 0~1 (정규화) = 값 / 255 | . RGB(255, 127, 0) -&gt; RGB(1.0, 0.498, 0.0) . | 0~1 -&gt; 0~255 (역정규화) = 값 * 255 (반올림 적용) | . RGB(0.5, 0.75, 1.0) -&gt; RGB(128, 191, 255) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-정규화-방법"
  },"40": {
    "doc": "2. Master Material",
    "title": "Color Control",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control"
  },"41": {
    "doc": "2. Master Material",
    "title": "1. 밝기: Brightness",
    "content": ". | RGB 값에 1보다 큰 수를 곱하는 것으로 설정 가능. | RGB는 0.0 ~ 1.0 범위로 표현됨 . | 0.0 = 완전한 어둠 (검정) | 1.0 = 최대 밝기 (순수한 색상) | . | R * 2 = R의 밝기 2배 증가 | R * 0.5 = R의 밝기 50% 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-%EB%B0%9D%EA%B8%B0-brightness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-밝기-brightness"
  },"42": {
    "doc": "2. Master Material",
    "title": "2. 채도: Satration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-%EC%B1%84%EB%8F%84-satration",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-채도-satration"
  },"43": {
    "doc": "2. Master Material",
    "title": "desaturation (탈색)",
    "content": "특정 색상을 흑백(grayscale)에 가깝게 변환하는 데 사용되는 노드. 이 노드를 사용하여 채도를 조절한다. | 입력 input (V3) : 일반적으로 텍스쳐의 RGB가 입력됨 | 입력 Fraction (V1) : 채도를 얼마나 줄일지 결정하는 값. | 0 : 원본 색상 유지 | 1 : 완전히 회색 | . | 출력 (V3) : desaturation 적용 결과 | . 내부 연산 공식 . Gray = R * 0.3 + G * 0.59 + B * 0.11 Output = lerp(Input, Gray, Fraction) . | Gray는 NTSC 표준 기반의 가중 평균. 인간의 눈이 가장 민감한 녹색에 높은 가중치를 둠 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-%ED%83%88%EC%83%89",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-탈색"
  },"44": {
    "doc": "2. Master Material",
    "title": "3. 대비: Contrast",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-%EB%8C%80%EB%B9%84-contrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-대비-contrast"
  },"45": {
    "doc": "2. Master Material",
    "title": "power",
    "content": "입력 값의 지수 승(power/exponentiation) 을 계산하는 노드 . Output = Base ^ Exponent . | 입력 Base (V,V3) : 일반적으로 RGB 텍스쳐 입력 | 입력 Exponent (V) : 지수 값. | 출력 (V, V3): 계산된 결과 값 (Base의 Exponent 승) | . ❓왜 Contrast 조절에 Power를 쓰는거야? . | power는 단순 곱셈으로는 할 수 없는 비선형적인 변화를 제공하기 때문이다 | . 곱셈 (Multiply) vs 지수승 (Power) . | 특성 | 곱셈 | 지수승 | . | 수학적 표현 | RGB × Scale | RGB ^ Gamma | . | 연산 유형 | 모든 픽셀의 밝기를 균일하게 스케일링 어두운 영역과 밝은 영역이 동일한 비율로 변화 | 비선형변환으로 밝기 분포를 비균형적으로 조정 | . | 밝기 변화 | 모든 픽셀 균일하게 스케일링 | 밝은 픽셀은 더 밝게 어두운 픽셀은 더 어둡게 (분포 왜곡) | . | 대비(Contrast) 영향 | 대비 유지 | 대비 증가 (Gamma &gt; 1) 대비 감소 (Gamma &lt; 1) | . | 시각적 효과 | 전체적으로 밝아지거나 어두워짐 | 어두운 영역과 밝은 영역의 차이 강조 or 완화 | . | 사용 예시 | 밝기 조정, 라이트 강도 증감 | Contrast 조정, 감마 보정 | . RGB (0.2, 0.5, 0.8) Power(2.0) -&gt; RGB(0.04, 0.25, 0.64) // 어두운 부분은 급격히 어두워지고 밝은 픽셀은 상대적으로 덜 영향받음. = 대비 강해짐 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power"
  },"46": {
    "doc": "2. Master Material",
    "title": "4. 색조: Tint",
    "content": "Base color의 RGB에 다른 색상의 RGB를 곱해서 얻을 수 있다. | 채널별 스케일링 . | 곱해지는 색상의 각 채널 값이 원본 색상의 해당 채널을 강화하거나 약화시킴 | 1.0 : 해당 채널 100% 유지 | 0.5 : 해당 채널 50% 감소 | 0.0 : 해당 채널 완전히 제거 | . | . // 원본 색상 RGB(0.8, 0.5, 0.2) // Tint 색상 RGB(1.0, 0.3, 0.3) // 결과 -&gt; R은 유지, G/B는 감소 (0.8*1.0, 0.5*0.3, 0.2*0.3) = (0.8, 0.15, 0.06) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-%EC%83%89%EC%A1%B0-tint",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-색조-tint"
  },"47": {
    "doc": "2. Master Material",
    "title": "6. MI Organize Paramaters",
    "content": "파라미터 노드를 그룹화 하여 마테리얼 인스턴스의 파라미터들을 원하는 순서대로 분류할 수 있다. | 파라미터 노드 클릭 | Details 창의 Material Expression 에서 Group 설정 . | 그룹은 0 - Z 알파벳 네임 순서대로 정렬되므로 00 Global Control, 01 Base Color 등으로 순서를 정함. | . | 그룹에 들어가길 원하는 파라미터 노드를 설정한 그룹에 넣어줌 | 그룹 하위 파라미터 노드들은 Sort Priority (정렬 우선순위)의 낮은 수 순서대로 마테리얼 인스턴스 그룹 목록에 정렬됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters"
  },"48": {
    "doc": "2. Master Material",
    "title": "7. Metallic",
    "content": "머티리얼 에디터에서 Metallic 소켓은 표면이 금속성인지 여부를 정의하는 입력값이다. 입력 값 범위: 0.0에서 1.0 사이의 스칼라(float) 값. | 0.0: 비금속(non-metal) 재질. (예: 나무, 플라스틱, 돌 등.) | 1.0: 금속(metal) 재질. (예: 철, 금, 알루미늄 등.) | 0.0과 1.0 사이의 값: 녹슨 금속과 같은 재질을 표현할 때 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic"
  },"49": {
    "doc": "2. Master Material",
    "title": "8. Specular",
    "content": "표면이 반사하는 거울 반사(specular reflection)의 강도를 조절하는 소켓. 디폴트 값은 0.5이다. Specular 값은 비금속 재질의 반사 특성을 조절하며, 금속 재질(Metallic)에는 영향을 주지 않는다. | 0.0: 표면이 전혀 반사하지 않음 (완전한 확산 반사) | 0.5: 표면이 약 4%의 빛을 반사함 (일반적인 비금속 재질의 기본값) | 1.0: 표면이 최대 8%의 빛을 반사함 (매우 반짝이는 비금속 재질) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular"
  },"50": {
    "doc": "2. Master Material",
    "title": "9. Roughness",
    "content": "표면의 거칠기를 정의하는 소켓으로 빛이 표면에 어떻게 반사되는지를 결정한다. 디폴트 값은 0.5이다. | 0.0: 매우 매끄러운 표면. 반사가 거울처럼 선명함 (예: 유리, 금속) | 0.5: 중간 정도 거칠기 반사가 흐릿하고 부드럽게 번짐 | 1.0: 매우 거친 표면. 반사가 거의 없거나 전혀 없음 (예: 콘크리트, 모래) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness"
  },"51": {
    "doc": "2. Master Material",
    "title": "Metallic vs Specular Workflow",
    "content": "메탈릭 워크플로우와 스페큘러 워크플로우는 PBR에서 재질을 표현하는 두 가지 다른 방식이며, 계산 공식과 입력값이 근본적으로 다르다. | UE5는 메탈릭/러프니스(Metallic/Roughness) 워크플로우에 최적화되어있다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow"
  },"52": {
    "doc": "2. Master Material",
    "title": "Metallic/Roughness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | BaseColor | 비금속: 재질의 기본 색상(Diffuse) 금속: 반사 색상(Fresnel F₀) | RGB | 금속은 diffuse(산란) 사용 X. 반사 색상이 사용됨 | . | Metallic | 재질이 금속인지 여부를 정의. 0: 비금속 1: 금속 | Grayscale | - 흰색: 금속 - 검은색: 비금속 | . | Roughness | 표면의 거칠기를 정의 0: 매끄러움 1: 거칠음 | Grayscale | Glossiness와 반대 | . | 메탈릭은 Metallic 맵으로 금속/비금속을 강제 분리해 물리적 일관성을 확보함 . | Metallic 파라미터 (0,1)로 재질 타입을 이진화 | 금속 (Metallic = 1) . | BaseColor = Fresnel 반사 색상 (F0). | Diffuse 성분 = 0 (물리적으로 정확한 금속 모델). | . | 비금속 (Metallic = 0) . | BaseColor = Diffuse 알베도. | Specular는 고정값 (~0.04) 또는 Specular 입력으로 미세 조정 | . | . | 메모리 효율적 (Specular 맵 불필요), 실시간 렌더링에 최적화. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-주요-맵-설명"
  },"53": {
    "doc": "2. Master Material",
    "title": "Specular/Glossiness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | Diffuse | 비금속 재질의 기본 색상. 금속: 디퓨즈 맵 사용 X | RGB | 메탈릭 워크플로우의 BaseColor와 유사하지만, 금속에서는 무시됨. | . | Specular | 모든 재질의 반사 색상 및 강도 금속: RGB 비금속: Grayscale | RGB / Grayscale | 메탈릭 워크플로우의 Metallic + BaseColor 역할을 동시에 함. | . | Glossiness | 표면 광택도 0: 거칠음 1: 매끄러움 | Grayscale | Roughness와 반대 | . | 스페큘라는 Specular 맵으로 반사 색상과 강도를 직접 제어함 | 반사 색상의 자유도 높음, 오프라인 렌더링(V-Ray)과 호환됨 | . 참고하면 좋은 링크 . | Metalness Maps and Workflow Explained . | PBR: metallic vs specular workflow . | Specular vs Metalness Workflows for PBR Shading in Blender . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-주요-맵-설명"
  },"54": {
    "doc": "2. Master Material",
    "title": "sRGB (standard Red Green Blue)",
    "content": "sRGB는 모니터, TV 등 대부분의 디스플레이에서 사용하는 표준 색 공간이다. | 사람이 인지하는 색감을 기준으로 설계됨 . | 인간의 눈은 어두운 색상의 변화에 더 민감함 | sRGB는 이를 반영해 암부(어두운 영역)의 색상 정보를 강조하는 비선형 곡선을 사용 | . | 감마 보정이 포함되어 있음 (약 γ = 2.2) . | 즉 색상 데이터가 밝게 저장됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue"
  },"55": {
    "doc": "2. Master Material",
    "title": "Gamma vs inear Workflow",
    "content": ". | 감마 워크플로우 (Gamma Workflow) . | 전통적인 방식으로, sRGB 공간에서 렌더링을 수행 | 텍스처와 최종 출력이 sRGB로 가정되기 때문에, 라이팅 계산 시 자동으로 리니어로 변환되지 않음 | 실시간 라이팅 계산이 부정함 (예: 어두운 영역에서 색상 밴딩 발생) | PBR(물리 기반 렌더링)과 호환성이 떨어짐 | . | 리니어 워크플로우 (Linear Workflow) . | 리니어 컬러 스페이스에서 렌더링을 수행 | 텍스처는 sRGB에서 로드될 때 자동으로 리니어로 변환되고, 최종 출력 시 다시 sRGB로 감마 보정 | 물리적으로 정확한 라이팅 계산이 가능 | . | . 감마, 리니어 워크플로우 처리과정 . | 감마 워크플로우 . | 텍스처(sRGB) → (감마 보정 해제 없음) → 라이팅 계산 → 출력(sRGB) | . | 리니어 워크플로우 . | 텍스처(sRGB) → 자동 리니어 변환 → 물리적 라이팅 계산 → sRGB로 출력 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow"
  },"56": {
    "doc": "2. Master Material",
    "title": "☑️결론",
    "content": "언리얼 엔진 5에서의 동작 . 텍스처 . | sRGB 플래그가 켜진 텍스처 (알베도, 디퓨즈)는 리니어로 변환되어 쉐이더에서 사용 | sRGB 플래그가 꺼진 텍스처 (메탈릭, 러프니스)는 변환 없이 리니어로 읽힘 | . 라이팅 계산 . | 모든 쉐이더 연산은 리니어 공간에서 이루어짐 | 실시간 광원, GI, 반사 등이 물리적으로 정확하게 계산 | . 최종 출력 . | 최종 프레임 버퍼는 모니터 표준(sRGB)에 맞게 자동 감마 보정되어 출력 | . 참고하면 좋은 링크 . | computer color is broken | Gamma Vs. Linear Workflow for KeyShot Users | UNDERSTANDING GAMMA CORRECTION | Gamma Color space와 Linear Color space란? | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EF%B8%8F%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#️결론"
  },"57": {
    "doc": "2. Master Material",
    "title": "Texture Compression Settings (텍스쳐 압축 세팅)",
    "content": "텍스쳐를 더블 클릭하면 열리는 창으로 텍스쳐 압축 세팅 설정 가능. | 알파가 없는 텍스쳐는 알파 없이 압축 체크 (Compress Without Alpha) | sRGB가 아닌 텍스쳐는 sRGB 체크 해제 | Compression Settings 에서 세팅 설정 . | Masks (no sRGB) | . | . 텍스쳐 샘플러 노드의 설정으로 샘플러 타입 설정 가능. | 텍스쳐가 sRGB라면 Sampler Type = color | 텍스쳐가 sRGB가 아니아면 Sampler Type = Linear color . | BlackPlaceholder | . | . 압축 설정과 샘플러 타입 설정이 모두 같게 설정 되어야 한다. (sRGB가 아닌경우 샘플러 Linear) . 참고하면 좋은 링크 . | Texture Compression Settings | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-%ED%85%8D%EC%8A%A4%EC%B3%90-%EC%95%95%EC%B6%95-%EC%84%B8%ED%8C%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-텍스쳐-압축-세팅"
  },"58": {
    "doc": "2. Master Material",
    "title": "10. Normal",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal"
  },"59": {
    "doc": "2. Master Material",
    "title": "로우 폴리 vs 하이 폴리 모델",
    "content": ". | 로우 폴리 모델은 표면이 평평하고 법선이 단순. | 하이 폴리 모델은 표면이 복잡하고 법선이 다양. | . 노멀 맵은 하이 폴리 모델의 법선 정보를 로우 폴리 모델에 “옮기는” 기술이다. | 로우 폴리 모델의 정점 법선은 평평해 보이지만, 노멀 맵으로 인해 픽셀 단위로 법선이 조정되어 하이 폴리 같은 디테일이 나온다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%A1%9C%EC%9A%B0-%ED%8F%B4%EB%A6%AC-vs-%ED%95%98%EC%9D%B4-%ED%8F%B4%EB%A6%AC-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#로우-폴리-vs-하이-폴리-모델"
  },"60": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 좌표계 (탄젠트 공간)",
    "content": "노멀 맵은 탄젠트 공간에 저장된다. | 노멀 맵의 픽셀 값 (R, G, B)은 탄젠트 공간에서의 법선 방향을 나타냄 | Z축은 “표면 바깥쪽”을 가리킨다. (일반적으로 (0,0,1)이 기본 법선) | 탄젠트 공간은 각 정점마다 다르다. | 노멀 맵의 법선 벡터는 각 정점의 탄젠트 공간(= 각 정점의 로컬 좌표계) 기준으로 저장된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%A2%8C%ED%91%9C%EA%B3%84-%ED%83%84%EC%A0%A0%ED%8A%B8-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-좌표계-탄젠트-공간"
  },"61": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 생성 과정",
    "content": "노멀 맵은 하이 폴리 모델의 법선을 로우 폴리 모델의 탄젠트 공간에 투영하여 저장한다. 1.하이 폴리 모델의 법선 추출 . | 하이 폴리 모델의 각 정점 법선을 계산 | 하이 폴리 모델의 법선은 월드 공간 또는 오브젝트 공간에 있음 | . 2.로우 폴리 모델의 탄젠트 공간 계산 . | 로우 폴리 모델의 각 정점에서 TBN 기저(basis)를 계산 | 로우 폴리 모델의 각 정점은 자신만의 T, B, N 벡터를 가진다. | 노멀 맵을 탄젠트 공간에 저장하기 위한 기준 좌표계를 제공 . | T (Tangent): UV의 U 방향 (텍스처 가로) | B (Bitangent): UV의 V 방향 (텍스처 세로) | N (Normal): 로우 폴리 모델의 표면 법선 | . | . 3.하이 폴리의 법선 → 로우 폴리의 탄젠트 공간으로 변환 . | 하이 폴리 법선을 로우 폴리 모델의 TBN 행렬의 역행렬로 변환한다. | 하이 폴리 법선을 탄젠트 공간으로 변환한 결과 값은 -1 ~ 1 범위를 가짐 | 변환된 법선을 RGB 값 (0 ~ 1)으로 리매핑해 저장 | . // 하이 폴리 법선 (오브젝트 공간) vec3 normal_high = normalize(hitNormal); // 탄젠트 공간으로 변환 (TBN은 로우 폴리의 기저) vec3 normal_tangent = transpose(TBN) * normal_high; // 노멀 맵 저장 (0~1 리매핑) vec3 normalMapValue = normal_tangent * 0.5 + 0.5; . | 채널 | 벡터 구성요소 | 설명 | . | R | X | Tangent(가로) 방향의 법선 벡터 성분 | . | G | Y | Bitangent(세로) 방향의 법선 벡터 성분 | . | B | Z | Surface Normal(법선) 방향의 법선 벡터 성분 | . 4.노멀 맵 데이터 생성 . | 노멀 맵에 “하이 폴리 법선이 로우 폴리 모델의 탄젠트 공간에서 어떻게 변형되어야 하는지”가 데이터로 저장됨. | . 5.노멀 맵의 사용 . 렌더링 시에는 노멀맵의 값을 다시 TBN 행렬을 통해 월드 공간 법선으로 복원한다. | 노말맵은 법선을 0 ~ 1로 리매핑해 저장된 상태. | 실제로 렌더링에 사용할 때는 다시 -1 ~ 1로 복원 | . // 노멀 맵에서 법선 추출 (0~1 → -1~1) vec3 normal_tangent = texture(normalMap, uv).rgb * 2.0 - 1.0; // 월드 공간 법선으로 변환 vec3 normal_world = normalize(TBN * normal_tangent); // 조명 계산 (예: Lambertian Diffuse) float diffuse = max(0.0, dot(normal_world, lightDir)); . 추가로 알면 좋은 점 . | 노멀맵이 대부분 파란 이유 . | 평평한 표면의 벡터가 (0, 0, 1)이기 때문 | 색 변화가 의미하는 것 = 파랑 외의 색은 법선이 좌우(X), 상하(Y)로 기울어진 정도를 의미 | . | 스무딩 그룹(Smoothing Groups) . | 로우 폴리 모델의 정점 법선을 보간할지 말지 결정 | 보간 O (같은 스무딩 그룹): 정점 사이가 부드럽게 연결 | 보간 X (다른 스무딩 그룹): 정점 사이가 날카롭게 끊어짐 | 로우 폴리의 법선이 스무딩 그룹에 따라 변하면 노멀맵에 저장되는 차이도 달라진다. | . | . 참고하면 좋은 링크 . | Tutorial: How Normal Maps Work &amp; Baking Process | Deconstructing a Normal Map | Normal Mapping | OpenGL Tutorial - Normal Maps | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-생성-과정"
  },"62": {
    "doc": "2. Master Material",
    "title": "Flatten Normal",
    "content": "노멀 벡터의 Z(Depth) 성분을 조절해 노멀맵을 평탄화 하는 노드 . | 입력 Normal (V3) (XYZ) : 탄젠트 공간에서의 노멀 벡터. 원본 노말 맵 | 입력 Flatten Strength (Scalr) : Float (0.0 ~ 1.0), 평탄화 강도 (1.0에 가까울수록 Z가 약해짐) | 출력 Result (V3) : 평탄화가 완료된 노멀 벡터터 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal"
  },"63": {
    "doc": "2. Master Material",
    "title": "Flip Green Channel",
    "content": "텍스처의 노멀 맵에서 G(Green) 채널을 반전시키는 옵션 . | 노멀 맵이 OpenGL 방식과 DirectX 방식 중 어떤 포맷으로 저장되었는지에 따라 옵션 사용 유무가 달라진다. | OpenGL과 DirectX는 Y(Green) 좌표계가 반대기 때문 | . 언리얼 엔진은 DirectX 기반이다. | OpenGL 기반 툴 (Blender, Substance Painter 등)에서 내보낸 노멀 맵을 언리얼에서 사용할 때 . | Flip Green Channel ☑️ (체크) | . | DirectX 기반 툴 (3ds Max, Maya 등)에서 내보낸 노멀 맵 . | Flip Green Channel ❌ (체크하지 않음) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel"
  },"64": {
    "doc": "2. Master Material",
    "title": "11. Ambient Occlusion",
    "content": "광원과 관계없이, 환경 전체에서 모든 방향에서 들어오는 간접광(Ambient Light) 이 차폐되는 정도에 따라 어두움을 표현하는 기법 . | AO는 순수히 기하학적 구조(geometry)에 의해 결정되는 그림자 차폐 효과 | AO는 오직 모델의 형태와 표면 간 거리만으로 차폐 정도를 계산 | 광원이 움직여도 AO 결과는 변하지 않음 (방향성 없음) | 깊이감이나 접촉면 강조를 통해 공간 인지를 높임 | . 그림자와 AO의 차이 . | 항목 | 그림자 (Shadow) | 앰비언트 오클루전 (AO) | . | 광원 의존성 | 광원의 위치와 방향에 따라 달라짐 | 광원과 상관없이 항상 동일함 | . | 생성 원리 | 광원에서 물체까지 직진하는 빛이 막혔을 때 발생 | 공간적 차폐 정도에 따라 빛이 덜 도달하는 효과 | . | 형태 | 명확한 실루엣 형태 | 부드러운 음영 효과 | . | 변화 여부 | 광원이 움직이면 그림자도 변화 | 광원이 움직여도 AO는 고정됨 | . | 렌더링 목적 | 광원 존재감, 선명한 명암 표현 | 깊이감, 접촉 강조, 사실감 부여 | . AO는 오프라인 렌더링과 실시간 렌더링이 있는데 계산 방식이 다르다. 아래는 오프라인 렌더링 AO MAP 생성 과정이다. | 계산 기반 : 표면 점에서 주변 반구(헤미스피어)로 발사된 광선이 차단되는 비율”을 계산 | 실제 빛의 동작을 단순화한 모델이지만, 레이 트레이싱과 유사한 광선 충돌 검사를 사용 | 차폐 정도(Occlusion Factor)는 0.0(완전히 열림)에서 1.0(완전히 차폐됨) 사이의 값으로 표현 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion"
  },"65": {
    "doc": "2. Master Material",
    "title": "오프라인 AO 맵 생성 과정",
    "content": "AO 맵은 “표면 점 → 반구형 광선 발사 → 충돌 검사 → 차폐 비율 계산” 과정으로 생성됨 . 1.모델 준비 . 2.표면 점(Surface Point) 선택 . | 모델의 각 버텍스 또는 텍셀에서 AO를 계산 | 예시: 4K 텍스처(4096×4096)라면 1,600만 개 이상의 점을 처리. | . 3.반구형 샘플링(Hemispheric Sampling) . | 표면 법선(Normal) 기반 반구 정의 : 점의 법선 벡터(N)를 기준으로 반구(헤미스피어)를 생성 . | 광선은 이 반구 내에서만 무작위 방향으로 발사됨 | . | 광선 발사(Ray Casting) . | 각 점에서 N개 광선을 무작위 방향(θ, φ)으로 발사 | θ(세타) : 법선 기준 각도 (0°~90°). | φ(피) : 방위각 (0°~360°). | 광선 거리(Ray Distance): 일반적으로 장면 크기의 10~20%로 제한 | . | 광선 충돌 검사: 발사된 광선이 다른 지오메트리와 충돌하는지 확인 . | 충돌 시 : “차폐됨(Occluded)” | 충돌 없음 : “개방됨(Open)” | . | 차폐 비율 계산: AO 값 = (차폐된 광선 수) / (전체 광선 수) . | 예: 100개 광선 중 30개가 차폐됐다면 AO = 0.3 | . | . 4.텍스처 베이킹 . | 계산된 AO 값을 흑백 텍스처로 저장함 | 픽셀 보간: 버텍스 기반 결과를 텍스처 픽셀에 매핑할 때 보간(Interpolation)이 일어남 | . 참고하면 좋은 링크 ambient occlusion in unrealengine5 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-ao-%EB%A7%B5-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#오프라인-ao-맵-생성-과정"
  },"66": {
    "doc": "2. Master Material",
    "title": "픽셀 보간(Interpolation)",
    "content": "텍스처 베이킹에서 “픽셀 보간(Interpolation)”이란? . | 3D 모델의 버텍스(정점)에서 계산된 값을 텍스처의 픽셀에 자연스럽게 채우기 위해 평활화하는 과정 | . ❓왜 보간(Interpolation)이 필요해? . | 버텍스는 한정적이지만, 텍스처는 고해상도라 픽셀 수가 훨씬 많음 | 버텍스 값만으로는 텍스처가 계단 현상(Aliasing)이나 뚝뚝 끊긴 패턴이 생길 수 있음 | . 버텍스(Vertex) vs 텍셀(Texel) . | 버텍스 : 3D 모델의 꼭짓점. AO는 보통 버텍스 단위로 먼저 계산됨 (각 버텍스에서 광선 발사) | 텍셀 : 텍스처의 픽셀. UV 맵으로 매핑될 때 버텍스 사이의 빈 공간을 채워야 함 | . 픽셀 보간 과정 . | 버텍스 AO 값 생성 모델의 각 버텍스에서 AO 계산이 완료되면, 다음과 같은 값이 만들어짐 . | 버텍스 A : AO = 0.2 | 버텍스 B : AO = 0.7 | 버텍스 C : AO = 0.5 | . | UV 공간에서의 보간 . | 삼각형 내부 픽셀 처리 : UV 맵에서 삼각형(Face) 내부의 픽셀은 주변 버텍스의 AO 값의 가중 평균으로 채워짐 | 예시 : 아래 그림에서 P 픽셀의 AO는 A, B, C 버텍스 값의 Barycentric Coordinates(무게중심좌표)로 보간됨 P의 AO = (A의 AO × 가중치₁) + (B의 AO × 가중치₂) + (C의 AO × 가중치₃) . | 결과 : A(0.2), B(0.7), C(0.5) 사이의 픽셀은 0.2~0.7 사이의 부드러운 그레이드로 채워짐 | . | 보간 알고리즘 . | Bilinear Interpolation : 인접한 4개 버텍스 값으로 2D 평면 보간 | Barycentric Interpolation : 삼각형 내부에서 3개 버텍스 기반 보간 (가장 흔함) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%ED%94%BD%EC%85%80-%EB%B3%B4%EA%B0%84interpolation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#픽셀-보간interpolation"
  },"67": {
    "doc": "2. Master Material",
    "title": "12. channel packing",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing"
  },"68": {
    "doc": "2. Master Material",
    "title": "RMA MAP / ARM MAP",
    "content": "하나의 RGB 텍스처에 Grayscale 속성 맵 3개를 각각의 채널(R/G/B)에 패킹해서 저장하는 방식이다. 실시간 렌더링에서 텍스처 메모리와 샘플 호출을 절약하는 데 매우 유리하다. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map"
  },"69": {
    "doc": "2. Master Material",
    "title": "RMA 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 | 설명 | . | R | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | G | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | B | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-텍스쳐-구성"
  },"70": {
    "doc": "2. Master Material",
    "title": "ARM 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 |   | . | R | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . | G | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | B | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | 경우에 따라 Alpha 채널에 다른 정보(예: Height, Opacity)를 저장하기도 한다. | 텍스쳐쳐 패킹 시 원본 맵의 명암비, 선명도가 유지되는지 확인해야 한다. | . | 장점 . | 메모리 절약: 3개의 별도 텍스처 대신 단일 텍스처로 관리 → VRAM 사용량 감소. | 성능 향상: 쉐이더에서 텍스처 샘플링 횟수 줄어듦 → 실시간 렌더링(게임)에 유리. | . | 단점 . | 텍스쳐 압축 알고리즘 특성 상 채널 간 데이터가 서로 영향을 미침 → Metallic(G) 채널의 강한 경계가 Roughness(R) 채널의 값을 흐리게 만들 수 있음 | 8비트 텍스처 (0~255)는 채널당 256단계만 표현 가능하므로 각 채널의 정밀도가 떨어진다. | 예: AO(B) 값의 127과 128 사이의 미세한 차이를 잃을 수 있음 | . | . | . 따라서 고퀄리티 아트워크에서는 RMA 대신 별도 맵 사용을 고려해야 한다. | 모바일 게임: RMA로 메모리 절약. | 시네마틱 렌더링: Roughness, Metallic, AO를 별도로 관리. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-텍스쳐-구성"
  },"71": {
    "doc": "2. Master Material",
    "title": "12. displacement MAP",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map"
  },"72": {
    "doc": "2. Master Material",
    "title": "13. project template",
    "content": "마테리얼 우클릭 -&gt; 에셋 액션 -&gt; migrate(마이그레이션) / 노드 그래프만 가져오고 싶으면 베이스 컬러 텍스쳐 -&gt; 디폴트 텍스쳐로 바꿔서 가져오면 됨 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template"
  },"73": {
    "doc": "3. Scene create",
    "title": "3. Scene create",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html"
  },"74": {
    "doc": "3. Scene create",
    "title": "1. 씬 계획하기",
    "content": ". | Find Reference Image : 컨셉 이미지 찾아보기 | block out : 대략적인 레이아웃 잡기 | Layering : 디테일 쌓기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-%EC%94%AC-%EA%B3%84%ED%9A%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-씬-계획하기"
  },"75": {
    "doc": "3. Scene create",
    "title": "fab export",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export"
  },"76": {
    "doc": "3. Scene create",
    "title": "2. post process vlome",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome"
  },"77": {
    "doc": "3. Scene create",
    "title": "lumen",
    "content": "이머시브 마테리얼도 라이트에 영향을 줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen"
  },"78": {
    "doc": "3. Scene create",
    "title": "nanite ? what",
    "content": "이 설정 꺼야 버텍스 페인팅 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what"
  },"79": {
    "doc": "3. Scene create",
    "title": "3. material blend",
    "content": "베이스, 중간, 탑 . 버텍스 브러쉬 . | 검정 : 칠해짐 | 흰색 : 지워짐 | r : 중간 텍스쳐 | g : 탑 텍스쳐 | b : puddle 레이어 (젖은 웅덩이 생성) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend"
  },"80": {
    "doc": "3. Scene create",
    "title": "vertex painting",
    "content": "표면의 꼭짓점에 어떠한 것을 칠할 수 있도록 해줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting"
  },"81": {
    "doc": "3. Scene create",
    "title": "4. decal",
    "content": ". | 표면에 붙일 수 있는 스티커 | 메시에 투사시킬수 있는 머티리얼 | sort order : 레이어 순서 (데칼이 겹쳤을 때 어느것이 위인지 결정) | wet decal : 데칼이 웅덩이에 영향을 받게 하고싶으면 마스터 머티리얼 복사해서 wet_decal 만든 뒤 러프니스 연결 끊기 | 스태틱 메시가 데칼의 영향을 받지 않게끔 하려면 Advanced의 Receives Decals 옵션 끄기 decal | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal"
  },"82": {
    "doc": "3. Scene create",
    "title": "Editor Utility Tool / Editor Scripting",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . cpp-quick-start . | g: 뷰포트 아이콘 끄기 켜기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting"
  },"83": {
    "doc": "Add Custom Delegate",
    "title": "목표: 콘텐트 브라우저 모듈을 로드하고 해당 모듈의 델리게이트 배열에 Custom 메뉴 델리게이트 추가하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%A1%9C%EB%93%9C%ED%95%98%EA%B3%A0-%ED%95%B4%EB%8B%B9-%EB%AA%A8%EB%93%88%EC%9D%98-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%B0%EC%97%B4%EC%97%90-custom-%EB%A9%94%EB%89%B4-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#목표-콘텐트-브라우저-모듈을-로드하고-해당-모듈의-델리게이트-배열에-custom-메뉴-델리게이트-추가하기"
  },"84": {
    "doc": "Add Custom Delegate",
    "title": "Pragma region",
    "content": ". | IDE에서 확장하거나 축소할 수 있는 코드 블록 지정 | 버튼을 통해 소스 코드 블록을 접었다 펼 수 있다 | . #pragma region 리전이름 void Test(){ // ... } #pragma endregion 리전이름 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region"
  },"85": {
    "doc": "Add Custom Delegate",
    "title": "InitCBMenuExtention() 함수 구현에 사용한 메서드",
    "content": "1. Module.GetAllPathViewContextMenuExtenders() . Content Browser의 폴더 뷰(경로 뷰)에서 우클릭 시 메뉴를 추가할 수 있도록 델리게이트(Extender) 리스트를 리턴해줌 . TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; GetAllPathViewContextMenuExtenders(); . | 반환값: . | TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; | 폴더 뷰 컨텍스트 메뉴 확장자(델리게이트) 리스트의 레퍼런스 | 이 리스트에 새로운 확장 델리게이트를 추가(Add) 하면, 폴더(경로) 우클릭 시 커스텀 메뉴가 동적으로 삽입됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-함수-구현에-사용한-메서드"
  },"86": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 리스트",
    "content": "언리얼에서는 기존 시스템을 건드리지 않고 사용자만의 기능을 쉽게 추가할 수 있도록 모듈 내부에 델리게이트 배열을 가지고 있다 . | 모듈별로 델리게이트 리스트가 있음 | 여기에 커스텀 델리게이트를 추가하면 이벤트 발생 시 엔진이 모든 델리게이트를 순회하여 호출함 | . | 모듈 | 확장 대상 | 델리게이트 리스트 함수 | . | FContentBrowserModule | 폴더(경로) 컨텍스트 메뉴 | GetAllPathViewContextMenuExtenders() | . | FContentBrowserModule | 에셋(파일) 컨텍스트 메뉴 | GetAllAssetViewContextMenuExtenders() | . | FContentBrowserModule | 컬렉션 컨텍스트 메뉴 | GetAllCollectionViewContextMenuExtenders() | . | FLevelEditorModule | 툴바 메뉴 | GetAllLevelEditorToolbarMenuExtenders() | . | FLevelEditorModule | 뷰포트 컨텍스트 메뉴 | GetAllLevelViewportContextMenuExtenders() | . | FLevelEditorModule | 레벨 에디터 컨텍스트 메뉴 | GetAllLevelEditorContextMenuExtenders() | . | FSequencerModule | 시퀀서 메뉴 | GetAddMenuExtensibilityManager() | . | FMainFrameModule | 메인 프레임 메뉴/툴바 | GetMainFrameMenuExtensibilityManager() | . | FBlueprintEditorModule | 블루프린트 툴바/메뉴 | GetMenuExtensibilityManager()GetToolbarExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 메뉴 | GetMenuExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 툴바 | GetToolbarExtensibilityManager() | . | FComponentAssetBrokerModule | 에디터 에셋 관련 메뉴 | GetAssetBrokerMenuExtensibilityManager() | . 폴더(경로) 메뉴 확장 델리게이트 등록 예시 . void RegisterContentBrowserFolderMenuExtender() { // 1. ContentBrowser 모듈 인스턴스 획득 FContentBrowserModule&amp; ContentBrowserModule = FModuleManager::LoadModuleChecked&lt;FContentBrowserModule&gt;(TEXT(\"ContentBrowser\")); // 2. 폴더 뷰 컨텍스트 메뉴 델리게이트 리스트 획득 TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; Extenders = ContentBrowserModule.GetAllPathViewContextMenuExtenders(); // 3. 사용자 델리게이트 생성 (람다 예시) FContentBrowserMenuExtender_SelectedPaths MyFolderMenuExtender = FContentBrowserMenuExtender_SelectedPaths::CreateLambda( [](const TArray&lt;FString&gt;&amp; SelectedPaths) -&gt; TSharedRef&lt;FExtender&gt; { TSharedRef&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); // 여기서 Extender-&gt;AddMenuExtension 등으로 커스텀 메뉴 항목을 추가 return Extender; } ); // 4. 델리게이트 리스트에 등록 (Add) Extenders.Add(MyFolderMenuExtender); } . 2. FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate . 콘텐츠 브라우저(Content Browser)의 컨텍스트 메뉴를 확장하기 위해 사용되는 델리게이트 타입 . | GetAllPathViewContextMenuExtenders()가 리턴하는 타입으로 델리게이트 타입 추론 가능 | 해당 타입의 정의를 가보면 반환값, 파라미터를 설명한 델리게이트 매크로를 볼 수 있음 | . 3. CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender) . 델리게이트에서 제공하는 여러 바인딩 메서드를 사용해 바인딩 할 수 있다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-리스트"
  },"87": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 바인딩 케이스",
    "content": "Case 1 : 명시적 변수 선언 + 바인딩 + 델리게이트 배열에 추가 . // 델리게이트 객체 선언 FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate; // 델리게이트를 통해 내가 쓸 커스텀 함수에 바인딩 CustomCBMenuDelegate.BindRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender); // 모듈의 델리게이트 배열에 내 함수를 바인딩한 델리게이트 추가 ContentBroswerModuleMenuExtenders.Add(CustomCBMenuDelegate); . | 가독성: delegate 선언 → 바인딩 → 추가, 각각의 단계가 명확하게 분리됨 | 디버깅 용이: 바인딩된 delegate를 변수로 직접 디버깅/추적/조작할 수 있음 | . Case 2 : CreateRaw()로 delegate 생성과 배열 추가 한번에 하기 . ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); . | 델리게이트 시스템에서 제공하는 정적 메서드 CreateRaw()로 생성과 배열 추가 한번에 가능 | 임시 변수가 없음: delegate 객체가 따로 이름을 가지지 않음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%BC%80%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-바인딩-케이스"
  },"88": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 static 생성 메서드",
    "content": "언리얼 델리게이트 타입이 아래 메서드들을 일관되게 제공 . 1. Raw 포인터 바인딩 . CreateRaw( RawObjectPtr, &amp;Class::Method ) FMyDelegate::CreateRaw(this, &amp;MyClass::Handler) . | 비-UObject C++ 클래스용 | . 2. UObject 바인딩 (자동 수명 관리) . CreateUObject( UObject*, &amp;UClass::Method ) FMyDelegate::CreateUObject(this, &amp;AMyActor::EventHandler) . | 가비지 컬렉션 대상 객체용 | . 3. 스마트 포인터 바인딩 . CreateSP( SharedPtr, &amp;Class::Method ) FMyDelegate::CreateSP(MySharedPtr.ToSharedRef(), &amp;FMyClass::Callback) . | TSharedPtr/TSharedRef와 함께 사용 | . 4. 스레드-안전 약한 포인터 . CreateThreadSafeSP( WeakPtr, &amp;Class::Method ) FMyDelegate::CreateThreadSafeSP(MyWeakPtr.Pin(), &amp;FMyClass::ThreadCallback) . | 멀티스레드 환경용 | . 5. 람다 함수 바인딩 . CreateLambda( []{ ... } ) FMyDelegate::CreateLambda([this](){ UE_LOG(LogTemp, Warning, TEXT(\"Lambda called!\")); . | 인라인 콜백 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-static-%EC%83%9D%EC%84%B1-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-static-생성-메서드"
  },"89": {
    "doc": "Add Custom Delegate",
    "title": "Add Custom Delegate",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html"
  },"90": {
    "doc": "Add Prifixes To Assets",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 클래스에 맞는 접두사(예: BP_) 붙이기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%A0%91%EB%91%90%EC%82%AC%EC%98%88-bp_-%EB%B6%99%EC%9D%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#목표-콘텐트-폴더에서-선택한-에셋-클래스에-맞는-접두사예-bp_-붙이기"
  },"91": {
    "doc": "Add Prifixes To Assets",
    "title": "Add Prifixes To Assets",
    "content": ". | TMap&lt;UClass*, FString&gt; PrefixMap 에 Prifixes 목록 작성 . | 예: {UBlueprint::StaticClass(),TEXT(\"BP_\")} | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html"
  },"92": {
    "doc": "Add Prifixes To Assets",
    "title": "add Prifixes 함수 구현에 사용한 메서드",
    "content": "1. UObject* S-&gt;GetClass()-&gt;GetName() . | 클래스 이름을 반환 . | (예: “AActor”, “UMyComponent”) | . | 해당 오브젝트가 어떤 클래스로 생성되었는지 알 수 있음 | . 2. UObject* S-&gt;GetName() . | 오브젝트 인스턴스의 이름을 반환 . | (예: “Player_123”, “Weapon_Sword”) | . | 에디터에서 부여한 이름이나 동적으로 생성된 이름이 반환 | . AActor* MyActor = GetWorld()-&gt;SpawnActor&lt;AActor&gt;(...); FString ClassName = MyActor-&gt;GetClass()-&gt;GetName(); // \"AActor\" FString InstanceName = MyActor-&gt;GetName(); // \"MyActor_42\" . 3. FString::StartsWith() . | 문자열이 특정 문자열로 시작하는지 여부를 bool로 반환 | 대소문자 구분 여부 선택 옵션 존재 | 주의 : InPrefix가 빈 문자열이면 항상 true를 반환 | . 함수 시그니처 . bool StartsWith( const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . 사용 예시 . FString FilePath = \"Content/Textures/PlayerTexture.png\"; // 대소문자 무시 (기본값) bool bIsContent = FilePath.StartsWith(\"Content\"); // true // 대소문자 구분 bool bIsExact = FilePath.StartsWith(\"content\", ESearchCase::CaseSensitive); // false // 실제 활용 예시 if (FilePath.StartsWith(\"Content/Textures/\")) { UE_LOG(LogTemp, Warning, TEXT(\"텍스처 경로가 유효합니다.\")); } . 4. FString::RemoveFromStart . | 대상 문자열의 앞부분이 특정 문자열로 시작할 경우, 해당 부분을 제거 | . bool RemoveFromStart(const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase); . | 매개변수 . | InPrefix: 앞에서 제거하고자 하는 문자열(접두사, Prefix) | SearchCase: 대소문자 구분 여부 (ESearchCase::IgnoreCase 또는 ESearchCase::CaseSensitive) | . | 반환값 . | 제거 성공 true / 실패 false | . | . 5. FString::RemoveFromEnd . | 대상 문자열의 끝이 특정 문자열로 끝날 경우, 해당 부분을 제거 | 위 메서드와 동일하게 뒤에서 제거하고자 하는 문자열과 대소문자 구분 여부를 받는다. | . FString Str = TEXT(\"HelloWorld\"); bool bRemoved = Str.RemoveFromEnd(TEXT(\"World\")); // Str은 \"Hello\"가 되고, bRemoved는 true FString Str2 = TEXT(\"HelloWorld\"); bool bRemoved2 = Str2.RemoveFromEnd(TEXT(\"Hi\")); // Str2는 그대로 \"HelloWorld\", bRemoved2는 false . 6. UObject::IsA() . | 해당 오브젝트가 특정 클래스 타입이거나 그 클래스의 자식 클래스인지를 확인하는 메서드 | 비슷한 경우로 IsA(UClass*) 가 있다 | . 예시 . // IsA&lt;T&gt;() template&lt;typename T&gt; FORCEINLINE bool IsA() const { return IsA(T::StaticClass()); } if (SelectedObject-&gt;IsA&lt;UMaterialInstanceConstant&gt;()) { // UMaterialInstanceConstant 타입일 때 실행 } // IsA() bool IsA(const UClass* TargetClass) const; if (SelectedObject-&gt;IsA(AActor::StaticClass())) { UE_LOG(LogTemp, Warning, TEXT(\"이 오브젝트는 Actor입니다!\")); } . ❓ 왜 머티리얼 인스턴스 클래스를 찾으려면 UMaterialInstanceConstant를 사용해야 할까? . | 계층구조 UMaterialInterface (베이스) ├─ UMaterial (실제 마테리얼 에셋) └─ UMaterialInstance (인스턴스 베이스) ├─ UMaterialInstanceDynamic (런타임 생성 인스턴스) └─ UMaterialInstanceConstant (에디터에서 생성된 인스턴스) . | . | UMaterialInstance . | 추상 베이스 클래스. 직접 인스턴스화되지 않음 | . | UMaterialInstanceConstant . | 에디터에서 미리 생성해 놓은 정적 마테리얼 인스턴스 | 런타임 중 파라미터 변경이 불가능 | . | UMaterialInstanceDynamic (MID) . | 런타임에 동적으로 생성되며, 파라미터를 실시간으로 변경할 수 있음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-함수-구현에-사용한-메서드"
  },"93": {
    "doc": "Asset Batch Duplication",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 복사하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#목표-콘텐트-폴더에서-선택한-에셋-복사하기"
  },"94": {
    "doc": "Asset Batch Duplication",
    "title": "Scripting Libraries",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries"
  },"95": {
    "doc": "Asset Batch Duplication",
    "title": "1. UEditorUtilityLibrary::",
    "content": "에디터에서 에셋(Asset) 관련 작업을 자동화하기 위한 기능 제공 . | 에셋의 로드, 저장, 복사, 이동, 삭제 등 파일 시스템 수준의 작업 | 에셋 메타데이터(metadata) 접근 및 수정 | 에셋 의존성(dependencies) 분석 | 에셋 브라우저(Content Browser)와 연동된 작업 | . 메소드 . | GetSelectedAssetData() : TArray&lt;FAssetData&gt;를 반환 | GetSelectedAssets() : TArray&lt;UObject*&gt;를 반환 . | FAssetData는 UObject* 보다 더 많은 정보를 포함 | . | 모두 static 함수임 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary"
  },"96": {
    "doc": "Asset Batch Duplication",
    "title": "2. UEditorAssetLibrary:: 클래스",
    "content": "에디터 UI 및 일반 유틸리티 작업을 지원 . | 선택된 객체(Selected Actors/Assets)에 접근 | 에디터 UI(알림, 다이얼로그) 제어 | 월드/레벨 편집과 관련된 작업 | 블루프린트/파이썬 스크립트와의 연동 용이 | . 정리 . | 에디터 상호작용 (선택된 객체 제어, 알림 표시, 다이얼로그 생성) → UEditorUtilityLibrary | 에셋 작업 (일괄 임포트, 이름 변경, 메타데이터 편집) → UEditorAssetLibrary | . | UEditorUtilityLibrary로 선택한 에셋을 가져온 후 UEditorAssetLibrary로 해당 에셋을 수정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-클래스"
  },"97": {
    "doc": "Asset Batch Duplication",
    "title": ".uasset",
    "content": "Unreal Engine이 에디터에서 사용하는 에셋(데이터) 저장 파일 포맷 (파일 확장자) . | 모든 에셋은 UObject를 상속한 특정 클래스(예: UMaterial, UStaticMesh 등)로 만들어진다 | 에디터에서 만드는 에셋은 각기 다른 UObject 파생 클래스의 인스턴스가 디스크에 .uasset으로 저장된 것 . | BP_NewBlueprint.uasset | MyMaterial.uasset | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset"
  },"98": {
    "doc": "Asset Batch Duplication",
    "title": "객체 식별",
    "content": ". | Asset Name: 에셋(객체) 이름. 에디터에서 보이는 에셋의 이름 . | (예: BP_NewBluePrint) | . | Package Path: 에셋이 저장된 폴더 경로 + 에셋 이름 . | (예:/Game/MyFolder/BP_NewBluePrint) | ‘패키지’란 언리얼에서 하나의 저장 단위 | 하나의 .uasset 파일 = 하나의 패키지 . | 패키지 파일(.uasset) 안에는 여러 객체(에셋)가 저장 될 수 있음 | . | 패키지 경로는 항상 /로 시작 | 패키지 경로에는 .uasset 확장자가 포함되지 않음 | . | Object Path: 패키지 경로 + .에셋(객체) 이름 . | (예: /Game/MyFolder/BP_NewBluePrint.BP_NewBlueprint) | 패키지 내부에는 여러 객체가 있을 수 있으므로, 반드시 객체 이름까지 명시해야 객체를 특정할 수 있다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EA%B0%9D%EC%B2%B4-%EC%8B%9D%EB%B3%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#객체-식별"
  },"99": {
    "doc": "Asset Batch Duplication",
    "title": "duplicate 함수 구현에 사용한 메서드",
    "content": "1..ToString() . | FString, FName, FText, FVector, FGuid 등 일부 엔진 주요 클래스에서 각 타입에 맞는 방식으로 문자열 변환 | . 2.FString::FromInt() . | 정수형 값을 FString 객체로 변환하는 정적(static) 메서드 . | 매개변수 . | int32 Value: 변환할 정수 값 | . | 반환값 . | FString: 정수를 문자열로 변환한 결과 | . | . int32 Number = 42; FString Str = FString::FromInt(Number); // \"42\" . 3.FPaths::Combine() . | 여러 개의 경로 문자열을 OS별로 올바른 구분자로 결합해 하나의 경로 문자열로 만듦. | 내부적으로 /, \\ 자동 정리 | . | 매개변수 . | 오버로드가 많으나, 대표적으로 다음과 같은 버전 | const FString&amp; PathA, const FString&amp; PathB | . | 반환값 . | FString: 결합된 경로 문자열 | . | . FString FullPath = FPaths::Combine(TEXT(\"C:/Project\"), TEXT(\"Content\"), TEXT(\"Textures\")); // \"C:/Project/Content/Textures\" . 4.UEditorAssetLibrary::DuplicateAsset() . | 에디터 전용 라이브러리 함수. Content Browser에서 특정 자산(에셋)을 지정 경로로 복제(복사)함 . | 매개변수 . | const FString&amp; SourceAssetPath: 원본 자산의 경로 . | (예: “/Game/StarterContent/Textures/T_Wood”) | . | const FString&amp; DestinationAssetPath: 복제될 위치의 경로 . | (예: “/Game/MyFolder/T_Wood_Copy”) | . | . | 반환값 . | UObject*: 복제된 자산의 포인터 . | (복제 실패 시 nullptr 반환) | . | . | . UObject* Duplicated = UEditorAssetLibrary::DuplicateAsset(TEXT(\"/Game/AssetA\"), TEXT(\"/Game/Folder/AssetB\")); if (Duplicated) { /* 성공 */ } . 5.UEditorAssetLibrary::SaveAsset() . | 에디터에서 지정한 자산(에셋)을 디스크에 저장 . | 매개변수 . | const FString&amp; AssetPath: 저장할 자산의 경로 (예: “/Game/MyFolder/AssetB”) | . | 반환값 . | bool (true: 저장 성공 / false: 저장 실패) | . | . bool bSaved = UEditorAssetLibrary::SaveAsset(TEXT(\"/Game/MyFolder/AssetB\")); . 6.TEXT() . | C++의 문자열 리터럴을 엔진 내부 문자 타입(TCHAR)로 변환하는 매크로 . | TEXT() 매크로는 C++의 매크로 전처리 기능을 사용 | . | . FString MyString = TEXT(\"Hello\"); // ↓ 매크로 확장 후 FString MyString = L\"Hello\"; // C++ 컴파일러가 처리할 코드 생성 . | L”Hello” : UTF-16/유니코드 문자열 리터럴로 컴파일 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-함수-구현에-사용한-메서드"
  },"100": {
    "doc": "Asset Batch Duplication",
    "title": "Custom Editor Message",
    "content": ". | FMessageDialog를 사용해 메시지 대화 상자 출력하기 (모달) | FNotificationInfo를 사용해 알림 정보 출력하기 (오른쪽 하단에 나타나는 비동기 알림) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message"
  },"101": {
    "doc": "Asset Batch Duplication",
    "title": "FMessageDialog",
    "content": ". | 에디터 환경에서 사용자에게 메시지 박스(모달 대화상자)를 띄울 때 사용하는 유틸리티 클래스 | core 소속 | 블로킹(Blocking) 방식으로, 다이얼로그가 닫히기 전까지 다음 코드가 실행되지 않음 | 정적(static) 메서드로만 구성 | . 1. FMessageDialog::Open(EAppMsgType::Type MsgType, const FText&amp; Message) . | 지정한 메시지 유형과 메시지 텍스트로 다이얼로그 표시 | . 2. EAppReturnType::Type . EAppReturnType::Type ShowMsgDialog( EAppMsgType::Type MsgType, const FString&amp; Message, bool bShowMsgAsWarning = true ) . | MsgType: 메시지 박스 버튼 조합(Ok, YesNo 등) 지정 | Message: 출력할 메시지 문자열 | bShowMsgAsWarning: 경고(Warning) 스타일로 메시지를 띄울지 여부, 기본값 true . | true면 경고 스타일(노란색 경고 아이콘, “Warning” 타이틀 등)로 표시 | false면 일반 정보 스타일(파란색 info 아이콘, “Message” 또는 “Info” 타이틀 등)로 표시 | . | . EAppMsgType::Type 정리 . | 타입 | 다이얼로그 버튼 조합 | 대표적 사용 상황 | . | Ok | OK | 단순 확인, 정보 알림 | . | YesNo | Yes / No | 선택(이행/거부) | . | YesNoCancel | Yes / No / Cancel | 저장 여부 등 3분기 선택 | . | OkCancel | OK / Cancel | 진행/중단 | . | CancelRetryContinue | Cancel / Retry / Continue | 재시도 여부(예: 파일 저장 실패) | . | YesNoYesAllNoAll | Yes / No / Yes to All / No to All | 여러 작업에 대해 일괄 처리 | . | YesNoYesAllNoAllCancel | Yes / No / Yes to All / No to All / Cancel | 여러 파일 작업에서 개별/일괄/취소 | . | YesNoCancelContinue | Yes / No / Cancel / Continue | 드문 복합적 분기 | . | YesNoYesAllNoAllCancelContinue | Yes / No / Yes to All / No to All / Cancel / Continue | 매우 복잡한 결정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog"
  },"102": {
    "doc": "Asset Batch Duplication",
    "title": "FNotificationInfo",
    "content": ". | 에디터 하단 (주로 오른쪽 아래)에 잠시 나타나는 비동기 알림(Notification Toast) 정보를 정의하는 구조체 | FSlateNotificationManager를 통해 실제 알림을 생성/표시 | slate 소속 | . FNotificationInfo Info(FText::FromString(TEXT(\"작업이 완료되었습니다.\"))); Info.bFireAndForget = true; Info.ExpireDuration = 2.0f; // 2초 후 자동 닫힘 Info.bUseThrobber = false; // 스피너 비표시 FSlateNotificationManager::Get().AddNotification(Info); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo"
  },"103": {
    "doc": "Asset Batch Duplication",
    "title": "Asset Batch Duplication",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html"
  },"104": {
    "doc": "Binding Funcionts",
    "title": "목표: hook을 사용해 메뉴 엔트리, 메뉴 항목, 사용할 함수 바인딩 하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EB%AA%A9%ED%91%9C-hook%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%A9%94%EB%89%B4-%EC%97%94%ED%8A%B8%EB%A6%AC-%EB%A9%94%EB%89%B4-%ED%95%AD%EB%AA%A9-%EC%82%AC%EC%9A%A9%ED%95%A0-%ED%95%A8%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#목표-hook을-사용해-메뉴-엔트리-메뉴-항목-사용할-함수-바인딩-하기"
  },"105": {
    "doc": "Binding Funcionts",
    "title": "에디터에서 Extension hook 보기",
    "content": ". | 언리얼 에디터 툴바에서 편집 클릭 | 하단 환경설정의 에디터 환경설정 클릭 | 에디터 환경설정 창의 검색에 ui extension 입력 | Developer Tools의 Display UI Extension Points 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-extension-hook-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#에디터에서-extension-hook-보기"
  },"106": {
    "doc": "Binding Funcionts",
    "title": "FExtender와 FExtensionBase의 동작 원리 이해하기",
    "content": ". | FExtender = 각각의 FExtensionBase 정보를 통합 | FExtensionBase = 메뉴, 툴바 등 실제 확장 정보 데이터 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender%EC%99%80-fextensionbase%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender와-fextensionbase의-동작-원리-이해하기"
  },"107": {
    "doc": "Binding Funcionts",
    "title": "FExtensionBase",
    "content": "언리얼 엔진 Slate UI에서 메뉴/툴바 확장 시스템에서 사용하는 기본 추상 베이스 클래스 . | 실질적인 메뉴/툴바 확장 정보를 가지고 있음 | . class FExtensionBase { public: /** 멤버가 제대로 정리되도록 가상 소멸자가 필요함 */ virtual ~FExtensionBase() { } /** @return 확장 객체의 유형을 반환합니다. 파생 클래스에서 구현하세요 */ virtual EExtensionType::Type GetType() const = 0; /** 확장 포인트의 ID */ FName Hook; /** 확장 지점과 관련하여 후크할 위치 */ EExtensionHook::Position HookPosition; /** UI에 추가되는 액션에 사용할 커맨드 목록 */ TSharedPtr&lt; FUICommandList &gt; CommandList; }; . 주요 파생 클래스들 . 주요 파생 클래스들에는 델리게이트까지 추가됨 . | FMenuExtension : 메뉴 확장 구현 | FToolBarExtension : 툴바 확장 구현 | FMenuBarExtension : 메뉴 바 확장 구현 | . | 인자 | 역할 | 설명 | . | FName Hook | 확장 위치 지정 | 어떤 Hook(지점) 근처에 엔트리를 추가할지(예: “Delete”) | . | EExtensionHook::Position HookPosition | 상대 위치 | Hook 기준 Before/After/First 중 어디에 넣을지 | . | const TSharedPtr&lt;FUICommandList&gt;&amp; CommandList | 커맨드 집합 | 메뉴 엔트리의 활성/실행/단축키/상태 관리용, 없으면 nullptr | . | const FMenuExtensionDelegate&amp; MenuExtensionDelegate | 생성 콜백 | 실제로 메뉴 엔트리 Slate 위젯을 추가하는 함수/람다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase"
  },"108": {
    "doc": "Binding Funcionts",
    "title": "FExtender",
    "content": "여러 소스에서 메뉴/툴바에 엔트리를 동적으로 삽입할 때, 각각의 확장 요청을 병합하는 기능을 담당 . | 여러 소스에서 반환한 확장 요청을 실제 Slate UI에 적용하기 전 단일 리스트로 통합 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender"
  },"109": {
    "doc": "Binding Funcionts",
    "title": "FExtender 동작 과정",
    "content": "1. 확장자 생성 . TSharedPtr&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); . | 빈 FExtender 컨테이너 생성 | . 2. 확장 항목 생성 및 등록 . MenuExtender-&gt;AddMenuExtension( FName(\"Delete\"), // 확장 지점 (예: 컨텐트 폴더 우클릭 창의 삭제) EExtensionHook::After, // 위치 (예: 삭제 항목 다음에 추가) TSharedPtr&lt;FUICommandList&gt;(), // 명령 처리기 (단축키 설정) FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry) // 메뉴 엔트리 생성 함수 ); . | AddMenuExtension 호출 시 새로운 FMenuExtension 인스턴스 생성 | FMenuExtension 인스턴스는 아래 정보 저장 . | 확장 지점 이름(FName(“Delete”)) | 위치 정보(After) | 연결된 명령 리스트 | 메뉴 생성 델리게이트 | . | 생성된 객체는 FExtender의 내부 배열에 저장 . | TArray&lt; TSharedPtr&lt; const FExtensionBase &gt; &gt; Extensions | . | . FExtender 다이어그램 . 3. 실제 메뉴 생성 . 사용자가 콘텐트 폴더를 우클릭하면 Slate가 FExtender::Apply()를 호출 . | FExtender의 Extensions를 순회하면서 조건에 맞는 확장 지점 찾음 | 해당 지점에 등록된 모든 FExtensionBase 파생 객체 순회 | 각 확장의 HookPosition에 따라 적절한 위치에 메뉴 항목 삽입 | 파생 객체의 delegate를 실행해 메뉴/툴바에 실제 메뉴 항목 생성 | 확장 해제(RemoveExtension) 가능 . | 사용자가 직접 반환받은 FExtensionBase 핸들을 이용해 해당 확장 객체를 Extensions에서 제거 | . | . 확장 제거 . // 확장 제거 예시 TSharedRef&lt;const FExtensionBase&gt; MyExtension = Extender-&gt;AddMenuExtension(...); // ... Extender-&gt;RemoveExtension(MyExtension); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-동작-과정"
  },"110": {
    "doc": "Binding Funcionts",
    "title": "정리",
    "content": ". | 등록과 실행이 분리된다 . | 확장은 미리 등록만 해두고 실제로 필요할 때만 생성 (예: 메뉴가 열릴 때만 메뉴 항목 생성) | . | 확장 지점 기반으로 작동한다 . | 예: 같은 확장 지점 Delete에서 Before, After 생성 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#정리"
  },"111": {
    "doc": "Binding Funcionts",
    "title": "FMenuBuilder",
    "content": "FExtender와 함께 사용되어 컨텍스트 메뉴, 툴바 메뉴, 메인 메뉴 등을 구성 . | FExtender : “어디에 메뉴를 추가할지” 결정 | FMenuBuilder : “메뉴에 무엇을 추가할지” 정의 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder"
  },"112": {
    "doc": "Binding Funcionts",
    "title": "자유 사용되는 메서드",
    "content": "1. AddMenuEntry() . 기본 메뉴 항목 추가 . AddMenuEntry( FText::FromString(\"메뉴 항목\"), // 표시 이름 FText::FromString(\"툴팁 설명\"), // 툴팁 FSlateIcon(FAppStyle::GetStyleSetName(), \"Icons.Play\"), // 아이콘 FUIAction(FExecuteAction::CreateLambda([](){ /* 액션 로직 */ })) // 델리게이트 ); . FUIAction . Slate의 액션(메뉴 엔트리, 버튼 등)을 나타내는 컨테이너 구조체 -&gt; 통합적 관리 가능 . | 실행(FExecuteAction) : (void() 시그니처 콜백) . | 실행할 함수 | . | 활성화 가능 여부(FCanExecuteAction) : (bool() 시그니처 콜백, 선택적) . | 메뉴가 활성화되는지/비활성화되는지 | . | 체크 상태(FIsActionChecked) : (bool() 시그니처 콜백, 토글 메뉴/버튼용, 선택적) . | 체크(토글) 상태를 반영할지 말지 | . | . FExecuteAction만 단독 사용 . FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) . | 내부적으로 활성/체크 상태 등은 기본값으로 취급 | . 2. AddMenuSeparator() . 메뉴 항목 사이에 구분선을 추가 . AddMenuEntry(...); // 첫 번째 항목 AddMenuSeparator(); // ----- 구분선 ----- AddMenuEntry(...); // 두 번째 항목 . 3. AddWidget() . 커스텀 위젯 추가 / 체크박스, 슬라이더, 버튼 등 복잡한 UI를 메뉴에 삽입할 때 사용 . AddWidget( SNew(SCheckBox) .IsChecked(false) .OnCheckStateChanged_Lambda([](ECheckBoxState State){ /* 체크 상태 변경 */ }) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%9E%90%EC%9C%A0-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#자유-사용되는-메서드"
  },"113": {
    "doc": "Binding Funcionts",
    "title": "총 세번의 바인딩",
    "content": ". | 메뉴 엔트리 생성 위치(1차 바인딩) | . InitCBMenuExtention() { ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); } // CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); TSharedRef&lt;FExtender&gt; FBacgroundToolsModule::CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelectedPaths) { TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); if (SelectedPaths.Num() &gt; 0) { MenuExtender-&gt;AddMenuExtension(FName(\"Delete\"), EExtensionHook::After, TSharedPtr&lt;FUICommandList&gt;(), FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); } return MenuExtender; } . | 메뉴 항목의 모양 및 동작(2차 바인딩) | . // FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); void FBacgroundToolsModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder) { MenuBuilder.AddMenuEntry ( FText::FromString(TEXT(\"Delete Unused Assets\")), FText::FromString(TEXT(\"Safely delete all unused assets under folder\")), FSlateIcon(), FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) ); } . | 실제 실행할 함수(3차 바인딩) | . // FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) void FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked() { } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%B4%9D-%EC%84%B8%EB%B2%88%EC%9D%98-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#총-세번의-바인딩"
  },"114": {
    "doc": "Binding Funcionts",
    "title": "Binding Funcionts",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html"
  },"115": {
    "doc": "Container",
    "title": "Container",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html"
  },"116": {
    "doc": "Container",
    "title": "TArray",
    "content": "동일한 타입의 데이터를 순차적으로 저장, 관리, 반복, 조작하기 위한 동적 배열 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray"
  },"117": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 하나의 TArray에는 반드시 동일 타입만 저장 가능 | 동적 크기 조절: 요소 추가/삭제에 따라 자동으로 메모리 할당/해제 및 재조정 | 슬랙(slack) 최적화: 추가/삭제에 따른 빈번한 할당/해제를 방지하기 위해 여유 메모리 유지 . | 실제 할당된 메모리는 Num(요소 개수) 이상일 수 있음(성능 최적화 목적) | . | 깊은 복사(Deep copy): 배열 자체의 복사는 내부 요소 모두 복사 | 메모리 및 성능 측면에서 튜닝 가능(Allocator, Reserve/Empty/Reset 등) | 블루프린트에서도 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징"
  },"118": {
    "doc": "Container",
    "title": "생성자 속성",
    "content": "TArray를 생성할 때 element Type, Allocator 두 가지 속성을 사용할 수 있다. TArray&lt;int32&gt; IntArray; // 요소 타입 지정 TArray&lt;int32, TInlineAllocator&lt;4&gt;&gt; IntArray; // 요소, 할당자 속성 지정, 할당자는 선택 옵션 . 요소 타입 (Element Type) . TArray는 동일한 타입의 요소들을 저장하는 동질적(homogeneous) 컨테이너 . | 즉, 배열에 저장되는 모든 요소는 동일한 타입이어야 한다 | 이는 TArray, TArray, TArray&lt;UMyObject*&gt; 등으로 선언 | . 요소 타입은 다음과 같은 조건을 만족해야 함 . | 복사 가능(Copyable): 요소는 복사 생성자를 통해 복사될 수 있어야 함 | 소멸 가능(Destructible): 요소는 소멸자를 통해 적절히 정리될 수 있어야 함 | . 할당자 (Allocator) . TArray는 메모리 할당 방식을 결정하는 할당자(Allocator)를 선택적으로 지정할 수 있음 . | 할당자 | 설명 | . | FDefaultAllocator | 기본 힙 기반 할당자 | . | TInlineAllocator&lt;N&gt; | 처음 N개의 요소는 스택에 할당하고, 그 이후는 힙에 할당. 작은 배열에 유리하며, 스택 할당으로 인해 성능이 향상될 수 있음 | . | TFixedAllocator&lt;N&gt; | 고정 크기의 할당자로, 최대 N개의 요소만 저장할 수 있다. 초과할 경우 런타임 에러가 발생 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#생성자-속성"
  },"119": {
    "doc": "Container",
    "title": "ADD vs Emplace",
    "content": "ADD . 함수에 넘긴 인자를 임시 객체(temporary)로 만든 후, 그 임시 객체를 배열 끝에 복사하거나 이동해서 저장함 . TArray&lt;FString&gt; Arr; Arr.Add(TEXT(\"Hello\")); . | TEXT(\"Hello\")는 우선 임시로 FString이 만들어지고, 그 임시 객체가 TArray 내부에 복사/이동됨 | . Emplace . 배열 내부에 직접 인자를 전달해 객체를 생성함 . TArray&lt;FString&gt; Arr; Arr.Emplace(TEXT(\"Hello\")); . | TEXT(\"Hello\")를 인자로 받아서, 배열 메모리 공간에 바로 FString 생성자 호출 | . 결론 . | Add: 임시 객체 → TArray 내부 복사(힙) (임시 객체는 함수 끝나면 사라짐) . | 이미 만들어진 객체를 추가할 때 사용 | “이 객체를 배열에 더한다”는 의도가 명확함 | . | Emplace: 임시 객체 없이, 바로 TArray 내부(힙)에 생성 . | 임시 객체 생성/복사를 피함 → 성능 최적화 | 복잡한 객체 (복사/이동 비용이 큰 구조체 등)에서 효율적 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace"
  },"120": {
    "doc": "Container",
    "title": "TMap",
    "content": "키-값 쌍(key-value pair)을 저장하는 해시 맵(hash map) 구조 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap"
  },"121": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 키-값 쌍 저장: 키(Key)와 값(Value)을 쌍으로 저장하는 자료 구조 | 빠른 검색: 해시 테이블 기반으로 구현되어 있어 평균 O(1) 시간 복잡도로 검색 가능 | 템플릿 기반: TMap&lt;KeyType, ValueType&gt; 형태로 사용 | UPROPERTY로 선언 시, 세이브/로드, 네트워크 레플리케이션, 블루프린트에서 접근 가능 . | Key, Value 모두 리플렉션 및 직렬화 지원 타입이어야 함 | 예: TMap&lt;FString, float&gt; → O , TMap&lt;int32, UObject*&gt; → X | . | TMap은 삽입 순서나 정렬 순서를 보장하지 않음 | . 기본 사용법 . // TMap 선언 TMap&lt;FString, int32&gt; FruitPrices; // 요소 추가 FruitPrices.Add(TEXT(\"Apple\"), 1000); FruitPrices.Add(TEXT(\"Banana\"), 800); // 요소 접근 int32 ApplePrice = FruitPrices[\"Apple\"]; // 값 찾기 int32* Score = FruitPrices.Find(TEXT(\"Apple\")); int32 SafePrice = FruitPrices.FindRef(TEXT(\"Apple\")); // 존재하지 않으면 ValueType의 기본값 반환( int32면 0) // 값 변경 FruitPrices[TEXT(\"Apple\")] = 90; // 키 존재 확인 if (FruitPrices.Contains(TEXT(\"Banana\"))) { // 처리 코드 } // 키-쌍 제거 FruitPrices.Remove(TEXT(\"Apple\")); // 맵 비우기 FruitPrices.Empty(); // 반복문 순회 for (const TPair&lt;FString, int32&gt;&amp; Elem : FruitPrices) { UE_LOG(LogTemp, Log, TEXT(\"%s: %d\"), *Elem.Key, Elem.Value); } // 포인터 값 저장 시 안전한 삭제 예시 TMap&lt;FString, MyClass*&gt; ObjectMap; ObjectMap.Add(TEXT(\"Obj1\"), new MyClass()); TMap&lt;FString, TSharedPtr&lt;MyClass&gt;&gt; SafeMap; SafeMap.Add(TEXT(\"Obj1\"), MakeShared&lt;MyClass&gt;()); SafeMap.Empty(); // 자동 해제됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징-1"
  },"122": {
    "doc": "Container",
    "title": "주요 메서드 정리",
    "content": "| 메서드 | 설명 | . | Add(Key, Value) | 키-값 쌍 추가, 이미 키가 있으면 값 갱신 | . | Find(Key) | 키에 해당하는 값 포인터 반환, 없으면 nullptr | . | FindRef(Key) | 키에 해당하는 값의 복사본 반환 (키 없으면 기본값) | . | Contains(Key) | 해당 키 존재 여부 반환 (bool) | . | Remove(Key) | 키-값 쌍 제거, 성공 여부 반환 | . | RemoveAndCopyValue(Key, OutValue) | 키 삭제 + 값 복사 (성공 여부 반환) | . | Num() | 저장된 쌍의 개수 반환 | . | Empty() | 모든 데이터 삭제 | . | Reset() | 메모리 해제 및 초기화 | . | operator[] | [] 연산자로 값 접근/생성 | . | GenerateKeyArray() | 모든 키를 TArray로 반환 | . | GenerateValueArray() | 모든 값을 TArray로 반환 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주요-메서드-정리"
  },"123": {
    "doc": "Container",
    "title": "주의사항",
    "content": ". | 포인터를 저장할 때는 메모리 관리에 유의 → 스마트 포인터(TSharedPtr) 사용 추천 . | Remove()나 Empty()는 맵에서의 연결만 끊을 뿐, 메모리 해제는 하지 않음 | 만약 new로 할당한 객체를 저장했다면, 별도로 delete 하기 | . | operator[]는 키가 없으면 기본값(0, nullptr 등) 생성 후 반환하므로, 의도치 않은 값 생성 가능성 있음 . | 검색 전 Contains()로 확인하거나 Find()를 권장 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주의사항"
  },"124": {
    "doc": "Container",
    "title": "TSet",
    "content": "참고 링크 . | TArray | TMap | TSet | TArray vs std::vector | Optimizing TArray Usage for Performance | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset"
  },"125": {
    "doc": "Delete unused Assets From Selelction",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 중 미사용 에셋 삭제하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EC%A4%91-%EB%AF%B8%EC%82%AC%EC%9A%A9-%EC%97%90%EC%85%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#목표-콘텐트-폴더에서-선택한-에셋-중-미사용-에셋-삭제하기"
  },"126": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Asset Referencers",
    "content": ". | 레벨에서 사용된 에셋의 경우 Asset References(에셋 참조)가 존재함 | 즉 미사용 상태의 에셋의 경우 참조 개수 = 0 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers"
  },"127": {
    "doc": "Delete unused Assets From Selelction",
    "title": "AssetRegistry",
    "content": "모든 프로젝트 에셋의 메타 데이터를 인덱싱/검색/관리하는 중앙 관리 모듈 . | 에디터 구동 시 모든 프로젝트 에셋(.uasset, .umap 등)을 빠르게 탐색/관리할 수 있도록 내부적으로 모든 에셋의 메타데이터를 스캔 | 에셋 인덱싱: 실제 에셋 객체(UObject 등)는 메모리에 로드하지 않고, 각 에셋의 메타 데이터를 메모리에 인덱싱 (FAssetData 생성) | 빠른 검색: 이름, 클래스, 태그 등 다양한 조건으로 에셋을 빠르게 조회 | 런타임/에디터 지원: 런타임 자동화, 에디터 UI, 플러그인 등에서 활용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry"
  },"128": {
    "doc": "Delete unused Assets From Selelction",
    "title": "FAssetData",
    "content": "에셋 레지스트리에서 찾은 에셋에 대한 중요한 정보를 저장하는 구조체 . | Asset Registry는 FAssetData의 집합 | 실제 에셋의 전체 데이터나 객체는 아님 (일시적) | AssetRegistry를 통해 조회 시 TArray&lt;FAssetData&gt;로 반환됨 | . AssetRegistry 다이어그램 . | FARFilter : AssetRegistry 에서 검색에 사용되는 필터 | FAssetData → UObject: 필요에 따라 일시적으로 참조(사용)한다 (예: GetAsset() 호출) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata"
  },"129": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Remove Unused Assets 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::FindPackageReferencersForAsset . | 특정 에셋(Asset)을 참조하는 모든 패키지(Package)의 목록을 찾아 반환 | 에셋 의존성 분석에 사용. 특히 에셋을 삭제하거나 수정할 때 어떤 다른 에셋들이 영향을 받을지 확인 | 에디터 전용 기능 | . static TArray&lt;FString&gt; UEditorAssetLibrary::FindPackageReferencersForAsset( const FString&amp; AssetPath, bool bLoadAssetsToConfirm = false ); . | 매개변수 . | AssetPath (필수): 분석할 대상 에셋의 경로 (Object path) | bLoadAssetsToConfirm (옵션, 기본값 false) . | true: 참조하는 패키지를 메모리에 로드하여 정확성을 확인 (느리지만 정확하다) | false: 에셋 레지스트리(Asset Registry)의 메타데이터만 사용하여 빠르게 검색 (빠르지만 간접 참조 누락 가능) | . | . | 반환 값 . | 참조하는 패키지의 경로 문자열(FString) 배열 (TArray) | 에셋이 사용되지 않으면 빈 배열 반환 | . | . 2. Num() . | 컨테이너에 저장된 요소의 개수(길이)를 반환 | c++의 .Size()와 같음 | . 3. ObjectTools::DeleteAssets(UnusedAssetsData); . Asset들을 안전하게 일괄 삭제하는 유틸리티 . // UnrealEd 모듈 내 ObjectTools.h 선언부 static bool DeleteAssets(const TArray&lt;FAssetData&gt;&amp; AssetDataList, bool bShowConfirmation = true, bool bForceDelete = false); . | 대표적으로 FAssetData 배열을 인자로 받음 (다른 타입 매개변수 사용 가능) | . 동작과정 . | 입력 받은 FAssetData 리스트에서 실제 에셋 객체(UObject)를 찾아옴 | 에셋이 참조되는지 (Reference Graph) 검사 . | 다른 에셋이나 오브젝트에서 참조하고 있는 경우, 경고 대화창을 띄워 사용자에게 확인 받음 | 옵션에 따라, 강제 삭제(bForceDelete) 가능 | . | 사용자에게 삭제 확인(Confirmation) 요청 . | bShowConfirmation 인자가 true일 경우, 실제 삭제 전에 “정말 삭제할까요?”와 같은 확인창 표시 | . | 트랜잭션 생성 및 삭제 실행 . | 삭제 과정 전체를 에디터 트랜잭션(Undo/Redo)에 등록 → 실수 시 실행 취소 가능 | 내부적으로 FScopedTransaction을 사용하여 트랜잭션 단위로 관리 | . | 실제 삭제 . | 에셋을 Content Browser 및 파일 시스템(디스크)에서 제거 | 참조된 경우, 일부 삭제가 제한되거나, 사용자가 강제 삭제시 후처리(레퍼런스 클린업 등) 발생 | . | 결과 반환 . | 성공적으로 삭제된 경우 true, 실패 또는 취소시 false 반환 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-함수-구현에-사용한-메서드"
  },"130": {
    "doc": "Delete unused Assets From Selelction",
    "title": "ObjectTools.h",
    "content": "에디터 환경에서 UObject 관련 유틸리티 함수 집합을 정의한 헤더 파일 . | 삭제/이동/복사 동작과 관련해, 사용자에게 경고 및 결과 알림 대화창을 띄워줌 | UnrealEd 모듈에 소속 . | 런타임 환경(게임 실행)에서는 사용 불가. 에디터에서만 사용하는 기능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh"
  },"131": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Delete unused Assets From Selelction",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html"
  },"132": {
    "doc": "Fix Up Redirectors From Code",
    "title": "목표: 리다이렉터 정리하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%AA%A9%ED%91%9C-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#목표-리다이렉터-정리하기"
  },"133": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Redirector",
    "content": "에셋이 이동하거나 이름이 변경되었을 때 기존 참조를 유지하기 위해 사용 . | 에디터의 콘텐트 브라우저에서 이동하거나 변경하면 자동으로 생성함 | 탐색기나 터미널을 사용하여 에셋 이동 시 리다이렉터가 생성되지 않음 . | 에디터 API 를 사용하는 경우는 리다이렉터 정상 생성 | . | 리다이렉터가 많아지면 빌드/로딩 속도가 느려짐 -&gt; 정리 필요 | 콘텐츠 브라우저에서 우클릭 → ‘레퍼런스 뷰어’로 참조 관계 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector"
  },"134": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터가 필요한 이유",
    "content": ". | 언리얼 엔진 프로젝트는 에셋 간의 참조(Reference) 관계가 복잡하게 얽혀 있음 | 만약 어떤 블루프린트, 머티리얼, 레벨 등이 특정 에셋을 참조하고 있는데, 그 에셋의 위치나 이름이 바뀌면 기존 참조가 모두 깨짐 | 이 문제를 방지하기 위해, 기존 위치(예전 경로)에 ‘리다이렉터’ 에셋을 생성함 | 이 리다이렉터 에셋은 “이 에셋은 이제 새로운 위치에 있습니다”라고 알려줌으로써, 예전 참조들이 새 위치의 에셋을 계속 사용할 수 있게 해줌 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터가-필요한-이유"
  },"135": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터 작동 방식",
    "content": "1. 디스크(파일) 저장 . 리다이렉터는 ObjectRedirector 타입의 .uasset 파일로 저장 . | 자신이 원래 위치했던 경로(Original Path) | 참조해야 하는 대상 오브젝트(DestinationObject, 새 경로의 에셋에 대한 소프트 참조) 가 저장됨 | 이 상태의 리다이렉터는 그냥 하나의 “Proxy” 에셋(패키지)일 뿐이며, 실제 오브젝트 인스턴스(UObject 인스턴스)는 생성되어 있지 않음 | . 리다이렉터 에셋 개념적 구조 . // ObjectRedirector.uasset (실제 파일은 바이너리이지만, 개념적으로 다음과 같은 정보를 저장) { \"OriginalObjectPath\": \"/Game/Characters/OldCharacter\", // 원본 경로 \"DestinationObjectPath\": \"/Game/Heroes/NewCharacter\", // 새 경로 (SoftObjectPath) \"Flags\": RF_Public | RF_Standalone, // 객체 플래그 \"DestinationObject\": \"Soft Reference\" // 실제로는 포인터가 아니라 소프트 참조(경로 정보) 형태 } . 2. 메모리 로드(에디터/엔진에서 참조할 때) . | 리다이렉터가 메모리로 로드됨 . | 어떤 에셋이 리다이렉터 경로를 참조하고 있을 때, 언리얼은 먼저 리다이렉터(.uasset) 파일을 로드해서 UObjectRedirector 인스턴스로 메모리에 올림 | . | DestinationObject로 즉시 변환 . | 엔진은 리다이렉터를 참조하는 순간, DestinationObject(실제 에셋)를 메모리로 로드하고 참조를 자동으로 대체함 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터-작동-방식"
  },"136": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Redirectors 함수 구현에 사용한 메서드",
    "content": "Fix 과정의 핵심 . | 모든 리다이렉터를 탐색 | 각 리다이렉터의 DestinationObject를 메모리에 로드 | 예전 참조(리다이렉터 경로)를 새 참조(DestinationObject 경로)로 교체 | 리다이렉터 파일 삭제 | . 1. IAssetRegistry&amp; AssetRegistry . 에셋 레지스트리 가져오기 . ❓ 왜 인터페이스 레퍼런스 타입으로 가져오는거야? . | AssetRegistry는 엔진 내부적으로 이미 생성되어 관리되는 객체 | new로 직접 인스턴스를 만들면, 엔진의 전역 에셋 DB와 분리된 “쓸모 없는 객체”가 만들어짐 | 즉, 반드시 엔진이 소유/관리하는 인스턴스를 사용해야 하며, 이를 제공받는 공식 경로는 아래와 같다. | . FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get() . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-함수-구현에-사용한-메서드"
  },"137": {
    "doc": "Fix Up Redirectors From Code",
    "title": "함수명에 붙은 Checked란?",
    "content": "함수명에 “Checked”가 붙었을 때는 무조건 성공해야 하며, 실패 시 프로그램을 즉시 중단(Assert/Crash)한다는 의미 . | CastChecked (타입 불일치 → 크래시) | LoadModuleChecked (모듈 없음/실패 → 크래시) | . 비교 예시 . | 함수 | 동작 | 실패 시 | . | LoadModule() | 모듈 로드, 실패 시 nullptr 반환 | 안전 | . | LoadModuleChecked() | 모듈 로드, 실패 시 Assertion Failure(크래시) | 위험 (강제 중단) | . | GetModule() | 이미 로드된 모듈만 반환, 없으면 nullptr | 안전 | . 2. FModuleManager::LoadModuleChecked&lt;T&gt; . 엔진/에디터 모듈을 런타임에 안전하게 로드 . | FModuleManager:: . | 모듈 동적 로딩 시스템을 관리하는 핵심 클래스 | . | LoadModuleChecked() . | 템플릿 함수로, 지정된 모듈 타입(T)을 강제로 로드하고 검증 후 반환 | 모듈이 존재하지 않으면 크래시 | . | . template&lt;class T&gt; static T&amp; LoadModuleChecked(FName ModuleName); . 동작 . | ModuleName에 해당하는 모듈이 이미 로드되어 있으면 . | → 바로 그 모듈의 레퍼런스(포인터/레퍼런스)를 반환 | . | 아직 로드되지 않았다면 . | 모듈을 로드(동적 DLL 또는 엔진 플러그인 로딩) 시도 | 성공하면 인스턴스 반환 | 실패시 크래시 | . | 반환 타입은 T&amp; (예: FAssetRegistryModule&amp;) | . 3. CastChecked&lt;T&gt;() . 주어진 포인터가 실제 런타임에 T 타입(혹은 그 하위 타입)인지 체크한 뒤, 맞으면 T로 변환해서 반환 . | 틀리면 에디터 빌드(Development/Debug)에서는 강제로 크래시(Assertion 실패)를 일으킴 | . CastChecked&lt;T&gt;와 Cast&lt;T&gt;의 차이 . | 함수 | 타입 체크 실패 시 동작 | 주로 사용하는 상황 | . | Cast&lt;T&gt;() | 실패 시 nullptr 반환 | 타입이 확실하지 않을 때, if문으로 분기 필요할 때 | . | CastChecked&lt;T&gt;() | 실패 시 크래시/Assertion Failure | 타입이 반드시 T여야 할 때 (논리 오류 방지) | . 3. FARFilter . AssetRegistry 모듈에서 사용하는 에셋 검색 조건을 표현하는 구조체 . | AssetRegistry API (GetAssets 등) 호출 시, 이 구조체를 넘겨주면 조건에 맞는 에셋만 결과로 반환 | . FARFilter 주요 멤버 . | 필드 | 역할 | . | TArray&lt;FName&gt; PackagePaths | 검색할 폴더 경로(예:/Game, /Game/MyFolder) | . | TArray&lt;FName&gt; ClassPaths | 검색할 클래스 유형(예: Blueprint, ObjectRedirector) | . | bool bRecursivePaths | 하위 폴더까지 검색할지 여부 | . | TArray&lt;FName&gt; ObjectPaths | 특정 오브젝트 경로 지정(옵션) | . | … | 이 외에도 Tag, Metadata 등 다양한 조건 가능 | . FARFilter 사용 예시 . // AssetRegistry 모듈 참조 얻기 IAssetRegistry&amp; AssetRegistry = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get(); // FARFilter 구조체 생성 FARFilter Filter; // 검색할 폴더 지정 (여러 개 가능) Filter.PackagePaths.Add(FName(\"/Game/MyFolder\")); // 예시: /Game/MyFolder 폴더만 검색 // 하위 폴더까지 재귀적으로 검색할지 여부 Filter.bRecursivePaths = true; // 검색할 클래스 지정 (여러 개 가능) Filter.ClassPaths.Add(UStaticMesh::StaticClass()-&gt;GetClassPathName()); // 스태틱 메시만 대상 // Filter.ClassPaths.Add(UMaterial::StaticClass()-&gt;GetClassPathName()); // 필요하면 다른 클래스도 추가 // 특정 태그 기반 검색 예시 (선택 사항) // Filter.TagsAndValues.Add(FName(\"MyTag\"), TEXT(\"MyValue\")); // 결과 저장할 배열 TArray&lt;FAssetData&gt; AssetList; // 실제 검색 수행 AssetRegistry.GetAssets(Filter, AssetList); // 결과 사용 예시 for (const FAssetData&amp; Asset : AssetList) { UE_LOG(LogTemp, Log, TEXT(\"Asset found: %s\"), *Asset.AssetName.ToString()); } . 4. AssetRegistry.GetAssets(Filter, AssetList) . Filter에 지정된 조건(폴더, 클래스, 태그 등)에 맞는 에셋의 메타데이터 목록을 OutAssetData(배열)에 추가 . virtual bool GetAssets( const FARFilter&amp; InFilter, TArray&lt;FAssetData&gt;&amp; OutAssetData, bool bSkipARFilteredAssets ) const = 0; . | 매개변수 . | const FARFilter&amp; Filter . | 에셋 검색 조건 | . | TArray&amp; OutAssetData . | 검색 결과가 담길 배열 (에셋 메타데이터(FAssetData) 객체) | . | bool bSkipARFilteredAssets . | AssetRegistry에 이미 “숨김(Filtered Out)” 처리된 에셋을 결과에서 제외 | 기본값 true (숨김 에셋 제외) | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%ED%95%A8%EC%88%98%EB%AA%85%EC%97%90-%EB%B6%99%EC%9D%80-checked%EB%9E%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#함수명에-붙은-checked란"
  },"138": {
    "doc": "Fix Up Redirectors From Code",
    "title": "AssetViewUtils",
    "content": "콘텐츠 브라우저(에셋 뷰)에서 에셋의 표시, 로딩, 정렬, 필터링 등과 관련된 작업 유틸리티 . | ContentBrowser 모듈에 포함 . | 에셋을 실제로 메모리로 로드(Load) | 에셋 목록을 정렬(Sort), 필터(Filter) | 콘텐츠 브라우저에서 사용할 다양한 유틸리티 제공 | . 5. AssetViewUtils::FLoadAssetsSettings . 에셋 로딩 동작을 세부적으로 제어하는 옵션 구조체 . | 위에서 설명한 Filter와 마찬가지로 설정 옵션을 정의하는 용도로 쓰임 | . FLoadAssetsSettings 주요 맴버 . | 필드 | 역할 | . | bFollowRedirectors | 에셋 경로가 리다이렉터인 경우, 자동으로 실제 에셋을 따라갈지 여부 - true면 리다이렉터를 따라가 실제 에셋을 로딩 - false면 리다이렉터 그 자체만 로드 | . | bAllowCancel | 로딩 도중 사용자가 취소(Interrupt/Cancel)할 수 있는 UI가 노출될지 여부 - 에디터에서 대량 에셋 로딩시 “취소” 가능 | . 6. AssetViewUtils::LoadAssetsIfNeeded . 에셋의 오브젝트 경로(ObjectPath) 리스트를 받아, 실제로 필요한 에셋만 메모리로 로드하는 에디터 유틸리티 함수 . | 이미 메모리에 로드된 에셋은 재로드하지 않음 | 콘텐츠 브라우저 및 에디터 툴에서 대량 에셋 로딩에 특화 | . // 매개변수 설명 ELoadAssetsResult LoadAssetsIfNeeded( const TArray&lt;FString&gt;&amp; AssetObjectPaths, // 오브젝트 경로 문자열 리스트 TArray&lt;UObject*&gt;&amp; LoadedAssets, // 실제 로딩된 에셋 객체가 저장될 배열 const FLoadAssetsSettings&amp; Settings // 로딩 옵션(구조체) ); AssetViewUtils::LoadAssetsIfNeeded(AssetObjectPaths, LoadedAssets, Settings); . 반환값 . | 값 | 의미 | . | ELoadAssetsResult::Succeeded | 모든 에셋 정상 로드 | . | ELoadAssetsResult::Cancelled | 로딩 중 사용자 취소 | . | ELoadAssetsResult::Failed | 로딩 자체 실패 | . 7. AssetToolsModule.Get().FixupReferencers() . FixupReferencers()는 깨진 참조를 수정하는 핵심 함수이다 . | 깨진 참조 자동 복구 . | 에셋 경로 변경으로 인해 깨진 참조를 검색하고 자동으로 수정 | 리다이렉터가 존재할 경우 대상 경로로 참조를 업데이트 | . | 대상 범위 . | 선택한 에셋(들)을 참조하는 모든 다른 에셋을 검사 | 블루프린트, 머티리얼, 레벨 등 모든 에셋 타입의 참조 처리 가능 | . | 리다이렉터 처리 . | 기존 리다이렉터를 제거하고 직접 참조로 변환할 수 있음 | . | . virtual void FixupReferencers( const TArray&lt;UObjectRedirector*&gt;&amp; Redirectors, bool bCheckoutDialogPrompt = false, ERedirectFixupMode FixupMode = ERedirectFixupMode::DeleteFixedUpRedirectors ) = 0; . | 매개변수 . | Redirectors: UObjectRedirector*의 배열로, 참조를 갱신할 리다이렉터 목록 | bCheckoutDialogPrompt: true로 설정하면, 소스 컨트롤 사용 시 체크아웃 다이얼로그를 표시 | FixupMode: 리다이렉터 처리 방식을 지정 . | ERedirectFixupMode::DeleteFixedUpRedirectors: 참조가 갱신된 리다이렉터를 삭제 | ERedirectFixupMode::LeaveFixedUpRedirectors: 참조가 갱신되더라도 리다이렉터를 유지 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils"
  },"139": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Up Redirectors From Code",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html"
  },"140": {
    "doc": "Function",
    "title": "나중에 리플렉션, 가비지 컬렉션, 직렬화, 네트워크 동기화, 에디터 통합으로 마크다운 파일 나누기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%82%98%EC%A4%91%EC%97%90-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9%EC%9C%BC%EB%A1%9C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%9D%BC-%EB%82%98%EB%88%84%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#나중에-리플렉션-가비지-컬렉션-직렬화-네트워크-동기화-에디터-통합으로-마크다운-파일-나누기"
  },"141": {
    "doc": "Function",
    "title": "UObject 특징",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-특징"
  },"142": {
    "doc": "Function",
    "title": "1. 리플렉션(Reflection)",
    "content": "런타임에 객체의 타입, 필드, 메서드 정보를 조회하고 동적으로 접근/수정할 수 있는 기능 . | 리플렉션 데이터는 컴파일 시점에 UHT(Unreal Header Tool)이 자동 생성 . | GENERATED_BODY() 매크로가 이를 활성화 | . | 런타임 타입 정보(RTTI): UCLASS, UPROPERTY, UFUNCTION 등 매크로를 통해 리플렉션 데이터 생성 | 동적 캐스팅: Cast&lt;UMyClass&gt;(SomeObject) 형태로 안전한 타입 변환 가능 | 프로퍼티 검사: 런타임에 객체의 프로퍼티를 검사하고 수정할 수 있음 . | C++ 표준에는 런타임 리플렉션 기능이 없음 . | 예를 들어, 클래스에 어떤 필드가 있는지, 메서드가 무엇인지 런타임에 알 수 없음 | RTTI로 typeid, dynamic_cast 정도만 제공 | . | 언리얼의 리플렉션 . | 자체적인 리플렉션 시스템을 만들어 UObject 계열 클래스에 한해 런타임 타입 정보, 속성, 함수 목록 등을 관리 | C++ 매크로(UCLASS, UPROPERTY, UFUNCTION)와 Unreal Header Tool(UHT)이 자동으로 메타데이터를 생성해 코드에 삽입 | . | . 내부 매커니즘 . | 각 UObject 인스턴스는 UClass 타입 메타데이터(속성, 함수, 부모 정보 등)를 보유. | 런타임에 GetClass(), FindField, GetDefaultObject, ProcessEvent 등의 API로 동적 접근. | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98reflection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-리플렉션reflection"
  },"143": {
    "doc": "Function",
    "title": "2. 가비지 컬렉션(Garbage Collection)",
    "content": "더 이상 필요하지 않은 객체(메모리)를 자동으로 탐지하여 해제하는 메커니즘 . | 자동 메모리 관리: UObject는 UE의 가비지 컬렉션 시스템과 통합되어 있어 참조가 없어지면 자동으로 제거 | UPROPERTY() 매크로로 표시된 멤버 변수는 가비지 컬렉터가 추적 . | C++은 명시적 메모리 관리(new/delete, 스마트 포인터)를 요구 . | 실수로 delete를 빼먹거나, 중복해서 delete하면 메모리 누수/오류가 발생할 수 있음. | . | 언리얼의 가비지 컬렉션 . | UObject 파생 객체만 엔진의 GC 대상이 됨 (일반 C++ 객체는 해당 없음) | 엔진은 참조 그래프(Reference Graph)를 따라 “루트 오브젝트에서부터 도달할 수 없는 UObject”를 자동 삭제 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98garbage-collection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-가비지-컬렉션garbage-collection"
  },"144": {
    "doc": "Function",
    "title": "레퍼런스 그래프(Reference Graph)",
    "content": "GC가 객체 간 참조 관계를 추적하는 핵심 메커니즘 . | 주기적으로 또는 명시적으로(엔진 Tick, 레벨 변경 등) GC가 수행됨 | UObject만 추적. 일반 C++ 객체/스마트 포인터는 GC 영향 없음 | 순환 참조 문제 자동 해결 | . // A가 B를 참조, B가 A를 참조해도 루트 연결이 없으면 모두 삭제됨 class A { UPROPERTY() B* RefB; }; class B { UPROPERTY() A* RefA; }; . 1. 루트 객체(Root Objects) 식별 . | 가비지 컬렉션의 시작점으로 절대 삭제되지 않는 객체들 | . - 월드에 배치된 `AActor` - `AddToRoot()`로 등록된 객체 - 게임 인스턴스(`UGameInstance`) - 에디터에서 열린 에셋 (`UPackage`) . 2. 그래프 탐색 (Mark 단계) . | 루트 객체부터 UPROPERTY() 참조를 재귀적으로 따라가며 도달 가능한 객체 마킹 | . Mark 단계 순서 . | GC Root(예: 월드, 게임 인스턴스, 에디터 오브젝트 등)에서 탐색 시작 | RootObjectA를 방문(Mark) | RootObjectA의 UPROPERTY 필드 참조를 따라 ObjB, ObjC를 방문(Mark) | ObjB의 UPROPERTY 필드 참조를 따라 ObjD, ObjE 방문(Mark) | … 이하 반복 | 모든 방문이 끝나면, Mark되지 않은 나머지 객체들은 GC 대상으로 간주 | . 3. 미사용 객체 삭제 (Sweep 단계) . | 마킹되지 않은 객체를 안전하게 제거 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EA%B7%B8%EB%9E%98%ED%94%84reference-graph",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#레퍼런스-그래프reference-graph"
  },"145": {
    "doc": "Function",
    "title": "3. 직렬화(Serialization)",
    "content": "UObject 기반 클래스 객체는 파일이나 네트워크로 저장/불러오거나 복제할 수 있음. | 맵, 에셋, 게임 세이브 파일, 블루프린트 인스턴스 등은 모두 UObject 파생 클래스의 직렬화에 기반해 저장/복원 | FArchive 기반의 엔진 직렬화 시스템이 모든 UPROPERTY 데이터를 자동으로 기록 및 재구성 . | UPROPERTY()로 선언된 변수는 별도의 코드 없이도 자동 직렬화 대상 | 예: SaveGame, 네트워크 동기화, 복제 등 | . | Serialize(FArchive&amp; Ar) 메서드를 오버라이드하면, 특정 데이터를 커스텀하게 저장/복원할 수 있음 | . 자동 직렬화 예시 . UCLASS() class UMySaveGame : public USaveGame { GENERATED_BODY() public: UPROPERTY() int32 PlayerLevel; UPROPERTY() FString PlayerName; }; // 이렇게 선언된 변수는 SaveGame 파일에 자동 저장/복원 . 커스텀 직렬화 시 버전 호환성을 위한 패턴 . void Serialize(FArchive&amp; Ar) { Super::Serialize(Ar); int32 Version = 0; Ar &lt;&lt; Version; // 버전 기록 if (Version &gt;= 1) { Ar &lt;&lt; MyNewVariable; } } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-%EC%A7%81%EB%A0%AC%ED%99%94serialization",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-직렬화serialization"
  },"146": {
    "doc": "Function",
    "title": "데이터 저장 흐름",
    "content": ". | UObject 계열 클래스는 저장 대상이 되면 . | 엔진 내부의 FArchive 객체(파일/메모리/네트워크 스트림)를 통함 | 각 UPROPERTY 값을 자동으로 기록(Serialize)한다 | . | 불러오기(로드) 시 저장된 바이너리 데이터가 FArchive로 읽혀짐 . | UPROPERTY 정보를 기반으로 객체(=UObject)의 멤버 변수로 복원(Deserialize) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#데이터-저장-흐름"
  },"147": {
    "doc": "Function",
    "title": "SaveGame 동작 예시",
    "content": "// SaveGame 객체 선언 UMySaveGame* SaveGameObj = NewObject&lt;UMySaveGame&gt;(); SaveGameObj-&gt;PlayerLevel = 25; SaveGameObj-&gt;PlayerName = TEXT(\"홍길동\"); // 저장 UGameplayStatics::SaveGameToSlot(SaveGameObj, TEXT(\"MySlot\"), 0); // 불러오기 UMySaveGame* LoadedGame = Cast&lt;UMySaveGame&gt;( UGameplayStatics::LoadGameFromSlot(TEXT(\"MySlot\"), 0) ); int32 LoadedLevel = LoadedGame-&gt;PlayerLevel; // 직렬화된 값이 자동 복원 . | 저장(Serialize) 과정 . | SaveGame 클래스 객체를 생성 | UGameplayStatics::SaveGameToSlot() 같은 API 호출 | 내부적으로 SaveGame 객체 → FArchive → UPROPERTY 자동 순회 및 값 기록 결과적으로 바이너리 파일(.sav 등)로 저장 | . | 불러오기(Deserialize) 과정 . | UGameplayStatics::LoadGameFromSlot() 같은 API 호출 | FArchive가 파일을 읽고, SaveGame 객체를 새로 만듦 | FArchive 데이터 → UPROPERTY 기반으로 멤버 변수 값이 자동 복원 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-동작-예시"
  },"148": {
    "doc": "Function",
    "title": "네트워크 동기화 (Replicate) 동작 예시",
    "content": "나중에 멀티 플레이 공부할 때 채워넣겠음 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-replicate-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#네트워크-동기화-replicate-동작-예시"
  },"149": {
    "doc": "Function",
    "title": "4. 에디터 통합",
    "content": "메타데이터로 자동으로 디테일 패널 생성. | 디테일 패널 표시: UPROPERTY 지정자를 통해 에디터에서 편집 가능 | 블루프린트 노출: UFUNCTION에 BlueprintCallable 등의 지정자 추가로 블루프린트에서 사용 가능 | . 커스텀 프로퍼티 에디터 예시 . FPropertyEditorModule&amp; PropModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\"); . 정리 . // 1. 객체 생성 + 메타데이터 UCLASS(BlueprintType, meta=(DisplayName=\"My Cool Object\")) class UMyObject : public UObject { GENERATED_BODY() public: // 2. 라이프사이클 관리 virtual void BeginDestroy() override { CleanupResources(); Super::BeginDestroy(); } // 3. 메타데이터 활용 UPROPERTY(EditAnywhere, meta=(ClampMin=0)) int32 Value; }; // 결과: // - 블루프린트에서 \"My Cool Object\"로 노출 (리플렉션) // - Value는 에디터에서 0 이상 값만 입력 가능 (에디터 통합) // - 객체 파괴 시 CleanupResources() 자동 호출 (GC 연동) . 참고 링크 . | Memory Management &amp; Garbage Collection in Unreal Engine 5 | 04. Reflection and Garbage Collection | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-에디터-통합"
  },"150": {
    "doc": "Function",
    "title": "Function",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html"
  },"151": {
    "doc": "Management",
    "title": "UObject 사용 방법",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-사용-방법"
  },"152": {
    "doc": "Management",
    "title": "1. 객체 생성 및 관리",
    "content": ". | UObject의 인스턴스화(Instantiation)와 기본 설정을 담당하는 단계 | “어떻게 객체가 만들어지고, 참조되고, 접근되는가?” | . (1) UObject 객체 생성 . | Outer와 Package: 객체의 계층 구조와 저장 위치 결정 // Outer: 객체의 소유자 (일반적으로 현재 객체를 생성하는 객체) // Package: 에셋으로 저장될 경우 대상 패키지 (예: /Game/MyAsset) UMyObject* Obj = NewObject&lt;UMyObject&gt;(Outer, Package, NAME_None, RF_Transactional); . | RF_Transactional: 에디터 실행 취소(Undo) 시스템에 등록할 때 사용하는 플래그 | RF_Standalone: 패키지와 무관한 독립적 존재 (에셋이 아닌경우) | RF_Transient : 임시 객체 (저장되지 않음) | RF_Public :에셋으로 저장 시 공개적으로 표시 | . // 1. 일반적인 생성 (Outer와 Name 지정 가능) UMyObject* Obj = NewObject&lt;UMyObject&gt;(GetTransientPackage(), TEXT(\"MyObj\")); // 2. 서브오브젝트 생성 (주로 Actor/Component에서 사용) UMyComponent* Comp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"Comp\")); . | NewObject&lt;T&gt;(): 새로운 UObject 인스턴스 생성 | CreateDefaultSubobject(): 생성자에서 서브오브젝트 생성 시 사용 | TWeakObjectPtr&lt;T&gt;: GC 영향을 받지 않는 참조 생성 | . (2) UObject 객체 접근 및 유효성 검사 . // 유효성 체크 (GC에 의해 파괴되지 않았는지 확인) if (IsValid(Obj)) { Obj-&gt;DoSomething(); } // 약한 참조 (WeakPtr)로 GC 방지 TWeakObjectPtr&lt;UMyObject&gt; WeakObj = Obj; . (3) UObject 객체 등록 관리 . // 객체를 특정 패키지에 등록 Obj-&gt;Rename(nullptr, MyPackage); // 에셋으로 저장 가능하게 함 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-객체-생성-및-관리"
  },"153": {
    "doc": "Management",
    "title": "2. 라이프 사이클 관리",
    "content": ". | UObject가 생성부터 파괴까지 거치는 전체 과정을 관리 | “객체가 어떤 단계를 거쳐 존재하고 소멸하는가?”를 정의 | 가비지 컬렉션과 연동 가능 | . (1) 라이프 사이클 - 생성 . // 예시: 초기화 흐름 UCLASS() class UMyAsset : public UObject { GENERATED_BODY() public: UMyAsset() { /* 생성자 */ } // 프로퍼티 초기화 후 호출 virtual void PostInitProperties() override { Super::PostInitProperties(); InitDefaultValues(); // 기본값 설정 } // 명시적 초기화 (필요한 경우) void Initialize() { LoadExternalData(); } // 에셋 로드 완료 시 호출 virtual void PostLoad() override { Super::PostLoad(); ApplyLoadedData(); // 로드된 데이터 적용 } }; . (2) 라이프 사이클 - 사용 . // 활성화/비활성화 제어 (AActor 파생클래스 예시) virtual void BeginPlay() override; // 게임 시작 시 호출 virtual void EndPlay() override; // 게임 종료 또는 제거 시 호출 . (3) 라이프 사이클 - 파괴 . virtual void BeginDestroy() override { // 리소스 해제 로직 Super::BeginDestroy(); } virtual void FinishDestroy() override { // 최종 정리 작업 Super::FinishDestroy(); } . UObject 라이프 사이클 3단계 요약 . 생성 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | 생성자 | NewObject() 호출 시 | 메모리 할당 + 기본값 설정 | UPROPERTY는 아직 초기화되지 않음 | . | PostInitProperties() | 생성자 직후 | 프로퍼티 초기화 완료 시점 | 에디터에서 설정한 기본값 적용됨 | . | PostLoad() | 에셋 로드 완료 시 | 디스크 데이터 처리 | 에셋 전용 (동적 생성 객체는 호출 X) | . 사용 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | AddToRoot() | 수동 호출 시 | GC 대상에서 제외 | 남용 시 메모리 누수 가능성 | . | BeginPlay() | 게임 시작 시(AActor 한정) | 게임플레이 로직 초기화 | UObject 직접 사용 불가 (Actor/Component 필요) | . | Tick() | 매 프레임 (AActor 한정) | 지속적인 업데이트 | 성성능 저하 가능성 → 꼭 필요할 때만 사용 | . 파괴 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | ConditionalBeginDestroy() | 수동 호출 또는 GC 시작 시 | 파괴 시작 신호 | 객체는 즉시 삭제되지 않음 | . | BeginDestroy() | GC 마킹 후 | 리소스 해제 (텍스처, 메모리 등) | 가상 함수 오버라이드 필수 | . | FinishDestroy() | 메모리 해제 직전 | 최종 정리 | 이후 모든 접근 불가능 | . (4) 가비지 컬렉션 연동 . // GC 대상에서 제외 (특수한 경우만 사용) Obj-&gt;AddToRoot(); // GC 대상으로 복귀 Obj-&gt;RemoveFromRoot(); . | BeginDestroy(): 객체가 파괴되기 전에 호출 | IsValidLowLevel(): 객체가 유효한지 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-%EB%9D%BC%EC%9D%B4%ED%94%84-%EC%82%AC%EC%9D%B4%ED%81%B4-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-라이프-사이클-관리"
  },"154": {
    "doc": "Management",
    "title": "3. 메타 데이터 시스템",
    "content": ". | UObject의 데이터(프로퍼티, 함수, 클래스 등)에 대해 추가 정보를 부여하는 키-값 쌍의 데이터 | “이 객체를 어떻게 표시하고, 직렬화하고, 에디터에서 다룰 것인가?”를 제어 . | “어떻게 에디터에서 표시할지”, “어떤 제약 조건을 둘지”, “블루프린트에 노출 여부” 등 | . | UCLASS, UPROPERTY 등에 메타데이터 추가 가능 | . UPROPERTY(EditAnywhere, meta=(DisplayName=\"My Custom Name\")) FString CustomizedName; . (1) 에디터 연동 및 UI 제어 . UPROPERTY(EditAnywhere, meta=(DisplayName=\"플레이어 이름\", Tooltip=\"캐릭터의 이름입니다.\")) FString CharacterName; . (2) 직렬화 동작 설정 . UPROPERTY(SaveGame, meta=(NoAutoLoad=true)) FString SaveSlotName; // 세이브 파일에 저장되지만 자동 로드 안 함 . (3) 리플렉션 시스템 연동 . UFUNCTION(meta=(WorldContext=\"WorldContextObject\")) static void MyFunction(UObject* WorldContextObject); //블루프린트에서 자동으로 World Context 연결 . (4) 제약 및 제어 커스텀 . UPROPERTY(meta=(ClampMin=0, ClampMax=100)) int32 Health; // 에디터에서 0~100 사이값만 입력 가능 . 메타데이터 시스템에서 자주 쓰는 키 목록 . | 메타 키 | 용도 | 예시 | . | BlueprintType | 블루프린트 변수로 사용 허용 | UCLASS(BlueprintType) | . | Category | 디테일 패널에서 그룹으로 묶임 | UPROPERTY(Category=\"Gameplay\") | . | AdvancedDisplay | 디테일 패널에서 접기 | meta=(AdvancedDisplay=true) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-%EB%A9%94%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-메타-데이터-시스템"
  },"155": {
    "doc": "Management",
    "title": "세 시스템 차이점 요약",
    "content": "| 시스템 | 핵심 질문 | 주요 도구 | 사용 예시 | . | 객체 생성 및 관리 | “객체를 어떻게 만들고 참조할까?” | NewObject CreateDefaultSubobject IsValid | 동적 객체 생성서브오브젝트 관리 | . | 라이프사이클 관리 | “객체가 생애주기 동안 무엇을 하는가?” | PostInitPropertiesBeginDestroyFinishDestroy | 리소스 할당/해제게임 로직 초기화 | . | 메타데이터 시스템 | “이 객체를 어떻게 표시/조작할까?” | meta=(…),UPROPERTY()/UFUNCTION() | 에디터 UI 커스터마이징직렬화 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#%EC%84%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#세-시스템-차이점-요약"
  },"156": {
    "doc": "Management",
    "title": "Management",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html"
  },"157": {
    "doc": "Module",
    "title": "Module",
    "content": "특정 에디터 도구, 런타임 기능, 라이브러리 또는 기타 기능들을 독립적인 코드 단위로 캡슐화한 것 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html"
  },"158": {
    "doc": "Module",
    "title": "특징",
    "content": ". | 코드 분리 : 모듈은 코드 분리를 강제하여, 기능을 캡슐화하고 내부 구현을 숨길 수 있음 | 독립적 빌드 : 모듈은 독립적인 컴파일 단위로 빌드됨 . | 변경된 모듈만 다시 빌드되므로, 대규모 프로젝트의 빌드 속도가 크게 향상 | . | 의존성 그래프 및 헤더 관리 : 모듈 간 의존성 그래프가 생성되고, 실제 사용되는 코드에만 헤더 포함이 허용 . | 사용하지 않는 모듈은 컴파일에서 안전하게 제외 | . | 런타임 로드/언로드 제어 : 특정 모듈을 언제 로드/언로드할지 제어 가능 . | 이를 통해 프로젝트의 성능 최적화가 가능 | . | 플랫폼별 포함/제외 : 모듈을 플랫폼별로 포함하거나 제외할 수 있음 . | 예: 윈도우, 맥, 리눅스, 안드로이드 등에서 포함하거나 제외 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#특징"
  },"159": {
    "doc": "Module",
    "title": "모듈 디렉터리 구조",
    "content": "YourProject/ ├── Source/ # 모든 모듈은 반드시 프로젝트 또는 플러그인의 Source 디렉토리 하위에 위치 │ ├── YourModule/ # 모듈 루트 폴더명은 모듈명과 동일해야 함 │ │ ├── Public/ # 외부에 노출할 헤더 파일 │ │ ├── Private/ # 내부 구현 파일 (.cpp 및 내부 헤더) │ │ └── YourModule.Build.cs │ ├── YourPlugin.uplugin ├── YourProject.uproject . | Public/: 외부 모듈에서 사용할 수 있도록 공개된 헤더 파일 (.h) | Private/: 해당 모듈 내부에서만 사용하는 구현 파일 (.cpp) 과 헤더 파일 포함 . | .cpp 파일은 모두 private 폴더에 두는 것이 권장됨 | . | Build.cs: 모듈의 빌드 설정과 의존성을 정의하는 파일 . | Target.cs는 최종 빌드 옵션과 엔트리 포인트를 정의 | . | .uproject / .uplugin : “Modules” 리스트가 있어, 어떤 모듈이 어떻게 로드될지 정의 . | 이름, 타입, 지원 플랫폼, 로딩 단계 등을 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-디렉터리-구조"
  },"160": {
    "doc": "Module",
    "title": "모듈 타입 설정",
    "content": ".uproject 또는 .uplugin 파일의 Type 에서 정의 . | 모듈 타입에 따라 로드/언로드, 의존성, 포함 가능 플랫폼이 달라짐 | . { \"Modules\": [ { \"Name\": \"YourModule\", \"Type\": \"Runtime\", // 모듈 타입 지정 \"LoadingPhase\": \"Default\" // 로딩 단계 지정 } ] } . | Type (모듈 타입) . | \"Runtime\" : 게임 실행 시 필수적인 기능 제공 (예: Core, Engine) | \"Editor\" : 에디터 전용 기능 제공 (예: 플러그인) | \"Program\" : 독립 실행형 프로그램으로 사용 (예: UnrealHeaderTool) | \"Developer\" : 개발 전용 (예: Profiler, Visualizer) . | Shipping(릴리즈) 빌드에 포함되지 않는 특수 모듈 | . | \"ThirdParty\" : 외부 라이브러리 래핑용 . | 외부 바이너리/헤더 포함 및 관리 목적 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%ED%83%80%EC%9E%85-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-타입-설정"
  },"161": {
    "doc": "Module",
    "title": "로딩 단계 지정",
    "content": ".uproject 또는 .uplugin 파일의 LoadingPhase 에서 정의 . | LoadingPhase (주요 로딩 단계) . | \"PreDefault\" : 엔진 초기화 전 로드 (예: 코어 시스템) | \"Default\" : 대부분 모듈의 기본 단계 (기본값) | \"PostDefault\" : 기본 모듈 로드 후 (예: 게임플레이 코드) | \"PostConfigInit\" : 설정 파일 로드 후 (예: 설정 의존성 모듈) | \"PostSplashScreen\" : 스플래시 스크린 표시 후 (예: UI 모듈) | . | . 로딩 주의 사항 . A 모듈이 B 모듈에 의존할 때, B의 로딩 단계가 A보다 빠르거나 같아야 함 . | 예: B가 PreDefault, A가 Default여야 정상 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%A1%9C%EB%94%A9-%EB%8B%A8%EA%B3%84-%EC%A7%80%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#로딩-단계-지정"
  },"162": {
    "doc": "Module",
    "title": "Build.cs 파일에서 의존성 설정",
    "content": "언리얼 빌드 시스템은 프로젝트의 Target.cs와 각 모듈의 Build.cs 파일을 기준으로 프로젝트를 빌드함 . | 각 모듈에는 반드시 [ModuleName].Build.cs가 필요 | ModuleRules 클래스를 상속받아 자신의 모듈을 정의 | . Build.cs 파일 예시 . using UnrealBuildTool; public class ModuleTest : ModuleRules { public ModuleTest(ReadOnlyTargetRules Target) : base(Target) { PrivateDependencyModuleNames.AddRange(new string[] { \"Core\" }); } ... } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-파일에서-의존성-설정"
  },"163": {
    "doc": "Module",
    "title": "주요 의존성 설정",
    "content": "1. PublicDependencyModuleNames . // 사용할 모듈(폴더) 이름 적기 PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); . | 해당 리스트에 들어간 모듈은 내 모듈의 Public 코드(즉, Public 헤더 파일)와 Private 코드에서 모두 사용 가능 . | 예: #include “A/Public/A.h” | . | 해당 모듈에 의존하는 다른 모듈의 Public 코드에서도 이 의존성 모듈의 Public 헤더를 사용 | . 2. PrivateDependencyModuleNames . PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" }); . | Private 리스트에 들어간 모듈은 내 모듈의 Private 코드에서만 사용 가능 . | 내 모듈의 Public 헤더에서는 해당 모듈의 헤더를 include할 수 없음 | . | 이 모듈을 의존하는 다른 모듈에서는 이 의존성이 전파되지 않음 | . 3. PublicIncludePaths / PrivateIncludePaths . // Public 또는 Private 폴더 외부에 헤더 파일이 위치한 경우 PublicIncludePaths.Add(Path.Combine(ModuleDirectory, \"ThirdParty/SomeLibrary/include\")); // 서브디렉토리를 포함해야 하는 경우 PrivateIncludePaths.Add(Path.Combine(ModuleDirectory, \"Private/SubModule\")); // 외부 라이브러리 사용 PublicIncludePaths.Add(\"C:/ExternalLibs/SomeLibrary/include\"); . | 헤더 파일의 추가 경로를 지정함 . | 비표준 디렉토리 구조를 사용하는 경우 | 서브디렉토리를 포함해야 하는 경우 | 외부 라이브러리를 사용하는 경우 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주요-의존성-설정"
  },"164": {
    "doc": "Module",
    "title": "의존성 정리",
    "content": "| 구분 | PublicDependencyModuleNames | PrivateDependencyModuleNames | . | 내 모듈의 Public 코드 | O (사용 가능) | X (사용 불가) | . | 내 모듈의 Private 코드 | O (사용 가능) | O (사용 가능) | . | 의존 모듈의 Public 코드 | O (전파됨) | X (전파 안 됨) | . PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\" }); . | Core, Engine . | 내 모듈의 Public/Private 코드 모두에서 사용 가능 | 내 모듈을 사용하는 다른 모듈의 Public 코드에서도 사용 가능(전파) | . | Slate . | 내 모듈의 Private 코드에서만 사용 가능 | 내 모듈의 Public 코드, 내 모듈을 사용하는 다른 모듈에서는 Slate 의존성이 전파되지 않음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#의존성-정리"
  },"165": {
    "doc": "Module",
    "title": "주의사항",
    "content": ". | 프로젝트 파일 재생성: Build.cs 파일이나 소스 폴더를 이동/수정한 경우, 반드시 프로젝트 파일을 재생성해야 함 . | GenerateProjectFiles.bat 실행 | .uproject 파일 우클릭 후 “Generate Project Files” 선택 | Unreal Editor의 메뉴: File &gt; Refresh Visual Studio Project | . | UE 빌드 시스템은 모듈 간 순환 참조(의존성)를 허용하지 않음 | 반드시 실제로 사용하는 헤더만 명시적으로 추가함 . | 실제 사용하는 헤더만 #include하고 그 헤더의 위치가 Public/Private이라면 빌드 시스템이 알아서 처리 | . | . 참고 링크 . | Unreal Engine Modules | Module Properties | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주의사항"
  },"166": {
    "doc": "Reference",
    "title": "주요 매크로 유형",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A3%BC%EC%9A%94-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#주요-매크로-유형"
  },"167": {
    "doc": "Reference",
    "title": "1. UCLASS",
    "content": ". | 클래스를 언리얼 리플렉션 시스템에 등록 (직렬화, GC, 에디터/블루프린트/네트워크 노출 가능) UCLASS(Blueprintable) class MYGAME_API AMyActor : public AActor { GENERATED_BODY() }; . | UCLASS()는 클래스 선언부 바로 위에 위치 | Blueprintable 등 옵션으로 블루프린트 생성 가능 여부 등 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass"
  },"168": {
    "doc": "Reference",
    "title": "2. USTRUCT",
    "content": ". | 구조체를 리플렉션 시스템에 등록 USTRUCT(BlueprintType) struct FMyStruct { GENERATED_BODY() UPROPERTY(EditAnywhere) int32 Value; }; . | BlueprintType : 블루프린트에서도 사용 가능하게 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct"
  },"169": {
    "doc": "Reference",
    "title": "3. UENUM",
    "content": "열거형(enum)을 리플렉션/에디터/블루프린트에 노출 . UENUM(BlueprintType) enum class EMyType : uint8 { TypeA UMETA(DisplayName = \"Type A\"), TypeB UMETA(DisplayName = \"Type B\") }; . | BlueprintType : 블루프린트에서 사용 가능 | UMETA(DisplayName = …) : 에디터에 표시될 이름 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum"
  },"170": {
    "doc": "Reference",
    "title": "4. UPROPERTY",
    "content": ". | 클래스 멤버 변수를 언리얼 리플렉션 시스템에 등록하기 위해 사용 | 에디터에서의 노출, 직렬화, 복제 등 다양한 기능 제어 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stats\") int32 Health; }; . | UPROPERTY로 연결된 객체만이 가비지 컬렉션에서 참조로 간주되어 소멸 방지 | 옵션(AccessSpecifier, Category 등): 노출 범위, 에디터 분류 등 지정 | 에디터, 블루프린트에서 실시간으로 값 변경 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty"
  },"171": {
    "doc": "Reference",
    "title": "5. UFUNCTION",
    "content": ". | 맴버 함수를 블루프린트에서 호출 가능하게 하거나 리플렉션 시스템에 등록 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UFUNCTION(BlueprintCallable, Category=\"Actions\") void TakeDamage(int32 Amount); }; . | BlueprintCallable : 블루프린트에서 호출 가능 | Server, Client 등 RPC 옵션 부여 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction"
  },"172": {
    "doc": "Reference",
    "title": "6. GENERATED_BODY",
    "content": ". | UHT(Unreal Header Tool)가 생성한 코드를 포함시키기 위해 사용 | 클래스 선언 끝에 반드시 포함되어야 함 UCLASS() class MYGAME_API AMyCharacter : public ACharacter { GENERATED_BODY() // ... }; . | GENERATED_BODY() 매크로가 없으면 UHT가 오류를 발생시킴 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body"
  },"173": {
    "doc": "Reference",
    "title": "7. UINTERFACE",
    "content": ". | 인터페이스 선언 . | 두 개의 타입을 동시에 정의함 . | UINTERFACE로 선언되는 UObject 기반 클래스 (메타데이터/리플렉션 목적) | 실제 인터페이스 본체 (관례적으로 I 접두어) | . | . | . UObject 기반 클래스 . // 헤더 파일: MyInterface.h // 1. UINTERFACE로 UObject 파생 클래스 선언 UINTERFACE(BlueprintType) class UMyInterface : public UInterface { GENERATED_BODY() }; // 2. 실제 인터페이스 본체(I 접두사 사용) class IMyInterface { GENERATED_BODY() public: // 인터페이스 함수 선언 (구현은 해당 인터페이스를 상속받는 클래스에서!) UFUNCTION(BlueprintCallable, Category=\"MyInterface\") void MyFunction(); }; . 상속 및 구현 예시 . UCLASS() class AMyActor : public AActor, public IMyInterface { GENERATED_BODY() public: virtual void MyFunction() override; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface"
  },"174": {
    "doc": "Reference",
    "title": "7. DECLARE_* 및 IMPLEMENT_* 매크로",
    "content": ". | 다양한 기능을 선언하고 구현하기 위한 매크로 쌍 . | DECLARE_*: 헤더 파일(.h)에 위치, 선언만 노출 (클래스/함수/변수의 존재를 시스템에 알림) | IMPLEMENT_*: 소스 파일(.cpp)에 위치, 실제 구현을 생성 (선언된 요소의 구체적인 동작 정의) | . | 모듈/플러그인 등록 (DECLARE_MODULE + IMPLEMENT_MODULE) | 로그 카테고리 생성 (DECLARE_LOG_CATEGORY_EXTERN + DEFINE_LOG_CATEGORY) | 인터페이스 구현 (DECLARE_INTERFACE + IMPLEMENT_INTERFACE) | . 기본 예시 . // MyModule.h class FMyModule : public IModuleInterface { public: DECLARE_MODULE(FMyModule) // 1. 모듈 선언 }; // MyModule.cpp IMPLEMENT_MODULE(FMyModule, MyModule) // 2. 모듈 구현 . | IMPLEMENT_MODULE이 자동으로 StartupModule(), ShutdownModule() 함수를 생성하고 모듈을 엔진에 등록 | . 내부 동작 . // 순수 C++ 방식 class MyClass {}; // 직접 구현 // 언리얼 방식 DECLARE_CLASS(MyClass) // UHT가 자동으로 다음 코드 생성: /* class MyClass { static StaticClass(); virtual UClass* GetClass() const; ... }; */ IMPLEMENT_CLASS(MyClass) // UHT가 자동으로 StaticClass() 구현체 생성 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-%EB%B0%8F-implement_-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-및-implement_-매크로"
  },"175": {
    "doc": "Reference",
    "title": "정리",
    "content": "| 매크로 | 적용 대상 | 리플렉션 | 직렬화 | GC | 네트워크 | 블루프린트 | 비고 | . | UCLASS() | 클래스 | O | O | O | O | O |   | . | USTRUCT() | 구조체 | O | O | X | X | O |   | . | UENUM() | enum | O | O | X | X | O |   | . | UPROPERTY() | 멤버 변수 | O | O | O | 옵션에 따라 | O | 옵션(Replicated 등) | . | UFUNCTION() | 멤버 함수 | O | X | X | 옵션에 따라 | O | 옵션(BlueprintCallable 등) | . | UINTERFACE() | 인터페이스 클래스 | O | X | X | X | O |   | . | GENERATED_BODY() | 클래스/구조체/인터페이스 | - | - | - | - | - | UHT 생성 코드 삽입 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#정리"
  },"176": {
    "doc": "Reference",
    "title": "매크로 사용 시 주의사항",
    "content": ". | 리플렉션 매크로는 템플릿 클래스와 호환되지 않음 | 가상 함수에 UFUNCTION 사용 시 반드시 override 키워드 추가 | Replicated 변수는 반드시 기본값 초기화 필요 UPROPERTY(Replicated) int32 Health = 100; // 초기화 필수 . | 에디터 전용 코드 . | WITH_EDITOR 매크로로 감싸지 않으면 런타임 크래시 가능성 #if WITH_EDITOR void EditorOnlyFunction() { ... } #endif . | . | 메모리 관리 : TObjectPtr 도입 (UE5.1+) . | UObject 파생 클래스는 절대 일반 C++ 포인터로 저장하지 말 것 | . | . // 잘못된 예 UPROPERTY() AActor* RawPtr; // 가비지 컬렉션 대상에서 누락될 수 있음 // 올바른 예 UPROPERTY() TObjectPtr&lt;AActor&gt; SafePtr; // UE5 권장 방식 . 참고 링크 . | UStruct | UFuncion | UInterface | 메타데이터 지정자 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#매크로-사용-시-주의사항"
  },"177": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html"
  },"178": {
    "doc": "Search And Delete Empty Folders",
    "title": "목표: 빈 폴더 찾아내서 삭제하기",
    "content": "강의에서는 UEditorAssetLibrary::ListAssets() 메서드를 통해 빈 폴더를 찾았지만, 내 버전 (UE 5.5)에서는 제대로 동작하지 않았다 . 그래서 AssetRegistry Module을 통해 해결했다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#%EB%AA%A9%ED%91%9C-%EB%B9%88-%ED%8F%B4%EB%8D%94-%EC%B0%BE%EC%95%84%EB%82%B4%EC%84%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#목표-빈-폴더-찾아내서-삭제하기"
  },"179": {
    "doc": "Search And Delete Empty Folders",
    "title": "OnDeleteEmptyFoldersButtonClicked() 함수 구현에 사용한 메서드",
    "content": "AssetRegistryModule.Get().GetSubPaths() . 특정 경로(폴더) 기준으로, 하위에 존재하는 모든 서브 폴더의 목록을 조회하는 기능 . void IAssetRegistry::GetSubPaths( const FString&amp; InBasePath, TArray&lt;FString&gt;&amp; OutPathList, bool bInRecurse ) const; . | 매개변수 . | const FString&amp; InBasePath : 서브 폴더를 검색할 기준이 되는 상위 폴더 경로 . | 예시: “/Game/MyFolder” | 반드시 패키지 경로 형식이어야 하며, 슬래시(/)로 시작함 | . | TArray&amp; OutPathList : 검색 결과로 반환될 서브 폴더 경로 문자열의 배열 . | 함수 호출 시 빈 배열을 넘기면 됨 | 함수가 반환되면, InBasePath의 하위에 존재하는 직속/모든(옵션) 폴더 경로가 여기 저장됨 | 패키지 경로 형식으로 배열에 담김김 | . | bool bInRecurse . | true : InBasePath의 모든 하위 폴더(재귀적으로 모든 Depth)를 탐색 | false : InBasePath 바로 직속 1 Depth의 폴더만 반환 (재귀 X) | . | . | 반환값 . | 반환값은 없으며, 결과는 OutPathList에 담김 | . | . UEditorAssetLibrary::DoesDirectoryExist() . 언리얼 에디터가 인식하는 특정 패키지 경로(폴더)가 실제로 존재하는지 확인하는 기능 . 이 함수는 “UE 에디터에서 인식”하는 패키지 경로 기준으로 폴더의 존재 유무만 판단한다 . 파일 시스템상의 디렉터리 유무와는 다를 수 있음 (에디터 DB에 등록된 경로만 인식) . static bool UEditorAssetLibrary::DoesDirectoryExist( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 존재 여부를 확인할 대상 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 에디터와 AssetRegistry에서 인식하는 경로임 | . | . | 반환값 . | true : 해당 경로의 폴더가 에디터 내에 실제로 존재함 . | 폴더가 비어있더라도, 존재하면 true를 반환 | . | false : 해당 경로의 폴더가 존재하지 않음 . | 완전히 삭제된 경우(에셋/폴더 모두 삭제 후 GC 반영 등), false를 반환 | . | . | . UEditorAssetLibrary::DoesDirectoryHaveAssets() . 지정한 패키지 경로(폴더)에 최소 1개 이상의 에셋(Asset)이 존재하는지를 확인하는 기능 . static bool UEditorAssetLibrary::DoesDirectoryHaveAssets( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 에셋 존재 유무를 확인할 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 언리얼 에디터가 인식하는 경로임 | . | . | 반환값 . | true : 해당 폴더 내에 최소 1개 이상의 에셋이 존재 | false : 폴더가 비어있거나(에셋 0개), 폴더 자체가 존재하지 않을 경우 | . | . FString::Append() . 문자열(또는 TCHAR 포인터, FString, FText 등) 값을 뒤에 이어붙이는 함수. 문자열 결합용 . FString S = TEXT(\"Hello\"); S.Append(TEXT(\" World\")); // S = \"Hello World\" . TArray::Append() . 다른 배열이나 범위의 모든 요소를 현재 배열 뒤에 “한꺼번에” 추가 . TArray&lt;Type&gt; Array; Array.Append(OtherArray); // OtherArray의 모든 원소를 뒤에 추가 Array.Append({ \"a\", \"b\", \"c\" }); // initializer list로 여러 개 추가 TArray&lt;FString&gt; Names = { \"Apple\" }; TArray&lt;FString&gt; NewFruits = { \"Banana\", \"Cherry\" }; Names.Append(NewFruits); // 배열: [\"Apple\", \"Banana\", \"Cherry\"] . | 결론 . | Add(): 배열에 “한 개”의 값을 추가 | Append(): 배열에 “여러 개(0개~N개)”의 값을 한 번에 추가 | . | . UEditorAssetLibrary::DeleteDirectory() . 지정한 패키지 경로(폴더) 및 그 하위의 모든 에셋과 폴더를 완전히 삭제하는 기능 . 삭제된 폴더/에셋은 휴지통(Trash) 등으로 이동되지 않고, 실제로 프로젝트에서 사라짐 . static bool UEditorAssetLibrary::DeleteDirectory( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 삭제할 대상 폴더의 패키지 경로 | . | 반환값 . | true : 폴더 및 하위 모든 에셋/폴더의 삭제에 성공 | false : 삭제 실패(예: 에디터가 폴더/에셋을 참조 중이거나, 파일 권한 문제 등) . | 일부 에셋/폴더만 삭제된 경우에도, 하나라도 실패 시 false | . | . | . 동작 설명 . DirectoryPath에 해당하는 폴더 및 모든 하위 폴더/에셋을 재귀적으로 완전 삭제 . | 해당 폴더 내 모든 에셋 및 폴더를 찾음 | 하위 폴더, 에셋 순으로 모두 삭제 | 삭제가 정상적으로 끝나면 true 반환 | 만약 삭제 불가(읽기 전용, 다른 곳에서 사용 중 등)한 경우 false | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-함수-구현에-사용한-메서드"
  },"180": {
    "doc": "Search And Delete Empty Folders",
    "title": "Search And Delete Empty Folders",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html"
  },"181": {
    "doc": "Search And Delete Unused Assets",
    "title": "목표 : 바인딩 된 함수 동작 구현하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EB%AA%A9%ED%91%9C--%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%90%9C-%ED%95%A8%EC%88%98-%EB%8F%99%EC%9E%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#목표--바인딩-된-함수-동작-구현하기"
  },"182": {
    "doc": "Search And Delete Unused Assets",
    "title": "글로벌 함수의 링크 에러 및 static/네임스페이스 처리",
    "content": "G 접두사가 붙은 변수나 함수에 static을 추가하기 . | 링크 에러 : 여러 cpp 파일에서 동일한 헤더를 include하고, 그 헤더에 글로벌 함수가 정의되어 있다면 컴파일 시 “중복 정의된 심볼” 에러 발생 | 전역 객체 : 전역 객체에 직접 접근하는 함수를 static으로 만들면 해당 함수를 사용하는 모듈이 전역 객체가 정의된 모듈에 대한 불필요한 종속성을 만들지 않음 | . -&gt; 디버그 헤더에 namespace 추가 (클래스가 아니라 namespace::로 사용하기 위해) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EA%B8%80%EB%A1%9C%EB%B2%8C-%ED%95%A8%EC%88%98%EC%9D%98-%EB%A7%81%ED%81%AC-%EC%97%90%EB%9F%AC-%EB%B0%8F-static%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#글로벌-함수의-링크-에러-및-static네임스페이스-처리"
  },"183": {
    "doc": "Search And Delete Unused Assets",
    "title": "OnDeleteUnsuedAssetButtonClicked() 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::ListAssets() . 특정 폴더 경로 내의 모든 에셋(assets) 목록을 가져오는 기능 . static TArray&lt;FString&gt; UEditorAssetLibrary::ListAssets( const FString&amp; Path, bool bRecursive = true, bool bIncludeFolder = false ); . | 매개변수 . | Path : 에셋을 검색할 디렉터리 경로 | bRecursive : 하위 폴더까지 탐색 여부 (기본값 true) | bIncludeFolder : 폴더 자체도 결과 배열에 포함할지 여부 (기본값 false) | . | 반환값 . | TArray : 폴더 내 모든 에셋/폴더의 \"Object Path\" 문자열 배열 . | 예 : /Game/Test/Sub/SM_Sphere.SM_Sphere | . | . | . 2. Contains() . 문자열 또는 컨테이너 내 특정 요소의 존재 여부를 검사 . bool FString::Contains( const TCHAR* SubStr, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . | 매개변수 . | const TCHAR* : 검색할 부분 문자열 (예: “Test”) | ESearchCase::Type : 대소문자 구분 여부 . | ESearchCase::IgnoreCase : 구분 안함 | ESearchCase::CaseSensitive : 구분함 | . | . | 반환값 . | 포함되면 true / 아니면 false | . | . 컨테이너 별 용도 . | 문자열 검색 → FString::Contains() | 빠른 요소 확인 → TSet::Contains() | 키 존재 여부 → TMap::Contains() | . 3. UEditorAssetLibrary::DoesAssetExist() . 에셋 경로(.uasset)가 실제로 존재하고 로드 가능한지 여부를 확인 . static bool UEditorAssetLibrary::DoesAssetExist( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검사할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환 값 . | 에셋이 존재하면 true, 아니면 false | . | . 4. UEditorAssetLibrary::FindAssetData() . 주어진 에셋 경로(.uasset)로부터 에셋의 메타데이터(FAssetData) 를 조회 . static FAssetData UEditorAssetLibrary::FindAssetData( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검색할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환값 . | FAssetData : 에셋 정보를 담은 객체 (없으면 빈 객체) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-함수-구현에-사용한-메서드"
  },"184": {
    "doc": "Search And Delete Unused Assets",
    "title": "Search And Delete Unused Assets",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html"
  },"185": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "목표: SCompoundWidget 상속받아 커스텀 위젯 클래스 만든 후 바인딩하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EB%AA%A9%ED%91%9C-scompoundwidget-%EC%83%81%EC%86%8D%EB%B0%9B%EC%95%84-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%A0-%ED%9B%84-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#목표-scompoundwidget-상속받아-커스텀-위젯-클래스-만든-후-바인딩하기"
  },"186": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "커스텀 위젯 등록과 바인딩",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%EB%93%B1%EB%A1%9D%EA%B3%BC-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#커스텀-위젯-등록과-바인딩"
  },"187": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule에서 이벤트 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%97%90%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule에서-이벤트-등록"
  },"188": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule의 역할",
    "content": "어떤 일이 생길 때, 무슨 코드를 실행할지를 엔진의 전역 관리자에게 등록 . 등록: 함수 포인터/Delegate, 생성자 콜백, 이름(ID) 등만 엔진 전역 자료구조에 저장 메모리상에는 해당 모듈이 필요해지면 이 콜백을 실행해서 만든다는 정보만 들어있음 . | 전역 테이블(맵, 배열, 리스트 등)에 ‘예약’만 해놓음 | . void FBacgroundToolsModule::StartupModule() { InitCBMenuExtention(); RegisterAdvanceDeletionTab(); } . | StartupModule()에서 RegisterAdvanceDeletionTab()을 호출 . | 탭(Advanced Deletion 패널)을 에디터에 “등록”하는 과정이 실행 | . | . void FBacgroundToolsModule::RegisterAdvanceDeletionTab() { FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;FBacgroundToolsModule::OnSpawnAdvanceDeletionTab)) .SetDisplayName(FText::FromString(TEXT(\"Advance Deletion\"))); } . FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner . | FGlobalTabmanager(언리얼 에디터의 전역 탭 관리자)에 “AdvanceDeletion” 이라는 ID로 탭 생성자를 등록 실제로 이 탭을 띄우기 전까지는 “정의만 되어있는 상태”이다 . 즉, “Advanced Deletion”이라는 이름의 탭을 만들 준비만 마친 것 . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule의-역할"
  },"189": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "탭을 실제로 여는 시점 (이벤트 발생)",
    "content": ". | OnAdvancedDeletionButtonClicked 함수 . | TryInvokeTab(\"AdvanceDeletion\")을 통해 등록된 스포너(생성 콜백)를 호출 | . | OnSpawnAdvanceDeletionTab() 함수를 통해 실제 인스턴스 생성 . | 이 순간부터 Advance Deletion 탭이 실제로 화면에 나타남 TSharedRef&lt;SDockTab&gt; FBacgroundToolsModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs) { return SNew(SDockTab).TabRole(ETabRole::NomadTab) [ SNew(SAdvanceDeletionTab) .TestString(TEXT(\"I am passing data\")) ]; } . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%ED%83%AD%EC%9D%84-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%EC%97%AC%EB%8A%94-%EC%8B%9C%EC%A0%90-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%9C%EC%83%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#탭을-실제로-여는-시점-이벤트-발생"
  },"190": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "정리",
    "content": ". | StartupModule()의 RegisterAdvanceDeletionTab()는 해당 이벤트 발생 전 준비만 바인딩 . | 이름만 등록, 실제 위젯 인스턴스 없음 | . | OnAdvancedDeletionButtonClicked()는 실제 사용자가 해당 이벤트를 발생시켰을 때 동작 바인딩 . | 실제 인스턴스 생성, SDockTab의 ChildSlot에 내가 생성한 위젯이 들어감 | . | . StartupModule() (에디터/플러그인 모듈 초기화) └→ RegisterAdvanceDeletionTab() └→ FGlobalTabmanager::RegisterNomadTabSpawner(\"AdvanceDeletion\", OnSpawnTab...) └→ \"AdvanceDeletion\" 탭 생성 콜백(준비만 해둠) └→ (사용자 요청이 있을 때까지 기다림) (사용자: 우클릭→Advanced deletion 메뉴 클릭) └→ OnAdvancedDeletionButtonClicked() → TryInvokeTab(\"AdvanceDeletion\") └→ FGlobalTabmanager에서 해당 탭 콜백 호출 └→ OnSpawnAdvanceDeletionTab() 실행 └→ SDockTab 생성, ChildSlot에 SAdvanceDeletionTab(Slate 위젯) 추가 └→ 트리 구조로 에디터 Slate 트리에 편입, 렌더링 시작 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#정리"
  },"191": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FGlobalTabmanager",
    "content": "언리얼 에디터 Slate 시스템의 탭(도킹 패널) 전체를 총괄하는 전역 관리자 . | 전역 객체 구조 . | FGlobalTabmanager::Get() : 항상 같은 전역 인스턴스 가져옴 | 실제로는 FSlateApplication 내부에 저장된 전역 포인터이다 | . | 역할 . | 탭의 등록/생성/소멸/상태관리 | 탭의 열림/닫힘/포커스/배치 등 관리 | ID(이름) ↔ 탭 생성자(Delegate) 맵 관리 | Slate 트리(SDockTab, SDockingArea, SWindow 등)와 연동 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager"
  },"192": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "주요 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#주요-메서드"
  },"193": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "RegisterNomadTabSpawner",
    "content": "RegisterNomadTabSpawner( FName TabId, FOnSpawnTab OnSpawnTabDelegate ) . | TabId : 이름의 도킹/플러그인 패널을 등록 | OnSpawnTabDelegate : 생성자 델리게이트 등록 | . 사용 예시 . // 탭 등록 FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner( FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;MyModule::OnSpawnAdvanceDeletionTab) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner"
  },"194": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "TryInvokeTab",
    "content": "TSharedPtr&lt;SDockTab&gt; TryInvokeTab(FName TabId); . | “TabId”의 탭이 열려있으면 포커스 | 없으면 등록된 Delegate로 탭 새로 생성/열기 | . 사용 예시 . // 탭 열기 (생성) FGlobalTabmanager::Get()-&gt;TryInvokeTab(FName(\"AdvanceDeletion\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab"
  },"195": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "UnregisterNomadTabSpawner",
    "content": "void UnregisterNomadTabSpawner(FName TabId); . | 등록해둔 탭 생성자(Delegate)와 ID 연결을 해제 . | 모듈이 종료될 때, ShutdownModule에서 주로 사용 | . | . 사용 예시 . // 탭 해제 FGlobalTabmanager::Get()-&gt;UnregisterNomadTabSpawner(FName(\"MyCustomTab\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner"
  },"196": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FindExistingLiveTab",
    "content": "TSharedPtr&lt;SDockTab&gt; FindExistingLiveTab(FName TabId); . | 이미 열려 있는 특정 TabId의 SDockTab Slate 객체를 반환 . | 없으면 nullptr | . | . 사용 예시 . // 이미 열린 탭 객체 얻기 TSharedPtr&lt;SDockTab&gt; LiveTab = FGlobalTabmanager::Get()-&gt;FindExistingLiveTab(FName(\"MyCustomTab\")); if (LiveTab.IsValid()) { // Tab이 이미 열려 있음 → 추가 동작 가능 } . ❓부모 모듈에서 에셋 데이터를 넘겨줘야 하는 이유? . | AdvanceDeletionTab은 “선택된 폴더 내의 에셋 데이터”를 리스트로 보여줘야 하므로, 그 데이터를 생성 시점에 한 번에 전달받아야 함 | 따라서 자식 위젯 클래스에서 설정한 SLATE_ARGUMENT에 부모가 에셋 리스트를 넘겨줘야 위젯의 생성자 초기화가 올바르게 세팅됨 | 부모에서 자식 탭을 생성할 때 반드시 값을 전달해야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab"
  },"197": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "Set Up A Class For Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html"
  },"198": {
    "doc": "Set Up Basic Layout",
    "title": "목표: 슬레이트 탭 레이아웃 작성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%AA%A9%ED%91%9C-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%ED%83%AD-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%9E%91%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#목표-슬레이트-탭-레이아웃-작성"
  },"199": {
    "doc": "Set Up Basic Layout",
    "title": "레이아웃 샘플 예시 보기",
    "content": ". | 에디터 플러그인 폴더 -&gt; 모듈 콘텐츠 폴더로 이동 | 우클릭 -&gt; 에디터 유틸리티 -&gt; 에디터 유틸리티 위젯 클릭 | 생성된 에디터 유틸리티 위젯 더블클릭 | 검색을 통해 슬롯에 추가 등 샘플 미리 볼 수 있음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%83%98%ED%94%8C-%EC%98%88%EC%8B%9C-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#레이아웃-샘플-예시-보기"
  },"200": {
    "doc": "Set Up Basic Layout",
    "title": "위젯 여러개 배치",
    "content": "SVerticalBox(세로 박스) 또는 SHorizontalBox(가로 박스)와 같은 패널 위젯을 사용 . | 해당 박스들은 여러개의 슬롯을 가질 수 있음 (보통 위젯은 하나의 슬롯만 가짐) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%9C%84%EC%A0%AF-%EC%97%AC%EB%9F%AC%EA%B0%9C-%EB%B0%B0%EC%B9%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#위젯-여러개-배치"
  },"201": {
    "doc": "Set Up Basic Layout",
    "title": "SVerticalBox",
    "content": "자식 위젯들을 수직 방향(위에서 아래로)으로 배치하는 레이아웃 컨테이너 . | 각 자식 위젯은 새로운 행에 배치됨 | SVerticalBox에 슬롯을 추가 . | .AddSlot() | + SVerticalBox::Slot() | . | . // 메인 세로 박스 SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ // 첫 번째 슬롯: 타이틀 텍스트 SNew(STextBlock) .Text(FText::FromString(TEXT(\"Advanced Deletion\"))) // 아래에 속성 추가 ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox"
  },"202": {
    "doc": "Set Up Basic Layout",
    "title": "SHorizontalBox",
    "content": "자식 위젯들을 수평 방향으로 배치하는 레이아웃 컨테이너 (왼쪽-&gt; 오른쪽) . | 각 자식은 새로운 열에 배치됨 | +SHorizontalBox::Slot() | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox"
  },"203": {
    "doc": "Set Up Basic Layout",
    "title": "속성 지정자",
    "content": "각각의 컨테이너는 각자의 Slot 구조체를 가지고 있고, 이 Slot의 속성을 통해 레이아웃을 제어할 수 있다 . | SVerticalBox::Slot() | SHorizontalBox::Slot() | SGridPanel::Slot() 등등 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#속성-지정자"
  },"204": {
    "doc": "Set Up Basic Layout",
    "title": "주요 Slot 속성 지정자",
    "content": "| 속성 지정자 | 설명 | 적용 가능한 컨테이너 | . | AutoWidth() | 자식 위젯의 자연스러운 너비로 자동 조정 | SHorizontalBox | . | AutoHeight() | 자식 위젯의 자연스러운 높이로 자동 조정 | SVerticalBox | . | FillWidth(float) | 사용 가능한 수평 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SHorizontalBox | . | FillHeight(float) | 사용 가능한 수직 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SVerticalBox | . | Padding(FMargin) | 슬롯 내부의 여백 설정 (Left, Top, Right, Bottom) | 모두 | . | HAlign(HAlign) | 수평 정렬 방식 (Left, Center, Right, Fill) | 모두 | . | VAlign(VAlign) | 수직 정렬 방식 (Top, Center, Bottom, Fill) | 모두 | . | MaxWidth(float) | 최대 너비 제한 | SHorizontalBox | . | MaxHeight(float) | 최대 높이 제한 | SVerticalBox | . | Expose(ExposedSlot&amp;) | 슬롯을 외부에서 접근할 수 있도록 노출 | 모두 | . | AutoHeight/AutoWidth: 해당 자식 위젯의 DesiredSize에 맞춰 영역을 할 | FillHeight/FillWidth: 남은 공간을 지정된 가중치대로 자식들에게 분배 . | 예: FillHeight(1.0f), FillHeight(2.0f)로 지정하면 1:2 비율로 높이를 나눔 | . | HAlign/VAlign: 박스 안에서 자식 위젯의 정렬을 결정 | Padding: 각 자식 위젯의 Slot에 여백 부여 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%A3%BC%EC%9A%94-slot-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#주요-slot-속성-지정자"
  },"205": {
    "doc": "Set Up Basic Layout",
    "title": "FSlateFontInfo",
    "content": "Slate 위젯에 텍스트 스타일 지정에 사용되는 구조체. 폰트 스타일, 크기 정보 . | STextBlock의 폰트 속성 지정자에 사용 | . struct FSlateFontInfo { UObject* FontObject; // 사용할 폰트 객체 (UFont 또는 FSlateFontInfo::GetFont) FName TypefaceFontName; // 폰트 페이스 이름(예: \"Bold\", \"Regular\") int32 Size; // 폰트 크기 FName FontMaterial; // 폰트 머티리얼 TEnumAsByte&lt;EFontHinting&gt; Hinting; // 폰트 힌팅 방식 bool bEnableOutline; // 아웃라인 사용 여부 float OutlineSize; // 아웃라인 크기 FLinearColor OutlineColor; // 아웃라인 색상 }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo"
  },"206": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": "// 에디터에서 제공하는 폰트 사용 FSlateFontInfo FontInfo = FCoreStyle::Get().GetFontStyle(\"Bold\", 18); // 직접 지정 FSlateFontInfo FontInfo(\"Roboto-Regular\", 24); // 폰트 패밀리, 크기 // 경로로 지정 FSlateFontInfo FontInfo( FPaths::EngineContentDir() / TEXT(\"Slate/Fonts/Roboto-Regular.ttf\"), 20 ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법"
  },"207": {
    "doc": "Set Up Basic Layout",
    "title": "텍스트 속성 지정",
    "content": "텍스트 속성 지정은 STextBlock을 사용해 지정한다 . // 텍스트 블록에 적용 SNew(STextBlock) .Font(FontInfo) // FSlateFontInfo 구조체 사용 .Text(FText::FromString(\"Hello Unreal\")) .ColorAndOpacity(FLinearColor::White) .Justification(ETextJustify::Center); . | 지정자 | 설명 | 예시 코드 | . | .Text(FText) | 표시할 텍스트 지정 | .Text(FText::FromString(TEXT(“Hello”))) | . | .Font(const FSlateFontInfo&amp;) | 폰트 패밀리/크기/스타일 지정 | .Font(FSlateFontInfo(“Roboto-Bold”, 24)) | . | .ColorAndOpacity(FSlateColor) | 텍스트 색상 및 불투명도(알파) 지정 | .ColorAndOpacity(FLinearColor::Red) | . | .ShadowOffset(FVector2D) | 텍스트 그림자 오프셋(거리) | .ShadowOffset(FVector2D(1, 1)) | . | .ShadowColorAndOpacity(FLinearColor) | 텍스트 그림자 색상 및 알파 | .ShadowColorAndOpacity(FLinearColor::Black) | . | .Justification(ETextJustify::Type) | 텍스트 정렬(좌/중앙/우) | .Justification(ETextJustify::Center) | . | .WrapTextAt(float) | 지정한 너비에서 텍스트 줄바꿈 | .WrapTextAt(200.0f) | . | .MinDesiredWidth(float) | 최소 표시 너비 | .MinDesiredWidth(50.0f) | . | .LineHeightPercentage(float) | 줄 간격 비율(1.0=기본) | .LineHeightPercentage(1.2f) | . | .AutoWrapText(bool) | 컨테이너 너비에 맞춰 자동 줄바꿈 | .AutoWrapText(true) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#텍스트-속성-지정"
  },"208": {
    "doc": "Set Up Basic Layout",
    "title": "Set Up Basic Layout",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html"
  },"209": {
    "doc": "Slate",
    "title": "Slate",
    "content": "언리얼 엔진의 로우레벨 UI 프레임워크 . | SlateCore: UI 위젯, 레이아웃, 입력 처리 등 Slate의 핵심 로직을 담당 | Slate: 렌더링, 스타일링, 고수준 위젯 구현, Windows/OSX/Linux와의 통합 등 확장 기능 담당 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html"
  },"210": {
    "doc": "Slate",
    "title": "슬레이트 구조 특징",
    "content": ". | Slate의 UI는 SWidget이라는 추상 클래스를 루트로 하는 트리 구조 | 각 위젯(버튼, 텍스트, 리스트 등)은 SWidget을 상속한 C++ 클래스 . | 예: SButton, STextBlock, SListView 등 | . | 모든 위젯은 부모-자식 관계로 연결되어 트리 형태 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B5%AC%EC%A1%B0-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-구조-특징"
  },"211": {
    "doc": "Slate",
    "title": "슬레이트 동작 과정",
    "content": ". | Slate Application 구동 . | 엔진 초기화 시 FSlateApplication 싱글턴이 생성 | 이 객체가 Slate의 메인 루프, 입력 이벤트 분배, 렌더링 등을 총괄 | . | 위젯 트리 구성 . | 프로그래머가 C++로 SWidget 트리를 생성 (ex. SNew(SVerticalBox) + SNew(STextBlock) 형태) | 이 트리를 SlateApplication이 루트부터 관리 | . | 입력 이벤트 처리 . | OS 레벨의 입력(마우스, 키보드 등)이 SlateApplication에 전달됨 | Slate는 이를 루트 SWidget부터 트리 순회하며 적절한 위젯에 분배 | 각 위젯은 OnMouseDown, OnKeyDown 등 가상 메서드에서 처리 | . | Tick &amp; 업데이트 . | Slate 트리는 매 프레임마다 Tick(갱신)됨 | 애니메이션, 상태 변화, Focus 변경 등 UI 갱신이 여기서 처리 | . | 레이아웃 &amp; 측정 . | 각 SWidget은 ComputeDesiredSize, ArrangeChildren 등 메서드로 자기 크기와 자식 위치를 계산 | 위젯 트리를 재귀적으로 순회하며 레이아웃 패스를 수행 | . | 렌더링 . | 각 위젯의 OnPaint가 호출되어 FSlateDrawElement 명령을 발행 | Slate 렌더러가 DrawElement를 실제 GPU로 렌더링 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-동작-과정"
  },"212": {
    "doc": "Slate",
    "title": "슬레이트 다이어그램",
    "content": ". 클래스 관계 . | FSlateApplication → SWindow: 여러 윈도우(에디터 창 등)를 관리 | SWindow → SWidget: 각 윈도우는 하나의 루트 위젯 트리를 가짐 | SWidget → SPanel/SCompoundWidget: 각 위젯의 파생 구조를 통해 복잡한 UI 트리를 형성 | FSlateWindowElementList → FSlateDrawElement: 각 윈도우에서 발생하는 모든 드로우 명령을 버퍼링 | FSlateDrawElement ↔ FWidgetStyle: 드로우 요소마다 스타일 정보를 가짐 | FSlateApplication → FSlateRenderer: 실제 GPU 렌더링을 위해 렌더러로 명령을 위임 | . FSlateApplication . | Slate 전체의 엔트리 포인트이자 메인 루프 | 입력 이벤트(마우스, 키보드 등) 처리, UI 업데이트(Tick), 드로우 메시지 생성, 윈도우 관리, 렌더링 요청까지 Slate 관련 모든 핵심 흐름을 담당 | Tick, ProcessInput, GeneratePaintMessages, DrawWindows 등 메서드를 통해 매 프레임 UI 시스템의 상태를 갱신하고, 렌더링 파이프라인을 실행 | 여러 개의 SWindow 인스턴스를 직접적으로 관리 | . SWindow . | OS 창(Window)의 추상화 | 에디터 창, 툴팁, 팝업 등 각종 윈도우를 의미 | 각 SWindow는 자신의 루트 위젯(RootWidget, SWidget)을 하나 포함 . | 즉, 한 SWindow의 모든 Slate UI 요소는 하나의 SWidget 트리로 구성됨 | . | 창의 콘텐츠 설정, 네이티브 창 객체 반환, 뷰포트(창 영역) 크기 정보 제공 등의 역할을 담당 | . SWidget . | 모든 Slate 위젯(버튼, 텍스트, 패널 등)의 최상위 추상 베이스 클래스 | 모든 시각적 UI 요소는 SWidget을 상속하여 구현 | 주요 메서드: . | ComputeDesiredSize: 위젯이 필요로 하는 최소/최적 크기 계산 | ArrangeChildren: 자식 위젯 배치 | OnPaint: 실제로 드로우 요소를 생성(FSlateDrawElement)하는 렌더링 엔트리 포인트 | OnMouseButtonDown: 입력 이벤트 핸들링 | Tick: 프레임마다 상태 갱신 등 | . | . SWidget 컨테이너 상속 구조 (SCompoundWidget, SPanel) . | SCompoundWidget . | SWidget에서 파생되며, 단일 자식(Slot)만을 가질 수 있는 컨테이너 | 복잡한 단일 구조 위젯에 적합 | . | SPanel . | SWidget에서 파생되며, 여러 자식(Slot/배열)을 가질 수 있는 컨테이너 | 리스트, 박스, 그리드 등 여러 자식 위젯을 배치하는 레이아웃 위젯에서 사용 | . | . FSlateWindowElementList . | 실제 드로잉 명령(FSlateDrawElement)의 집합/버퍼 역할 | 각 SWindow의 OnPaint 과정에서 위젯 트리를 순회하며, SWidget들이 페인트 시 호출되는 OnPaint에서 DrawElement를 이 리스트에 기록 | Draw Call 최적화와 레이어 관리의 핵심 중간 계층 | . FSlateDrawElement . | 실제 GPU로 전달되는 드로우 명령을 표현하는 구조체 | 박스, 텍스트, 선, 이미지 등 다양한 유형의 그리기 명령을 포함 | SWidget이 OnPaint에서 시각적 요소를 그리고자 할 때, FSlateDrawElement를 만들어 FSlateWindowElementList에 추가함 | . FWidgetStyle . | 위젯의 시각적 스타일(컬러, 불투명도, 폰트 등)을 정의 | FSlateDrawElement와 연계되어, 각 드로우 요소에 스타일 속성을 부여 | 상위에서 하위로 스타일이 전파되어, 일관성 있는 UI 테마 구현이 가능 | . FSlateRenderer . | 실제 하드웨어(DirectX/OpenGL/Vulkan 등) 렌더러와의 인터페이스 | FSlateApplication이 그리기 명령을 넘기면, FSlateRenderer가 이를 플랫폼별로 변환/렌더링 | Slate의 플랫폼 독립성과 실제 렌더링 동작을 분리하는 핵심 계층 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-다이어그램"
  },"213": {
    "doc": "Slate",
    "title": "정리",
    "content": ". | FSlateApplication → SWindow → SWidget 트리 (OnPaint) → FSlateWindowElementList → FSlateDrawElement → FSlateRenderer (플랫폼별) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#정리"
  },"214": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "목표 : 커스텀 에디터 탭 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%AA%A9%ED%91%9C--%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%90%EB%94%94%ED%84%B0-%ED%83%AD-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#목표--커스텀-에디터-탭-등록"
  },"215": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 매크로",
    "content": ". | SLATE_BEGIN_ARGS , SLATE_END_ARGS 매크로는 필수적으로 클래스 안에 들어가야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-매크로"
  },"216": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_BEGIN_ARGS / SLATE_END_ARGS",
    "content": "위젯의 생성자 인자 구조체인 FArguments를 정의 . | SLATE_BEGIN_ARGS는 구조체의 시작 | SLATE_END_ARGS는 구조체의 끝 | 시작과 끝 매크로 안에서 위젯의 속성, 이벤트 등을 선언 | . SLATE_BEGIN_ARGS(SMyWidget) // 시작 선언 : _Title(FText::FromString(\"Default Title\")) // 기본값 설정 {} SLATE_ARGUMENT(FText, Title) SLATE_ATTRIBUTE(int32, Count) SLATE_EVENT(FOnClicked, OnButtonClicked) SLATE_END_ARGS() // 끝 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args"
  },"217": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ARGUMENT(Type, Name)",
    "content": "생성자 인자로 전달되는 불변 값을 선언 . | SLATE_ARGUMENT(FText, Title)은 FText 타입의 Title이라는 인자를 선언 | FArguments 구조체 내에서 _Title로 접근 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name"
  },"218": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ATTRIBUTE(Type, Name)",
    "content": "동적으로 변경 가능한 속성을 선언 . 외부 데이터와 바인딩하여 UI 요소가 실시간으로 업데이트되도록 할 수 있다 . | SLATE_ATTRIBUTE(int32, Count)은 Count라는 이름의 속성을 선언 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name"
  },"219": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_EVENT(DelegateType, Name)",
    "content": "위젯에서 발생하는 이벤트를 처리할 델리게이트를 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name"
  },"220": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_NAMED_SLOT(OwnerArgsType, SlotType, SlotName)",
    "content": "사용자 정의 슬롯을 선언할 때 사용. 슬롯은 위젯의 특정 위치에 다른 위젯을 삽입할 수 있는 영역을 의미 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname"
  },"221": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "매크로 정리",
    "content": "| 매크로 | 용도 | 사용 예시 | 설명 | . | SLATE_BEGIN_ARGS | 위젯 생성 인자 정의 시작 | SLATE_BEGIN_ARGS(SMyWidget) | 클래스의 생성 인자 정의 블록을 시작 | . | SLATE_END_ARGS | 위젯 생성 인자 정의 종료 | SLATE_END_ARGS() | 생성 인자 정의 블록을 종료 | . | SLATE_ARGUMENT | 단일 값 인자 정의 | SLATE_ARGUMENT(FText, InitialText) | 위젯 생성 시 전달되는 단일 값 인자 | . | SLATE_ATTRIBUTE | 바인딩 가능한 속성 정의 | SLATE_ATTRIBUTE(FText, DisplayText) | 동적으로 변경 가능한 속성(TAttribute로 래핑됨) | . | SLATE_EVENT | 이벤트 핸들러 정의 | SLATE_EVENT(FOnClicked, OnButtonClicked) | 위젯에서 발생하는 이벤트 핸들러 | . | SLATE_STYLE_ARGUMENT | 스타일 인자 정의 | SLATE_STYLE_ARGUMENT(FName, StyleName) | 스타일 세트에서 스타일을 지정하는 인자 | . | SLATE_DEFAULT_SLOT | 기본 슬롯 속성 정의 | SLATE_DEFAULT_SLOT(FArguments, Content) | 위젯의 기본 콘텐츠 슬롯을 정의 | . | SLATE_NAMED_SLOT | 명명된 슬롯 정의 | SLATE_NAMED_SLOT(FArguments, Header) | 특정 이름을 가진 슬롯을 정의 | . | SLATE_SUPPORTS_SLOT | 슬롯 타입 지원 선언 | SLATE_SUPPORTS_SLOT(SVerticalBox::FSlot) | 위젯이 지원하는 슬롯 타입 선언 | . | SLATE_USER_ARGS | 사용자 정의 인자 구조체 | SLATE_USER_ARGS() | 사용자 정의 인자 구조체 정의 시 사용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#매크로-정리"
  },"222": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 초기화 설정하기",
    "content": "Slate 위젯은 생성자(constructor) 대신 Construct() 함수를 통해 실질적인 초기화를 수행한다 . | 엔진에서 위젯 인스턴스를 만든 뒤 곧바로 Construct를 호출하여 속성(Arguments)과 함께 위젯의 동작을 설정함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-초기화-설정하기"
  },"223": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "코드 예시",
    "content": "void SYourWidget::Construct(const FArguments&amp; InArgs) { // 1. 포커스 관련 설정 bCanSupportFocus = true; // 또는 false (위젯 용도에 따라) // 2. 마우스 이벤트 처리 설정 SetCanTick(true); // 틱 활성화 (애니메이션 등 필요시) bAcceptsInput = true; // 마우스/터치 입력 허용 // 3. 시각적 상태 설정 SetVisibility(EVisibility::Visible); // 기본 가시성 설정 // 4. 콘텐츠 구성 (가장 중요한 부분) ChildSlot [ // 위젯 계층 구조 정의 SNew(SBorder) .Padding(FMargin(5)) [ SNew(STextBlock) .Text(LOCTEXT(\"DefaultText\", \"Hello Slate!\")) ] ]; // 5. 인자에서 전달받은 값 적용 if (InArgs._SomeArgument.IsSet()) { // 인자 처리 로직 } } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#코드-예시"
  },"224": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "초기화 설정 정리",
    "content": "| 설정 | 설명 | 기본값 | 사용 예시 | . | bCanSupportFocus | 위젯이 키보드 포커스를 받을 수 있는지 설정 | false | bCanSupportFocus = true; | . | bAcceptsInput | 마우스/터치 입력 허용 여부 | false | bAcceptsInput = true; | . | SetVisibility() | 위젯의 가시성 설정 (Visible, Collapsed, Hidden, HitTestInvisible, SelfHitTestInvisible) | EVisibility::Visible | SetVisibility(EVisibility::Visible); | . | SetCanTick() | 위젯이 Tick 이벤트를 받을지 설정 (애니메이션, 실시간 업데이트 시 필요) | false | SetCanTick(true); | . | SetClipping() | 콘텐츠 클리핑 방식 (OnDemand, ClipToBounds, ClipToBoundsWithoutIntersecting, ClipToBoundsAlways) | EWidgetClipping::Inherit | SetClipping(EWidgetClipping::ClipToBounds); | . | SetCursor() | 마우스 오버 시 커서 모양 (Default, Hand, TextEdit, Crosshairs 등) | EMouseCursor::Default | SetCursor(EMouseCursor::Hand); | . | SetEnabled() | 위젯의 활성화/비활성화 상태 | true | SetEnabled(TAttribute(this, &amp;SMyWidget::IsEnabled)); | . | SetToolTipText() | 툴팁 텍스트 설정 | FText::GetEmpty() | SetToolTipText(LOCTEXT(“Tooltip”, “Click me!”)); | . | SetHAlign() / SetVAlign() | 수평/수직 정렬 (HAlign_Fill, VAlign_Center 등) | HAlign_Fill, VAlign_Fill | SetHAlign(HAlign_Center); | . | SetPadding() | 안쪽 여백 설정 | FMargin(0) | SetPadding(FMargin(5.0f)); | . | SetRenderTransform() | 변환 행렬 적용 (위치, 회전, 스케일) | FSlateRenderTransform() | SetRenderTransform(FSlateRenderTransform(FVector2D(10, 10))); | . | SetRenderOpacity() | 투명도 설정 (0.0 ~ 1.0) | 1.0f | SetRenderOpacity(0.5f); | . | SetForegroundColor() | 전경색 (텍스트, 아이콘 등) | FSlateColor::UseForeground() | SetForegroundColor(FLinearColor::White); | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#초기화-설정-정리"
  },"225": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "커스텀 위젯 플로우 요약",
    "content": ". | 사용자 정의 Slate 위젯 클래스 구현 | 에디터 확장 코드에서 커스텀 Slate 위젯 인스턴스 생성 . | (예: 커스텀 패널, 탭, 도킹 윈도우 등에서 SNew(SMyWidget) 사용) | . | Slate 위젯 트리(Widget Tree)에 삽입 . | 에디터 패널/탭/도킹 윈도우 등의 컨테이너가 커스텀 Slate 위젯의 부모가 됨 | . | Slate Application이 매 프레임마다 Tick &amp; Render 호출 . | Slate 렌더링 파이프라인에 따라 모든 위젯을 탐색하며 그리기 | DirectX/OpenGL/Vulkan 등 RHI 기반 드로우콜로 변환 | . | 사용자 입력/이벤트 처리 및 갱신 . | Slate Application이 마우스/키보드/포커스 등 이벤트 분배 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#커스텀-위젯-플로우-요약"
  },"226": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "Spawn A Coustom Editor Tab",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html"
  },"227": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html"
  },"228": {
    "doc": "String",
    "title": "FString",
    "content": "FString은 일반적인 문자열 데이터로 문자열 검색, 수정, 비교를 할 수 있다. | 데이터 구조 . | 메모리 상에 각 인스턴스마다 고유 문자 배열을 직접 저장 | 내부적으로 TArray&lt;TCHAR&gt; (=동적 배열 기반 유니코드 문자열) | C++의 std::wstring(wide string)과 비슷하지만, 언리얼 엔진 특화 기능(TCHAR, UTF-16, 매크로 등)이 있다 | . | 대표적 사용 예 . | 파일 경로, 로그 메시지 | 유저 입력 (채팅, 이름 등) | 임시 데이터 처리, 문자열 연산 | . | 특징 . | 수정 가능 | 문자열 조작이 자유로움 | 각 인스턴스가 자체 메모리 공간 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring"
  },"229": {
    "doc": "String",
    "title": "FName",
    "content": "FString과 다르게 문자열 전체 저장 X. 글로벌 네임 테이블에 저장되어 데이터를 경량화 . | 데이터 구조 . | 엔진 시작 시부터 종료까지 고유 문자열을 전역적으로 관리하는 글로벌 네임 테이블 사용 . | 실제 문자열 데이터는 네임 테이블에 한번만 등록됨 | . | 어떤 FName이 새로 생성될 때, 문자열이 이미 테이블에 있으면 기존 인덱스를 사용하고, 없으면 새로 추가함 | . | 문자열의 중복 저장을 막고, 모든 FName이 같은 문자열이면 동일한 인덱스를 공유한다 | . | 대표적인 사용 예 . | 오브젝트 식별에 주로 사용 | 변수명, 파라미터 이름 | 리소스/에셋 이름 | GameplayTags | . | 특징 . | 수정 불가 | 비교 검색이 매우 빠름 . | 문자열끼리 직접 비교하는 대신, 인덱스만 비교하면 되기 때문에 성능이 우수하다 | . | 대소문자 구분이 없다 | 가비지 컬렉션 대상이 아니다 (엔진이 꺼질 때 까지 유지) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname"
  },"230": {
    "doc": "String",
    "title": "FText",
    "content": "사용자에게 보여지는 텍스트에 주로 사용된다. 다국어 번역이 필요한 경우 사용. FText는 외부 API에서 받은 플레이어 이름 등을 UI에 표시할 때처럼, 현지화 테이블 미등록 텍스트 문자열에도 쓰인다. | 데이터 구조 | . 최상위 . | ITextData(인터페이스)의 TSharedRef 스마트 포인터만을 소유 | 실질적 데이터는 FTextData에 들어있다. class FText { private: TSharedRef&lt;ITextData, ESPMode::ThreadSafe&gt; TextData; ... }; . | . FTextData 구조체 . struct FTextData : ITextData { FString SourceString; // 원본 문자열 FCulturePtr TextCulture; // 해당 텍스트의 문화권(언어) 정보 FTextHistory TextHistory; // 텍스트 생성/변환 이력 (핵심!) ... }; . 현지화 히스토리 . | 다양한 하위 클래스를 통해 데이터 관리 가능 . | FTextHistory_LocalizedString : 현지화 키, 원본 텍스트, 로컬라이제이션 리소스 정보 등 저장 | FTextHistory_FormattedNumber : 숫자 포맷, 소수점, 지역화 등 정보 | FTextHistory_FormatString : 포맷 패턴, 인자 배열 등 | . | . class FTextHistory_LocalizedString : public FTextHistory_Base { FString SourceString; // 원본 텍스트 FString Namespace; // 현지화 네임스페이스 FString Key; // 현지화 키 FString LocalizedString; // 번역된 문자열(캐싱) ... }; . FText 구조 정리 . FText └─ TextData (FTextData) ├─ SourceString (원본) ├─ TextCulture (문화권) └─ TextHistory (생성/포맷/현지화 이력) ├─ 현지화키 ├─ 네임스페이스 ├─ 포맷정보 └─ 캐시된 번역값 등... | 대표적인 사용 예 . | UI 버튼/ 메뉴 텍스트 (시작, Continue 등) | 게임 대사, 퀘스트 설명, 튜토리얼 메시지 | 점수, 날짜, 숫자 등 표시 | 모든 다국어 지원 필요한 표시용 텍스트 | . | 특징 . | 현지화, 포맷, 문화권별 번역 자동 처리 | 직접 수정 불가. 변환 후 새로 만들어야 함 | 직접 비교/조작은 제한됨 . | FText끼리 == 연산은 데이터 주소 또는 히스토리 비교이므로, 실제 표시 문자열이 같아도 false가 나올 수 있음 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext"
  },"231": {
    "doc": "String",
    "title": "정리",
    "content": "| 클래스 | 사용 목적 | 데이터 구조 | 특징 | . | FString | 임의 문자열, 수정/검색/연결 | TArray(인스턴스별 동적 배열) | 수정 가능, 조작 자유 | . | FText | 현지화/번역 표시 텍스트 | TSharedRef + FTextHistory | 현지화 지원, 수정 어려움, 포맷/언어 처리 | . | FName | 식별자/키/이름/빠른비교 | 글로벌 해시 테이블 인덱스+번호 | 비교 빠름, 대소문자 무시, 수정 불가 | . 참고 링크 . | String Handling | Why you should be using GameplayTags in Unreal Engine | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#정리"
  },"232": {
    "doc": "Transform",
    "title": "Transform",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html"
  },"233": {
    "doc": "Transform",
    "title": "FVector",
    "content": "3차원 공간상의 위치, 방향, 속도, 크기 등 벡터 값을 표현할 때 사용 . | 오브젝트의 위치 (Location) : SetActorLocation(FVector(100.f, 200.f, 300.f)); | 이동 방향 및 속도 (Velocity, Direction) : FVector Direction = Target - Source; | 스케일(Scale) 값 (상대적 크기) | 힘(Force), 가속도(Acceleration) 등 물리 연산 | 충돌 처리에서 법선 벡터(Normal) 표현 | . | 데이터 구조 struct FVector { float X; float Y; float Z; }; . | 오른손 법칙 좌표계 : Z-위, X-앞, Y-오른쪽 | . | 특징 . | 기본적인 연산자 오버로딩 지원 (+, -, *, /, dot, cross 등) | 크기, 정규화, 내적(dot), 외적(cross) 등 벡터 연산 지원 | 단순 위치/방향뿐 아니라, 각종 수학적, 물리적 벡터 표현에 모두 사용 | 방향성과 크기를 함께 가짐 (예: 방향 벡터는 크기=1로 정규화) | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Size() | 없음 | float | 벡터의 크기를 반환합니다. | . | Normalize() | 없음 | 없음 | 벡터를 정규화합니다. | . | Dot() | const FVector&amp; Other | float | 두 벡터의 내적 | . | Cross() | const FVector&amp; Other | FVector | 두 벡터의 외적 | . | Rotation() | 없음 | FRotator | 벡터의 방향을 회전 값으로 반환 | . | Lerp() | const FVector&amp; A const FVector&amp; B float Alpha | FVector | 두 벡터 간의 선형 보간 | . | Size() / SizeSquared() |   | 벡터의 크기 또는 크기의 제곱을 반환 |   | . 배경 수학 . 벡터 연산(덧셈, 뺄셈, 스칼라 곱/나눗셈, 내적/외적 등)은 선형대수의 기본 연산. 내적(Dot Product): 두 벡터의 방향성이 얼마나 일치하는지 계산 → 코사인 법칙과 연관되어 각도 구하기, 투영, 정규화, 평면 법선 등 계산에 사용 . A·B = Ax * Bx + Ay * By + Az * Bz . 외적(Cross Product): 두 벡터에 수직인 벡터 산출 → 평면의 법선, 회전축 등 계산 . A×B = (Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx) . 정규화(Normalization) → 크기를 1로 맞춤 . V.Normalize() → V / |V| . 거리/길이 . V.Size() = sqrt(X^2 + Y^2 + Z^2) . 선형보간(LERP) . Lerp(A, B, Alpha) = (1-Alpha)*A + Alpha*B . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector"
  },"234": {
    "doc": "Transform",
    "title": "FRotator",
    "content": "오일러 각(Euler Angle)(Pitch, Yaw, Roll)로 3D 회전을 표현할 때 사용 . | 오브젝트 회전 : SetActorRotation(FRotator(0.f, 90.f, 0.f)); | 캐릭터, 카메라의 방향(회전) | Actor/Component의 회전값 저장 : GetActorRotation() | 블루프린트, 에디터의 회전값 입력 등 | . | 데이터 구조 struct FRotator { float Pitch; // X축 회전 (상하) float Yaw; // Z축 회전 (좌우) float Roll; // Y축 회전 (틸트) }; . | 세 개의 float값(Pitch, Yaw, Roll)로 오일러 각 표현 | . | 특징 . | 오일러 각 특성상 Gimbal Lock(짐벌락) 문제 발생 가능 | 사람에게 직관적으로 이해하기 쉬움 (디자이너, 에디터에서 많이 사용) | 내부적으로는 보통 Degree(각도) 단위 사용 (Radian 변환 필요시 지원) | FRotator는 내부적으로 회전 행렬 혹은 쿼터니언으로 변환 가능 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Quaternion() | 없음 | FQuat | 오일러 각을 쿼터니언으로 변환 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | UnrotateVector() | const FVector&amp; V | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | GetNormalized() | 없음 | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | Clamp() | 없음 | FRotator | 회전 값을 제한 | . 배경 수학 . | 오일러 각(Euler Angle) : 세 축(X, Y, Z)에 대한 회전 각도(θx, θy, θz)로 회전을 표현. | 언리얼 엔진은 Z(Yaw) → Y(Pitch) → X(Roll) 순서로 회전 (즉, “Yaw → Pitch → Roll” 오더) | . 행렬 변환: 오일러 각은 각각의 축 회전을 행렬로 변환 후 곱셈해서 최종 회전값을 만듦 . R = Rz(Yaw) * Ry(Pitch) * Rx(Roll) . Gimbal Lock: 두 축이 일치하여 3차원 회전 자유도가 2차원으로 줄어드는 현상 . | 예: Pitch가 ±90°에 가까워지면, Roll과 Yaw가 같은 평면이 됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator"
  },"235": {
    "doc": "Transform",
    "title": "FQuat",
    "content": "3D 공간에서 회전을 쿼터니언(Quaternion)으로 표현하여, 회전 연산의 정확성 및 안정성 확보 . | 모션 블렌딩, 본(스켈레톤) 등 애니메이션의 회전 보간 | 부드러운 연속 회전 (SLERP) | Gimbal Lock 방지가 중요한 복잡한 회전 연산 | . | 데이터 구조 struct FQuat { float X; // 허수 (벡터) float Y; // 허수 (벡터) float Z; // 허수 (벡터) float W; // 실수 (스칼라) 부분 }; . | 4개의 float형 멤버(X, Y, Z, W)로 구성 | 단위 쿼터니언(norm = 1) 으로 회전 표현 | . | 특징 . | 4차원 복소수로 회전 표현 | Gimbal Lock 문제 없음 | 회전 합성/보간에 최적화 (SLERP, NLERP 등 지원) | FRotator, FMatrix 등과 상호 변환 함수 제공 | 보통은 FRotator(에디터/코드) ↔ FQuat(엔진 내부)로 변환하며 사용 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | Inverse() | 없음 | FQuat | 쿼터니언의 역을 반환 | . | Slerp() | const FQuat&amp; A const FQuat&amp; B float Alpha | FQuat | 두 쿼터니언 간의 구면 선형 보간을 수행 | . | ToAxisAndAngle() | FVector&amp; Axis float&amp; Angle | 없음 (출력 매개변수 사용) | 회전 축과 각도로 변환 | . | MakeFromEuler() | const FVector&amp; Euler | FQuat | 오일러 각도로부터 쿼터니언을 생성 | . 배경 수학 . | 쿼터니언(Quaternion): 실수부(w)와 허수부(x, y, z)로 구성된 4차원 수학 구조 Q = w + xi + yj + zk (i, j, k는 허수 단위벡터) . | 회전 표현: 3D 공간에서 임의의 축(axis)과 각도(θ)에 대한 회전 Q = [cos(θ/2), (axis * sin(θ/2))] . | 복합 회전: 쿼터니언 곱셈으로 연속 회전 표현 Q' = Q2 * Q1 (Q1 후 Q2 수행) . | 회전 적용: 점 P를 Q로 회전시키려면 P' = Q * P * Q⁻¹ (여기서 P는 벡터를 허수부로 취급한 쿼터니언) . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat"
  },"236": {
    "doc": "Transform",
    "title": "FTransform",
    "content": "위치, 회전, 스케일을 함께 관리하여 오브젝트의 변환을 효율적으로 처리 . | 오브젝트의 전체 변환 설정: SetActorTransform(FTransform(Rotation, Translation, Scale)); | . | 데이터 구조 struct FTransform { FQuat Rotation; FVector Translation; FVector Scale3D; }; . | 특징 . | 위치, 회전, 스케일을 하나의 구조체로 관리 | 계층적 트랜스폼 계산에 유용 | 블루프린트에서 쉽게 사용할 수 있도록 지원 | . | 주요 메서드 | . 많아서 나중에 정리할랭 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform"
  },"237": {
    "doc": "Transform",
    "title": "정리",
    "content": "| 타입 | 목적/용도 | 데이터 구조 | 특징 요약 | . | FVector | 3D 위치, 방향, 벡터 | X, Y, Z (float) | 모든 위치/방향/벡터 연산에 사용 | . | FRotator | 오일러 각 기반 3D 회전 | Pitch, Yaw, Roll (float) | 직관적, Gimbal Lock 위험 | . | FQuat | 쿼터니언 기반 3D 회전 | X, Y, Z, W (float) | Gimbal Lock 없음, 고급 회전 | . | FTransform | 위치, 회전, 스케일 통합 변환 | 위치, 회전, 스케일 구조체 | Actor 변환, 부모-자식 변환 관리 | . 참고 링크 . | UE4 Transform Calculus | Vectors | Roll, Pitch, Yaw | Quaternion | Gimbal lock | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#정리"
  },"238": {
    "doc": "1. Quick Asset Actions",
    "title": "1. Quick Asset Actions",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/"
  },"239": {
    "doc": "1. Quick Asset Actions",
    "title": "에셋 액션",
    "content": "언리얼 에디터에서 에셋(Asset)에 대해 사용자가 직접 수행할 수 있는 특정 동작/명령 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%97%90%EC%85%8B-%EC%95%A1%EC%85%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#에셋-액션"
  },"240": {
    "doc": "1. Quick Asset Actions",
    "title": "동작 방식 (5.3 이상)",
    "content": ". | C++에서 UAssetActionUtility 기반 커스텀 클래스 생성 . | UAssetActionUtility는 언리얼이 제공하는 에디터 확장용 베이스 클래스 | 이 클래스를 상속받아 C++ 또는 블루프린트에서 커스텀 명령(함수)을 구현 | . | 함수에 UFUNCTION(CallInEditor) 매크로 등록 . | 에디터에서 호출 가능한 함수로 등록 | 함수명은 명확하게 작성 | . | 에디터 유틸리티 블루프린트(Asset Action Utility BP) 생성 . | 플러그인 또는 프로젝트의 콘텐츠 브라우저에서 생성 | 부모 클래스로 1번에서 만든 커스텀 C++ 클래스를 선택 | (에디터가 이 BP 인스턴스를 통해 실제 액션을 인식) | . | 동작 실행 . | 에디터에서 에셋을 우클릭 → “스크립팅된 에셋 액션”에서 등록된 함수가 메뉴에 나타남 | 클릭 시 실제 동작 수행 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#동작-방식-53-이상"
  },"241": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈",
    "content": "모듈은 언리얼 엔진의 구성 블록이다. 에디터를 만들려면 자신만의 모듈을 만들어야 한다. ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈"
  },"242": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈에서 알아야 할 세가지 주요 포인트",
    "content": ". | 모듈은 코드 분리를 강제한다. | 여러 개의 무작위 코드들이 서로 소통해야 할 때 매우 유용하다 | . | 모든 모듈은 Build.cs 파일이 필요하다. | 새 프로젝트 자체도 하나의 모듈이다. | 모듈은 자신의 빌드 파일을 가진다. [ModuleName].Build.cs [ProjectName].Build.cs . | . | 모듈은 Build.cs 파일에 추가하여 포함할 수 있다. | 다른 모듈에 위치한 헤더 파일을 포함해야 할 때 해당 헤더의 모듈 이름을 Build.cs 파일에 추가한다. | 보통 PublicDependencyModuleNames에 모듈 이름을 추가하는 경우가 많다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88%EC%97%90%EC%84%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EC%84%B8%EA%B0%80%EC%A7%80-%EC%A3%BC%EC%9A%94-%ED%8F%AC%EC%9D%B8%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈에서-알아야-할-세가지-주요-포인트"
  },"243": {
    "doc": "1. Quick Asset Actions",
    "title": "플러그인 생성하기",
    "content": ". | 언리얼 상단 메뉴 Edit &gt; Plugins 클릭 | 왼쪽 상단의 +ADD 버튼 클릭 | 여러가지 템플릿 목록에서 선택 (현재는 Blank 선택) . | 플러그인 이름이 곧 모듈 이름이다. | 한번 정하면 변경할 수 없다. | . | Create Plugin 버튼 클릭 | 비주얼 스튜디오로 돌아가 모두 로드 버튼 클릭 . | 프로젝트 소스 폴더 위에 플러그인 폴더 생성된 것 확인 | . | . // .uplugin \"Modules\": [ { \"Name\": \"BackgroundTool\", \"Type\": \"Editor\", // 만들 기능은 에디터 전용이므로 Runtime(게임 동작시 실행되는 타입) -&gt; Editor로 변경 \"LoadingPhase\": \"PreDefault\" // 플러그인이 언제 로드될지 결정함. PreDefault: 게임 모듈보다 먼저 로드됨 } ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#플러그인-생성하기"
  },"244": {
    "doc": "1. Quick Asset Actions",
    "title": "액터와 에셋",
    "content": ". | 에셋 : 콘텐트 브라우저 안에 존재하는 것 (머티리얼, 스태틱 매시 등) . | 에셋은 AssetActionUtility라는 내장 클래스를 사용 | . | 액터 : 레벨(뷰) 안에 존재하며 클릭할 수 있는 것 . | 액터는 ActorActionUtility라는 클래스를 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%95%A1%ED%84%B0%EC%99%80-%EC%97%90%EC%85%8B",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#액터와-에셋"
  },"245": {
    "doc": "1. Quick Asset Actions",
    "title": "Public/Private",
    "content": ". | 모듈을 하나 생성할 때 Pubilc, Private 폴더를 나눠서 생성할 수 있음 . | Pubilc : 헤더 | Private : cpp 소스 코드 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate"
  },"246": {
    "doc": "1. Quick Asset Actions",
    "title": "build.cs",
    "content": ". | 인클루드 된 헤더에 빨간 밑줄 : 현재 모듈이 이 헤더 파일에 접근할 권한 없음 | . 접근권한 해결하기 . | 솔루션 탐색기에서 해당 헤더 검색 후 헤더가 들어있는 모듈 찾기 | 해당 모듈의 build.cs 소스 코드에 각각 private, pubilc 모듈 경로를 찾을수 있음 | 내가 쓸 build.cs에 private, pubilc에 해당하는 경로 붙여넣기 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs"
  },"247": {
    "doc": "1. Quick Asset Actions",
    "title": "테스트용 에셋 함수 구동하기 (5.3 이상)",
    "content": "함수 준비하기 : 플러그인 콘텐트 . | 플러그인의 콘텐트 폴더로 이동 | 플러그인 콘텐트 브라우저에서 마우스 오른쪽 버튼 클릭 | 에디터 유틸리티 -&gt; 에디터 유틸리티 블루 프린트 -&gt; 에셋 액션 유틸리티 선택하여 생성 | 더블 클릭하여 해당 에셋을 열고 우측 상단의 파일 클릭 | 부모 블루프린트 -&gt; 내가 만든 c++ 클래스 입력 | 컴파일 및 저장 클릭 | . 이 과정이 없으면 에디터는 사용자가 만든 에셋 액션을 전혀 인식하지 못함 . | C++ 클래스 = 설계도 | 에셋 액션 유틸리티 BP 에셋 = 실제 완성품 (에디터가 사용할 수 있는 인스턴스) | . 함수 사용하기 . | 메인 콘텐트에서 Blueprint 폴더 생성 | Blueprint 클래스 생성 | 해당 클래스 우클릭 -&gt; Scripted Asset Actions | 플러그인 콘텐트에서 추가한 c++ 클래스가 보임 | 클릭하여 동작 확인 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9-%EC%97%90%EC%85%8B-%ED%95%A8%EC%88%98-%EA%B5%AC%EB%8F%99%ED%95%98%EA%B8%B0-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#테스트용-에셋-함수-구동하기-53-이상"
  },"248": {
    "doc": "1. Quick Asset Actions",
    "title": "디버그 헤더 만들기",
    "content": ". | 플러그인 안의 폴더를 오른쪽 버튼으로 클릭 | 새 항목 추가 선택 | 추가 창이 뜨면 위치를 플러그인 -&gt; 모듈 -&gt; public 폴더로 선택 | 만들 유형 헤더로 선택하고 Debug.h 이름 지정 | Debug.h의 함수를 사용할 cpp 파일에 #include “Debug.h” 추가 | . void PrintMessage(const FString&amp; Message, const FColor&amp; Color) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage(-1, 8.f, Color, Message); // 화면 좌상단에 출력 } } void PrintLog(const FString&amp; Message) { UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *Message); // 콘솔 로그창에 출력 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%94%94%EB%B2%84%EA%B7%B8-%ED%97%A4%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#디버그-헤더-만들기"
  },"249": {
    "doc": "1. Quick Asset Actions",
    "title": "단축키",
    "content": ". | UE 상단에서 툴 -&gt; visual studio 새로고침 선택 | Ctrl + B : vs studio 빌드 | Ctrl + F5 : 편집기 (엔진) 실행 | Ctrl + Alt + F11 : 라이브 코딩 실행 | Alt + F12(피킹 정의) : Quick Info 주석 보기 | Ctrl + ` : 터미널 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8B%A8%EC%B6%95%ED%82%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#단축키"
  },"250": {
    "doc": "Graphics rendering pipeline",
    "title": "Graphics rendering pipeline",
    "content": "3D 좌표로 표현된 기하학적 객체의 장면을 2D 디스플레이에 렌더링하는 데 필요한 일련의 단계 . | 참고 링크 Graphics Programming Compendium | 참고 링크 a trip through the graphics pipeline | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/"
  },"251": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/C++/",
    
    "relUrl": "/docs/C++/"
  },"252": {
    "doc": "C++",
    "title": "스마트 포인터",
    "content": ". | C++11부터 표준 라이브러리에 포함됨 | raw pointer보다 스마트 포인터 사용이 권장됨 | 상황에 맞는 스마트 포인터를 선택하고, 반드시 소유권 규칙을 명확히 해야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/C++/#스마트-포인터"
  },"253": {
    "doc": "C++",
    "title": "스마트 포인터 종류",
    "content": "1. std::unique_ptr . | 단일 소유권(Exclusive ownership): 오직 하나의 포인터만 객체를 소유 | 소유자가 사라질 때(포인터 scope 종료, 소멸자 호출 등) 자동으로 자원 해제 | 복사가 금지되어 있고, 소유권 이동은 move(이동)만 허용 | 용도: 소유권 이전(transfer)이 명확하고, 참조 카운팅이 필요 없는 객체 | . #include &lt;memory&gt; void func() { std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42); // std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 컴파일 에러! 복사 불가 std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1); // 소유권 이동 } . 2. std::shared_ptr . | 공유 소유권(Shared ownership): 여러 개의 포인터가 동일한 객체를 소유 | 내부적으로 참조 카운트(reference count) 관리 . | (카운트가 0이 되면 자원 해제) | . | 용도: 여러 곳에서 동시에 객체를 소유/관리해야 할 때 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42); std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 복사 가능, 참조 카운트 증가 // ptr1과 ptr2가 모두 소멸되면 메모리 해제 } . 3. std::weak_ptr . | 비소유 참조(Non-owning reference): shared_ptr로 관리되는 객체를 참조하지만, 참조 카운트에는 관여하지 않음 | 주로 순환 참조(circular reference) 방지 목적 | 용도: shared_ptr들 사이에서 서로 참조(특히 그래프, 트리 등)할 때 메모리 누수 방지 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; shared = std::make_shared&lt;int&gt;(42); std::weak_ptr&lt;int&gt; weak = shared; // 소유권 없음, 참조 카운트 변하지 않음 if (auto locked = weak.lock()) { // shared_ptr로 잠금 가능 // 객체가 아직 살아있을 때만 접근 가능 int value = *locked; } } . 스마트 포인터의 장점 . | 자동 메모리 관리: RAII(Resource Acquisition Is Initialization) 패턴 적용 | 예외 안전성: 예외 발생 시에도 자원 누수 없음 | 명확한 소유권 모델: 객체의 라이프사이클이 코드상에서 드러남 | . 스마트 포인터의 단점 . | 순환 참조 문제: shared_ptr만 사용하면 서로를 참조하는 객체들에서 해제가 안 될 수 있음(→ weak_ptr로 해결) | 성능 오버헤드: 특히 shared_ptr의 참조 카운트 갱신 비용 | 사용법 혼동 주의: 소유권 이전/공유 규칙이 코딩 컨벤션으로 정립되어야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/C++/#스마트-포인터-종류"
  },"254": {
    "doc": "C++",
    "title": "람다",
    "content": ". | C++11에서 도입된 기능으로, 이름 없는 함수(익명 함수)를 만들 수 있게 해줌 | 간단한 함수 객체(functor)나 콜백(callback) 등을 즉석에서 정의 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#람다"
  },"255": {
    "doc": "C++",
    "title": "기본 문법과 구조",
    "content": "람다 함수의 기본 형태 . // [캡처](매개변수) -&gt; 반환타입 { 함수본문 } [capture](parameters) -&gt; return_type { // 함수 본문 ... } // 예시 [my_mod](int v_) -&gt; int { return v_ % my_mod; } . | [capture] : 외부 변수(스코프 밖의 변수)를 람다 내부에서 사용할 때 어떻게 사용할지 지정 | (parameters) : 함수의 매개변수 목록 | -&gt; return_type : 반환 타입 (void 는 -&gt; 생략 가능 / 컴파일러가 추론) | . ",
    "url": "/docs/C++/#%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95%EA%B3%BC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/C++/#기본-문법과-구조"
  },"256": {
    "doc": "C++",
    "title": "c++98 함수 객체 vs C++11 람다",
    "content": "c++98 . struct Compare { bool operator()(int a, int b) { return a &lt; b; } }; std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), Compare()); // 함수 객체 전달 . c++11 . std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), [](int a, int b) { return a &lt; b; // 람다로 간결하게 표현 }); . ",
    "url": "/docs/C++/#c98-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-vs-c11-%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#c98-함수-객체-vs-c11-람다"
  },"257": {
    "doc": "C++",
    "title": "람다 핵심 개념 : 캡처 리스트",
    "content": "외부 변수를 람다에서 어떻게 참조할지 결정 . | 캡처 형태 | 의미 | 예시 | . | [] | 아무것도 캡처하지 않음 | []() { /* ... */ } | . | [=] | 모든 외부 변수를 값으로 복사 | [=]() { cout &lt;&lt; x; } | . | [&amp;] | 모든 외부 변수를 참조로 사용 | [&amp;]() { x = 42; } | . | [x, &amp;y] | 특정 변수 선택적 캡처 | [x, &amp;y]() { y += x; } | . [] . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 외부 변수 캡처 없음 → 오직 매개변수만 사용 가능 auto lambda = [](int a, int b) { return a + b; }; std::cout &lt;&lt; lambda(3, 5); // 출력: 8 // std::cout &lt;&lt; lambda(x, y); // ⚠️ x, y는 매개변수로 전달해야 함 } . [=] . | 원본 보존 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 값으로 복사 (x, y의 복사본 사용) auto lambda = [=]() { std::cout &lt;&lt; x + y; // 출력: 30 (원본 x, y는 변경되지 않음) }; lambda(); x = 100; // 원본 수정 lambda(); // 출력: 30 (복사본은 영향 없음) } . | 람다가 생성될 때 [=]는 현재 스코프의 모든 변수 (x 등)를 값으로 복사해 저장 . | 람다 객체 내부에 int x_copy = x; 같은 복사본이 생김 | . | 람다는 항상 자신이 가진 복사본(x_copy)을 참조하므로, 원본이 변경되어도 복사본은 변하지 않음 | . [&amp;] . | 원본 제어 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 참조로 캡처 (원본 직접 접근) auto lambda = [&amp;]() { x = 30; // 원본 수정 std::cout &lt;&lt; y; // 출력: 20 }; lambda(); std::cout &lt;&lt; x; // 출력: 30 (람다에서 수정된 값) } . [x, &amp;y] . | 특정 변수만 선택적으로 캡처할 때 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // x는 값으로, y는 참조로 캡처 auto lambda = [x, &amp;y]() { y += x; // y는 원본 참조 (y = 20 + 10) // x = 5; // x는 복사본이므로 수정 불가 (mutable 키워드 필요) }; lambda(); std::cout &lt;&lt; y; // 출력: 30 (원본 y 변경됨) } . 참고 링크 . | 람다(lambda) 함수 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90--%EC%BA%A1%EC%B2%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/C++/#람다-핵심-개념--캡처-리스트"
  },"258": {
    "doc": "C++",
    "title": "아래부터 나중에 추가 정리해야 할 것",
    "content": ". 언리얼 엔진5의 스마트 포인터 UE5는 C++ 표준 라이브러리와의 호환성 문제(예: 모듈 경계, 플랫폼별 동작 차이)로 자체 스마트 포인터를 제공합니다. (1) TSharedPtr&lt;&gt; C++의 std::shared_ptr&lt;&gt;과 유사하지만 UE5 전용 최적화가 적용됨. 관리 대상: UObject를 상속받지 않은 일반 C++ 클래스. 특징: . 참조 카운팅 + 스레드 안전성 지원. TWeakPtr&lt;&gt;으로 약한 참조 가능. MakeShared&lt;&gt;()로 생성 최적화. (2) TUniquePtr&lt;&gt; C++의 std::unique_ptr&lt;&gt;과 거의 동일하지만 UE5 메모리 할당자와 통합됨. 관리 대상: UObject가 아닌 객체. 특징: . 복사 불가능, 이동만 가능. MakeUnique&lt;&gt;()로 생성. (3) FObjectPtr (UE5+) UObject 전용으로 설계된 경량 포인터. C++ 표준과 무관하며, UE5의 가비지 컬렉션 시스템과 연동됩니다. 특징: . UObject의 안전한 참조를 위해 사용 (예: 크로스-스레드 접근 방지). TSharedPtr&lt;&gt;과 달리 참조 카운팅 없이 엔진 내부에서 관리. | C++ vs UE5 스마트 포인터 비교 기능 C++ (std) UE5 차이점 공유 소유권 std::shared_ptr&lt;&gt; TSharedPtr&lt;&gt; UE5는 스레드 안전성 강화. 독점 소유권 std::unique_ptr&lt;&gt; TUniquePtr&lt;&gt; UE5는 할당자 통합. 약한 참조 std::weak_ptr&lt;&gt; TWeakPtr&lt;&gt; 동일한 개념. 가비지 컬렉션 없음 FObjectPtr UObject 전용. 생성 방법 std::make_shared&lt;&gt; MakeShared&lt;&gt; UE5는 커스텀 메모리 풀 사용 가능. | . ",
    "url": "/docs/C++/#%EC%95%84%EB%9E%98%EB%B6%80%ED%84%B0-%EB%82%98%EC%A4%91%EC%97%90-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%A6%AC%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83",
    
    "relUrl": "/docs/C++/#아래부터-나중에-추가-정리해야-할-것"
  },"259": {
    "doc": "2. Extend Content Browser Menu",
    "title": "1. Extend Content Browser Menu",
    "content": "에디터 내 Content Browser의 폴더/에셋을 우클릭할 때, “나만의 기능” 메뉴를 추가하기 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu"
  },"260": {
    "doc": "2. Extend Content Browser Menu",
    "title": "에디터 메뉴 시스템 확장 과정",
    "content": ". | 모듈 생성 및 초기화 . | Editor 타입의 모듈 생성 (uplugin의 “Type”: “Editor”) | . | 명령(Command) 정의 . | 메뉴에 바인딩될 명령(이름, 단축키, 아이콘, 툴팁 등)을 TCommands를 상속받아 정의 | . | 실제 동작 (Action) 바인딩 . | 실제 실행할 동작을 정의 (함수 구현) 한 후 델리게이트로 바인딩 | 보통 플러그인이나 에디터 모듈의 StartupModule()에서 이루어짐 | . | 메뉴 확장(Menu Extension) 적용 . | FExtender/FMenuExtensionDelegate 를 통해 기존 메뉴 섹션에 새로운 엔트리(항목)를 추가 | 원하는 위치 (섹션명)은 엔진 문서 참고 | . | UI 적용 및 정리 . | 에디터가 종료될 때 ShutdownModule()를 통해 리소스 및 이벤트 정리 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EC%97%90%EB%94%94%ED%84%B0-%EB%A9%94%EB%89%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%95%EC%9E%A5-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#에디터-메뉴-시스템-확장-과정"
  },"261": {
    "doc": "2. Extend Content Browser Menu",
    "title": "Delegate",
    "content": "이벤트 기반 프로그래밍을 구현하기 위한 강력한 시스템으로, C++의 함수 포인터나 콜백 시스템을 더 안전하고 유연하게 확장한 개념 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate"
  },"262": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 특징",
    "content": ". | 타입 안전성: 컴파일 시점에 타입 검사를 수행 | 멤버 함수 바인딩: 객체 인스턴스와 함께 멤버 함수를 바인딩 가능 | 멀티캐스트 지원: 하나의 이벤트에 여러 함수를 등록 가능 | 다이나믹 델리게이트: 블루프린트와 연동 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-특징"
  },"263": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 사용하기",
    "content": "Delegate 타입 선언 : 매크로 사용 . DECLARE_DELEGATE(FMyDelegate); DECLARE_DELEGATE_RetVal_OneParam(ReturnType, DelegateName, ParamType); . | ReturnType: 반환 타입 (예: int32) | DelegateName: 델리게이트 타입 이름 (예: FMyDelegateWithReturn) | ParamType: 함수에 전달될 파라미터의 타입 (예: FString) | . 바인딩 : 위에 선언한 델리게이트 타입 객체에 함수 연결 . FMyDelegate MyDelegate; // 선언(위 매크로로 정의된 타입) MyDelegate.BindRaw(this, &amp;FMyClass::Handler); . | Bind~(), Add~(), Execute(), Broadcast() 등의 멤버 함수를 사용해 연결/호출 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-사용하기"
  },"264": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 종류",
    "content": "1. 단일 캐스트 델리게이트 (Single-cast Delegates) . | 하나의 함수만 바인딩 가능 | DECLARE_DELEGATE 매크로로 선언 | 반환 값이 있을 경우 DECLARE_DELEGATE_RetVal 사용 | . DECLARE_DELEGATE(FMyDelegate); // 기본 형태 DECLARE_DELEGATE_OneParam(FMyDelegateWithParam, FString); // 매개변수 하나 DECLARE_DELEGATE_RetVal_OneParam(int32, FMyDelegateWithReturn, FString); // 반환 값과 매개변수 // 사용 예 FMyDelegate MyDelegate; MyDelegate.BindUObject(this, &amp;AMyClass::MyFunction); MyDelegate.Execute(); . 2. 멀티캐스트 델리게이트 (Multi-cast Delegates) . | 여러 함수를 동시에 바인딩 가능 | DECLARE_MULTICAST_DELEGATE 매크로로 선언 | 반환 값 지원 안함 | . DECLARE_MULTICAST_DELEGATE(FMyMulticastDelegate); // 사용 예 FMyMulticastDelegate MyMulticastDelegate; MyMulticastDelegate.AddUObject(this, &amp;AMyClass::Function1); MyMulticastDelegate.AddUObject(OtherObject, &amp;AOtherClass::Function2); MyMulticastDelegate.Broadcast(); . 3. 다이나믹 델리게이트 (Dynamic Delegates) . | 블루프린트와 연동 가능 | 시리얼라이즈(직렬화) 지원 | 이름 기반 바인딩으로 런타임에 바인딩 가능 | DECLARE_DYNAMIC_DELEGATE로 선언 | . DECLARE_DYNAMIC_DELEGATE(FMyDynamicDelegate); // 사용 예 FMyDynamicDelegate MyDynamicDelegate; MyDynamicDelegate.BindDynamic(this, &amp;AMyClass::MyFunction); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-종류"
  },"265": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 바인딩 메서드",
    "content": "| 메서드 | 대상 유형 | 지원 Delegate 타입 | 자동 해제 | 용도/특징 | 주의점 | . | BindRaw | 일반 C++ 객체 | Single | X | 일반 포인터 대상, Raw C++ 객체 | 수명 관리 직접 필요 | . | AddRaw | 일반 C++ 객체 | Multi | X | 멀티캐스트 Delegate에 Raw 객체 바인딩 | 수명 관리 직접 필요 | . | BindUObject | UObject 파생 객체 | Single | O | Unreal UObject에 안전하게 바인딩 | GC 연동, 자동 해제 지원 | . | AddUObject | UObject 파생 객체 | Multi | O | 멀티캐스트 Delegate에 UObject 바인딩 | GC 연동, 자동 해제 지원 | . | BindSP | TSharedPtr 객체 | Single | O | TSharedPtr 기반 객체에 안전하게 바인딩 | WeakPtr로 자동 해제 | . | AddSP | TSharedPtr 객체 | Multi | O | 멀티캐스트 Delegate에 TSharedPtr 바인딩 | WeakPtr로 자동 해제 | . | BindLambda | 람다(익명함수) | Single | X | 임시 람다식 함수 직접 바인딩 | 캡처 객체 수명 주의 | . | AddLambda | 람다(익명함수) | Multi | X | 멀티캐스트 Delegate에 람다 함수 추가 | 캡처 객체 수명 주의 | . // Raw MyDelegate.BindRaw(this, &amp;FMyClass::Func); // this는 일반 C++ 객체 // UObject MyDelegate.BindUObject(this, &amp;UMyObject::Func); // this는 UObject 파생 클래스 // SharedPtr MyDelegate.BindSP(MySharedPtr, &amp;FMySharedClass::Func); // Lambda MyDelegate.BindLambda([](){ /* ... */ }); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-바인딩-메서드"
  },"266": {
    "doc": "2. Extend Content Browser Menu",
    "title": "2. Extend Content Browser Menu",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/"
  },"267": {
    "doc": "Computer Graphics",
    "title": "Computer Graphics",
    "content": " ",
    "url": "/docs/Computer%20Graphics/",
    
    "relUrl": "/docs/Computer%20Graphics/"
  },"268": {
    "doc": "Coding Standard",
    "title": "Coding Standard",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/"
  },"269": {
    "doc": "Coding Standard",
    "title": "저작권 고지",
    "content": "배포하는 모든 소스 파일(.h, .cpp, .xaml 등)에는 파일의 첫 줄에 반드시 다음과 같은 저작권 공지가 포함되어야 한다. // Copyright Epic Games, Inc. All Rights Reserved. 해당 줄이 없거나 형식이 다르면 오류 -&gt; 빌드 실패 처리됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A0%80%EC%9E%91%EA%B6%8C-%EA%B3%A0%EC%A7%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#저작권-고지"
  },"270": {
    "doc": "Coding Standard",
    "title": "클래스 구성",
    "content": "클래스는 읽는 사람을 우선으로 구성해야 한다. 대부분 클래스를 읽는 사람들은 public 인터페이스를 사용한다. 따라서 클래스는 . | public | protected | private | . 순으로 작성한다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-구성"
  },"271": {
    "doc": "Coding Standard",
    "title": "클래스 접두사",
    "content": "언리얼 엔진의 클래스에는 접두사가 있다. 해당 접두사를 알고있으면 어떤 클래스에서 파생됐는지 알 수 있다. | 접두사 | 클래스 | 예시 | . | A | AActor | AActor, APawn, AGameMode | . | U | UObject | UTexture, UBlueprintFunctionLibrary | . | S | SWidget | SButton, Swidget | . | F | 사용자 구조체 | FVector, FHitResult | . | I | 추상 인터페이스 | IInterface | . | T | 템플릿 클래스 | TArray&lt;T&gt;, TMap&lt;&lt;T&gt; | . | E | Enum 타입 | EGAmeState | . | G | globals 전역변수 | GEngine | . | b | Boolean 변수 | bHasFadedIn, bDied | . 사용예시 . typedef TArray&lt;FMytype&gt; FArrayOfMyTypes; . typedef에는 해당 타입에 적합한 문자가 접두사로 붙어야 한다. 위 예시는 사용자 구조체 타입을 받는 템플릿 클래스다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%91%EB%91%90%EC%82%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-접두사"
  },"272": {
    "doc": "Coding Standard",
    "title": "네이밍 규칙",
    "content": ". | 단어 사이에 언더스코어(_) 를 사용하지 않는다 | 단어의 첫 글자는 대문자로 표기한다 . | 예: MouseCoordinates (o), delta_x (x) | . | 타입명에는 추가로 대문자 접두사를 붙여 변수명과 구분한다 . | 예: FSkin (타입), Skin (FSkin 타입의 인스턴스) | . | 모든 변수는 한줄씩 선언한다 | 반환값이 있는 함수는 이름만으로 반환값을 명확히 한다 . | O: bool IsTeaFresh(FTea Tea) True 의미 명확 | X: bool CheckTea(FTea Tea) 어떤걸 반환할지 의미 불명확 | . | 반환값이 없는 절차 함수는 강한 동사+목적어 형식 . | 메서드의 목적어가 자기 자신이면 (맴버 함수) 생략 가능 | Handle, Process 등 모호한 동사 피하기 | . | bool 반환 함수는 항상 Yes/No 질문 형태를 취한다 . | IsVisible(), ShouldClearBuffer() | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#네이밍-규칙"
  },"273": {
    "doc": "Coding Standard",
    "title": "Const 정확성",
    "content": ". | 함수 인자가 함수 내에서 변경되지 않는다면, const pointer 또는 const reference로 전달 | 객체를 변경하지 않는 메서드는 const로 명시 | 컨테이너를 수정하지 않는 반복문은 const 반복자 사용 | . 사용예시 . void SomeMutatingOperation(FThing&amp; OutResult, const TArray&lt;Int32&gt;&amp; InArray) { // InArray는 수정되지 않음, OutResult는 아마 수정될것임 } void FThing::SomeNonMutatingOperation() const { // 이 코드는 FThing을 변경하지 않음 } TArray&lt;FString&gt; StringArray; for (const FString&amp; : StringArray) { // 반복문 내부에서 StringArray를 수정하지 않음 } . | 반환 타입에 const 사용 금지 (컴파일 경고 발생) . | 단 const 레퍼런스, 포인터 반환은 허용 | . | . // 좋은 예시 - const 참조 반환 const TArray&lt;FString&gt;&amp; GetSomeArray(); // 좋은 예시 - const 포인터 반환 const TArray&lt;FString&gt;* GetSomeArray(); // 나쁜 예시 - const 배열 반환 const TArray&lt;FString&gt; GetSomeArray(); // 나쁜 예시 - const 포인터를 const로 반환 const TArray&lt;FString&gt;* const GetSomeArray(); . | 포인터 자체를 const로 만들 때는 타입 뒤에 const . | 포인터가 가리키는 값이 아닌, 포인터 자체의 재할당을 막음 | . | . // 포인터는 재할당 불가, T는 변경 가능 T* const Ptr = ...; // 잘못된 사용: 불가(레퍼런스는 재할당 불가 특성상 의미 없음) T&amp; const Ref = ...; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-%EC%A0%95%ED%99%95%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-정확성"
  },"274": {
    "doc": "Coding Standard",
    "title": "주석",
    "content": ". | 클래스 주석 . | 이 클래스가 해결하는 문제 | 클래스 생성 이유 | . | 함수 (메서드) 주석 . | 함수 목적 기입 | . | 매개변수 주석 @param . | 측정 단위 | 예상 값 범위 | 불가능한 값 | 상태/오류 코드 의미 | . | 반환값 주석 @return . | 예상 반환 값 | . | 추가 정보 . | @warning 경고, @See보기 등을을 선택적으로 사용함 | . | . 사용예시 . /** The interface for drinkable objects. */ class IDrinkable { public: /** * Called when a player drinks this object. * @param OutFocusMultiplier - 반환 시, 마시는 사람의 집중력에 곱할 배수를 담는다. * @param OutThirstQuenchingFraction - 반환 시, 갈증 해소 정도(0~1)를 담는다. * @warning 반드시 음료가 제대로 준비된 후 호출해야 함. */ virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) = 0; }; /** 단일 찻잔 */ class FTea : public IDrinkable { public: /** * 주어진 물의 부피와 온도로 우려냈을 때, 차의 맛 변화량을 계산 * @param VolumeOfWater - 우릴 때 사용된 물의 양(mL) * @param TemperatureOfWater - 물의 온도(Kelvin) * @param OutNewPotency - 우려낸 후 차의 효능(0.97~1.04) * @return 차의 맛 강도 변화량(1분당 TTU) */ float Steep( const float VolumeOfWater, const float TemperatureOfWater, float&amp; OutNewPotency ); /** 설탕 당도 기준으로 감미를 추가 */ void Sweeten(const float EquivalentGramsOfSucrose); /** 일본 내 판매가(엔) */ float GetPrice() const { return Price; } virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) override; private: /** 가격(엔) */ float Price; /** 감미(설탕 환산 그램) */ float Sweetness; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#주석"
  },"275": {
    "doc": "Coding Standard",
    "title": "차후 더 추가 예정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%B0%A8%ED%9B%84-%EB%8D%94-%EC%B6%94%EA%B0%80-%EC%98%88%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#차후-더-추가-예정"
  },"276": {
    "doc": "Coding Standard",
    "title": "사용가능한 표준 라이브러리 목록",
    "content": ". | &lt;atomic&gt; : 신규 코드는 std::atomic 사용. 기존 TAtomic은 부분 구현만 되어 있음. | &lt;type_traits&gt; : 겹치는 부분은 표준 trait 사용. (표준 trait는 value/type 소문자, 기존 UE는 대문자 Value/Type 주의) | &lt;initializer_list&gt; : braced initializer 지원에 필수, 대체재 없음 | &lt;regex&gt; : 직접 사용 가능하나 에디터 전용 코드에 한정. 자체 구현 계획 없음. | &lt;limits&gt; : std::numeric_limits 전부 사용 가능 | &lt;cmath&gt; : 부동소수점 비교 함수만 사용 허용 | . 참고 링크 . | Coding Standard | Recommended Asset Naming Conventions | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%91%9C%EC%A4%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AA%A9%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#사용가능한-표준-라이브러리-목록"
  },"277": {
    "doc": "3. Slate Widget",
    "title": "목표 : 에디터 확장을 더 깊게 다루기 위해 슬레이트(Slate) 코드를 직접 작성해보자",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EB%AA%A9%ED%91%9C--%EC%97%90%EB%94%94%ED%84%B0-%ED%99%95%EC%9E%A5%EC%9D%84-%EB%8D%94-%EA%B9%8A%EA%B2%8C-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8slate-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%9E%91%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#목표--에디터-확장을-더-깊게-다루기-위해-슬레이트slate-코드를-직접-작성해보자"
  },"278": {
    "doc": "3. Slate Widget",
    "title": "슬레이트가 어렵게 느껴지는 이유",
    "content": ". | 슬레이트 코드는 고유의 문법을 가지고 있다 . | 일반적인 C++ 코드와 매우 다르다 | . | 시각화가 어렵다 . | 위젯 레이아웃을 전부 코드로만 해야 한다는 것이 문제 | 변경한 내용을 바로바로 미리보기로 확인할 수 없다 | . | 다른 모듈과의 연동 . | 다른 모듈과 데이터를 주고받고 상호작용하는 것이 바로 연동(communication)이다 | 이 부분이 슬레이트 위젯을 구현할 때 가장 어렵고 중요하다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8%EA%B0%80-%EC%96%B4%EB%A0%B5%EA%B2%8C-%EB%8A%90%EA%BB%B4%EC%A7%80%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#슬레이트가-어렵게-느껴지는-이유"
  },"279": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터",
    "content": "모듈 간의 데이터 전달 문제(communication issue)를 해결하기 위해서는 반드시 이해해야 할 중요한 개념 . 언리얼 엔진에서는 new 키워드를 직접 써서 객체를 만들도록 허용하지 않는다 . | new 키워드로 메모리를 할당할 일이 있다면, 반드시 스마트 포인터와 함께 쓴다 | . UE에서 지원하는 스마트 포인터 . | Shared Pointer (TSharedPtr) | Shared Reference (TSharedRef) | Weak Pointer (TWeakPtr) | Unique Pointer (TUniquePtr) | . TSharedPtr (Shared Pointer, 공유 포인터) . | 소유권(Owning) 보유: Shared Pointer는 해당 객체의 소유권을 갖는다 이 포인터가 존재하는 한 객체는 삭제되지 않음 . | 참조 카운팅(reference counting) 방식: 이 객체를 참조하는 Shared Pointer/Reference가 모두 사라지면 자동으로 삭제 . | null 할당 가능: 아직 가리키는 대상이 없어도 선언만 할 수 있다 . | . TSharedRef (Shared Reference, 공유 참조) . Shared Pointer와 거의 동일하지만 항상 유효한 객체만 가리킬 수 있다다 . | null 할당 불가능: 항상 유효한 인스턴스가 존재해야 하므로, 슬레이트 함수 반환값 등에서 주로 사용 . | 따라서 Shared Reference는 언제나 Shared Pointer로 변환할 수 있다 . | 유효한 Shared Pointer는 언제나 Shared Reference로 변환이 가능하다 . | . TWeakPtr (Weak Pointer, 약한 참조) . | 소유권을 갖지 않음: Weak Pointer는 객체의 소유권이 없음 객체가 삭제되는 것을 막지 않는다 . | “참조 순환(Reference Cycle)” 문제를 해결할 때 매우 유용하다 즉, 객체가 살아있을 때만 약하게 참조하고, 객체가 삭제되면 자동으로 무효(null)가 된다 . | 사용할 때마다 “이 객체가 아직 살아 있나요?”라고 먼저 체크해야 하며, 살아있으면 사용할 수 있다 . | . ❓게임 개발에서는 잘 안 보이는 이유? . | 스마트 포인터들은 UObject 기반 오브젝트에서는 쓸 수 없다 | UObject 시스템 자체가 고유한 메모리 관리(가비지 컬렉션)를 사용하기 때문 | Object 포인터를 직접 스마트 포인터로 관리하면 엔진의 GC 시스템과 충돌이 생김 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터"
  },"280": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터 생성 문법",
    "content": "TSharedRef&lt;FMyType&gt; MyObject = MakeShareable(new FMyType(...)); . | MakeShareable . | public 생성자가 필요하지만 훨씬 효율적 | . | MakeShared . | 제한이 덜하지만, 약간 비효율적 | . | . 위 함수들은 객체 인스턴스를 생성과 동시에 만든다 . TSharedPtr&lt;FMyType&gt; Ptr = MakeShared&lt;FMyType&gt;(...); . 슬레이트 위젯을 만들 때 자주 사용됨 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%83%9D%EC%84%B1-%EB%AC%B8%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터-생성-문법"
  },"281": {
    "doc": "3. Slate Widget",
    "title": "커스텀 Slate 레이아웃 구현 과정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%BB%A4%EC%8A%A4%ED%85%80-slate-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EA%B5%AC%ED%98%84-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#커스텀-slate-레이아웃-구현-과정"
  },"282": {
    "doc": "3. Slate Widget",
    "title": "1. Slate 위젯 클래스 정의",
    "content": ". | 대부분의 커스텀 슬레이트 위젯은 SCompoundWidget을 상속 | . #pragma once #include \"Widgets/SCompoundWidget.h\" class SMyCustomLayout : public SCompoundWidget {}; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-위젯-클래스-정의"
  },"283": {
    "doc": "3. Slate Widget",
    "title": "2. Slate 속성 매크로(Arguments) 활용",
    "content": "| 매크로 | 역할 | 예시 | . | SLATE_ARGUMENT | “불변 값” 1회성 복사(생성자 인자) | SLATE_ARGUMENT(FText, Title) | . | SLATE_ATTRIBUTE | “동적 값”(TAttribute 바인딩) | SLATE_ATTRIBUTE(int32, Count) | . | SLATE_EVENT | “이벤트/Delegate” (콜백 함수) | SLATE_EVENT(FOnClicked, OnButtonClicked) | . | SLATE_ARGUMENT: 위젯의 생성자(Construct)에 전달될 “불변 값” 인자 | SLATE_ATTRIBUTE: 바인딩 가능한 동적 값(속성) . | TAttribute로 선언되어 외부의 값을 실시간으로 바꿀 수 있음 | . | SLATE_EVENT: Slate Delegate/이벤트(함수, 람다 등 콜백) | . // CustomButtonPanel.h class SCustomButtonPanel : public SCompoundWidget { public: SLATE_BEGIN_ARGS(SCustomButtonPanel) {} // 슬레이트 속성 정의 SLATE_ARGUMENT(FText, Title) SLATE_ARGUMENT(TArray&lt;FText&gt;, ButtonLabels) SLATE_EVENT(FOnInt32Selected, OnButtonSelected) SLATE_END_ARGS() void Construct(const FArguments&amp; InArgs); private: // 위젯 상태 변수 TArray&lt;FText&gt; ButtonLabels; FOnInt32Selected OnButtonSelected; }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-%EC%86%8D%EC%84%B1-%EB%A7%A4%ED%81%AC%EB%A1%9Carguments-%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-속성-매크로arguments-활용"
  },"284": {
    "doc": "3. Slate Widget",
    "title": "3. Construct 함수 구현",
    "content": ". | ChildSlot을 이용해 Slate 레이아웃 선언 | ChildSlot(컨테이너의 루트)에 원하는 레이아웃 위젯(예: SVerticalBox, SHorizontalBox 등)으로 하위 위젯을 배치 | . void SMyCustomLayout::Construct(const FArguments&amp; InArgs) { Title = InArgs._Title; ChildSlot [ SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ SNew(STextBlock).Text(FText::FromString(Title)) ] + SVerticalBox::Slot() .FillHeight(1.0f) [ SNew(SButton) .Text(NSLOCTEXT(\"MyCustomLayout\", \"Button\", \"Click Me\")) // .OnClicked(....) ] ]; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-함수-구현"
  },"285": {
    "doc": "3. Slate Widget",
    "title": "4. Slate 스타일 및 Theme 적용",
    "content": ". | FSlateStyleSet을 사용해 스타일 정의 | FSlateBrush로 브러시 설정 | FSlateFontInfo로 폰트 설정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%8F-theme-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-스타일-및-theme-적용"
  },"286": {
    "doc": "3. Slate Widget",
    "title": "5. 이벤트 처리",
    "content": ". | 마우스/키보드 이벤트 바인딩 | 델리게이트를 사용한 커스텀 이벤트 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-이벤트-처리"
  },"287": {
    "doc": "3. Slate Widget",
    "title": "언리얼 에디터 슬레이트 계층 구조",
    "content": ". | 루트 레벨 (FSlateApplication) . | 모든 슬레이트 위젯의 최상위 관리자 . | 입력 이벤트, 렌더링 순서, 포커스 관리 | SMainFrame과 독립적인 팝업 창(SWindow_Standalone)을 자식으로 가짐 | . | . | 메인 프레임 (SMainFrame) . | 에디터 메인 창 (가장 바깥 윈도우) . | 상속 구조: SWindow → SMainFrame | . | . | 도킹 시스템 (SDockingArea) . | 탭/분할 레이아웃을 관리하는 컨테이너 | 여러 SDockTabStack(탭 묶음)을 포함하는 도킹 가능 영역 . | SSplitter : 수직/수평 영역 분할 | SDockTabStack : 탭 그룹 (ex. 왼쪽/가운데/오른쪽 스택) | SDockTab : 사용되는 실제 개별 패널 (ex. 콘텐츠 브라우저, 디테일 패널) | . | . | 탭 컨텐츠 (SDockTab → SCompoundWidget) . | 각 탭의 실제 UI 구현체 . | 커스텀 위젯은 반드시 SCompoundWidget을 상속받아 구현 | . | . | 기본 위젯 (Leaf Nodes) . | 최하위에 위치하는 실제 UI 요소 . | SextBlock, SButton, SImage 등 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%90%EB%94%94%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#언리얼-에디터-슬레이트-계층-구조"
  },"288": {
    "doc": "3. Slate Widget",
    "title": "3. Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/"
  },"289": {
    "doc": "UObject",
    "title": "UObject",
    "content": "언리얼 엔진의 모든 객체 지향 시스템의 기반이 되는 핵심 클래스. | 게임플레이 요소, 컴포넌트, 에셋 등 거의 모든 UE5 객체가 UObject에서 파생됨 | UObject 객체를 생성함으로써 리플렉션, 가비지 컬렉션(GC), 직렬화 등의 기능을 사용할 수 있다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/"
  },"290": {
    "doc": "UObject",
    "title": "개발자가 직접 사용하는 도구 (원인)",
    "content": ". | 객체 생성 및 관리 . | NewObject(), IsValid(), ConditionalBeginDestroy() | . | 라이프사이클 관리 . | PostInitProperties(), BeginDestroy(), AddToRoot() | . | 메타데이터 시스템 . | UPROPERTY(meta=(...)), UFUNCTION() 지정자 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-%EC%9B%90%EC%9D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#개발자가-직접-사용하는-도구-원인"
  },"291": {
    "doc": "UObject",
    "title": "UObject를 사용함으로써 자동으로 얻는 기능 (결과)",
    "content": ". | 리플렉션 . | UCLASS()로 등록한 클래스가 블루프린트/파이썬에서 자동 인식 | . | 가비지 컬렉션 . | UPROPERTY() 참조가 없어지면 GC가 자동으로 객체 제거 | . | 직렬화 . | SaveGame 지정 시 별도 코드 없이도 디스크에 저장 가능 | . | 에디터 통합 . | EditAnywhere 메타데이터로 자동으로 디테일 패널 생성 | . | . UObject 상속 계층 구조 . UObject (최상위 베이스 클래스) ├─ UActorComponent (액터 컴포넌트 베이스) │ ├─ USceneComponent (변환 기능 포함) │ │ ├─ UPrimitiveComponent (렌더링 가능) │ │ │ ├─ UMeshComponent (메시 기반) │ │ │ │ ├─ USkeletalMeshComponent (스켈레탈 메시) │ │ │ │ └─ UStaticMeshComponent (스태틱 메시) │ │ │ └─ ULightComponent (라이트 소스) │ │ └─ UCameraComponent (카메라) │ └─ UAudioComponent (사운드) ├─ AActor (월드 배치 객체) │ ├─ APawn (플레이어/AI 제어 가능) │ │ ├─ ACharacter (캐릭터 메시/이동 포함) │ │ └─ ADefaultPawn (기본 이동 기능) │ └─ AStaticMeshActor (스태틱 메시 배치) ├─ UDataAsset (데이터 전용 에셋) │ ├─ UPrimaryDataAsset (프라이머리 에셋 시스템) │ └─ UAnimSequence (애니메이션 데이터) ├─ UBlueprintFunctionLibrary (블루프린트 함수) │ ├─ UKismetSystemLibrary (시스템 유틸리티) │ └─ UKismetMathLibrary (수학 함수) └─ 기타 주요 클래스 ├─ UGameInstance (게임 인스턴스) ├─ UWorld (월드 컨텍스트) ├─ UUserWidget (UMG 위젯) └─ UMaterial (머티리얼) . 주의사항 . | 스택 할당 금지: 반드시 힙에 생성 (GC 관리 대상이어야 함) | 다중 상속 제한: UObject를 다중 상속할 때는 주의가 필요 (일반적으로 UInterface 사용) | 표준 C++ 타입과의 호환성: std::vector 등은 UPROPERTY()로 표시할 수 없으며, TArray를 사용함 | 아주 가벼운 데이터만 다룰 경우 USTRUCT를 권장 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%96%BB%EB%8A%94-%EA%B8%B0%EB%8A%A5-%EA%B2%B0%EA%B3%BC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject를-사용함으로써-자동으로-얻는-기능-결과"
  },"292": {
    "doc": "UObject",
    "title": "UObject의 내부 구조",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject의-내부-구조"
  },"293": {
    "doc": "UObject",
    "title": "UClass",
    "content": ". | UClass는 UObject 객체의 청사진 (UObject 타입에 대한 메타데이터와 구조 정보) | 프로퍼티의 이름/타입/위치(오프셋) . | (예: “고양이” 종류의 객체는 “고양이 클래스” DNA를 가짐) | . | 모든 UObject는 자신의 클래스 정보 (UClass)를 가리키는 ClassPrivate 포인터를 갖는다 | . class UClass : public UObject { TArray&lt;UProperty*&gt; Properties; // 프로퍼티 목록 (예: 체력, 공격력) TArray&lt;UFunction*&gt; Functions; // 함수 목록 (예: 점프(), 공격()) UClass* SuperClass; // 부모 클래스 (상속 관계) UObject* ClassDefaultObject; // CDO 포인터 // ... 기타 메타데이터 }; . 동작 예시 . UMyObject* Obj = NewObject&lt;UMyObject&gt;(); UClass* ObjClass = Obj-&gt;GetClass(); // 데이터 추출 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass"
  },"294": {
    "doc": "UObject",
    "title": "CDO (Class Default Object)",
    "content": ". | UClass가 관리하는 특별한 UObject 인스턴스 | 모든 UObject 인스턴스의 초기값을 제공하는 원본 . | (예: “고양이 클래스”의 기본 색상=검정, 기본 체력=100) | . | . | 클래스가 언리얼 모듈에 로드될 때 한 번만 생성됨 | . 내부 구조와 CDO의 관계 다이어그램 . | UClass : 모든 인스턴스가 공유하는 “청사진” | CDO : 인스턴스들이 참조하는 변하지 않는 원본 | UObject 인스턴스 : CDO의 기본값을 복사받아 생성된 개별 객체 | . CDO 접근 방법 . // CDO 얻기 UMyObject* Defaults = GetDefault&lt;UMyObject&gt;(); // 기본값 사용 예시 float DefaultHealth = Defaults-&gt;Health; // 에디터에서 설정한 Health 값 . CDO 실제 활용 . | 에디터 연동 (인스턴스 초기값 세팅) UPROPERTY(EditDefaultsOnly, Category=\"Settings\") float Health; // CDO에서만 편집 가능 . | 런타임 검사 if (MyObj-&gt;Health == GetDefault&lt;UMyObject&gt;()-&gt;Health) { UE_LOG(LogTemp, Warning, TEXT(\"체력이 기본값입니다!\")); } . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object"
  },"295": {
    "doc": "UObject",
    "title": "UObject 객체 생성 과정",
    "content": ". | UClass 로드 : 엔진 시작 시 UMyObject::StaticClass() 호출 → UClass 생성 | CDO 생성 : UClass 초기화 과정에서 GetDefaultObject()가 CDO 생성 | UObject 인스턴스 생성 : NewObject() 시 CDO의 프로퍼티 값을 복사 | . CDO vs 인스턴스 . | 비교 항목 | CDO | 일반 인스턴스 | . | 생성 시점 | 모듈 로드 시 1회 | NewObject() 호출 시 | . | 수정 가능성 | 에디터에서만 (런타임 X) | 런타임 자유롭게 변경 가능 | . | 메모리 위치 | 영구적 (게임 종료 시까지) | GC에 의해 삭제 가능 | . | 용도 | 기본값 템플릿 | 실제 게임 내 객체 | . | 에디터에서 Health=200 변경 → 모든 새 인스턴스는 Health=200으로 생성됨 | 기존 인스턴스는 영향 없음 (이미 생성된 객체는 독립적) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-객체-생성-과정"
  },"296": {
    "doc": "UObject",
    "title": "ObjectFlags",
    "content": "객체의 상태를 나타내는 비트 플래그 . enum EObjectFlags { RF_Public = 0x00000001, // 에디터에 노출 여부 RF_Transactional= 0x00002000, // Undo/Redo 지원 RF_Transient = 0x00004000, // 임시 객체 (저장 안 됨) // ... 30여 가지 플래그 }; . | UObject 인스턴스는 자신만의 ObjectFlags를 보유 | UClass는 UObject의 파생 클래스이므로, UClass도 자신만의 ObjectFlags를 가짐 | . ObjectFlags 내부 구조 다이어그램 . | UObject 인스턴스의 ObjectFlags: 개별 인스턴스의 런타임 상태 제어 . | 이 객체만의 상태 플래그 | . | UClass의 ObjectFlags: 클래스 전체의 정적 특성 정의, 추상 클래스 여부, 블루프린트 노출 . | 클래스 전체에 적용되는 플래그 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags"
  },"297": {
    "doc": "UObject",
    "title": "서브오브젝트 시스템 (Subobject System)",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-subobject-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-시스템-subobject-system"
  },"298": {
    "doc": "UObject",
    "title": "서브오브젝트 (컴포넌트)",
    "content": "다른 UObject (주로 AActor나 UActorComponent)에 종속된 자식 객체 . | “서브오브젝트”란 별도 클래스가 아니라, Outer 체계를 활용한 소유 관계/구조 . | ACharacter 내부의 USkeletalMeshComponent (캐릭터 메시) | UCameraComponent (플레이어 카메라) | 커스텀 로직을 가진 UMyCustomComponent | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-컴포넌트"
  },"299": {
    "doc": "UObject",
    "title": "서브오브젝트의 특징",
    "content": "| 특징 | 설명 | . | 생명주기 | 부모 종속 부모 객체가 파괴되면 함께 파괴됨 (GC 대상) | . | 생성 시점 제한 | 반드시 부모의 생성자에서 CreateDefaultSubobject()로 생성해야 함 | . | 자동 직렬화 | 부모와 함께 저장/로드됨 (에디터에서 편집 가능) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트의-특징"
  },"300": {
    "doc": "UObject",
    "title": "서브오브젝트 vs UObject",
    "content": "| 비교 항목 | 서브오브젝트 | 일반 UObject | . | 생성 방법 | CreateDefaultSubobject() | NewObject() | . | 생명주기 | 부모 종속 | 독립적 | . | 에디터 노출 | 부모의 디테일 패널에 자동 표시 | 별도 관리 필요 | . | 사용 사례 | 컴포넌트, 내부 부품 | 독립적인 데이터 에셋 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-vs-uobject",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-vs-uobject"
  },"301": {
    "doc": "UObject",
    "title": "서브오브젝트 구조",
    "content": "class UObject { protected: UObject* Outer; // 상위 객체 (서브오브젝트인 경우 소유자) FName Name; // 고유 이름 (Outer + Name으로 식별) UClass* Class; // 타입 정보 // 기타... }; . | Outer : 서브 오브젝트의 소유자 (예: USceneComponent의 Outer는 일반적으로 소유자 AActor) | Name : 같은 소유자를 가진 그룹에서 고유하게 가져야함 (중복 시 경고 발생) | 블루프린트: 에디터에서 Add Component 버튼으로 추가 가능 | AActor: Actor의 경우 추가로 Components 배열 사용 | . UClass와의 관계 . | UClass는 서브오브젝트 목록을 직접 관리하지 않음 | UPROPERTY 메타데이터를 통해 리플렉션 및 자동 탐색이 이루어짐 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-구조"
  },"302": {
    "doc": "UObject",
    "title": "서브오브젝트 탐색 방식",
    "content": "1. 리플렉션 기반 탐색 (UPROPERTY) . | UPROPERTY()로 표시된 멤버만 탐색 가능 UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* Comp; // 서브오브젝트는 UPROPERTY로 노출됨 }; . | . 2. Outer 체인 탐색 . | AActor가 아닌 일반 UObject 서브오브젝트를 찾을 때 사용 | . // 모든 서브오브젝트 순회 (예시 코드) TArray&lt;UObject*&gt; Subobjects; GetObjectsWithOuter(MyActor, Subobjects); // MyActor를 Outer로 가진 객체 찾기 // 결과 출력 for (UObject* Obj : Subobjects) { UE_LOG(LogTemp, Warning, TEXT(\"Subobject: %s\"), *Obj-&gt;GetName()); } . 3. AActor 특수 처리 . | AActor만 Components 배열을 명시적으로 별도 관리 | . class AActor : public UObject { TArray&lt;UActorComponent*&gt; Components; // 서브오브젝트 명시적 관리 }; // FindComponentByClass 활용 (최적화된 탐색) UMyComponent* MyComp = FindComponentByClass&lt;UMyComponent&gt;(); . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%83%90%EC%83%89-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-탐색-방식"
  },"303": {
    "doc": "UObject",
    "title": "서브오브젝트 생성 및 과정",
    "content": "// MyActor.h UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* MyComp; // 서브오브젝트 포인터 AMyActor() { // 생성자에서 서브오브젝트 생성 MyComp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"MyComp\")); } }; . | 생성자 호출 . | 반드시 부모 객체의 생성자 내에서 호출 . | 예외: UActorComponent는 InitializeComponent()에서 추가 초기화 | . | . | 메모리 할당 . | 엔진은 UMyComponent 인스턴스를 생성하고, Outer를 AMyActor로 설정 | . | 이름 등록 . | TEXT(“MyComp”)를 이름으로 지정, 중복 검사 수행 | . | 리플렉션 연동 . | UPROPERTY가 없어도 서브오브젝트 생성 (에디터에서 수정 불가. 블루 프린트 노출 X) | UPROPERTY가 있으면 디테일 패널에 노출 | . | Actor에 등록 . | AActor 전용으로 Actor와 연관된 오브젝트가 아닐 경우 패스됨 | AActor의 경우 Components 배열에 자동 추가 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-생성-및-과정"
  },"304": {
    "doc": "UObject",
    "title": "서브오브젝트 다이어그램",
    "content": ". | 실선: 명시적 참조 (AActor의 Components 배열) | 점선: 암시적 참조 (Outer 포인터) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-다이어그램"
  },"305": {
    "doc": "Macro",
    "title": "Macro",
    "content": ". | 언리얼 전용 메타데이터 매크로는 코드 재사용성과 생산성을 높이기 위한 강력한 기능을 제공한다 | 함수나 변수마다 위에 매크로를 붙이지 않으면 언리얼 엔진의 리플렉션 시스템에 등록되지 않는다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/"
  },"306": {
    "doc": "Macro",
    "title": "매크로의 주요 기능",
    "content": ". | 리플렉션 시스템 통합 : 런타임에 클래스 정보 조회 가능 | 블루프린트 연동 : C++과 블루프린트 간의 상호 운용성 제공 | 직렬화 지원 : 객체 상태 저장 및 로드 가능 | 네트워크 복제 : 멀티플레이어 게임에서 변수 및 함수 복제 | 가비지 컬렉션 : UObject 파생 클래스의 자동 메모리 관리 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로의-주요-기능"
  },"307": {
    "doc": "Macro",
    "title": "빌드 시스템과 매크로 연동",
    "content": "1. 빌드 시스템 기본 구조 . | UBT(Unreal Build Tool) . | 모든 빌드 명령을 관리/자동화. | 각종 .Build.cs, .Target.cs 파일을 해석하여 모듈, 의존성, 플랫폼, 설정에 따라 빌드를 분기 | . | UnrealHeaderTool(UHT) . | 언리얼 리플렉션을 위해 추가적으로 동작하는 툴 | 리플렉션 매크로(UCLASS, UPROPERTY, 등)가 붙은 소스코드를 파싱 | 메타데이터와 Glue 코드(C++에선 자동 생성된 코드)를 생성 | . | . 2. 매크로와 빌드 파이프라인 . | UCLASS 등을 통해 매크로를 사용한 코드 작성 | UBT : 빌드 시작 | UHT : 헤더 파싱 &amp; Glue 코드(메타데이터) 생성 . | *.generated.h 를 반드시 #include로 포함해야 함 | 이 파일이 누락될 경우 컴파일 에러 발생 | . | C++ 컴파일러가 코드 + 자동코드 컴파일 | 런타임: 리플렉션 시스템 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%97%B0%EB%8F%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#빌드-시스템과-매크로-연동"
  },"308": {
    "doc": "Macro",
    "title": "UHT (UnrealHeaderTool) 의 작동 과정",
    "content": ". | 소스 코드 스캐닝 . | UHT는 .h 헤더 파일을 파싱하여 UCLASS, USTRUCT, UFUNCTION, UPROPERTY 등의 매크로가 포함된 특수 주석을 검색 | 일반 C++ 파서와 달리, 언리얼 특수 매크로를 이해하는 커스텀 파서를 사용 | . | 메타데이터 추출 . | 매크로에 지정된 속성들(예: BlueprintCallable, EditAnywhere 등)을 분석 | 클래스 계층 구조, 프로퍼티 타입, 함수 시그니처 등의 정보를 추출 | . | 리플렉션 코드 생성 . | GENERATED_BODY() 매크로 위치에 대체될 실제 코드를 생성 | 생성되는 파일들은 주로 Intermediate/Build 폴더에 저장 | 주요 생성 파일: . | [ModuleName].generated.h | [ClassName].generated.cpp | . | . | 직렬화/리플렉션 시스템 통합 . | UObject 시스템이 런타임에 클래스 정보를 조회할 수 있도록 함 | 블루프린트와의 상호 운용을 위한 바인딩 코드를 생성 | . | . 생성되는 코드 예시 . | 원본 UCLASS(Blueprintable) class AMyActor : public AActor { GENERATED_BODY() UPROPERTY(EditAnywhere) float Health; }; . | UHT가 생성하는 코드 (간소화 된 예) | . // AMyActor.generated.h #define AMyActor_Extra_Code \\ public: \\ static UClass* StaticClass(); \\ virtual UClass* GetClass() const override; \\ static void __StaticDependenciesAssets(TArray&lt;FAssetData&gt;&amp; OutAssets); \\ private: \\ static UClass* PrivateStaticClass; \\ public: \\ DECLARE_CLASS(AMyActor, AActor, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(\"/Script/MyGame\"), NO_API) \\ DECLARE_REPLICATION_FRAGMENT(AMyActor) \\ enum {IsIntrinsic=COMPILED_IN_INTRINSIC}; // 리플렉션 데이터 구조체 static const FClassFunctionLinkInfo Z_Construct_UClass_AMyActor_Functions[]; static const FPropertyParamsBase* const Z_Construct_UClass_AMyActor_Properties[]; . UHT가 생성하는 정보 . | 클래스 등록용 StaticRegisterNatives | UPROPERTY 메타정보 배열 | 블루프린트용 함수 등록 | C++에서 런타임에 사용할 수 있는 메타데이터 구조체 | 에디터/런타임용 데이터 구조 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-의-작동-과정"
  },"309": {
    "doc": "Macro",
    "title": "UHT 처리의 특징",
    "content": ". | 템플릿 기반 코드 생성 . | 단순 복사-붙여넣기가 아닌, 템플릿을 기반으로 상황에 맞는 최적화된 코드 생성 | . | 의존성 분석 . | 클래스 간의 관계를 분석하여 올바른 초기화 순서 보장 | . | 크로스-레퍼런스 해결 . | 모듈 간 상호 참조 문제를 해결하기 위한 전방 선언(forward declaration) 생성 | . | 빌드 시스템 통합 . | 생성된 코드가 실제 컴파일 과정에 올바르게 포함되도록 Makefile/UBT 스크립트 조정 | . | 에러 체크 . | 잘못된 매크로 사용이나 충돌하는 설정을 빌드 전에 검출 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-%EC%B2%98%EB%A6%AC%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-처리의-특징"
  },"310": {
    "doc": "Macro",
    "title": "매크로 카테고리",
    "content": "| 카테고리 | 주요 매크로 | 용도 | . | 코어 리플렉션 | UCLASS, USTRUCT, UENUM, UPROPERTY, UFUNCTION, GENERATED_BODY | 언리얼 리플렉션 시스템 등록 | . | 네트워크 복제 | Replicated, ReplicatedUsing, DOREPLIFETIME, RPC 관련 매크로 | 멀티플레이어 게임에서 변수/함수 동기화 | . | 메모리 관리 | UPROPERTY(), UObject 관련 매크로 | 가비지 컬렉션 및 메모리 안전성 보장 | . | 에디터 연동 | EditAnywhere, VisibleDefaultsOnly, BlueprintReadOnly, Category | 에디터 노출 및 편집 제어 | . | 플랫폼 특화 | PLATFORM_WINDOWS, PLATFORM_ANDROID, WITH_EDITOR, WITH_SERVER_CODE | 플랫폼/빌드 설정별 코드 분기 | . | 디버깅/로깅 | UE_LOG, UE_CHECK, UE_ASSERT, ensure(), check() | 런타임 검증 및 로깅 | . | 성능 최적화 | UE_INLINE, UE_NOINLINE, FORCEINLINE, CORE_API | 인라인 제어 및 DLL 인터페이스 정의 | . | 메타데이터 | UMETA, DisplayName, ClampMin, ToolTip | 추가 속성 지정 | . | 모듈/플러그인 | IMPLEMENT_MODULE, IMPLEMENT_GAME_MODULE, PLUGIN_API | 모듈 초기화 및 플러그인 시스템 통합 | . | 최신 기능 | UE_DEPRECATED, UE_NODISCARD, TOptional, TSoftObjectPtr 관련 매크로 | 현대적 C++ 기능 지원 | . 참고 링크 . | 빌드 파이프라인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로-카테고리"
  },"311": {
    "doc": "Math",
    "title": "Math",
    "content": " ",
    "url": "/docs/Math/",
    
    "relUrl": "/docs/Math/"
  },"312": {
    "doc": "Create Custom Editor Tools",
    "title": "Create Custom Editor Tools",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . 참고 링크 . | AssetRegistry | EditorUtilityLibrary | FMessageDialog | SNotificationList | FSlateNotificationManager | ContentBrowser | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/"
  },"313": {
    "doc": "Computer architecture",
    "title": "Computer architecture",
    "content": " ",
    "url": "/docs/Computer%20architecture/",
    
    "relUrl": "/docs/Computer%20architecture/"
  },"314": {
    "doc": "GPU Architecture",
    "title": "GPU Architecture",
    "content": "GPU에서 실행되는 애플리케이션 프로그램을 준비할 때 GPU 하드웨어 설계의 주요 기능을 이해하고 CPU와의 유사점과 차이점을 파악하고자 한다. | 참고링크 Conrnell Virtual Workshop | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/"
  },"315": {
    "doc": "Linear Algebra",
    "title": "Linear Algebra",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/",
    
    "relUrl": "/docs/Math/linear%20algebra/"
  },"316": {
    "doc": "Material",
    "title": "Material",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/"
  },"317": {
    "doc": "Unreal Engine 5",
    "title": "Unreal Engine 5",
    "content": "참고하면 좋은 링크 . | UnrealEngine c++ Guide | blueprints vs c++ | Exploring Unreal’s physics framework | Unreal Engine UI Tutorials | Unreal Engine C++ API Reference | UE Classes API | . ",
    "url": "/docs/Unreal%20Engine%205/",
    
    "relUrl": "/docs/Unreal%20Engine%205/"
  },"318": {
    "doc": "Home",
    "title": "Home",
    "content": ". ✨2025-05-02 . | 깃허브 블로그 개설 | 커스텀 설정 추가 (custom.scss) . | site-title font : Darumadrop One 으로 변경 | .nav-list-link : color 수정 | . | . ✨2025-05-03 . | 커스텀 설정 추가 . | 마크다운 font : Noto Sans KR 로 변경 | 인용 블록 : border-radius 추가, 색상 변경 | 코드 블록 : font Rubik 으로 변경, border-radius 추가, Rouge github 테마로 폰트 색상 변경 | . | . ✨2025-05-04 . | 커스텀 설정 추가 . | 테이블 : font IBM Plex Sans KR 로 변경, 라인 색상 변경, 사이드 라인 제거 | 링크 버튼 : btn-purple color 변경 | 인용 블록 종류 추가 : warning, highlight, note, important, new | . | . ✨2025-05-06 . | 로고 추가 | 푸터 추가 | . ",
    "url": "/",
    
    "relUrl": "/"
  }
}
