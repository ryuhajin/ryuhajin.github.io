{"0": {
    "doc": "1. Creating a Framework and Window",
    "title": "1. Creating a Framework and Window",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html"
  },"1": {
    "doc": "1. Creating a Framework and Window",
    "title": "프레임 워크 요소",
    "content": ". | main.cpp : 응용 프로그램의 진입점을 처리하기 위해 WinMain 함수 . | 시스템 클래스 포함 | . | systemclass : inputclass, applicaionclass 포함 . | inputclass : 사용자 입력 처리 | applicationclass : 그래픽 코드를 처리하여 렌더링 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#프레임-워크-요소"
  },"2": {
    "doc": "1. Creating a Framework and Window",
    "title": "KEYWORD NOTE",
    "content": "systemclass 소스 코드에서 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#keyword-note"
  },"3": {
    "doc": "1. Creating a Framework and Window",
    "title": "MSG structure",
    "content": "Windows 운영체제에서 발생하는 다양한 이벤트 정보를 담는 구조체 . | 사용자가 키보드를 누르거나, 마우스를 움직이거나, 창의 크기를 조절하는 등의 모든 행위는 | Windows에 의해 메시지로 변환되어 해당 애플리케이션의 메시지 큐에 쌓임 | . MSG 구조체 정보 . | hwnd: 메시지가 발생한 Window의 핸들(고유 식별자) | message: 어떤 종류의 메시지인지 나타내는 정수 값 (예: WM_KEYDOWN, WM_MOUSEMOVE, WM_QUIT) | wParam, lparam: 메시지에 대한 추가적인 정보 . | 키보드 메시지 : 어떤 키가 눌렸는지 | 마우스 메시지 : 마우스의 좌표가 무엇인지 | . | time: 메시지가 발생한 시간 | pt: 메시지 발생 시점의 마우스 커서 위치 (화면 좌표) | . 메시지 루프는 메시지 큐에서 메시지를 하나씩 커내와서 처리하는 역할을 함 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#msg-structure",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#msg-structure"
  },"4": {
    "doc": "1. Creating a Framework and Window",
    "title": "Message Queue",
    "content": "메시지 큐 관리 . PeekMessage . 메시지 큐에 메시지가 있는지 확인 . | PeekMessage는 메시지가 없는 동안에도 Frame() 함수를 호출하여 게임 로직이나 렌더링을 계속해서 실행할 수 있음 | 실시간으로 화면이 변해야 하는 게임이나 그래픽 프로그램에서 필수적 | PM_REMOVE 옵션은 메시지를 확인한 후 큐에서 제거하라는 의미 | . GetMessage와 다른점? : GetMessage는 메시지가 올 때까지 프로그램의 실행을 멈추고 기다림 . TranslateMessage . 키보드 입력 메시지를 가공 . | WM_KEYDOWN (키가 눌림)과 WM_KEYUP (키가 떨어짐) 같은 저수준 메시지가 발생했을 때, 이를 조합하여 WM_CHAR (문자 입력) 메시지를 생성 | . | 예 : 사용자가 ‘Shift’ 키를 누른 상태에서 ‘a’ 키를 누름 | TranslateMessage는 이를 해석해서 대문자 ‘A’에 해당하는 WM_CHAR 메시지를 만든다 | . DispatchMessage . 메시지를 실제 창의 처리 함수로 “보내는(dispatch)” 역할 . | msg 구조체에 담긴 hwnd (창 핸들)를 보고, 해당 창에 등록된 윈도우 프로시저(WndProc) 함수를 호출함 | WndProc 함수는 DispatchMessage에 의해 호출되고, WndProc은 메시지 처리 핸들링을 하게됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#message-queue",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#message-queue"
  },"5": {
    "doc": "1. Creating a Framework and Window",
    "title": "VK_ESCAPE",
    "content": "Virtual-Key Code의 약자로, 키보드의 물리적인 키에 대한 가상 코드 . | 가상 키 코드 (VK) | 키보드 키 | 설명 | . | VK_ESCAPE | Esc | 이스케이프 키 | . | VK_RETURN | Enter | 엔터 키 | . | VK_SPACE | Spacebar | 스페이스 바 | . | VK_TAB | Tab | 탭 키 | . | VK_SHIFT | Shift | Shift 키 (왼쪽, 오른쪽 구분 없음) | . | VK_LSHIFT | Left Shift | 왼쪽 Shift 키 | . | VK_RSHIFT | Right Shift | 오른쪽 Shift 키 | . | VK_CONTROL | Ctrl | Ctrl 키 (왼쪽, 오른쪽 구분 없음) | . | VK_LCONTROL | Left Ctrl | 왼쪽 Ctrl 키 | . | VK_RCONTROL | Right Ctrl | 오른쪽 Ctrl 키 | . | VK_MENU | Alt | Alt 키 (메뉴 키, 왼쪽/오른쪽 구분 없음) | . | VK_LMENU | Left Alt | 왼쪽 Alt 키 | . | VK_RMENU | Right Alt | 오른쪽 Alt 키 | . | VK_CAPITAL | Caps Lock | Caps Lock 키 | . | VK_BACK | Backspace | 백스페이스 키 | . | VK_DELETE | Delete | Delete 키 | . | VK_UP | ↑ (Up Arrow) | 위쪽 화살표 키 | . | VK_DOWN | ↓ (Down Arrow) | 아래쪽 화살표 키 | . | VK_LEFT | ← (Left Arrow) | 왼쪽 화살표 키 | . | VK_RIGHT | → (Right Arrow) | 오른쪽 화살표 키 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#vk_escape",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#vk_escape"
  },"6": {
    "doc": "1. Creating a Framework and Window",
    "title": "DefWindowProc()",
    "content": "Windows가 제공하는 기본 메시지 처리 함수 . | 메세지 핸들러에서 WM_KEYDOWN과 WM_KEYUP처럼 내가 특별히 처리하고 싶은 메시지만을 골라서 처리함 | 그 외에 우리가 신경 쓰지 않는 나머지 모든 메시지들은 DefWindowProc 함수을 통해 전달 | . DefWindowProc 함수가 창 이동, 크기 조절, 최소화/최대화 등과 같은 기본적인 창의 동작들을 알아서 처리 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#defwindowproc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#defwindowproc"
  },"7": {
    "doc": "1. Creating a Framework and Window",
    "title": "GetSystemMetrics(SM_CXSCREEN)",
    "content": "시스템(주로 디스플레이)의 다양한 크기나 설정 값들을 얻어오는 함수 . | SM_CXSCREEN . | “System Metrics, C(ount of) X, SCREEN” | 주 모니터 화면의 너비(width)를 픽셀 단위로 반환 | . | SM_CYSCREEN . | 주 모니터 화면의 높이(height)를 픽셀 단위로 반환 | . | . GetSystemMetrics(SM_CXSCREEN) 함수를 통해 현재 사용자의 모니터 해상도가 얼마인지를 알 수 있음 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#getsystemmetricssm_cxscreen",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#getsystemmetricssm_cxscreen"
  },"8": {
    "doc": "1. Creating a Framework and Window",
    "title": "HRESULT",
    "content": "COM(Component Object Model) 에서 사용되는 표준 반환 코드 타입 . | “Handle to RESULT” 의 약자 | 함수나 메서드의 실행 결과(성공, 실패, 추가 정보)를 통일된 방식으로 반환하기 위해 설계 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#hresult",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#hresult"
  },"9": {
    "doc": "1. Creating a Framework and Window",
    "title": "특징",
    "content": ". | 성공/실패 판단: SUCCEEDED()와 FAILED() 매크로로 쉽게 확인 가능 | 풍부한 정보: 오류의 출처, 심각도, 구체적인 원인 포함 | 표준화: 모든 COM 인터페이스에서 일관되게 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#특징"
  },"10": {
    "doc": "1. Creating a Framework and Window",
    "title": "구조",
    "content": "32비트(4바이트) 크기의 부호 있는 정수(long) . 31 30 29 28 27 26 25 ... 16 15 ... 0 +---+---+---+---+---+---+-------+-----------+ | S | R | C | N | X | Facility | Code | +---+---+---+---+---+---+-------+-----------+ . | S (1비트): 심각도 비트 (0 = 성공, 1 = 실패) | R, C, N, X: 예약된 비트 (일반적으로 0) | Facility (11비트): 오류가 발생한 그룹 또는 기능을 나타내는 11비트 코드 | Code (16비트): 오류의 구체적인 원인을 나타내는 16비트 코드 | . 코드 예시 . HRESULT hr = SomeComFunction(); if (SUCCEEDED(hr)) { // 성공 처리 std::cout &lt;&lt; \"작업 성공!\" &lt;&lt; std::endl; } else { // 실패 처리 std::cerr &lt;&lt; \"오류 발생: 0x\" &lt;&lt; std::hex &lt;&lt; hr &lt;&lt; std::endl; // 구체적인 오류 처리 if (hr == E_INVALIDARG) { std::cerr &lt;&lt; \"잘못된 인수입니다.\" &lt;&lt; std::endl; } else if (hr == E_OUTOFMEMORY) { std::cerr &lt;&lt; \"메모리가 부족합니다.\" &lt;&lt; std::endl; } } . 링크 . | Structure of COM Error Codes | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#구조"
  },"11": {
    "doc": "1. Creating a Framework and Window",
    "title": "LRESULT",
    "content": "윈도우 메시지 처리를 위한 반환 값 . WindowProc 메시지를 처리한 후 운영체제(Windows)에게 결과를 돌려줄 때 사용 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#lresult",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#lresult"
  },"12": {
    "doc": "1. Creating a Framework and Window",
    "title": "특징",
    "content": ". | 값 자체로는 성공/실패를 알 수 없고, 문맥에 따라 해석해야 함 | 메시지 종류(WM_XXX)에 따라 의미가 완전히 달라짐 | WindowProc 함수 내부에서 메시지를 처리하고 반환 | . 코드 예시 . LRESULT CALLBACK WndProc(HWND hwnd, UINT umessage, WPARAM wparam, LPARAM lparam) { switch (umessage) { // 창 파괴 확인 case WM_DESTROY: { PostQuitMessage(0); return 0; } // 창 닫히는지 확인 case WM_CLOSE: { PostQuitMessage(0); return 0; } // 다른 모든 메시지는 시스템 클래스의 메시지 핸들러로 전달 default: { return ApplicationHandle-&gt;MessageHandler(hwnd, umessage, wparam, lparam); } } } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#특징-1"
  },"13": {
    "doc": "1. Creating a Framework and Window",
    "title": "CALLBACK",
    "content": "이 함수는 특별한 규칙에 따라 호출되어야 한다고 컴파일러에게 알려주는 지시어(매크로) . #define CALLBACK __stdcall . | CALLBACK은 내부적으로 __stdcall 이라는 키워드로 정의 | 함수를 호출하고 인자를 전달하는 방식(호출 규약)을 지정 | . 호출 규약이 왜 필요할까? . 함수가 호출될 때, 컴퓨터 내부에서는 다음과 같은 일이 일어남 . | 함수에 전달할 인자(파라미터)들을 메모리(스택)에 순서대로 쌓음 | 함수의 코드가 있는 곳으로 점프하여 실행 | 함수 실행이 끝나면, 스택에 쌓아두었던 인자들을 정리하고 원래 위치로 돌아옴 | . 스택을 누가 정리할 것인가? 에 따라 호출 규약이 나뉨 . | __cdecl (C/C++의 기본 방식) : 함수를 호출한 쪽(Caller)이 스택을 정리 | __stdcall (Windows API의 표준 방식) : 함수 자신(Callee)이 스택을 정리 | . CALLBACK(__stdcall)을 쓰는 이유 . | WndProc의 호출자는 Windows 운영체제 | 내가 WndProc을 직접 호출하지 않았음 | CALLBACK(__stdcall) 규약에 따라, 호출당한 함수인 WndProc이 스스로 스택을 정리할 책임을 가짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#callback",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/1.%20Creating%20a%20Framework%20and%20Window.html#callback"
  },"14": {
    "doc": "1. Dot products",
    "title": "1. Dot products",
    "content": "벡터의 내적 . 두 벡터의 내적은 행렬 곱셈을 확장한 개념으로, 각 성분을 곱해 모두 더한 값이다 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html"
  },"15": {
    "doc": "1. Dot products",
    "title": "2차원에서의 내적",
    "content": "두 2차원 벡터 \\(\\vec{u} = (u_1,u_2), \\ \\vec{v} = (v_1, v_2)\\) 의 내적은 대응하는 성분끼리 곱한 뒤 더해 정의함 . \\[\\vec{u}\\cdot\\vec{v} = \\begin{bmatrix}u_{1}&amp;u_{2}\\end{bmatrix} \\begin{bmatrix}v_{1}\\\\v_{2}\\end{bmatrix} = u_{1}v_{1}+u_{2}v_{2}\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#2%EC%B0%A8%EC%9B%90%EC%97%90%EC%84%9C%EC%9D%98-%EB%82%B4%EC%A0%81",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#2차원에서의-내적"
  },"16": {
    "doc": "1. Dot products",
    "title": "벡터의 길이와  내적",
    "content": ". | 2차원 벡터 \\(\\vec{u} = (u_1, u_2)\\) 의 길이는 피타고라스 정리로 구할 수 있음 | . \\[\\lVert\\vec{u}\\rVert = \\sqrt{u_{1}^{2}+u_{2}^{2}}\\] . | 벡터를 자기 자신과 내적하면 다음과 같음 | . \\[\\vec{u} \\cdot \\vec{u} = \\begin{bmatrix} u_1 u_2\\end{bmatrix} \\cdot \\begin{bmatrix} u_1 \\\\ u_2\\end{bmatrix} = u_1u_1 + u_2u_2 = u_{1}^{2}+u_{2}^{2}\\] . | \\(\\vec{u} \\cdot \\vec{u} = u_{1}^{2}+u_{2}^{2}\\) 는 길이 공식의 루트 아래에 있는 값이기도 하다 | . \\[(\\lVert\\vec{u}\\rVert)^2 = \\left(\\Large{\\sqrt{u_{1}^{2}+u_{2}^{2}}}\\right)^2\\] . \\[\\lVert\\vec{u}\\rVert^{2} = u_{1}^{2}+u_{2}^{2}\\] . | \\(u_{1}^{2}+u_{2}^{2}\\) 은 \\(\\vec{u} \\cdot \\vec{u}\\) 로 대체 할 수 있다 | . \\[\\lVert\\vec{u}\\rVert^{2} = \\vec{u} \\cdot \\vec{u}\\] . 즉, 벡터 길이의 제곱은 벡터를 자기 자신과 내적한 값과 같다 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#%EB%B2%A1%ED%84%B0%EC%9D%98-%EA%B8%B8%EC%9D%B4%EC%99%80--%EB%82%B4%EC%A0%81",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#벡터의-길이와--내적"
  },"17": {
    "doc": "1. Dot products",
    "title": "내적의 성질",
    "content": ". | 교환 법칙 | . \\[\\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u}\\] . | 분배 법칙 | . \\[(\\vec{u} + \\vec{v}) \\cdot \\vec{w} = \\vec{u} \\cdot \\vec{w} + \\vec{v} \\cdot \\vec{w}\\] \\[(\\vec{u} - \\vec{v}) \\cdot \\vec{w} = \\vec{u} \\cdot \\vec{w} - \\vec{v} \\cdot \\vec{w}\\] . | 스칼라곱 | . \\[(c \\vec{u}) \\cdot \\vec{v} = c(\\vec{v} \\cdot \\vec{u})\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#%EB%82%B4%EC%A0%81%EC%9D%98-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#내적의-성질"
  },"18": {
    "doc": "1. Dot products",
    "title": "내적 계산",
    "content": "\\[\\vec{u} = (3, -2), \\ \\vec{v} = (-1 ,4), \\ \\vec{w} = (0, 5)\\] \\[\\vec{w} \\cdot (3\\vec{u} + 2\\vec{v})\\] . | 스칼라 곱 | . \\[3\\vec{u}=3(3,-2)=(9,-6) \\\\ 2\\vec{v}=2(-1,4)=(-2,8)\\] . | 벡터 합 | . \\[3\\vec{u}+2\\vec{v}=(9,-6)+(-2,8)=(7,2)\\] . | 내적 계산 | . \\[\\vec{w}\\cdot(3\\vec{u}+2\\vec{v}) = (0,5)\\cdot(7,2) \\\\ = 0\\cdot7 + 5\\cdot2 \\\\ = 10\\] . 참고하면 좋은 링크 . | 행벡터의 의미와 벡터의 내적 | 내적을 구하는 3가지 방법 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#%EB%82%B4%EC%A0%81-%EA%B3%84%EC%82%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/1.%20Dot%20products.html#내적-계산"
  },"19": {
    "doc": "1. Element Array",
    "title": "1. Element Array",
    "content": "인덱스 버퍼(Index Buffer, Element Buffer)라고도 하며, GPU에서 삼각형(또는 기타 프리미티브) 형태로 모델 데이터를 효율적으로 전달하기 위한 방식 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html"
  },"20": {
    "doc": "1. Element Array",
    "title": "Vertex Array",
    "content": "모델링의 버텍스 데이터가 연속적으로 저장되어 있는 배열 . | 인덱스 : n번째 버텍스 (예: 0번째 인덱스 -&gt; 0번째 버텍스) | 값 : 버텍스의 x,y,x 좌표 | . // Vertex Array (각각 [x, y, z] 좌표) float VertexIndices[][3] = { {1, 1, 1}, // 0 번째 버텍스 {1, 1, -1}, // 1 번째 버텍스 {1, -1, 1}, // 2 번째 버텍스 {1, -1, -1}, // 3 ... {-1, 1, 1}, // 4 {-1, 1, -1}, // 5 {-1, -1, 1}, // 6 {-1, -1, -1} // 7 }; . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#vertex-array",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#vertex-array"
  },"21": {
    "doc": "1. Element Array",
    "title": "Element Array",
    "content": "버텍스 배열에서 삼각형을 어떻게 조합할지에 대한 인덱스 정보를 저장한 배열 . | 인덱스 : n번째 삼각형 (예: 0번째 인덱스 -&gt; n번째 버텍스) | 값 : n번째 삼각형을 정의하는 Vertex Array 인덱스 집합 . | 예: {0, 1, 2} = Vertex Array의 [0], [1], [2] 버텍스를 사용한 삼각형 | . | . // Element Array (삼각형을 이루는 버텍스 인덱스) unsigned int Triangle[][3] = { {0, 1, 2}, // Vertex Array의 [0], [1], [2] 버텍스를 사용한 삼각형 {2, 1, 3}, // ... {4, 6, 5}, {5, 6, 7} }; . ❓ 버텍스 배열과 삼각형 배열을 따로 분리하는 이유? . | 버텍스 중복 저장 방지 : 3D 모델에서 여러 삼각형이 동일한 버텍스를 공유하는 경우가 매우 많음 | 각 삼각형마다 중복된 좌표 데이터를 저장하지 않고, 인덱스만 다르게 참조 . | 메모리 효율성과 캐싱 효율을 높임 | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#element-array",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#element-array"
  },"22": {
    "doc": "1. Element Array",
    "title": "동작 과정",
    "content": " ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#동작-과정"
  },"23": {
    "doc": "1. Element Array",
    "title": "1. 모델링 파일 파싱",
    "content": ". | 애플리케이션/엔진에서 모델링 파일 로드 | 버텍스 좌표, 인덱스 정보 등을 메모리로 읽어옴 | . 모델링 파일 예시 (.obj) . | 모델링 파일의 버텍스 좌표는 모델 로컬 공간 기준으로 저장됨 . | 예: 모델의 한 꼭짓점 (1,1,1) 은 모델의 중심 (pivot)에서 x,y,z로 각각 1만큼 떨어진 지점에 위치 | . | 1-based 인덱스 : 인덱스가 1부터 시작 . | 실제 GPU에선 0-based로 맞춰서 변환 필요 | . | . v 1.000000 1.000000 1.000000 // 버텍스 1 (x, y, z) v 1.000000 1.000000 -1.000000 // 버텍스 2 v 1.000000 -1.000000 1.000000 // 버텍스 3 v 1.000000 -1.000000 -1.000000 // 버텍스 4 ... f 1 2 3 // face (1,2,3번 버텍스가 삼각형을 이룸) f 3 2 4 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%ED%8C%8C%EC%9D%BC-%ED%8C%8C%EC%8B%B1",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#1-모델링-파일-파싱"
  },"24": {
    "doc": "1. Element Array",
    "title": "2. 데이터 정렬",
    "content": "파싱한 값을 버텍스 배열, 삼각형 배열(Element Array)로 정렬/변환 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EB%A0%AC",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#2-데이터-정렬"
  },"25": {
    "doc": "1. Element Array",
    "title": "3. GPU 업로드",
    "content": "완료된 버텍스 배열과 삼각형 배열을 GPU에 업로드 . | GPU는 이 데이터를 바탕으로 렌더링 파이프라인을 시작 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#3-gpu-%EC%97%85%EB%A1%9C%EB%93%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#3-gpu-업로드"
  },"26": {
    "doc": "1. GPU 특성",
    "title": "1. GPU 특성",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html"
  },"27": {
    "doc": "1. GPU 특성",
    "title": "1. Design: GPU vs. CPU",
    "content": ". GPU는 원래 그래픽 렌더링을 위해 설계되었다. 3D 객체를 구성하는 수천 개의 독립적인 폴리곤을 셰이딩, 텍스처링, 렌더링하는 데 매우 효과적이다. | Core (녹색 영역) : 명령어 실행 및 계산 처리 (연산, 레지스터 조작 등) | Control (금색 영역) : 명령어 해석 및 실행 제어 (제어 신호 생성, 흐름 제어 등) | L1 Cache (보라 영역) : 데이터 / 명령어 저장 (코어에 가장 가까운 고속 캐시 메모리) | L2/L3 chache (파랑 영역) : L1 보다 느리지만 더 큼. L3는 여러 코어 간 공유되는 경우가 많음 | . ☑️ 위 그림으로 알수 있는 점 . | CPU는 GPU만큼 산술 논리 장치나 부동 소수점 장치가 많지 않다. (Core 녹색 영역) . | 하지만 CPU 코어의 ALU와 FPU는 더 많은 기능을 갖추고 있다. | . | CPU는 GPU보다 캐시 메모리가 더 많다. | GPU는 병렬화 될 수 있는 워크로드를 위해 설계되었다. | core의 각 행마다 Control이 하나씩 있는 것으로 나타난다. | . | . | 특징 | CPU | GPU | . | 목적 | 범용 컴퓨팅 (다양한 작업 처리) | 병렬 컴퓨팅 (그래픽 및 대량 데이터 처리) | . | 코어 수 | 적음 (일반적으로 2~64개) | 매우 많음 (수백 ~ 수천 개의 코어) | . | 작업 유형 | 직렬 처리에 최적화 | 병렬 처리에 최적화 | . | 사용 사례 | 운영체제, 일반 소프트웨어, 논리 연산 | 그래픽 렌더링, 머신러닝, 과학 계산 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu"
  },"28": {
    "doc": "1. GPU 특성",
    "title": "2. Performance: GPU vs. CPU",
    "content": ". 아래의 그림은 연산 능력을 초당 수십억 번의 부동 소수점 연산( Gflop/s )으로 측정하여 보여준다. | Single Precision (단정밀도) : 부동 소수점 수의 32비트 표현 | Double Percision (배정밀도) : 부동 소수점 수의 64비트 표현 | . 단정밀도는 배정밀도보다 두 배 빠르게 처리될 수 있는 경우가 많다. ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu"
  },"29": {
    "doc": "1. GPU 특성",
    "title": "3. Threads, Cores 재정의",
    "content": ". GPU는 그래픽 파이프라인의 두 가지 핵심 속성을 통해 속도가 가속화된다. | 렌더링은 일반적으로 많은 독립적인 오브젝트 (예:표면을 근사화하는 작은 삼각형 메시)로 구성된다. | 각 오브젝트를 렌더링하는데 필요한 단계의 순서는 기본적으로 모든 오브젝트에 동일하다. | 따라서 계산 단계가 모든 오브젝트에 대해 한번번에 병렬로 수행될 수 있다. | . | . GPU와 CPU 간의 용어 비교 . | GPU 용어 | GPU에서의 간단한 정의 | CPU에서의 대응 개념 | . | Thread | 하나의 CUDA 코어에서 실행되는 명령어와 데이터의 흐름. SIMT 모델에서 실행됨. | 일반적으로 명시적 대응 없음. | . | CUDA Core | SIMT 명령어의 일부를 처리하는 단일 연산 유닛. | 벡터 유닛 내의 벡터 레인 | . | Warp | 32개의 스레드로 구성된 그룹. 서로 다른 데이터에 동일한 명령어 스트림을 함께 실행한다. | 벡터 연산에서의 벡터 | . | Kernel | GPU에서 실행되는 함수. 커널은 여러 스레드 블록으로 구성될 수 있다. | CPU의 스레드 | . | Streaming Multiprocessor (SM) | 스레드 블록을 실행할 수 있는 단위. GPU의 물리적 유닛. | CPU의 코어 | . ❓ 스레드 블록 . | 스레드 블록 (Thread Block) . | 여러 스레드가 모여 하나의 논리적 단위로 구성되는 실행 단위 | . | CUDA 프로그래밍에서 스레드는 블록 단위로 묶여 실행된다. | 하나의 블록은 n ~ n백개의 스레드를 포함할 수 있다. | 블록은 SM(Streaming Multiprocessor)에 배정된다. | . ❓ 명령어 스트림 . | 명령어 스트림 (Instruction Stream) . | 스레드들이 공유하는 명령어의 흐름 (제어 흐름 분기(조건문)가 영향을 줌) | . | 스트림(stream)이라는 말은 일련의 명령어가 순차적으로 흐르는 데이터 흐름을 의미 | SIMT 모델에서 말하는 “명령어 스트림”은 모든 스레드가 따르는 동일한 명령어 흐름 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-%EC%9E%AC%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-재정의"
  },"30": {
    "doc": "1. GPU 특성",
    "title": "4. SIMT (Single Instruction, Multiple Threads)",
    "content": ". | 한 명령어를 여러 스레드가 동시에 실행하는 GPU 실행 모델 | . __global__ void add(int *a, int *b, int *c) { int idx = threadIdx.x; c[idx] = a[idx] + b[idx]; } . | 위 함수가 32개의 스레드에서 실행되면 모든 스레드가 같은 c[idx] = a[idx] + b[idx] 명령어 수행. | 각 스레드는 자신만의 idx 값을 사용해서 다른 데이터에 접근함. | . SIMT에서 제어 흐름 분기 예시 . | SIMT에서는 선택한 스레드를 활성화 또는 비활성화할 수 있다 | . | 활성 스레드: 명령과 데이터 처리. | 비활성 스레드: 아무런 작업도 수행하지 않음. 로컬 데이터가 변경되지 않은 상태로 유지됨. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads"
  },"31": {
    "doc": "1. GPU 특성",
    "title": "5. Warps",
    "content": ". | 런타임 시, 스레드 블록은 SIMT 실행을 위해 워프로 나뉜다. | 하나의 완전한 워프는 연속된 스레드 인덱스를 가진 32개의 스레드 묶음으로 구성된다. | 워프에 포함된 스레드들은 32개의 CUDA 코어 집합에 의해 함께 처리된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps"
  },"32": {
    "doc": "1. GPU 특성",
    "title": "6. Kernels (in software)",
    "content": ". 연결된 GPU 에서 병렬로 실행되도록 설계된 함수를 커널이라고 한다. | C++ 함수 선언 앞에 __global__ 지정자가 있는 것으로 식별된다. | . | 커널은 한 번만 실행되는 것이 아니라, GPU의 N개의 서로 다른 스레드 에 의해 N번 병렬로 실행된다. | 각 스레드에는 메모리 주소를 계산하고 제어 결정을 내리는 데 사용할 수 있는 고유 ID(실제로는 인덱스)가 할당된다. | . CUDA 커널이 스레드 배열에 의해 실행되는 방식 . 커널 호출은 GPU에서 사용할 스레드 수를 지정하는 특수 인수를 제공해야 한다. 특수 인수는 아래와 같다. func&lt;&lt;&lt;1, N&gt;&gt;&gt;(x, y, z) . // 커널 함수 정의: 두 벡터를 더해서 결과 저장 __global__ void addVectors(int *a, int *b, int *c, int N) { int idx = threadIdx.x; if (idx &lt; N) { c[idx] = a[idx] + b[idx]; } } int main() { const int N = 256; // 커널 호출: 블록 1개, 스레드 256개로 구성 addVectors&lt;&lt;&lt;1, N&gt;&gt;&gt;(d_a, d_b, d_c, N); } . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software"
  },"33": {
    "doc": "1. GPU 특성",
    "title": "7. Streaming multiprocessors (in hardware)",
    "content": ". GPU에서 커널 호출은 하나 이상의 스트리밍 멀티프로세서에 의해 실행된다. 각 SM의 CUDA 코어는 항상 32개 세트로 배열되어 SM이 스레드의 전체 워프를 실행하는 데 사용할 수 있다. | GPU가 커널 호출을 실행하는 데 실제로 사용하는 SM의 수는 호출에 지정된 스레드 블록 수로 제한된다. | 예를 들어 fun&lt;&lt;&lt;M, N&gt;&gt;&gt;(x, y, z) 이 있을 때, 각 SM에 할당할 수 있는 블록은 최대 M개이다. | 스레드 블록은 여러 SM으로 분할될 수 없다. | 사용 가능한 SM보다 블록이 많은 경우, 동일한 SM에 여러 블록을 할당할 수 있다. | . | . | 매 사이클 마다 각 SM의 스케줄러 는 사용 가능한 32개의 CUDA 코어 세트에서 실행될 스레드의 전체 워프를 할당한다. | SM에는 레지스터 , L1 캐시 , 상수 캐시, 공유 메모리가 포함된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware"
  },"34": {
    "doc": "1. GPU 특성",
    "title": "☑️ 정리",
    "content": "[Kernel] ↓ [Grid] (커널의 전체 작업 공간 = 스레드 블록 집합) ┌─────────────────┐ │ Thread Block 1 │ → SM 0 (리소스 여유 있을 시 SM 1에도 할당 가능) │ Thread Block 2 │ → SM 0 or 다른 SM │ ... │ (한 SM이 여러 블록을 동시에 실행 가능) │ Thread Block N │ → SM m (m ≤ n, SM 수 ≤ 블록 수) └─────────────────┘ ↓ ↓ [Warp 0] [Warp 1] ... (각 32스레드) ↓ ↓ CUDA Cores (SIMT 방식으로 워프 단위 병렬 처리 실행) ↓ ALU/FPU/Tensor Cores (실제 연산) . | 하나의 커널(GPU 함수)은 수많은 스레드 블록으로 구성 | 각 스레드 블록은 SM에 할당되어 실행된다. | SM이 스레드 블록을 실행한다 = SM은 워프 스케줄링, 메모리, 명령어 분배 등 전체 실행을 관리한다 | 한 SM이 여러 블록을 동시에 실행 가능 (SM의 자원이 충분하다면 여러 블록을 동시에 수용 가능) | . | 스레드 블록 내부의 스레드들은 32개 단위로 워프로 나뉨 | 각 스레드는 CUDA 코어에서 개별적으로 연산을 수행한다. | CUDA Core가 연산을 수행한다 = 각 스레드의 연산은 CUDA 코어에서 처리된다. 각 스레드의 명령은 워프 단위로 동기화(SIMT)되어 CUDA Core에 할당되며, 워프 내 스레드의 명령어를 ALU/FPU에 전달해 연산을 수행한다. | CUDA Core 자체가 ALU나 FPU를 내장하고 있거나, 복합적으로 연결되어 있다. | . | Tensor Core는 행렬 곱 연산(Matrix Multiply) 등에 최적화된 특수 연산 유닛으로, 워프 단위에서만 활성화되며 CUDA Core와 독립적으로 존재 | . | 구성 요소 | 설명 | 예시 용어 | . | Kernel | GPU에서 실행되는 함 | myKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...) | . | Grid | 모든 스레드 블록의 집합 | 논리적 실행 단위 | . | Thread Block | 스레드의 집합, SM에 할당됨 | blockDim.x, blockIdx.x 등으로 접근 | . | SM | Streaming Multiprocessor. 블록을 실행하는 하드웨어 유닛 | Warp Scheduler, CUDA Cores 포함 | . | Warp | 32개 스레드로 구성된 실행 단위 | SIMT 방식 실행 | . | CUDA Core | 실제 산술/논리 연산을 수행하는 유닛 | ALU/FPU로 구성된 연산 유닛의 논리적 집합 | . | Tensor Core | 고속 행렬 곱셈 (AI 특화) | SM 내부에 있는 별도 유닛으로 워프 단위 처리 | . FPU vs ALU vs Tensor Core . | 유닛 | 연산 타입 | 주요 용도 | 예시 | . | FPU | 부동소수점 (실수) | 물리 시뮬레이션, 3D 렌더링 | float x = y * 1.5; | . | ALU | 정수/논리 연산 | 인덱스 계산, 조건문 | int i = j + 1; | . | Tensor Core | 행렬 연산 | AI 학습/추론, DLSS | A = B × C (행렬 곱셈) | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#%EF%B8%8F-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#️-정리"
  },"35": {
    "doc": "1. Material Basic",
    "title": "1. Material Basic",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html"
  },"36": {
    "doc": "1. Material Basic",
    "title": "1. Data Types",
    "content": "constant - 1 float . constant2Vector - 2 floats . constant3Vector - 3 floats . 어떤 포지션과 묶느냐에 따라 floats 값이 RGB or XYZ 가 될 수 있다. | Base Color에 1 vector, 2 vector 를 넣어도 엔진에서 자동으로 입력을 처리한다. | (r 1, g 0, b 0) 이런 식 | . | Color에서 constant value 값 . | 0 : black | 1 : white | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types"
  },"37": {
    "doc": "1. Material Basic",
    "title": "2. Roghness",
    "content": "표면의 반사 정도를 제어 . | 0 : 거울 반사 (정반사) | 1 : 완전 무광 (난반사) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness"
  },"38": {
    "doc": "1. Material Basic",
    "title": "3. Lerp",
    "content": "Linear Interpolation (선형 보간법) 약어 . | 입력 A : 시작 포인트 | 입력 B : 끝 포인트 | 알파 : 보간 계수 (두 값 사이에서 어느 지점에 위치하는지를 나타내는 비율이자 가중치) | 리턴 : 보간된 값 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp"
  },"39": {
    "doc": "1. Material Basic",
    "title": "UV Mapping",
    "content": "2D 이미지를 3D 모델 표면에 투영하는 것 . | u : 수평 | v : 수직 | . | Texture coordinate Node . | tiling : 크기가 커질수록 텍스쳐는 작아지고 반복됨 | mutilply 사용으로도 타일링 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping"
  },"40": {
    "doc": "1. Material Basic",
    "title": "component mask",
    "content": "벡터 배열 중 가져오고 싶은 인덱스만 마스킹 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask"
  },"41": {
    "doc": "1. Material Basic",
    "title": "append",
    "content": "값1, 값2 합쳐서 매개변수로 사용하고 싶을때 쓰임 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append"
  },"42": {
    "doc": "1. Material Basic",
    "title": "4. Opacity",
    "content": "투명도를 주고싶으면 블렌드 모드를 바꿔야 함. (디폴트 Opaque(불투명)) . | material blend mode -&gt; Translucent(반투명) 변경 -&gt; Opacity 속성 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity"
  },"43": {
    "doc": "1. Material Basic",
    "title": "5. moving texture",
    "content": ". | speed (음수로 두면 -&gt; 방향으로 감) | time | distance = speed * time | subtract . | -로도 검색 가능 | append를 쓰면 speed에 음수로 방향 | subtract를 쓰면 speed는 늘 양수 (subtract가 뺄셈처리) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture"
  },"44": {
    "doc": "1. Material Basic",
    "title": "6. Panner",
    "content": "위 무빙 텍스쳐를 쉽게 하나로 만든 형태 . | 입력 coordinate : 텍스쳐 UV 좌표 | 입력 Time : UV 이동에 사용할 시간 값 | 입력 Speed : UV 좌표의 이동 속도를 설정하는 2D vector | 출력 UV : 입력된 UV 좌표를 시간과 속도에 따라 변형한 결과를 출력 | . ❓ 왜 speed 를 양수로 하면 왼쪽으로 가는것 처럼 보일까? . | Speed X 값이 양수일 때, 위의 계산에 따라 UV 좌표의 U 값이 증가 | 이는 텍스처의 샘플링 위치가 오른쪽으로 이동함을 의미 | 따라서 실제로 화면에서 보이는 텍스처는 왼쪽으로 이동하는 것처럼 보임 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner"
  },"45": {
    "doc": "1. Material Basic",
    "title": "7. Material Instance",
    "content": ". | M_material | MI_materialInstance | . | 머티리얼 인스턴스를 만들고 머티리얼 파라미터를 추가해 빠르게 머티리얼을 수정할 수 있다. | 머티리얼 인스턴스는 창이 다름 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance"
  },"46": {
    "doc": "1. Material Basic",
    "title": "8. Comment",
    "content": ". | 노드 클릭 / 드래그 후 C 버튼 눌러서 주석 달기 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment"
  },"47": {
    "doc": "1. Material Basic",
    "title": "9. Sine 표현식",
    "content": "사인 함수를 호출하는 노드 . | 입력 : 라디안 단위 각도 | 출력 : 입력의 라디안 사인을 계산한 결과 (-1 ~ 1) | . | 객체를 상하로 흔들거나 파도, 진동 등 주기적 변동 구현에 사용 | 입력값을 라디안 단위로 해석하여 사용함 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-%ED%91%9C%ED%98%84%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-표현식"
  },"48": {
    "doc": "1. Material Basic",
    "title": "10. Saturate",
    "content": "0 ~ 1 범위로 한정 시킴 = 클램핑 . 클램핑이 뭐야 ❓Clamp wiki Link . | 입력 : 클램핑할 값 | 출력 : 0 이하 = 0 / 1 이상 = 1 / 그 외 = 원본값 유지 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate"
  },"49": {
    "doc": "1. Material Basic",
    "title": "11. Sine_Remapped",
    "content": ". | 입력 sine Phase : 보간 계수 | 입력 Value1 (V3) : 0으로 맵핑될 때 반환할 시작 벡터 | 입력 Value2 (V3) : 1로 맵핑될 때 반환할 목표 벡터 | 출력 Remapped Sine (Vec3) : lerp(val1, val2, (sin(Sine Phase) + 1) / 2) 로 선형보간한 결과 | . | Sine Phase(실수)를 사인파로 계산한 뒤 [-1,1] 범위의 출력을 Value 1 (V3)와 Value 2 (V3) 사이의 벡터로 선형 보간하여 반환 | 내부적으로 sin(Sine Phase)의 결과에 +1을 더해 0~2로 이동시킨 뒤 0.5로 스케일링 하여 0~1 범위로 remap | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped"
  },"50": {
    "doc": "1. Material Basic",
    "title": "12. world position offset",
    "content": ". | 입력 World Position Offset (V3) : 오브젝트 버텍스에 더해질 월드 공간 오프셋 벡터 | 출력 (V3): 최종 버텍스 위치 | . | 간단한 이동 애니메이션이나 주기적 바운스 효과(Sind_Remapped 사용) 를 줄 때 사용한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset"
  },"51": {
    "doc": "1. Material Basic",
    "title": "13. CheapContrast",
    "content": ". | 입력 in (Scalar) : 대비를 조정할 입력 채널 (흑백 값) | 입력 Contrast (Scalar) : 대비 증가 강도. 값이 커질수록 대비 강도 증가 | . | 흑백 마스크 대비 보정할 때 사용 | 내부 동작 수식 Remapped = ( (In – 0.5) * (1 + Contrast) ) + 0.5 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast"
  },"52": {
    "doc": "1. Material Basic",
    "title": "Texture Sample UVs 혼합하기",
    "content": "❓ 흑백 텍스쳐 샘플 노드가 2개 있을 때, 1번 텍스쳐 샘플의 R 채널과 0을 2번 텍스쳐 샘플의 UV로 넣는 과정은 어떤 결과가 나올까? . | (R, 0)은 “2번 텍스쳐의 수평 위치를 1번 택스쳐의 R값으로 조정”한다는 뜻! | 예: R = 0.3 → 2번 텍스쳐의 30% 위치의 색상을 가져옴. | 수직은 0으로 고정이므로 R 값에 따라 수평으로만 왜곡시키는 효과를 냄 | . 과정 상세 설명 . | 1번 텍스쳐 (흑백) / R 채널만 사용 (흑백이므로 R=G=B). 값은 0 ~ 1 사이 | Append 노드로 (R, 0) 생성 / 예 픽셀 R은 0.7 → (0.7, 0) | 2번 텍스쳐에 (R, 0)을 UV로 입력 | 원래 UV가 (0.5, 0.5)라면, 새 UV는 (0.5 + 0.7, 0.5 + 0) = (1.2, 0.5) 같은 식으로 계산. | . 결과 . | 1번 텍스쳐의 밝은 부분(R≈1) → 2번 텍스쳐가 오른쪽으로 밀림. | 어두운 부분(R≈0) → 2번 텍스쳐가 왼쪽으로 수축. | 수직(V) 방향은 0으로 고정되므로 위아래 왜곡은 없음. | . UV 혼합은 그라데이션 왜곡, 노이즈 패턴 변형, 동적 텍스쳐 오프셋 등에 활용 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-%ED%98%BC%ED%95%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-혼합하기"
  },"53": {
    "doc": "1. Material Basic",
    "title": "14. Name Reroute Node",
    "content": "Material Editor 전용으로 제공되는 노드. 와이어가 얽히지 않도록 중앙 리루트 지점을 만들어 그래프를 깔끔하게 유지 할 수 있다. | Declaration (선언) 노드 : 오직 입력(Input) 만 갖고, 값을 ‘이름’으로 보관 | Usage: 오직 출력(Output) 만 갖고, 해당 이름의 값을 그래프 전역에 사용 가능. | . 사용방법 . | 와이어 두번 클릭 | 마우스 오른쪽 버튼 클릭 | 이름을 가진 경유 노드로 변환 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node"
  },"54": {
    "doc": "1. Material Basic",
    "title": "15. 1-x / OneMinus",
    "content": "색상 반전, 마스크 반전에 쓰임 . | 입력 input (float) : 연산 대상 X의 값. 스칼라일 경우 단일 채널, 벡터일 경우 각 채널별로 처리 | 출력 float : 계산 결과 1 - Input을 각 채널에 적용한 값 출력 | . | 출력 예시 : OneMinus((0.2, 0.5, 1.0)) → (0.8, 0.5, 0.0) | . 📌 단축키 . | 단축키 | 동작 | . | 숫자 1, 2, 3, 4 키 + 좌클릭 | 해당 constant vector 노드 생성 | . | T + 좌클릭 | texture sample | . | L + 좌클릭 | lerp | . | m + 좌클릭 | multiply | . | alt -&gt; 기즈모 이동 | 오브젝트 복사 | . | ctrl + D | 이전 행동 다시 반복 | . | 좌클릭 + f2 | 파일 이름 변경 | . | S + 좌클릭 | 머티리얼 파라미터 추가 | . | c + 좌클릭 | comment 주석달기 | . | Alt + 핀 클릭 | 모든 연결 끊기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus"
  },"55": {
    "doc": "1. Multiplying matrices and vectors",
    "title": "1. Multiplying matrices and vectors",
    "content": "행렬-벡터 곱 . ",
    "url": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html"
  },"56": {
    "doc": "1. Multiplying matrices and vectors",
    "title": "벡터와 행렬의 곱",
    "content": "행렬에 담긴 규칙(새로운 좌표계)에 따라 벡터의 좌표를 새로 계산한다 . | 행렬은 ‘좌표 공간 그 자체’를 담고 있는 그릇 | 행렬과 벡터를 곱하는 행위 = “벡터 A가 있던 공간의 좌표를 B 공간의 기준으로 다시 측정하는 과정” | . ",
    "url": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#%EB%B2%A1%ED%84%B0%EC%99%80-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1",
    
    "relUrl": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#벡터와-행렬의-곱"
  },"57": {
    "doc": "1. Multiplying matrices and vectors",
    "title": "v = (1, -4) 와 행렬 M의 곱셈",
    "content": "기준 설정 . | 기존 좌표계 (우리가 출발하는 곳) . | x축: (1, 0) (오른쪽) | y축: (0, 1) (위쪽) | . | 벡터 v: (1, -4) | 즉, (1 * x축) + (-4 * y축) 만큼 이동한 위치 | . 새로운 좌표계 (우리가 도착할 곳) = 행렬 M . 새로운 좌표계를 정의하고 이 정보를 행렬 M에 담음 . | 새로운 x축: 기존의 y축 방향인데, 길이는 2배. 즉, (0, 2) | 새로운 y축: 기존의 x축 방향인데, 길이는 2배. 즉, (2, 0) | . 이 정보를 행렬 M으로 만들면 다음과 같음. (열들이 새로운 축 방향) . [새로운x축.x, 새로운y축.x] = [0, 2] [새로운x축.y, 새로운y축.y] = [2, 0] . | 이 행렬 M은 “기존 좌표계를 시계방향으로 90도 회전시키고 | 모든 길이를 2배로 늘려라”는 변환 규칙을 담고 있음 | . 곱셈 실행: v를 M의 규칙으로 변환하기 . 목표는 v = (1, -4)를 이 새로운 좌표계에서 다시 측정하는 것 . | 새로운 좌표 = (v의 x값 * 새로운 x축) + (v의 y값 * 새로운 y축) . | (1 * (0, 2)) + (-4 * (2, 0)) | (0, 2) + (-8, 0) | (0 - 8, 2 + 0) | (-8, 2) | . | . 결과 . | 원래 벡터 v = (1, -4): 오른쪽으로 한 칸, 아래로 네 칸 가는 벡터였음 | 변환 규칙 M: 시계방향 90도 회전 + 크기 2배 | 변환된 벡터 v' = (-8, 2): 왼쪽으로 여덟 칸, 위로 두 칸 가는 벡터가 됨 | . 행렬 곱셈은 벡터를 “행렬의 좌표로 옮기는 것”이 아니라, “행렬에 담긴 방향과 크기, 원점 정보를 바탕으로 벡터의 좌표를 재구성하는 변환”이다 . ",
    "url": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#v--1--4-%EC%99%80-%ED%96%89%EB%A0%AC-m%EC%9D%98-%EA%B3%B1%EC%85%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#v--1--4-와-행렬-m의-곱셈"
  },"58": {
    "doc": "1. Multiplying matrices and vectors",
    "title": "나중에 동차좌표계로 옮기기",
    "content": "\\[T = \\begin{bmatrix} A &amp; \\mathbf{b} \\\\ \\mathbf{0}^T &amp; 1 \\end{bmatrix}, \\quad A= \\begin{bmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{bmatrix}, \\quad \\mathbf{b}= \\begin{bmatrix} b_{1} \\\\ b_{2} \\end{bmatrix}\\] 일반식 (w를 남겨둔 형태) . \\(\\begin{bmatrix} x' \\\\ y' \\\\ w' \\end{bmatrix} = \\begin{bmatrix} A &amp; \\mathbf{b} \\\\ \\mathbf{0}^T &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ w \\end{bmatrix} = \\begin{bmatrix} A\\begin{bmatrix}x\\\\y\\end{bmatrix} + \\mathbf{b}\\,w \\\\ w \\end{bmatrix}\\) . 점 (point): \\; w = 1 . \\(\\mathbf{p}_h= \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} \\Rightarrow T\\mathbf{p}_h= \\begin{bmatrix} A\\begin{bmatrix}x\\\\y\\end{bmatrix} + \\mathbf{b} \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} a_{11}x + a_{12}y + b_{1} \\\\ a_{21}x + a_{22}y + b_{2} \\\\ 1 \\end{bmatrix}\\) . 방향 벡터 (direction): \\; w = 0 . \\(\\mathbf{v}_h= \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\end{bmatrix} \\Rightarrow T\\mathbf{v}_h= \\begin{bmatrix} A\\begin{bmatrix}v_x\\\\v_y\\end{bmatrix} + \\mathbf{b}\\cdot 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} a_{11}v_x + a_{12}v_y \\\\ a_{21}v_x + a_{22}v_y \\\\ 0 \\end{bmatrix}\\) . 숫자 예시로 확인하기 . \\[T = \\begin{bmatrix} 0 &amp; -1 &amp; 3 \\\\ 1 &amp; \\;\\;0 &amp; -2 \\\\ 0 &amp; \\;\\;0 &amp; 1 \\end{bmatrix} = \\begin{bmatrix} A &amp; \\mathbf{b} \\\\ \\mathbf{0}^T &amp; 1 \\end{bmatrix}, \\quad A= \\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; \\;\\;0 \\end{bmatrix}, \\quad \\mathbf{b}= \\begin{bmatrix} 3 \\\\ -2 \\end{bmatrix}\\] 위 (A)는 원점 기준 90° 회전(시계 반대)이고, (\\mathbf{b}=(3,-2)^T)는 이동입니다. 1) 점(point) (p=(2,5)) . 동차좌표: (\\;p_h = \\begin{bmatrix} 2 \\ 5 \\ 1 \\end{bmatrix}) . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = T \\begin{bmatrix} 2 \\\\ 5 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0\\cdot 2 + (-1)\\cdot 5 + 3\\cdot 1 \\\\ 1\\cdot 2 + 0\\cdot 5 + (-2)\\cdot 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -5 + 3 \\\\ 2 - 2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -2 \\\\ 0 \\\\ 1 \\end{bmatrix}\\] 즉, (p’ = (-2,\\; 0)). 2) 방향 벡터(direction) (v=(4,-1)) . 동차좌표: (\\;v_h = \\begin{bmatrix} 4 \\ -1 \\ 0 \\end{bmatrix}) . \\[\\begin{bmatrix} v_x' \\\\ v_y' \\\\ 0 \\end{bmatrix} = T \\begin{bmatrix} 4 \\\\ -1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0\\cdot 4 + (-1)\\cdot(-1) + 3\\cdot 0 \\\\ 1\\cdot 4 + 0\\cdot(-1) + (-2)\\cdot 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 4 \\\\ 0 \\end{bmatrix}\\] 즉, (v’ = (1,\\; 4)). (이동 벡터 (\\mathbf{b})가 곱해지는 항은 (w=0)이라서 사라짐) . 요점 재확인 . | (\\mathbf{b})는 마지막 성분 (w)와 곱해져서 윗부분에 더해진다. | 점은 (w=1)이므로 (\\mathbf{b})가 그대로 더해져 이동 적용 | 방향 벡터는 (w=0)이므로 (\\mathbf{b})가 사라져 이동 미적용, 선형 부분 (A)만 적용 | . ",
    "url": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#%EB%82%98%EC%A4%91%EC%97%90-%EB%8F%99%EC%B0%A8%EC%A2%8C%ED%91%9C%EA%B3%84%EB%A1%9C-%EC%98%AE%EA%B8%B0%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/1.%20Multiplying%20matrices%20and%20vectors.html#나중에-동차좌표계로-옮기기"
  },"59": {
    "doc": "1. Open World",
    "title": "1. Open World",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html"
  },"60": {
    "doc": "1. Open World",
    "title": "전통적 월드 시스템 (맵 경계 로딩 방식)",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%A0%84%ED%86%B5%EC%A0%81-%EC%9B%94%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%A7%B5-%EA%B2%BD%EA%B3%84-%EB%A1%9C%EB%94%A9-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#전통적-월드-시스템-맵-경계-로딩-방식"
  },"61": {
    "doc": "1. Open World",
    "title": "과정",
    "content": ". | 월드 분할: 개발자가 수동으로 월드를 여러 개의 작은 맵(레벨)으로 분할 | 경계 설정: 각 맵의 로딩 트리거 영역(보이지 않는 경계 박스)을 설정 | 스트리밍 방 . | 플레이어가 특정 영역에 접근하면 해당 맵 로드 | 이전 맵은 메모리에서 언로드 또는 유지(설정에 따라) | . | 로딩 화면: 맵 전환 시 로딩 화면이 표시되는 경우가 많음 | 수동 최적화: 개발자가 LOD(Level of Detail)와 오클루전 컬링을 수동으로 설정 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#과정"
  },"62": {
    "doc": "1. Open World",
    "title": "특징",
    "content": ". | 간단한 게임에 적합 | 메모리 관리가 비교적 직관적 | 대규모 오픈 월드에는 부적합(로딩 화면 빈번) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#특징"
  },"63": {
    "doc": "1. Open World",
    "title": "언리얼 5 World Partition 시스템",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%96%B8%EB%A6%AC%EC%96%BC-5-world-partition-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#언리얼-5-world-partition-시스템"
  },"64": {
    "doc": "1. Open World",
    "title": "과정",
    "content": ". | 자동 공간 분할: 월드를 정사각형 셀(grid)로 자동 분할(기본 1km²) | 데이터 레이어: 동일한 공간에 여러 버전의 콘텐츠를 계층화 가능(예: 낮/밤 버전) | 지능형 스트리밍 . | 서버 기반 거리 계산으로 필요한 셀만 로드 | One File Per Actor 시스템으로 개별 에셋 단위 제어 가능 | . | 지속적인 업데이트 . | 플레이어 위치를 실시간으로 모니터링 | 시야 범위와 데이터 레이어 활성화 상태를 고려해 LOD 자동 조정 | . | HLOD(계층적 LOD) . | 거리에 따라 자동으로 HLOD 버전 생성 및 전환 | 원거리 오브젝트는 자동으로 단순화된 버전으로 렌더링 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EA%B3%BC%EC%A0%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#과정-1"
  },"65": {
    "doc": "1. Open World",
    "title": "특징",
    "content": ". | 대규모 오픈 월드에 최적화 | 로딩 화면 없이 원활한 월드 탐색 가능 | 개발자 편의성 향상(수동 분할 불필요) . | World Partition | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#특징-1"
  },"66": {
    "doc": "1. Open World",
    "title": "정리",
    "content": "| 특징 | 전통적 월드 시스템 | 언리얼 5 World Partition | . | 월드 분할 방식 | 수동 분할 | 자동 그리드 분할 | . | 로딩 방식 | 전체 맵 단위 로드/언로드 | 셀 단위 지능형 스트리밍 | . | 로딩 화면 | 빈번하게 발생 | 거의 없음 | . | 최적화 방식 | 수동 LOD 설정 | 자동 HLOD 생성 | . | 메모리 관리 전체 | 맵 단위 | 개별 액터 단위 제어 | . | 개발 편의성 | 낮음 (수작업 필요) | 높음 (자동화 시스템) | . | 적합 규모 | 소/중규모 게임 | 대규모 오픈 월드 | . | 실행 중 변경 | 제한적 | 동적 조정 가능 (데이터 레이어) | . | 에디터 작업 성능 | 전체 맵 로딩 필요 | 작업 영역만 로딩 (로컬 영역) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#정리"
  },"67": {
    "doc": "1. Open World",
    "title": "패널 세팅하기",
    "content": ". | 상단의 창(window) -&gt; 월드 파티션 | 월드 파티션 -&gt; 월드 파티션 에디터 클릭 | 월드 파티션 패널 등장 | 상단의 창(window) -&gt; 월드 세팅 체크 | 월드 세팅 패널 등장 | . 월드 파티션 에디터로 world가 셀로 나누어 지는 걸 볼 수 있음 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8C%A8%EB%84%90-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#패널-세팅하기"
  },"68": {
    "doc": "1. Open World",
    "title": "프로젝트 맵 세팅하기",
    "content": "엔진을 열 때 보여질 맵 세팅 . | 상단의 편집(Edit) -&gt; 프로젝트 세팅 | 프로젝트 세팅 창에서 맵 &amp; 모드 클릭 | default Maps 목록에서 에디터 시작 맵 -&gt; 원하는 맵 클릭하여 세팅 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%B5-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#프로젝트-맵-세팅하기"
  },"69": {
    "doc": "1. Open World",
    "title": "LOD (Level of Detail)",
    "content": "객체의 시각적 복잡성을 거리에 따라 동적으로 조절하는 시스템 . 가까운 객체는 고품질로, 먼 객체는 저품질로 렌더링 . | 장점 | 설명 | . | 성능 향상 | 먼 객체의 폴리곤 수 감소 → GPU 부하 ↓ | . | 메모리 절약 | 저해상도 텍스처/모델 사용 | . | 렌더링 효율화 | 불필요한 오버드로우 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-level-of-detail",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-level-of-detail"
  },"70": {
    "doc": "1. Open World",
    "title": "LOD 동작 과정",
    "content": "1. 거리 계산 단계 . 렌더러가 카메라와 각 객체 사이의 거리를 실시간으로 측정 . | 예: 0-10m(고품질), 10-30m(중간), 30m+(저품질) | . 2. 모델 전환 단계 . if (distance &lt; 10m) Render(HighPolyModel); else if (distance &lt; 30m) Render(MediumPolyModel); else Render(LowPolyModel); . 3. 부드러운 전환 . | LOD 교체 시점에서 팝핑 현상 방지를 위한 페이딩 효과 적용 | 언리얼의 경우 “LOD Bias” 설정으로 전환 거리 조정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-동작-과정"
  },"71": {
    "doc": "1. Open World",
    "title": "LOD 생성 방법",
    "content": "1. 수동 제작 . 전통적 방식으로 3D 모델러가 동일 객체의 여러 버전 제작 . | 예: 나무 모델을 10,000폴리곤 → 5,000 → 1,000 → 200 폴리곤 버전으로 제작 | . 2. 자동 생성 . 현대 엔진에서 쓰이는 방식 . 언리얼의 Auto LOD Generation . | 원본 메시 임포트 | Mesh Settings → LOD Settings에서 “Generate Auto LODs” 체크 | 폴리곤 감소 % 설정 (예: LOD1=50%, LOD2=25%, LOD3=10%) | . | 블렌더/마야의 리토폴로지 도구 활용 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-생성-방법"
  },"72": {
    "doc": "1. Toon Shader implementation",
    "title": "1. Toon Shader implementation",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html"
  },"73": {
    "doc": "1. Toon Shader implementation",
    "title": "Cel Shading",
    "content": "툰 셰이더(Cel Shading)의 핵심은 빛의 세기를 몇 개의 단계로 단순화(discretize)하여 만화 같은 느낌을 내는 것 . | 기본 명암 계산 . | 먼저 일반적인 3D 셰이더처럼 빛의 방향과 물체 표면의 방향(법선 벡터)을 내적(dot product)하여 빛의 세기(lightIntensity, 0.0 ~ 1.0 사이)를 계산 | . | 명암 단계화 (핵심) . | 계산된 빛의 세기를 연속적인 값(gradient)으로 사용하지 않고, if 문이나 step 함수를 사용해 몇 개의 정해진 값으로 뚝뚝 끊어줌 | 부드러운 명암 대신 만화처럼 경계가 명확한 그림자 덩어리가 생김 | . | 최종 색상 조합 . | 단계별로 나뉜 명암 값(lightIntensity)을 이용해 최종 색상을 만듦 | 최종 색상 = (주변광 + 분산광 * 단계명암) * 텍스처 색상 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#cel-shading",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#cel-shading"
  },"74": {
    "doc": "1. Toon Shader implementation",
    "title": "Outline",
    "content": ". | outline.vs . | 모델의 정점들을 각 정점의 법선(normal) 방향으로 살짝 밀어내어 모델을 크게 만든다 | . | outline.ps . | 화면에 그려지는 모든 픽셀을 정해진 컬러값으로 칠함 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#outline",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#outline"
  },"75": {
    "doc": "1. Toon Shader implementation",
    "title": "림 라이팅(Rim Lighting)",
    "content": "모델 뒤에서 조명을 비추는 것처럼, 물체의 가장자리(테두리)를 밝게 빛나게 해서 입체감을 살림 . | 프레넬(Fresnel) 효과 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EB%A6%BC-%EB%9D%BC%EC%9D%B4%ED%8C%85rim-lighting",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#림-라이팅rim-lighting"
  },"76": {
    "doc": "1. Toon Shader implementation",
    "title": "림 라이팅의 원리",
    "content": "림 라이팅은 빛의 방향이 아니라 카메라(시점)와 물체 표면이 이루는 각도를 이용해 계산 . | 카메라가 물체의 표면을 정면으로 바라볼 때는 효과가 나타나지 않음 | 카메라가 물체의 가장자리, 즉 둥근 표면이 꺾이는 부분을 비스듬히 바라볼 때 빛이 강하게 나타남 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EB%A6%BC-%EB%9D%BC%EC%9D%B4%ED%8C%85%EC%9D%98-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#림-라이팅의-원리"
  },"77": {
    "doc": "1. Toon Shader implementation",
    "title": "림 라이트(Rim Light) 구현",
    "content": "림 라이트의 핵심 아이디어 . “표면이 시선 방향과 거의 수직일 때 (즉, 모델의 가장자리 부분일 때) 빛이 나게 한다.” . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EB%A6%BC-%EB%9D%BC%EC%9D%B4%ED%8A%B8rim-light-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#림-라이트rim-light-구현"
  },"78": {
    "doc": "1. Toon Shader implementation",
    "title": "림 라이트 요소",
    "content": "1. 필요한 벡터들 . | N: 표면의 노멀 벡터 (표면이 바라보는 방향) | V: 시선 방향 벡터 (표면에서 카메라(눈)로 향하는 방향) | . 2. 림 라이트 세기(Rim Intensity) 계산 공식 . 노멀 벡터 N과 시선 벡터 V가 얼마나 수직에 가까운지를 계산 . | dot(N, V) . | 두 벡터가 같은 방향일수록 1 | 수직일수록 0 | 반대 방향일수록 -1 | . | . 우리는 수직일 때(0) 가장 강한 효과를 원함 . | dot 결과가 0일 때 1이 되고, 1일 때 0이 되도록 만드는 가장 간단한 방법은 | 1.0 - dot(N, V) | . Rim Intensity = 1.0 - saturate(dot(N, V)) . | dot(N, V)가 1에 가까우면 (정면을 바라봄) -&gt; Rim Intensity는 0 (빛 없음) | dot(N, V)가 0에 가까우면 (가장자리에 위치) -&gt; Rim Intensity는 1 (가장 밝은 빛) | saturate()는 dot 결과가 음수가 되는 뒷면을 0으로 처리 | . 3. 림 라이트 두께(Rim Factor) 조절 공식 . Rim Intensity를 rimPower 값으로 거듭제곱 . | rimPower 값이 클수록 림 라이트의 두께는 더 얇고 날카로워짐 | . Rim Factor = pow(Rim Intensity, rimPower) . | HLSL 픽셀 셰이더 코드 예시 | . // --- 입력 변수 (상수 버퍼나 다른 곳에서 미리 계산되어 넘어옴) --- // float3 input.normal : 픽셀의 노멀 벡터 // float3 viewDir : 정규화된 시선 방향 벡터 (표면 -&gt; 카메라) // float4 rimColor : 림 라이트의 색상 // float rimPower : 림 라이트의 두께/세기 (예: 2.0, 3.0 ...) // 1. 노멀(N)과 시선(V) 벡터를 내적 float rimDot = dot(input.normal, viewDir); // 2. 림 라이트의 기본 세기를 계산 (가장자리일수록 1에 가까워짐) float rimIntensity = 1.0 - saturate(rimDot); // 3. pow 함수를 이용해 림 라이트의 두께와 세기를 조절 float rimFactor = pow(rimIntensity, rimPower); // (선택) 툰 스타일처럼 딱딱한 림 라이트를 원한다면 step 함수를 사용할 수 있음 // float rimFactorToon = step(0.5f, rimFactor); // rimFactor가 0.5를 넘으면 1, 아니면 0 // 4. 최종 림 라이트 색상을 계산 float4 finalRimLight = rimFactor * rimColor; // --- 최종 색상 조합 --- // 이 finalRimLight 값을 최종 색상에 더해주기 finalColor = baseColor + finalSpecular + finalRimLig . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EB%A6%BC-%EB%9D%BC%EC%9D%B4%ED%8A%B8-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#림-라이트-요소"
  },"79": {
    "doc": "1. Toon Shader implementation",
    "title": "상수 버퍼의 패킹 규칙(Constant Buffer Packing Rules)",
    "content": "GPU는 매우 빠른 병렬 연산에 최적화되어 있어서, 데이터를 어중간한 크기로 가져오는 것보다 정해진 큰 덩어리(chunk)로 한 번에 가져오는 것이 훨씬 효율적 . | Direct3D에서는 이 ‘덩어리’의 기본 단위를 16바이트로 약속 | 이는 float4 나 XMFLOAT4 변수 하나의 크기와 같음 (float 하나가 4바이트이므로 4 * 4 = 16). | . C++ 명시적으로 16바이트 규칙 맞춰주기 . // C++ 쪽 구조체 정의 // DirectXMath 라이브러리를 사용하기 위해 헤더를 포함 #include &lt;DirectXMath.h&gt; using namespace DirectX; struct CameraBufferType { // 카메라의 위치를 저장하는 3차원 벡터 // float가 3개 있으므로 크기는 12바이트 (4 * 3) XMFLOAT3 cameraPosition; // 패딩(Padding) 변수 // cameraPosition (12바이트) 다음에 4바이트를 추가하여 // 전체 구조체의 크기를 16바이트의 배수로 만들어줌 // 이는 HLSL의 16바이트 정렬 규칙을 맞추기 위함 float padding; }; . 만약 padding을 추가하지 않으면 sizeof(CameraBufferType)은 12가 됨 . | 데이터를 GPU로 복사할 때, 데이터가 계속 12바이트 간격으로 이어지게 되어 | GPU가 예상한 16바이트 간격과 어긋나게 됨 이는 결국 렌더링 깨짐 현상으로 이어짐 . | . HLSL의 경우 . HLSL 컴파일러는 이 16바이트 패킹 규칙을 이미 알고 있음 . | 따라서 프로그래머가 굳이 padding 변수를 선언하지 않아도, 알아서 다음 변수를 16바이트 경계에 배치 | . // HLSL 쪽 상수 버퍼(Constant Buffer) 정의 // cbuffer는 C++에서 보내준 데이터가 담길 공간 // register(b0)는 이 버퍼가 0번 슬롯(slot)에 바인딩됨을 의미 cbuffer CameraBuffer : register(b0) { // C++의 cameraPosition 데이터가 이곳으로 복사 // float3는 12바이트 크기 // HLSL 컴파일러는 이 변수 다음에 4바이트의 빈 공간이 있을 것이라고 // '암묵적으로' 인지하고 있다 float3 cameraPosition; }; // 아주 간단한 픽셀 셰이더 예시 float4 main(float4 pos : SV_POSITION) : SV_TARGET { // 상수 버퍼에서 카메라 위치 값을 읽어옵니다. // 예를 들어, 카메라의 x좌표 값에 따라 다른 색을 출력할 수 있습니다. if (cameraPosition.x &gt; 0) { return float4(1.0f, 0.0f, 0.0f, 1.0f); // 빨간색 } else { return float4(0.0f, 0.0f, 1.0f, 1.0f); // 파란색 } } . 참고 링크 . | DX : hlsl-packing-rules | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EC%83%81%EC%88%98-%EB%B2%84%ED%8D%BC%EC%9D%98-%ED%8C%A8%ED%82%B9-%EA%B7%9C%EC%B9%99constant-buffer-packing-rules",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#상수-버퍼의-패킹-규칙constant-buffer-packing-rules"
  },"80": {
    "doc": "1. Toon Shader implementation",
    "title": "KEYWORD NOTE",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#keyword-note"
  },"81": {
    "doc": "1. Toon Shader implementation",
    "title": "lerp",
    "content": "Linear Interpolation. 선형 보간의 줄임말. | 두 개의 값 사이를 ‘선형적으로’ 보간하여 중간값을 얻는 함수 | 선형적 = 직선처럼 일정하게 변한다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#lerp",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#lerp"
  },"82": {
    "doc": "1. Toon Shader implementation",
    "title": "lerp 공식 유도 과정",
    "content": "\\[\\text{Let } x = \\text{시작점, } y = \\text{끝점, } s = \\text{진행률 (0 to 1)}\\] . 1.시작점에서 끝점까지의 전체 벡터 . \\[V_{total} = y - x\\] . 2.진행률 s 만큼 이동한 벡터 . \\[V_{progress} = (y - x) \\cdot s\\] . 3.최종 위치는 시작점에 진행한 벡터를 더한 값 . \\[P_{final} = x + V_{progress} \\\\ P_{final} = x + (y - x) \\cdot s\\] . 4.식을 전개하여 정리 . | 시작하는 식 | . \\[P_{final} = x + y \\cdot s - x \\cdot s\\] . | 덧셈의 교환법칙을 이용해 x가 포함된 항들을 옆으로 모음 | . \\[= x - x \\cdot s + y \\cdot s \\\\\\] . | x를 x 곱하기 1로 생각하여 명시적으로 표현 | . \\[= (x \\cdot 1) - (x \\cdot s) + y \\cdot s \\\\\\] . | 분배법칙을 역으로 적용하여 공통 인수 x를 괄호 밖으로 묶음 | 인수분해 과정 | . \\[(x * 1) - (x * s) =&gt; x * (1 - s) \\\\ = x(1 - s) + y \\cdot s\\] . | 최종적으로 정리된 공식이 유도 | . \\[\\text{lerp}(x, y, s) = x \\cdot (1 - s) + y \\cdot s\\] . 코드 예시 . #include &lt;iostream&gt; // 3차원 벡터를 표현하기 위한 간단한 구조체 struct Vector3 { float x, y, z; }; // float 타입에 대한 lerp 함수 float lerp(float x, float y, float s) { // x: 시작 값 // y: 목표 값 // s: 보간 계수 (0.0 ~ 1.0) return x * (1.0f - s) + y * s; } // Vector3 타입에 대한 lerp 함수 Vector3 lerp(const Vector3&amp; x, const Vector3&amp; y, float s) { Vector3 result; // 각 성분(x, y, z)에 대해 개별적으로 lerp 연산을 수행 result.x = lerp(x.x, y.x, s); result.y = lerp(x.y, y.y, s); result.z = lerp(x.z, y.z, s); return result; } int main() { // 빨간색(1, 0, 0)과 파란색(0, 0, 1)을 정의 Vector3 red = {1.0f, 0.0f, 0.0f}; Vector3 blue = {0.0f, 0.0f, 1.0f}; // 두 색상을 50% 비율로 혼합 (s = 0.5) float s = 0.5f; Vector3 purple = lerp(red, blue, s); // 결과 출력 (보라색에 가까운 (0.5, 0, 0.5)가 출력) std::cout &lt;&lt; \"Result: (\" &lt;&lt; purple.x &lt;&lt; \", \" &lt;&lt; purple.y &lt;&lt; \", \" &lt;&lt; purple.z &lt;&lt; \")\" &lt;&lt; std::endl; return 0; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#lerp-%EA%B3%B5%EC%8B%9D-%EC%9C%A0%EB%8F%84-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#lerp-공식-유도-과정"
  },"83": {
    "doc": "1. Toon Shader implementation",
    "title": "step",
    "content": "이름 그대로 ‘계단’처럼 작동하는 함수. | 특정 임계값(threshold)을 기준으로 입력값이 그보다 작으면 0 | 크거나 같으면 1을 반환 | . 명확한 경계가 필요할 때 if문 분기 없이 산술 연산만으로 표현이 가능 . 코드 예시 . #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cmath&gt; // sqrt, pow 함수 사용을 위해 포함 // HLSL의 step 함수를 C++로 구현 float step(float edge, float x) { // x가 edge(임계값)보다 작으면 0.0, 크거나 같으면 1.0을 반환 return x &lt; edge ? 0.0f : 1.0f; } // HLSL의 dot 함수(2차원 벡터용)를 C++로 구현 float dot(float x1, float y1, float x2, float y2) { // 두 벡터의 내적은 각 성분의 곱의 합 // 여기서는 벡터와 자기 자신의 내적을 구하여 길이의 제곱을 계산 return x1 * x2 + y1 * y2; } int main() { // 셰이더의 렌더링 타겟(화면)을 흉내내는 2D 그리드 크기 설정 const int width = 40; const int height = 20; // 원의 반지름 설정 const float radius = 0.4f; // 비교를 위해 반지름의 제곱을 미리 계산. (제곱근 연산을 피하기 위함) const float radiusSq = radius * radius; // 화면의 모든 픽셀(문자)을 순회 for (int j = 0; j &lt; height; ++j) { for (int i = 0; i &lt; width; ++i) { // 현재 픽셀의 좌표를 0.0 ~ 1.0 범위로 정규화 (UV 좌표처럼) // 너비에 2.0을 곱해 종횡비를 대략적으로 맞춘다 float u = static_cast&lt;float&gt;(i) / (width / 2.0f); float v = static_cast&lt;float&gt;(j) / height; // 좌표의 중심을 (0,0)으로 이동 (범위를 -0.5 ~ 0.5 근처로) float centeredU = u - 1.0f; float centeredV = v - 0.5f; // 중심으로부터 현재 픽셀까지의 거리의 '제곱'을 계산 float distSq = dot(centeredU, centeredV, centeredU, centeredV); // step 함수를 사용하여 원의 내부와 외부를 결정 // distSq가 radiusSq보다 크면(원의 바깥) 1.0, 작으면(원의 안) 0.0을 반환. float outside = step(radiusSq, distSq); // 결과가 1.0(바깥)이면 공백을, 0.0(안)이면 '#' 문자를 출력 if (outside == 1.0f) { std::cout &lt;&lt; \" \"; } else { std::cout &lt;&lt; \"##\"; } } std::cout &lt;&lt; std::endl; // 한 줄 출력이 끝나면 줄바꿈 } return 0; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#step",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#step"
  },"84": {
    "doc": "1. Toon Shader implementation",
    "title": "Clarity Notes",
    "content": "공부하며 헷갈렸던 부분 명료화 하기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#clarity-notes",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#clarity-notes"
  },"85": {
    "doc": "1. Toon Shader implementation",
    "title": "Color Operations in HLSL",
    "content": "덧셈과 곱셈은 빛과 색을 다루는 방식의 차이가 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#color-operations-in-hlsl",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#color-operations-in-hlsl"
  },"86": {
    "doc": "1. Toon Shader implementation",
    "title": "Multiplication (곱셈) - 빛의 반사율과 감산 혼합",
    "content": "물체의 색상(텍스처)은 각 색상 채널(R, G, B)의 빛을 얼마나 반사(Reflect)하는지를 나타내는 반사율(Reflectance)의 집합이다 . 물체 표면의 알베도(Albedo, 기본 색상)가 특정 파장의 빛을 얼마나 반사하는지를 나타냄 . Albedo = Diffuse Color = 물체의 고유 색 . 빛이 물체 표면에 닿았을 때 어떤 색으로 반사되는지를 결정하는 텍스처 . | Albedo의 각 component (R, G, B)는 해당 채널의 빛이 반사되는 비율이다 | 즉, 그림자, 빛의 강도, 반사광 등 모든 효과가 제거된 물체의 순수한 색상 정보 | . // (순수한 빨간색): 빨간광은 100% 반사, 녹색과 파란광은 0% 반사 (완전 흡수). albedoColor = (1.0, 0.0, 0.0) // (회색): 모든 빛을 50% 반사하고 50% 흡수. albedoColor = (0.5, 0.5, 0.5) . Component-wise Multiplication (성분별 곱셈) 예시 . 각 채널(R, G, B)끼리 독립적으로 곱셈을 수행 . | 백색광 (White Light) : (1.0, 1.0, 1.0) | 붉은 사과 : 반사율 (1.0, 0.1, 0.1) | . \\[\\text{Final Color} = \\text{Incoming Light Color} × \\text{Surface Reflectance} \\\\\\] . \\[(1.0,1.0,1.0)×(1.0,0.1,0.1) = (1.0×1.0,1.0×0.1,1.0×0.1) \\\\ = (1.0,0.1,0.1)\\] . 우리 눈에는 R 성분이 강한 빛이 들어오므로 사과가 빨갛게 보임 . | 물감을 섞는 것과 같은 감산 혼합(Subtractive Color Model)의 원리와 유사 | 물감을 섞을수록 특정 파장의 빛이 더 많이 흡수되어 어두워지는 것처럼 색상 곱셈은 항상 결과가 입력보다 어두워지거나 같아진다 . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#multiplication-%EA%B3%B1%EC%85%88---%EB%B9%9B%EC%9D%98-%EB%B0%98%EC%82%AC%EC%9C%A8%EA%B3%BC-%EA%B0%90%EC%82%B0-%ED%98%BC%ED%95%A9",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#multiplication-곱셈---빛의-반사율과-감산-혼합"
  },"87": {
    "doc": "1. Toon Shader implementation",
    "title": "Addition (덧셈) - 광원의 중첩과 가산 혼합",
    "content": "여러 광원에서 출발한 빛 에너지가 한 지점에 모이면 그 지점의 총 에너지는 각 에너지의 합이 된다 . | 한 픽셀이 받는 총 빛의 양은 각 광원으로부터 오는 빛의 양을 모두 합산한 것과 같음 | . float3 totalLighting = ambientLight; totalLighting += diffuseLight1; totalLighting += specularLight1; totalLighting += diffuseLight2; // ... (다른 광원들 추가) . \\[\\text{Total Illumination} = \\text{Ambient Light} + \\text{Specular Light} + ... \\text{다른 광원들}\\] . 주변광, 방향광 등 서로 다른 광원들은 서로의 존재에 영향을 주지 않고 장면에 빛을 더해감 . | 빛을 섞을수록 밝아지는 가산 혼합(Additive Color Model)의 원리와 같다 | 우리 눈이나 모니터의 RGB 픽셀이 빛을 혼합하는 방식 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#addition-%EB%8D%A7%EC%85%88---%EA%B4%91%EC%9B%90%EC%9D%98-%EC%A4%91%EC%B2%A9%EA%B3%BC-%EA%B0%80%EC%82%B0-%ED%98%BC%ED%95%A9",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#addition-덧셈---광원의-중첩과-가산-혼합"
  },"88": {
    "doc": "1. Toon Shader implementation",
    "title": "결론",
    "content": ". | 곱셈 (*) = 반사율 | 덧셈 (+) = 광원 중첩 | . 참고 링크 . | RB Whitaker’s Wiki - Creating a Toon Shader | Basic Theory of Physically-Based Rendering | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/1.%20Toon%20Shader%20implementation.html#결론"
  },"89": {
    "doc": "1. Vectors",
    "title": "1. Vectors",
    "content": "벡터는 두 가지 정보를 담는다 . | 방향 : 벡터가 가리키는 방향 | 크기 : 벡터의 길이 | . \\[\\overrightarrow{a} = (3, 4)\\] \\[\\overrightarrow{b} = (3, 4, 5)\\] 위와 같이 표현할 수 있다. ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html"
  },"90": {
    "doc": "1. Vectors",
    "title": "행, 열 벡터",
    "content": "벡터는 열 행렬 또는 행 행렬로도 쓸 수 있다 . | 열 행렬 | . \\[\\overrightarrow{a} = \\begin{bmatrix} 3 \\\\ 4 \\end{bmatrix}\\] \\[\\overrightarrow{b} = \\begin{bmatrix} 3 \\\\ 4 \\\\ 5 \\end{bmatrix}\\] . | 행 행렬 | . \\[\\overrightarrow{a} = \\begin{bmatrix} 3 &amp; 4 \\end{bmatrix}\\] \\[\\overrightarrow{b} = \\begin{bmatrix} 3 &amp; 4 &amp; 5 \\end{bmatrix}\\] . | 행렬과 벡터가 “가깝다”고 하는 이유 = | 한 열(또는 한 행)을 뽑아 보면 그 자체가 벡터 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#%ED%96%89-%EC%97%B4-%EB%B2%A1%ED%84%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#행-열-벡터"
  },"91": {
    "doc": "1. Vectors",
    "title": "행렬 속 벡터 예시",
    "content": ". | 열 벡터 성분의 개수로 몇 차원에 속하는지 알 수 있다 . | 열 벡터 성분 2 개 = \\(\\Reals^2\\) | . | 예시 | . \\[\\overrightarrow{A} = \\begin{bmatrix} 4 &amp; 6 &amp; 1 &amp; -8 &amp; 5 \\\\ 1 &amp; 1 &amp; -2 &amp; 9 &amp; 0 \\end{bmatrix}\\] . \\[\\overrightarrow{a_1} = \\begin{bmatrix} 4 &amp; 6 &amp; 1 &amp; -8 &amp; 5 \\\\ \\end{bmatrix} \\\\\\] \\[\\overrightarrow{a_2} = \\begin{bmatrix} 1 &amp; 1 &amp; -2 &amp; 9 &amp; 0 \\end{bmatrix}\\] . | 열 벡터 성분 5개 = \\(\\Reals^5\\) | 2개의 벡터 = \\(\\Reals^5\\) 안의 2차원 평면 형성 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#%ED%96%89%EB%A0%AC-%EC%86%8D-%EB%B2%A1%ED%84%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#행렬-속-벡터-예시"
  },"92": {
    "doc": "1. Win32 Basics",
    "title": "DirectX Tutorial",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#directx-tutorial",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#directx-tutorial"
  },"93": {
    "doc": "1. Win32 Basics",
    "title": "1. Win32 Basics",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html"
  },"94": {
    "doc": "1. Win32 Basics",
    "title": "A Primer of Basic Windows",
    "content": ". | 기본적인 Windows 애플리케이션을 만드는 방법 배우기 | 컴파일 오류 시 . | 프로젝트 속성 → Linker(링커) → System → SubSystem을 Windows (/SUBSYSTEM:WINDOWS) 로 변경 | . | . | “Hello World!” 창 띄우는 예시 | . #include &lt;windows.h&gt; // 모든 Windows 프로그램의 진입점 (WINAPI WinMain) int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR IpCmdLine, int nCmdShow) { //MessageBox()를 사용해 메시지 상자 만들기 MessageBox(NULL, L\"Hello World!\", L\"Just Hello World Program!\", MB_ICONEXCLAMATION | MB_OK); // windows에 0 반환 return (0); } . int WINAPI WinMain . | HINSTANCE hInstance . | 인스턴스 핸들.객체를 식별하는 32비트 정수 | 프로그램이 시작되면 windows는 숫자를 선택하여 hInstance 매개변수에 입력함 | . | HINSTANCE hPrevInstance . | 과거의 유물. 현재는 사용하지 않음.이전 버전과 호환성을 위해서 존재 | 과거에는 이전 인스턴스가 있는 경우 핸들을 제공하고, 없는 경우 (인스턴스가 유일한 경우) NULL을 반환함 | . | LPSTR lpCmdLine . | 프로그램 호출 명령줄을 포함하는 문자열에 대한 포인터 | “MyApp.exe”라는 애플리케이션을 시작 메뉴의 실행 명령 프롬프트에서 실행한 경우 | “MyApp.exe” 또는 “MyApp.exe RunA” 또는 “MyApp.exe RunB”와 같이 실행할 수 있다 | lpCmdLine은 입력된 모든 내용을 저장하여 프로그램이 특수 매개변수를 확인할 수 있도록 한다 . | 안전 모드, 창 모드, 소프트웨어 렌더링 모드 등 특수 모드를 실행하는 데 유용 | . | . | int nCmdShow . | 창이 생성될 때 어떻게 표시될지 지정 | 창을 최소화, 최대화 또는 일반 모드로 표시하거나, 백그라운드에서 실행 중인 창을 열도록 설정 | . | . MessageBox . | HWND hWnd . | 창의 핸들. 핸들은 색체를 식별하는 정수. | 현재 아직 창이 생성되지 않았으므로 NULL로 지정됨 . | NULL : 어떤 창에서도 오지 않고 바탕화면에서 옴 | . | . | LPCTSTR lptext . | 메시지 박스 안에 표시될 텍스트가 담긴 16비트 문자열을 가리키는 포인터 | . | LPCTSTR lpcaption . | 메시지 상자의 제목 표시줄이나 캡션 텍스트를 포함하는 16비트 문자열을 가리키는 포인터 | . | UINT utype . | 메시지 상자의 스타일을 결정. 여러 값의 경우 논리 OR (|) 연산자와 함께 사용 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#a-primer-of-basic-windows",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#a-primer-of-basic-windows"
  },"95": {
    "doc": "1. Win32 Basics",
    "title": "Creating a Window",
    "content": ". | 이벤트 기반 (버튼 클릭, 창 크기 조절, 키 입력) WinProc() 사용하기 . | 윈도우 창 생성하기 예시 . | . #include &lt;windows.h&gt; #include &lt;windowsx.h&gt; // windowProc 함수 프로토 타입 (아래에 정의됨) LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM IParam); // windows 프로그램 진입점 int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR IpCmdLine, int nCmdShow) { // 함수로 채워진 창의 핸들 HWND hWnd; // 창 클래스에 대한 정보를 보관하는 구조체 WNDCLASSEX wc; // 메모리 초기화 ZeroMemory(&amp;wc, sizeof(WNDCLASSEX)); // 구조체에 필요 정보 채우기 wc.cbSize = sizeof(WNDCLASSEX); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = WindowProc; wc.hInstance = hInstance; wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)COLOR_WINDOW; wc.lpszClassName = L\"WindowClass1\"; // 창 클래스 등록 RegisterClassEx(&amp;wc); // 창 만들고 결과를 핸들로 사용 hWnd = CreateWindowEx(NULL, L\"WindowClass1\", // 창 클래스 이름 L\"First Windowed Program\", //창 제목 WS_OVERLAPPEDWINDOW, // 창 스타일 300, // 창 x 위치 300, // 창 y 위치 500, // 창 너비 400, // 창 높이 NULL, // 부모 창 없음 NULL, // 메뉴 사용 안함 hInstance, // 애플리케이션 핸들 NULL); // 여러 창과 함께 사용 X // 화면에 창 표시 ShowWindow(hWnd, nCmdShow); // 메인 루프 시작 // windows 이벤트 메시지 보관용 구조체 MSG msg; // 큐에서 다음 메시지를 기다리고 결과를 msg에 저장 while (GetMessage(&amp;msg, NULL, 0, 0)) { // 키 입력 메시지를 올바른 형식으로 변환 TranslateMessage(&amp;msg); // 메시지를 WindowProc 함수로 보냄 DispatchMessage(&amp;msg); } // WM_QUIT 메시지 파트를 윈도우에 반환 return (msg.wParam); } // 프로그램의 메인 메세지 핸들러 LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM IParam) { // 메시지를 정렬하여 실행할 코드 찾기 switch (message) { // 창이 닫히면 이 메시지를 읽음 case WM_DESTROY: { // 애플리케이션 닫기 PostQuitMessage(0); return (0); } break; } // switch 케이스가 아닌 메시지는 여기서 처리 DefWindowProc(hWnd, message, wParam, IParam); } . 창 생성 함수 . | 창을 생성하는 단계 이외에는 창을 계속 실행하는데 사용된다 | . | 윈도우 클래스 등록 . | RegisterClassEx(); | . | 윈도우 생성 . | CreateWindowEx(); | . | 윈도우를 표시 . | ShowWindow(); | . | . 이벤트 처리 . | 이벤트 처리는 두 부분으로 나뉜다 | . | 메인 루프 . | GetMessage(), TranslateMessage(), DispatchMessage() 함수로만 구성 | . | WindowProc() 함수 . | 특정 메시지가 전송될 때 실행되는 코드로만 구성 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#creating-a-window",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#creating-a-window"
  },"96": {
    "doc": "1. Win32 Basics",
    "title": "Window Size vs Client Size",
    "content": ". | 렌더링은 클라이언트 영역 내에 그려진다 | 따라서 클리아언트 크기를 결정한 후 적절한 창 크기를 계산하는 것이 더 좋다 | . | AdjustWindowRect() 함수로 클라이언트 영역 크기 지정하기 | . BOOL AdjustWindowRect(LPRECT lpRect, //RECT 구조체에 대한 포인터 //RECT 구조체에는 원하는 클라이언트 영역의 좌표가 포함됨 DWORD dwStyle, // 창 스타일. 창 테두리의 크기를 결정함 BOOL bMenu); // 메뉴 사용 여부를 함수에 알려줌 // 'left'와 'top' 값에는 위치를 지정하지 않음 RECT wr = {0, 0, 500, 400}; // 크기 조정 AdjustWindowRect(&amp;wr, WS_OVERLAPPEDWINDOW, FALSE); // 창을 설정하고 그 결과를 핸들로 사용 hWnd = CreateWindowEx(NULL, L\"WindowClass1\", L\"First Windowed Program\", WS_OVERLAPPEDWINDOW, 300, // 창의 x 위치 300, // 창의 y 위치 wr.right - wr.left, // 창의 너비 wr.bottom - wr.top, // 창의 높이 NULL, NULL, hInstance, NULL); . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#window-size-vs-client-size",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#window-size-vs-client-size"
  },"97": {
    "doc": "1. Win32 Basics",
    "title": "The Real-Time Message Loop",
    "content": ". | 이전에 사용한 GetMessage() 함수는 메시지 큐가 비어있으면 스레드를 블로킹함 | PeekMessage() 함수는 메시지 큐 상태와 관계없이 즉시 반환 (비블로킹) . | PeekMessage() 함수를 사용한 루프 | . // Windows 이벤트 메시지를 보관하는 구조체 MSG MSG msg = {0}; // 무한 메시지 루프 while(TRUE) { // 큐에 대기 중인 메시지가 있는지 확인 if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { // 키 입력 메시지를 올바른 형식으로 변환 TranslateMessage(&amp;msg); // 메시지를 WindowProc 함수로 보냄 DispatchMessage(&amp;msg); // 종료 확인 if(msg.message == WM_QUIT) break; } else { // 여기에서 게임 코드를 실행 } } . | PeekMessage()는 메시지가 있으면 TRUE를, 없으면 FALSE를 반환함 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#the-real-time-message-loop",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/1.%20Win32%20Basics.html#the-real-time-message-loop"
  },"98": {
    "doc": "1. simultaneous equations",
    "title": "simultaneous equations (연립방정식)",
    "content": ". ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#simultaneous-equations-%EC%97%B0%EB%A6%BD%EB%B0%A9%EC%A0%95%EC%8B%9D",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#simultaneous-equations-연립방정식"
  },"99": {
    "doc": "1. simultaneous equations",
    "title": "연립방정식 풀이",
    "content": ". | 대입법 | 소거법 | 그래프법 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#%EC%97%B0%EB%A6%BD%EB%B0%A9%EC%A0%95%EC%8B%9D-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#연립방정식-풀이"
  },"100": {
    "doc": "1. simultaneous equations",
    "title": "Substitution Method 대입법",
    "content": "하나의 방정식을 한 변수에 대해 정리한 후, 다른 방정식에 대입하여 해 구하기 . 예시 . \\[\\begin{cases} y = 2x + 1\\\\ 3x + 2y = 20 \\end{cases}\\] . 풀이 . 1.첫번째 식에서 y가 정리되어 있으므로 두번째 식에 대입 . \\[3x + 2(2x+1) = 20\\] . 2.괄호 풀고 계산 . \\[3x + 4x + 2 = 20 \\\\ 7x + 2 = 20\\] . 3.x 구하기 . \\[7x = 18 \\Rightarrow x = \\frac{18}{7}\\] . 4.x를 첫번째 식에 대입해 y 구하기 . \\[y = 2 \\left ( \\frac{18}{7} \\right ) + 1 = \\frac{36}{7} + \\frac{7}{7} = \\frac{43}{7}\\] . 최종 해 . \\[x = \\frac{18}{7}, \\; y = \\frac{43}{7}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#substitution-method-%EB%8C%80%EC%9E%85%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#substitution-method-대입법"
  },"101": {
    "doc": "1. simultaneous equations",
    "title": "Elimination Method 소거법",
    "content": "두 방정식을 더하거나 빼서 하나의 변수를 제거한 후 해 구하기 . 예시 . \\[\\begin{cases} 2x + 3y = 12\\\\ 4x - y = 10 \\end{cases}\\] . 풀이 . 1.두번째 식 y 계수를 첫번째 식과 맞추기 위해 3을 곱하기 . \\[3 \\times 4x - y = 10 \\\\ \\Rightarrow 12x - 3y = 30\\] . 2.첫번째 식과 두번째 식을 더해 y 소거 . \\[\\; 2x + 3y = 12\\\\ + 12x - 3y = 30\\\\ 14x = 42 \\\\ \\Rightarrow x = 3\\] . 3.x=3을 대입해 y 구하기 . \\[4(3) - y = 10 \\\\ \\Rightarrow 12 - y = 10 \\\\\\Rightarrow y = 2\\] . 최종 해 . \\[x = 3, \\; y = 2\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#elimination-method-%EC%86%8C%EA%B1%B0%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#elimination-method-소거법"
  },"102": {
    "doc": "1. simultaneous equations",
    "title": "Graphing Method 그래프법",
    "content": "두 방정식을 그래프로 그려 교점을 찾아 해 구하기 . | y = ax + n 기울기-절편식으로 주로 품 | . 예시 . \\[\\begin{cases} x + 3y = 12\\\\ 2x - y = 5 \\end{cases}\\] . 풀이 . 1.첫번째 방정식을 기울기절편 형식으로 만들기 . \\[x - x + 3y = -x + 12 \\\\ 3y = -x + 12 \\\\\\] . 2.첫번째 식 계산 . \\[\\frac{3y}{3} = -\\frac{x}{3} + \\frac{12}{3} \\\\ \\Rightarrow y = -\\frac{1}{3}x + 4\\] . 3.두번째 방정식 기울기절편 형식으로 만들기 . \\[2x -2x -y = -2x + 5 \\\\ -y = -2x + 5 \\\\ \\Rightarrow y = 2x - 5\\] . 4.그래프 그려서 두 선이 교차하는 점이 해 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#graphing-method-%EA%B7%B8%EB%9E%98%ED%94%84%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#graphing-method-그래프법"
  },"103": {
    "doc": "1. simultaneous equations",
    "title": "1. simultaneous equations",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html"
  },"104": {
    "doc": "10. 2D Rendering",
    "title": "10. 2D Rendering",
    "content": "대부분의 사용자 인터페이스, 스프라이트 시스템, 텍스트 엔진은 2D 이미지로 구성된다 . | DirectX 11에서는 2D 이미지를 폴리곤에 매핑한 후 직교 투영 행렬을 사용하여 렌더링할 수 있음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html"
  },"105": {
    "doc": "10. 2D Rendering",
    "title": "프레임 워크 요소",
    "content": ". | application class 에 하위 클래스 (BitMapClass) 추가 | BitMap Class에 하위 클래스 (TextureClass) 추가 | LightShaderClass 제거 | TextureShaderClass 추가 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#프레임-워크-요소"
  },"106": {
    "doc": "10. 2D Rendering",
    "title": "2D Screen Coordinates",
    "content": "2D 이미지를 화면에 렌더링하려면 화면의 X 및 Y 좌표를 계산해야 함 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-screen-coordinates",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-screen-coordinates"
  },"107": {
    "doc": "10. 2D Rendering",
    "title": "Screen coordinates",
    "content": "(0,0) ----&gt; X+ | v Y+ . | 원점 (0, 0)이 화면의 왼쪽 위(Top-Left)에 있음 | X값은 오른쪽으로 갈수록 증가 | Y값은 아래쪽으로 갈수록 증가 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#screen-coordinates",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#screen-coordinates"
  },"108": {
    "doc": "10. 2D Rendering",
    "title": "3D World Space",
    "content": ". | 정점 셰이더로 최종적으로 넘겨줘야 하는 좌표계 (정확히는 직교 투영 후의 월드 공간) | 원점 (0, 0)이 화면의 정중앙(Center) | . DirectX의 경우 . | 화면 중앙이 0.0 | . // Calculate the screen coordinates of the left side of the bitmap. left = (float)((m_screenWidth / 2) * -1) + (float)m_renderX; // Calculate the screen coordinates of the right side of the bitmap. right = left + (float)m_bitmapWidth; // Calculate the screen coordinates of the top of the bitmap. top = (float)(m_screenHeight / 2) - (float)m_renderY; // Calculate the screen coordinates of the bottom of the bitmap. bottom = top - (float)m_bitmapHeight; . | (m_screenWidth / 2) * -1 . | 이 부분은 화면의 가장 왼쪽 끝의 X좌표를 구하는 것 | 예: 화면 너비가 800이라면, 화면 중앙의 X는 0, 왼쪽 끝의 X는 -400 | . | (float)m_renderX: 위에서 구한 왼쪽 끝 위치에서, m_renderX 값만큼 오른쪽으로 이동 | . “일단 화면의 가장 왼쪽 끝으로 이동한 뒤, 거기서부터 m_renderX 픽셀만큼 오른쪽으로 간다.” . | 이 과정은 좌표계 Screen의 X값을 World space의 X값으로 변환한다 | . | right = left + (float)m_bitmapWidth . | left 에 비트맵의 너비(m_bitmapWidth)를 더하면 오른쪽 변의 위치가 나옴 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#3d-world-space",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#3d-world-space"
  },"109": {
    "doc": "10. 2D Rendering",
    "title": "예시",
    "content": ". | 화면 크기: 800 x 600 | 그리고 싶은 위치: m_renderX = 100, m_renderY = 200 | 비트맵 크기: 50 x 50 | . | left = (800 / 2) -1 + 100 = -400 + 100 = -300 | top = (600 / 2) - 200 = 300 - 200 = 100 | right = -300 + 50 = -250 | bottom = 100 - 50 = 50 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#예시"
  },"110": {
    "doc": "10. 2D Rendering",
    "title": "Disabling Z buffer in DirectX 11",
    "content": "2D 렌더링은 Z-버퍼를 비활성화한다. 즉 깊이 테스트(Depth Test)를 하지 않는다. ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#disabling-z-buffer-in-directx-11",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#disabling-z-buffer-in-directx-11"
  },"111": {
    "doc": "10. 2D Rendering",
    "title": "Z-버퍼(깊이 버퍼)의 역할",
    "content": "Z-버퍼는 3D 렌더링에서 사용되는 화면 크기와 동일한 2D 배열(메모리 공간) . | 각 픽셀의 깊이(Depth) 정보, 즉 카메라로부터 얼마나 멀리 떨어져 있는지를 나타내는 Z값을 저장 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#z-%EB%B2%84%ED%8D%BC%EA%B9%8A%EC%9D%B4-%EB%B2%84%ED%8D%BC%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#z-버퍼깊이-버퍼의-역할"
  },"112": {
    "doc": "10. 2D Rendering",
    "title": "Depth Buffering",
    "content": ". | 지금 그리려는 픽셀의 Z값을 계산 | Z-버퍼에서 같은 위치(x, y)에 이미 저장된 Z값을 읽어옴 | 새로 그릴 픽셀의 Z값이 기존 Z값보다 작으면 (카메라에 더 가까우면), 해당 픽셀을 화면에 그리고 Z-버퍼의 값도 새로운 Z값으로 업데이트 | 그렇지 않으면 (카메라에 더 멀리 있으면), 새로 그릴 픽셀을 그냥 버림 (그리지 않는다) | . 이 과정을 통해 3D 공간에서 물체들이 서로를 올바르게 가리는 현상(Occlusion)을 처리 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#depth-buffering",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#depth-buffering"
  },"113": {
    "doc": "10. 2D Rendering",
    "title": "2D 렌더링에서 Z-버퍼를 비활성화하는 이유",
    "content": "1. 그리는 순서가 곧 레이어 순서 . | 일반적인 2D 렌더링(UI, 스프라이트 등)에서는 깊이 개념이 없음 | 배경을 먼저 그리고, 그 위에 캐릭터를 그리고, 마지막으로 점수판 UI를 그리는 것처럼 | 그리는 순서(Draw Call 순서)가 곧 화면에 보이는 레이어 순서가 됨 | 마지막에 그린 것이 항상 가장 위에 보여야 하므로, Z값을 비교하는 깊이 테스트는 불필요하며 오히려 방해가 될 수 있다 | . 2. 성능 향상 . | 2D UI처럼 화면 전체를 덮는 요소를 그릴 때 이 기능을 끄면 불필요한 연산을 줄여 약간의 성능 향상을 얻을 수 있음 | . 3. Z-파이팅(Z-Fighting) 방지 . | 만약 여러 2D 객체를 모두 같은 Z값(예: 0)으로 렌더링하면 | 부동소수점 정밀도 문제로 인해 어떤 픽셀이 그려져야 할지 GPU가 정확히 판단하지 못해 | 화면이 깜빡거리거나 깨지는 Z-파이팅 현상이 발생할 수 있다 | . | 깊이 테스트 상태 변경으로 비활성화 하기 | . // D3D11_DEPTH_STENCIL_DESC 구조체를 사용하여 렌더링 상태를 정의 // 구조체의 DepthEnable 멤버를 FALSE로 설정 D3D11_DEPTH_STENCIL_DESC depthDisabledStencilDesc; ZeroMemory(&amp;depthDisabledStencilDesc, sizeof(depthDisabledStencilDesc)); // 깊이 테스트 off depthDisabledStencilDesc.DepthEnable = FALSE; // ... (나머지 설정) // ID3D11DepthStencilState 객체를 생성 (CreateDepthStencilState 함수 사용) m_pDeviceContext-&gt;OMSetDepthStencilState(m_pDepthDisabledStencilState, 1); . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90%EC%84%9C-z-%EB%B2%84%ED%8D%BC%EB%A5%BC-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-렌더링에서-z-버퍼를-비활성화하는-이유"
  },"114": {
    "doc": "10. 2D Rendering",
    "title": "Dynamic Vertex Buffers in 2D rendering",
    "content": "2D 렌더링에서 동적 정점 버퍼를 사용하는 이유는 2D 객체들의 특성과 렌더링 최적화 기법인 ‘배치(Batch) 렌더링’ 때문 . 끊임없이 변하는 2D 객체 . | UI 요소 . | 마우스 커서, 클릭에 반응하는 버튼, 움직이는 창, 바뀌는 텍스트 등 | 매 프레임 위치나 모양, 내용이 바뀔 수 있다 | . | 스프라이트 . | 캐릭터나 적들은 계속해서 위치를 바꾸고, 애니메이션에 따라 텍스처 좌표(UV)가 바뀔 수 있다 | . | . 이처럼 매 프레임 정점 데이터(위치, 텍스처 좌표 등)가 바뀌는 객체들을 효율적으로 처리하려면 . | 매번 버퍼를 새로 생성하는 것보다 동적 버퍼의 내용을 Map/Unmap으로 업데이트하는 것이 훨씬 빠름 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#dynamic-vertex-buffers-in-2d-rendering",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#dynamic-vertex-buffers-in-2d-rendering"
  },"115": {
    "doc": "10. 2D Rendering",
    "title": "Batch Rendering",
    "content": "배치 렌더링은 Draw 명령 횟수를 줄이기 위한 기법 . | 비슷한 물체들을 한 번에 묶어서 GPU에 그리라고 요청하는 기술 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#batch-rendering",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#batch-rendering"
  },"116": {
    "doc": "10. 2D Rendering",
    "title": "Draw Call",
    "content": "GPU에 그리기 명령(Draw Call)을 한 번 내리는 것은 상당한 비용이 드는 작업이다 . | CPU가 GPU에게 명령을 전달할 때마다 다음과 같은 오버헤드(추가 작업)가 발생 . | 상태 변경(State Switching): 어떤 셰이더를 쓸지, 어떤 텍스처를 입힐지 등 렌더링 설정을 계속 바꿔야 함 | 드라이버 오버헤드: CPU의 명령을 GPU가 이해할 수 있는 형태로 변환하는 과정에서 시간이 소요 | CPU 병목 현상: CPU가 너무 바쁘게 드로우 콜을 보내느라, GPU는 명령을 기다리며 쉬게 되는 현상이 발생할 수 있음 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#draw-call",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#draw-call"
  },"117": {
    "doc": "10. 2D Rendering",
    "title": "Batch Rendering VS basic Rendering",
    "content": "컴퓨터 그래픽에서 화면에 무언가를 그리려면 CPU가 GPU에게 드로우 콜 명령을 내려야 함 . basic Rendering . 만약 화면에 돌멩이 1,000개를 그려야 한다면, 가장 단순한 방법은 다음과 같다 . | CPU: “돌멩이 1번 그려줘!” -&gt; GPU: (그림) | CPU: “돌멩이 2번 그려줘!” -&gt; GPU: (그림) | … | CPU: “돌멩이 1000번 그려줘!” -&gt; GPU: (그림) | . 이 방식은 드로우 콜을 1,000번이나 발생시킴 . Batch Rendering . 만약 1,000개의 돌멩이가 모두 같은 모양과 재질(텍스처, 셰이더)을 사용한다면, 굳이 1,000번씩이나 명령을 내릴 필요가 없음 . | 배치 렌더링은 이 비효율을 개선시킴 | CPU: “여기 돌멩이 1,000개 정보가 있는데, 전부 같은 방식으로 한 번에 그려줘!” -&gt; GPU: (1,000개를 한 번의 명령으로 그림) | . 즉, 드로우 콜이 단 1번으로 줄어든다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#batch-rendering-vs-basic-rendering",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#batch-rendering-vs-basic-rendering"
  },"118": {
    "doc": "10. 2D Rendering",
    "title": "배치 렌더링의 조건",
    "content": "보통 아래와 같은 속성들이 동일한 객체들을 하나의 배치(Batch)로 묶을 수 있음 . | 머티리얼 (Material): 동일한 셰이더(Shader)와 텍스처(Texture)를 사용하는 객체들 | 렌더링 상태 (Render State): 투명도 설정(Alpha Blending), 깊이 테스트(Depth Test) 등 렌더링 관련 설정이 같은 객체들 | . 대표적인 배치 렌더링 기법 . | 정적 배치 (Static Batching) . | 게임 중에 움직이지 않는 건물, 바위, 나무 등을 미리 하나의 큰 메쉬(Mesh)로 합쳐버리는 방식 | 가장 효과적이지만 움직이는 객체에는 쓸 수 없음 | . | 동적 배치 (Dynamic Batching) . | 움직이지만 같은 머티리얼을 쓰는 작은 객체들(총알, 파티클 등)을 매 프레임마다 | CPU에서 하나의 버퍼로 묶어 보내는 방식 | . | GPU 인스턴싱 (GPU Instancing) . | 최신 기술로, GPU에게 “이 메쉬를 1,000번 그려. 단, 각각의 위치, 크기, 색상은 이 데이터를 참고해” 라고 한 번에 명령하는 방식 | 풀, 나무, 군중 등 똑같이 생긴 객체를 대량으로 그릴 때 매우 효율적 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#%EB%B0%B0%EC%B9%98-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%98-%EC%A1%B0%EA%B1%B4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#배치-렌더링의-조건"
  },"119": {
    "doc": "10. 2D Rendering",
    "title": "Bitmap Quad",
    "content": "비트맵 쿼드(Bitmap Quad)는 간단하게 말해 2D 비트맵 이미지를 띄우기 위한 판 이다 . | Direct3D 같은 3D 그래픽스 API는 픽셀로 이루어진 2D 이미지를 직접 화면에 그릴 수 없다 | API는 오직 정점(Vertex)으로 구성된 폴리곤(Polygon), 주로 삼각형(Triangle)만을 그릴 수 있음 | . 따라서 2D 이미지를 화면에 보여주려면, 일종의 ‘꼼수’가 필요 . | 먼저 3D 공간에 납작한 사각형(Quad) 모양의 판을 하나 만든다 . | 이 사각형은 보통 2개의 삼각형으로 이루어짐 | . | 보여주고 싶은 2D 이미지(비트맵)를 이 사각형 판 위에 텍스처(Texture)로 입힌다 | . | 즉 GPU는 사각형 plane의 정점 데이터를 바탕으로 비트맵 쿼드를 그리고, | 픽셀 셰이더가 텍스처 좌표를 이용해 그 위에 이미지를 입혀 최종적으로 우리가 보는 2D 이미지가 화면에 나타나게 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#bitmap-quad",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#bitmap-quad"
  },"120": {
    "doc": "10. 2D Rendering",
    "title": "2D rendering loop",
    "content": "매 프레임마다 다음 과정이 반복 . | 씬 시작 . | m_Direct3D-&gt;BeginScene()을 호출하여 백 버퍼(Back Buffer)와 깊이 버퍼를 특정 색으로 초기화 | . | Z-Buffer 비활성화 . | m_Direct3D-&gt;TurnZBufferOff()를 호출하여 깊이 테스트 끄기. | 2D 이미지를 화면에 그릴 때는 3D 객체처럼 깊이를 비교할 필요 없이, 그리는 순서대로 화면에 덮어쓰기 위함 | . | 비트맵 렌더링 준비 (BitmapClass::Render) . | UpdateBuffers(): 비트맵의 위치나 크기가 변경되었는지 확인 | 만약 변경되었다면, 새로운 위치에 맞는 화면 좌표를 계산하여 정점 버퍼의 내용을 갱신 . | 이 과정은 GPU 메모리에 있는 정점 버퍼를 직접 수정(Map, Unmap) | . | RenderBuffers(): 준비된 정점/인덱스 버퍼를 입력 조립기(Input Assembler) 단계에 바인딩하여 GPU가 그릴 수 있도록 설정 | . | 셰이더 실행 및 드로우 콜 (TextureShaderClass::Render) . | SetShaderParameters(): 월드, 뷰, 프로젝션(여기서는 직교) 행렬과 비트맵의 텍스처를 셰이더로 전달 | RenderShader(): GPU에 최종적으로 그리라는 명령(DrawIndexed)을 내림 | 이 호출로 인해 비트맵의 사각형 폴리곤이 렌더링 파이프라인을 통과하고, 픽셀 셰이더에 의해 텍스처가 입혀져 화면에 그려짐 | . | Z-Buffer 활성화 . | m_Direct3D-&gt;TurnZBufferOn()를 호출하여 깊이 테스트를 다시 킴 | 이후에 3D 객체를 그릴 경우를 대비하기 위함 | . | 씬 종료 . | m_Direct3D-&gt;EndScene()을 호출하여 완성된 백 버퍼의 내용을 화면에 표시(Present) | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-rendering-loop",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/10.%202D%20rendering.html#2d-rendering-loop"
  },"121": {
    "doc": "11. Sprites and Timers",
    "title": "11. Sprites and Timers",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html"
  },"122": {
    "doc": "11. Sprites and Timers",
    "title": "Data Driven Design 데이터 기반 설계",
    "content": "프로그램의 핵심 로직(알고리즘)과 이 로직이 사용할 데이터를 명확하게 분리하는 소프트웨어 설계 방식 . | 렌더링할 객체의 속성 (색상, 크기, 위치 등)을 코드 안에 직접 하드코딩하지 않음 | 텍스트 파일, 슬라이더가 있는 도구 등을 사용하여 프로그램의 내용이나 흐름을 제어 | . 예제에서는 스프라이트 작동 방식을 텍스트 파일을 읽어 제어하는 방식으로 구현 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#data-driven-design-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B8%B0%EB%B0%98-%EC%84%A4%EA%B3%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#data-driven-design-데이터-기반-설계"
  },"123": {
    "doc": "11. Sprites and Timers",
    "title": "Sprite Data",
    "content": "// 스프라이트를 구성하는 targa 이미지의 개수 4 // 스프라이트를 구성하는 각 targa 이미지의 파일 경로 및 이름 ../texture/sprite01.tga ../texture/sprite02.tga ../texture/sprite03.tga ../texture/sprite04.tga // 스프라이트가 이미지를 순환할 속도(밀리초) 250 . | 해당 텍스트 파일을 읽어 파싱한 뒤 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#sprite-data",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#sprite-data"
  },"124": {
    "doc": "11. Sprites and Timers",
    "title": "Sprite rendering (스프라이트 애니메이션 렌더링 흐름)",
    "content": "여러 장의 텍스처를 배열에 저장해두고, 일정한 시간마다 다음 텍스처로 교체하여 화면에 그려주는 방식으로 동작 . | 전체 흐름은 초기화 → 프레임 업데이트 → 렌더링 순서로 진행 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#sprite-rendering-%EC%8A%A4%ED%94%84%EB%9D%BC%EC%9D%B4%ED%8A%B8-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#sprite-rendering-스프라이트-애니메이션-렌더링-흐름"
  },"125": {
    "doc": "11. Sprites and Timers",
    "title": "1. 초기화 및 텍스처 로딩",
    "content": "애플리케이션 시작 시, SpriteClass는 애니메이션에 사용될 모든 텍스처를 미리 로드하여 m_Textures 배열에 저장 . bool SpriteClass::LoadTextures(ID3D11Device* device, ID3D11DeviceContext* deviceContext, char* filename) { ifstream fin; // ... // 파일에서 텍스처 개수 읽기 fin &gt;&gt; m_textureCount; // 텍스처 개수만큼 배열 할당 m_Textures = new TextureClass[m_textureCount]; // 각 텍스처 파일에 대해 반복하며 로드 for (i = 0; i &lt; m_textureCount; i++) { // ... (파일 경로 읽기) // m_Textures 배열의 각 요소에 텍스처를 로드 result = m_Textures[i].Initialize(device, deviceContext, textureFilename); // ... } // 애니메이션 주기(cycle time) 읽기 fin &gt;&gt; m_cycleTime; // ... // 정수 밀리초를 부동 소수점 형식으로 변환 m_cycleTime = m_cycleTime * 0.001f; return true; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#1-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%8F-%ED%85%8D%EC%8A%A4%EC%B2%98-%EB%A1%9C%EB%94%A9",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#1-초기화-및-텍스처-로딩"
  },"126": {
    "doc": "11. Sprites and Timers",
    "title": "2. 프레임 업데이트 및 텍스처 갱신",
    "content": "매 프레임마다 어떤 텍스처를 보여줄지 결정 . // spriteclass.cpp void SpriteClass::Update(float frameTime) { // 매 프레임마다 경과 시간을 누적 m_frameTime += frameTime; // 누적 시간이 설정된 주기를 넘었는지 확인 if (m_frameTime &gt;= m_cycleTime) { // 누적 시간을 재설정하고 다음 텍스처로 전환 m_frameTime -= m_cycleTime; // 다음 텍스처를 가리키도록 인덱스 증가 m_currentTexture++; // 마지막 텍스처였다면 처음으로 되돌림 if (m_currentTexture == m_textureCount) { m_currentTexture = 0; } } } . | 프레임 간의 경과 시간(frameTime)을 m_frameTime에 누적 | 누적된 시간이 지정된 주기(m_cycleTime)를 넘어서면, 현재 텍스처를 가리키는 인덱스 m_currentTexture를 1 증가시켜 다음 프레임으로 전환 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#2-%ED%94%84%EB%A0%88%EC%9E%84-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%B0%8F-%ED%85%8D%EC%8A%A4%EC%B2%98-%EA%B0%B1%EC%8B%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#2-프레임-업데이트-및-텍스처-갱신"
  },"127": {
    "doc": "11. Sprites and Timers",
    "title": "3. 렌더링",
    "content": "Update 함수에서 갱신된 m_currentTexture 인덱스를 사용하여 현재 프레임에 맞는 텍스처를 화면에 그림 . // applicationclass.cpp bool ApplicationClass::Render() { // ... // 셰이더를 통해 그릴 때, m_Sprite-&gt;GetTexture()로 현재 텍스처를 가져옴 result = m_TextureShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Sprite-&gt;GetIndexCount(), worldMatrix, viewMatrix, orthoMatrix, m_Sprite-&gt;GetTexture()); // ... } . // spriteclass.cpp ID3D11ShaderResourceView* SpriteClass::GetTexture() { // m_Textures 배열에서 m_currentTexture 인덱스에 해당하는 텍스처를 반환 return m_Textures[m_currentTexture].GetTexture(); } . | 이 텍스처는 최종적으로 TextureShaderClass에 의해 픽셀 셰이더에 설정되고, DrawIndexed 호출을 통해 화면에 그려짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#3-%EB%A0%8C%EB%8D%94%EB%A7%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#3-렌더링"
  },"128": {
    "doc": "11. Sprites and Timers",
    "title": "Timer",
    "content": "컴퓨터의 CPU는 사람의 심장 박동처럼 일정한 속도로 신호를 만들어내는 내부 시계(Internal Clock)를 가지고 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#timer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#timer"
  },"129": {
    "doc": "11. Sprites and Timers",
    "title": "Crystal Oscillator",
    "content": "특정 모양으로 자른 수정 조각에 전압을 가하면, 수정이 일정한 주파수(Frequency)로 매우 빠르게 떨리는 압전 효과(Piezoelectric Effect)가 발생 . | 떨림이 바로 규칙적인 전기 신호, 즉 클럭 신호(Clock Signal)가 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#crystal-oscillator",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#crystal-oscillator"
  },"130": {
    "doc": "11. Sprites and Timers",
    "title": "Clock Speed &amp; Hz (클럭 속도와 헤르츠)",
    "content": "얼마나 빨리 진동하는지 나타내는 단위가 바로 클럭 속도(Clock Speed), 헤르츠(Hz)로 측정 . - 1 Hz: 1초에 1번 진동하는 속도 - 1 KHz (킬로헤르츠): 1초에 1,000번 - 1 MHz (메가헤르츠): 1초에 1,000,000번 (백만 번) - 1 GHz (기가헤르츠): 1초에 1,000,000,000번 (십억 번) . | 3.2 GHz CPU는 1초에 32억 번의 클럭 신호를 만들어 냄 | 이 신호는 0과 1이 반복되는 디지털 파형(Square Wave)의 형태를 가짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-speed--hz-%ED%81%B4%EB%9F%AD-%EC%86%8D%EB%8F%84%EC%99%80-%ED%97%A4%EB%A5%B4%EC%B8%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-speed--hz-클럭-속도와-헤르츠"
  },"131": {
    "doc": "11. Sprites and Timers",
    "title": "Clock Cycle",
    "content": "CPU가 가장 기본적인 작업을 수행하는 데 걸리는 시간 단위. 진동 한번을 클럭 사이클(Clock Cycle) 또는 클럭 틱(Clock Tick)이라고 부름 . | 신호가 한 번 올라갔다가 내려와 제자리로 돌아오는 전체 과정을 1 클럭 사이클이라고 한다 | CPU는 이 클럭 싸이클이 일어날 때 하나의 기본 연산을 처리 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-cycle",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-cycle"
  },"132": {
    "doc": "11. Sprites and Timers",
    "title": "클럭 사이클과 CPU 연산",
    "content": "클럭 사이클은 CPU가 수행할 수 있는 가장 작고 원자적인(atomic) 작업의 기준이 됨 . 명령어(Instruction) 와의 관계: ‘1 클럭 사이클 = 1 명령어’가 아니라는 것 . 프로그래밍 언어의 한 줄 (a = b + c;) 은 컴파일을 거치면 여러 개의 기계어 명령어(Instruction)로 번역된다 . 그리고 이 기계어 명령어 하나를 처리하기 위해서는 또다시 여러 번의 클럭 사이클이 필요하다 . | 1단계 (Fetch): 메모리에서 명령어를 가져온다. (여러 클럭 사이클 소요) | 2단계 (Decode): 명령어를 해석한다. (여러 클럭 사이클 소요) | 3단계 (Execute): 명령어를 실행한다. (여러 클럭 사이클 소요) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#%ED%81%B4%EB%9F%AD-%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC-cpu-%EC%97%B0%EC%82%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#클럭-사이클과-cpu-연산"
  },"133": {
    "doc": "11. Sprites and Timers",
    "title": "Clock Cycle vs Clock Speed",
    "content": ". | 클럭 사이클 (Clock Cycle): 시간의 길이 . | 시간의 단위 | CPU가 가장 기본적인 작업 하나를 처리하는 데 필요한 시간을 의미 | . | 클럭 속도 (Clock Speed): 빈도(빠르기) . | 주파수 빠르기의 단위 | 1초 동안 클럭 사이클이 몇 번이나 반복되는지를 나타냄. 단위는 헤르츠(Hz) | . | . | 관점 | 클럭 사이클 (Clock Cycle) | 클럭 속도 (Clock Speed) | . | 의미 | 한 번의 진동에 걸리는 시간 | 1초당 발생하는 진동의 횟수 | . | 단위 | 초 (s), 나노초 (ns) | 헤르츠 (Hz), 기가헤르츠 (GHz) | . | 비유 | 걸음 하나에 걸리는 시간 | 1초에 걷는 걸음 수 | . 예시 어떤 CPU의 클럭 속도가 4 GHz 라 가정 . | 4 GHz = 4,000,000,000 Hz (1초에 40억 번 진동) | 이 CPU의 클럭 사이클 시간은 1 / 4,000,000,000 초 = 0.00000000025 초 | . 이것을 읽기 쉽게 나노초(ns, 10억 분의 1초) 단위로 바꾸면 0.25 ns . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-cycle-vs-clock-speed",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#clock-cycle-vs-clock-speed"
  },"134": {
    "doc": "11. Sprites and Timers",
    "title": "KEYWORD NOTE",
    "content": "sprite, timer class 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#keyword-note"
  },"135": {
    "doc": "11. Sprites and Timers",
    "title": "INT64",
    "content": ". | 64 bit (8 바이트) 부호있는 정수 타입 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#int64",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#int64"
  },"136": {
    "doc": "11. Sprites and Timers",
    "title": "LARGE_INTEGER",
    "content": "64비트 정수를 저장하는 공용체(union) 구조체 . typedef union _LARGE_INTEGER { struct { DWORD LowPart; // 하위 32비트 LONG HighPart; // 상위 32비트 }; LONGLONG QuadPart; // 전체 64비트 값 } LARGE_INTEGER; . 32비트와 64비트 시스템 모두에서 호환되도록 설계됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#large_integer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#large_integer"
  },"137": {
    "doc": "11. Sprites and Timers",
    "title": "QueryPerformanceFrequency()",
    "content": "BOOL QueryPerformanceFrequency(LARGE_INTEGER* lpFrequency); . | 반환값: 성공 시 0이 아닌 값, 실패 시 0 | 사용 목적: 시스템의 고성능 카운터 주파수 (초당 카운트 수)를 얻음 | . 시스템이 초당 몇 번의 카운트를 하는지 확인하여 시간 계산의 기준이 됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#queryperformancefrequency",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#queryperformancefrequency"
  },"138": {
    "doc": "11. Sprites and Timers",
    "title": "QueryPerformanceCounter()",
    "content": "BOOL QueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount); . | 반환값: 성공 시 0이 아닌 값, 실패 시 0 | 사용 목적: 현재의 고성능 카운터 값을 얻어 시간 측정에 사용 | . 사용 예시 . // 시간 측정 시작 INT64 startTime; QueryPerformanceCounter((LARGE_INTEGER*)&amp;startTime); // 어떤 작업 수행 // ... // 시간 측정 종료 INT64 endTime; QueryPerformanceCounter((LARGE_INTEGER*)&amp;endTime); // 경과 시간 계산 (초 단위) float elapsedTime = (float)(endTime - startTime) / m_frequency; //m_startTime에 저장되는 실제 값 INT64 m_startTime = 35829476123456; // 약 3.58 × 10^13 // 이 값의 의미: // - CPU가 부팅된 이후의 클럭 사이클 수 // - CPU 주파수가 3.0GHz라면: // 35,829,476,123,456 사이클 ÷ 3,000,000,000 Hz = 약 11,943초 (3.3시간) . 시간 변환 예시 . // 밀리초 변환 double elapsedSeconds = (double)elapsedCycles / m_frequency; // 초 단위 std::cout &lt;&lt; \"경과 시간: \" &lt;&lt; elapsedSeconds * 1000.0 &lt;&lt; \" ms\" &lt;&lt; std::endl; // 사이클당 시간 계산 double timePerCycle = 1.0 / m_frequency; // 초 단위 std::cout &lt;&lt; \"사이클당 시간: \" &lt;&lt; timePerCycle * 1000000.0 &lt;&lt; \" 마이크로초\" &lt;&lt; std::endl; . | 경과 시간 × 1000.0: 초 → 밀리초 (게임 루프, 프레임 시간에 적합) | 사이클 시간 × 1000000.0: 초 → 마이크로초 (CPU 내부 동작 시간 측정에 적합) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#queryperformancecounter",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/11.%20Sprites%20and%20Timers.html#queryperformancecounter"
  },"139": {
    "doc": "12. font engine",
    "title": "12. font engine",
    "content": "화면에 텍스트 쓰기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html"
  },"140": {
    "doc": "12. font engine",
    "title": "프레임 워크 요소",
    "content": ". | FontClass 추가 : 글꼴 데이터를 저장하고 문자열 렌더링에 필요한 정점 버퍼 생성 | TextClass 추가 : 화면에 렌더링해야 하는 각 텍스트 문자열 세트에 대한 정점 버퍼와 인덱스 버퍼 설정 | FontShaderClass 추가 : 폰트 쉐이더로 해당 버퍼 렌더링 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#프레임-워크-요소"
  },"141": {
    "doc": "12. font engine",
    "title": "Font data",
    "content": ". | font.txt | . 32 0.0 0.0 0 33 ! 0.0 0.00390625 4 34 \" 0.0048828125 0.0107421875 6 35 # 0.01171875 0.025390625 14 36 $ 0.0263671875 0.0390625 13 37 % 0.0400390625 0.0546875 15 38 &amp; 0.0556640625 0.0693359375 14 //... 순서대로 . [문자의 ASCII 값] [문자] [왼쪽 텍스처 U 좌표] [오른쪽 텍스처 U 좌표] [문자의 픽셀 너비] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-data",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-data"
  },"142": {
    "doc": "12. font engine",
    "title": "Font data Load",
    "content": "위에 있는 font.txt 파일을 읽어 m_Font 배열에 저장 . struct FontType { float left, right; int size; }; // 폰트 텍스트 파일 파싱하여 FontType에 데이터 저장하기 bool FontClass::LoadFontData(char* filename) { ifstream fin; int i; char temp; // Create the font spacing buffer. m_Font = new FontType[95]; // Read in the font size and spacing between chars. fin.open(filename); if (fin.fail()) { return false; } // Read in the 95 used ascii characters for text. for (i = 0; i &lt; 95; i++) { fin.get(temp); while (temp != ' ') { fin.get(temp); } fin.get(temp); while (temp != ' ') { fin.get(temp); } fin &gt;&gt; m_Font[i].left; fin &gt;&gt; m_Font[i].right; fin &gt;&gt; m_Font[i].size; } // Close the file. fin.close(); return true; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-data-load",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-data-load"
  },"143": {
    "doc": "12. font engine",
    "title": "font vertex array",
    "content": "각 문자마다 문자를 그릴 사각형 생성해주기 . // text class에서 호출되어 입력으로 전송된 텍스트 문장 기반으로 정점 버퍼 생성 void FontClass::BuildVertexArray(void* vertices, char* sentence, float drawX, float drawY) { VertexType* vertexPtr; int numLetters, index, i, letter; // 매개변수 vertices를 VertexType 구조체로 변환 vertexPtr = (VertexType*)vertices; // 문장의 문자 수를 가져오기 numLetters = (int)strlen(sentence); // 배열의 인덱스 초기화 index = 0; // 텍스처 좌표와 픽셀 크기를 갖는 m_Font 배열을 사용하여 글꼴 텍스처의 문자를 두 삼각형에 매핑 // 각 문자를 사각형에 그리기 (사각형 = 두개의 삼각형) for (i = 0; i &lt; numLetters; i++) { // 아스키 코드를 m_font 배열의 유효한 0기반 인덱스로 변환 letter = ((int)sentence[i]) - 32; // 공백 문자일 경우 3픽셀 이동 if (letter == 0) { drawX = drawX + m_spaceSize; } else { // First triangle in quad. vertexPtr[index].position = XMFLOAT3(drawX, drawY, 0.0f); // Top left. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 0.0f); index++; vertexPtr[index].position = XMFLOAT3((drawX + m_Font[letter].size), (drawY - m_fontHeight), 0.0f); // Bottom right. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 1.0f); index++; vertexPtr[index].position = XMFLOAT3(drawX, (drawY - m_fontHeight), 0.0f); // Bottom left. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 1.0f); index++; // Second triangle in quad. vertexPtr[index].position = XMFLOAT3(drawX, drawY, 0.0f); // Top left. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].left, 0.0f); index++; vertexPtr[index].position = XMFLOAT3(drawX + m_Font[letter].size, drawY, 0.0f); // Top right. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 0.0f); index++; vertexPtr[index].position = XMFLOAT3((drawX + m_Font[letter].size), (drawY - m_fontHeight), 0.0f); // Bottom right. vertexPtr[index].texture = XMFLOAT2(m_Font[letter].right, 1.0f); index++; // Update the x location for drawing by the size of the letter and one pixel. drawX = drawX + m_Font[letter].size + 1.0f; } } return ; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-vertex-array",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#font-vertex-array"
  },"144": {
    "doc": "12. font engine",
    "title": "KEYWORD NOTE",
    "content": "헷갈리는 키워드 정리 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#keyword-note"
  },"145": {
    "doc": "12. font engine",
    "title": "ShaderResourceView",
    "content": "셰이더가 텍스쳐를 어떻게 해석할지 방법 지정 . | GPU가 리소스에 안전하게 접근할 수 있는 인터페이스를 제공 | . ShaderResourceView 사용 예시 . | 동일한 텍스쳐를 두 가지 방식으로 해석하기 | . // 같은 텍스처를 두 가지 방식으로 해석하는 예제 ID3D11Texture2D* texture; // 원본 텍스처 // SRV 1: RGB 채널로 해석 (색상 텍스처용) D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc1; ID3D11ShaderResourceView* srvColorSRV; srvDesc1.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // 컬러로 해석 // SRV 2: R 채널만 해석 (흑백 높이맵용) D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc2; ID3D11ShaderResourceView* srvHeightSRV; srvDesc2.Format = DXGI_FORMAT_R8_UNORM; // 흑백으로 해석 // 같은 텍스처, 다른 SRV 두 개 생성 m_device-&gt;CreateShaderResourceView(texture, &amp;srvDesc1, &amp;srvColorSRV); m_device-&gt;CreateShaderResourceView(texture, &amp;srvDesc2, &amp;srvHeightSRV); . | 픽셸 쉐이더에서 여러 SRV 사용 예시 | . // 실제 게임에서의 사용 예시 class Character { ID3D11Texture2D* m_diffuseTexture; // 알베도 맵 (색상) ID3D11Texture2D* m_normalTexture; // 노말 맵 (법선 벡터) ID3D11Texture2D* m_specularTexture; // 스페큘러 맵 (반사 강도) // 각 텍스처별로 SRV 생성 ID3D11ShaderResourceView* m_diffuseSRV; ID3D11ShaderResourceView* m_normalSRV; ID3D11ShaderResourceView* m_specularSRV; }; // 픽셀 셰이더에서 동시에 여러 SRV 사용 void RenderCharacter() { // 각 SRV를 다른 슬롯에 바인딩 context-&gt;PSSetShaderResources(0, 1, &amp;m_diffuseSRV); // t0: 색상 context-&gt;PSSetShaderResources(1, 1, &amp;m_normalSRV); // t1: 법선 context-&gt;PSSetShaderResources(2, 1, &amp;m_specularSRV); // t2: 반사 } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#shaderresourceview",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#shaderresourceview"
  },"146": {
    "doc": "12. font engine",
    "title": "SUBRESOURCE_DATA vs SHADER_RESOURCE_VIEW",
    "content": "두 구조체의 역할이 헷갈려서 다시 알아보았다 . | D3D11_SUBRESOURCE_DATA : 데이터를 VRAM에 복사 | D3D11_SHADER_RESOURCE_VIEW_DESC : 어떤 종류의 리소스인지 셰이더에게 해석 넘김 | . // [1단계]: 데이터 준비 (SUB_RESOURCE_DATA) std::vector&lt;unsigned char&gt; imageData = LoadImage(\"character.png\"); D3D11_SUBRESOURCE_DATA textureData; textureData.pSysMem = imageData.data(); // \"데이터는 여기있어\" textureData.SysMemPitch = 512 * 4; // \"한 줄은 2048바이트야\" textureData.SysMemSlicePitch = 0; // [2단계]: 텍스처 생성 (GPU 메모리에 데이터 복사) ID3D11Texture2D* texture; device-&gt;CreateTexture2D(&amp;texDesc, &amp;textureData, &amp;texture); // ↑ 여기서 textureData의 역할 끝! 데이터 전달 완료 // [3단계]: 해석 방법 설정 (SHADER_RESOURCE_VIEW_DESC) D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc; srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // \"이 텍스처는 RGBA야!\" srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D; srvDesc.Texture2D.MostDetailedMip = 0; srvDesc.Texture2D.MipLevels = 1; // [4단계]: SRV 생성 (셰이더에서 읽을 수 있게) ID3D11ShaderResourceView* srv; device-&gt;CreateShaderResourceView(texture, &amp;srvDesc, &amp;srv); . | 구분 | D3D11_SUBRESOURCE_DATA | D3D11_SHADER_RESOURCE_VIEW_DESC | . | 목적 | CPU → GPU 데이터 복사 | 리소스 해석 방법 정의 | . | 사용 시점 | 리소스 생성할 때 | SRV 생성할 때 | . | 데이터 소스 | CPU 메모리 | GPU 메모리 (이미 있는 리소스) | . | 수명 | 일회성 사용 | SRV와 함께 유지 | . | SubResourceData : “데이터를 어떻게 GPU에 올릴지” | ShaderResourceViewDesc : “올라간 데이터를 어떻게 해석할지” | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#subresource_data-vs-shader_resource_view",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#subresource_data-vs-shader_resource_view"
  },"147": {
    "doc": "12. font engine",
    "title": "View",
    "content": "리소스는 그냥 데이터 컨테이너일 뿐, 뷰를 통해야만 역할이 부여 . Direct3D는 모든 리소스 접근에 뷰(View) 시스템을 사용한다 . | SRV(Shader Resource View): GPU에 리소스 해석 설정 | RTV(Render Target View): GPU에 렌더링 결과를 여기에 쓰라고 알림 | UAV(Unordered Access View): 컴퓨트 셰이더에게 병렬 처리 가능한 리소스라고 알림 | DSV(Depth Stencil View): 해당 리소스를 깊이/스텐실 버퍼로 사용하라고 알림 | . 리소스는 직접 접근하지 않고, 뷰를 통해 접근한다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#view",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#view"
  },"148": {
    "doc": "12. font engine",
    "title": "Vertex Input Layout (정점 입력 레이아웃)",
    "content": "GPU가 메모리에 저장된 정점(Vertex) 데이터를 어떻게 해석해야 하는지 알려주는 설명서 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#vertex-input-layout-%EC%A0%95%EC%A0%90-%EC%9E%85%EB%A0%A5-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#vertex-input-layout-정점-입력-레이아웃"
  },"149": {
    "doc": "12. font engine",
    "title": "정점 입력 레이아웃이 뭐야?",
    "content": ". | 3D 모델은 수많은 정점(Vertex)들로 구성됨 | 각 정점은 위치, 색상, 텍스처 좌표, 법선 벡터(Normal Vector) 등 다양한 속성들을 가짐 | 이 정점 데이터는 GPU 메모리의 버퍼(Vertex Buffer)에 저장됨 | . 문제는 이 버퍼가 그저 연속된 바이트(byte) 덩어리일 뿐이라는 점 . | GPU는 이 바이트 덩어리에서 어떤 부분이 위치이고 | 어떤 부분이 색상이며 | 어떤 데이터 타입(float, int 등)을 가지는지 알 수 없다 | . 정점 입력 레이아웃은 바로 이 문제를 해결해줌 . 이는 다음과 같은 정보를 포함하여 GPU에 정점 데이터의 구조를 명확하게 알림 . | Semantic Name (각 정점 속성의 의미) . | “이것은 위치(POSITION)다” | “이것은 색상(COLOR)이다” | “이것은 텍스처 좌표(TEXCOORD)다” 등등 | . | struct 구조체 설정 . | struct Vertex { float x, y, z; float u, v; }; 와 같이 정점 데이터를 정의 | 정점 입력 레이아웃은 C++ 코드의 정점 구조체와 셰이더의 입력 구조체가 서로 일치하도록 보장 | GPU가 정점 버퍼의 원시 데이터를 셰이더가 이해할 수 있는 형태로 파싱할 수 있게 해줌 | . | . 사용 예시 코드 . | C++에서 정의하는 정점 구조체 | . // 이 구조체의 메모리 레이아웃을 GPU에 알려주는 것이 Input Layout의 목적 struct VertexType { DirectX::XMFLOAT3 position; // 3D 위치 (x, y, z) DirectX::XMFLOAT2 texture; // 텍스처 좌표 (u, v) DirectX::XMFLOAT4 color; // 색상 (r, g, b, a) }; . | 정점 입력 레이아웃 설명 (D3D11_INPUT_ELEMENT_DESC 배열) | . // 이 배열이 GPU에게 VertexType 구조체가 어떻게 생겼는지 알림 // VertexType에 3가지 요소가 있으므로 배열 크기 3 D3D11_INPUT_ELEMENT_DESC polygonLayout[3]; // 첫 번째 요소: 위치 (POSITION) polygonLayout[0].SemanticName = \"POSITION\"; // 셰이더에서 'POSITION' 시맨틱과 매칭 polygonLayout[0].SemanticIndex = 0; // POSITION0 (하나만 있으므로 0) polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT; // 3개의 float (X, Y, Z) polygonLayout[0].InputSlot = 0; // 0번 정점 버퍼 슬롯에서 가져옴 polygonLayout[0].AlignedByteOffset = 0; // 정점 구조체 시작으로부터 0바이트 오프셋 polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; // 정점마다 데이터가 다름 polygonLayout[0].InstanceDataStepRate = 0; // 인스턴싱 사용 안 함 // 두 번째 요소: 텍스처 좌표 (TEXCOORD) polygonLayout[1].SemanticName = \"TEXCOORD\"; polygonLayout[1].SemanticIndex = 0; polygonLayout[1].Format = DXGI_FORMAT_R32G32_FLOAT; // 2개의 float (U, V) polygonLayout[1].InputSlot = 0; polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT; // 이전 요소 뒤에 자동으로 오프셋 계산 polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; polygonLayout[1].InstanceDataStepRate = 0; // 세 번째 요소: 색상 (COLOR) polygonLayout[2].SemanticName = \"COLOR\"; polygonLayout[2].SemanticIndex = 0; polygonLayout[2].Format = DXGI_FORMAT_R32G32B32A32_FLOAT; // 4개의 float (R, G, B, A) polygonLayout[2].InputSlot = 0; polygonLayout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT; // 이전 요소 뒤에 자동으로 오프셋 계산 polygonLayout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; polygonLayout[2].InstanceDataStepRate = 0; . | 입력 레이아웃 객체 생성 | . // ID3D11Device* device; // D3D 디바이스 객체 (초기화되어 있어야 함) // ID3DBlob* vertexShaderBuffer; // 컴파일된 버텍스 셰이더 바이트코드 (초기화되어 있어야 함) ID3D11InputLayout* m_layout = nullptr; unsigned int numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]); // 배열 요소 개수 device-&gt;CreateInputLayout( polygonLayout, // 위에서 정의한 레이아웃 설명 배열 numElements, // 배열 요소 개수 vertexShaderBuffer-&gt;GetBufferPointer(), // 버텍스 셰이더 바이트코드 포인터 vertexShaderBuffer-&gt;GetBufferSize(), // 버텍스 셰이더 바이트코드 크기 &amp;m_layout // 생성될 ID3D11InputLayout 객체 포인터 ); if (FAILED(hr)) { } // 에러처리 . | 입력 레이아웃 바인딩 (렌더링 파이프라인 설정 시) | . // ID3D11DeviceContext* deviceContext; // D3D 디바이스 컨텍스트 객체 (초기화되어 있어야 함) deviceContext-&gt;IASetInputLayout(m_layout); // Input Assembler (IA) 스테이지에 레이아웃 설정 . | 버텍스 셰이더 입력 구조체 (HLSL 코드) | . // 이 HLSL 구조체는 C++의 VertexType과 Input Layout에 정의된 내용과 정확히 일치해야 힘 struct VertexInputType { float3 position : POSITION; // SemanticName \"POSITION\", SemanticIndex 0 float2 tex : TEXCOORD; // SemanticName \"TEXCOORD\", SemanticIndex 0 float4 color : COLOR; // SemanticName \"COLOR\", SemanticIndex 0 }; . 정점 입력 레이아웃은 GPU가 정점 버퍼의 데이터를 올바르게 읽고, 이를 버텍스 셰이더의 입력으로 정확하게 전달하기 위한 필수적인 설정 단계이다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#%EC%A0%95%EC%A0%90-%EC%9E%85%EB%A0%A5-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83%EC%9D%B4-%EB%AD%90%EC%95%BC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#정점-입력-레이아웃이-뭐야"
  },"150": {
    "doc": "12. font engine",
    "title": "Sampler (샘플러)",
    "content": "샘플러는 텍스처에서 색상(또는 다른 데이터)을 가져오는(샘플링하는) 방법을 정의하는 GPU의 구성 요소 . | 3D 모델에 텍스처를 입힐 때, 화면의 각 픽셀에 해당하는 텍스처 좌표(UV)가 주어지면 | 샘플러는 이 좌표를 사용하여 텍스처 이미지에서 어떤 색상 값을 가져올지 결정 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#sampler-%EC%83%98%ED%94%8C%EB%9F%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#sampler-샘플러"
  },"151": {
    "doc": "12. font engine",
    "title": "샘플링이 필요한 이유?",
    "content": ". | 비정수 텍스처 좌표 . | 화면 픽셀에 해당하는 텍스처 좌표는 텍스처 이미지의 실제 픽셀(텍셀, Texel) 중심과 정확히 일치하지 않는 경우가 많음 | . | 확대/축소 . | 텍스처가 화면에서 확대되거나 축소될 때, 하나의 텍셀이 여러 화면 픽셀을 덮거나 여러 텍셀이 하나의 화면 픽셀에 압축될 수 있다 | 이때 어떤 색상을 가져와야 자연스러운 결과를 얻을지 결정해야 함 | . | 성능 최적화 . | 밉맵(Mipmap)과 같은 기술을 사용하여 텍스처의 축소 시 발생하는 앨리어싱(aliasing) 현상을 줄이고 성능을 향상 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#%EC%83%98%ED%94%8C%EB%A7%81%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#샘플링이-필요한-이유"
  },"152": {
    "doc": "12. font engine",
    "title": "SamplerState",
    "content": "SamplerState는 텍스처 샘플링 방식을 정의하는 객체 . | C++ 코드에서 D3D11_SAMPLER_DESC 구조체를 채우고 | ID3D11Device::CreateSamplerState() 함수를 호출하여 생성 | . 코드 예시 . | D3D11_SAMPLER_DESC : SamplerState를 정의하는 구조체 | . D3D11_SAMPLER_DESC samplerDesc; ZeroMemory(&amp;samplerDesc, sizeof(samplerDesc)); // 필터링 설정: 텍스처 확대/축소/밉맵 시 어떤 방식으로 색상을 보간할지 결정 // D3D11_FILTER_MIN_MAG_MIP_LINEAR: 축소, 확대, 밉맵 모두 선형 필터링 (부드러움) // D3D11_FILTER_MIN_MAG_MIP_POINT: 축소, 확대, 밉맵 모두 점 필터링 (선명하지만 계단 현상) samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR; // 주소 모드 설정: 텍스처 좌표가 0.0~1.0 범위를 벗어났을 때 처리 방식 samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP; // U 좌표가 범위를 벗어나면 반복 (타일링) samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP; // V 좌표가 범위를 벗어나면 반복 samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP; // W 좌표 (3D 텍스처용) // 밉맵 관련 설정 (선택 사항) samplerDesc.MipLODBias = 0.0f; // 밉맵 레벨 바이어스 samplerDesc.MaxAnisotropy = 1; // 비등방성 필터링 시 최대 비등방성 값 samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS; // 비교 함수 (주로 섀도우 맵에 사용) samplerDesc.BorderColor[0] = 0; samplerDesc.BorderColor[1] = 0; // Border 모드 시 경계 색상 samplerDesc.BorderColor[2] = 0; samplerDesc.BorderColor[3] = 0; samplerDesc.MinLOD = 0; // 최소 밉맵 레벨 samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; // 최대 밉맵 레벨 . | SamplerState 객체 생성 | . ID3D11SamplerState* m_sampleState = nullptr; HRESULT hr = device-&gt;CreateSamplerState(&amp;samplerDesc, &amp;m_sampleState); if (FAILED(hr)) { } // 에러처리 . | 셰이더에 바인딩 | . // 생성된 SamplerState를 픽셀 셰이더에 바인딩 deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState); // 0번 슬롯에 바인딩 . | 픽셀 셰이더와의 연계 | . // C++에서 ID3D11SamplerState* 로 바인딩된 샘플러 스테이트 // register(s0) : 샘플러 스테이트가 0번 샘플러 슬롯에 바인딩되었음을 나타냄 SamplerState SampleType : register(s0); struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; // 텍스처 좌표 }; float4 PixelShaderFunction(PixelInputType input) : SV_TARGET { // Sample() 함수를 사용하여 텍스처에서 색상 샘플링 // SampleType (SamplerState)의 규칙에 따라 shaderTexture (텍스처)에서 // input.tex (텍스처 좌표) 위치의 색상을 가져옴 return shaderTexture.Sample(SampleType, input.tex); } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#samplerstate",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#samplerstate"
  },"153": {
    "doc": "12. font engine",
    "title": "Sample()",
    "content": "HLSL에서 텍스처를 샘플링하기 위한 내장 함수 . color = shaderTexture.Sample(SampleType, input.tex); . | 이 함수는 GPU의 텍스처 샘플링 하드웨어에 직접 명령을 내림 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#sample",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#sample"
  },"154": {
    "doc": "12. font engine",
    "title": "작동 과정",
    "content": ". | 입력: Sample() 함수는 두 가지 주요 인자를 받음 . | SamplerState 객체: 텍스처를 샘플링할 때 적용할 필터링, 주소 모드 등의 규칙을 정의 (예: SampleType) | 텍스처 좌표: 텍스처에서 색상을 가져올 (U, V) 좌표 (예: input.tex) | . | 좌표 변환 및 텍셀 접근: . | GPU는 주어진 텍스처 좌표(input.tex)를 텍스처의 실제 텍셀(픽셀) 좌표로 변환 | 이때 텍스처 좌표가 0.0 ~ 1.0 범위를 벗어나면 SamplerState에 정의된 주소 모드(WRAP, CLAMP 등)에 따라 처리 | . | 필터링 적용: . | 변환된 텍셀 좌표가 텍스처의 텍셀 중심과 정확히 일치하지 않거나, 텍스처가 확대/축소된 경우, SamplerState에 정의된 필터링 방식(POINT, LINEAR, ANISOTROPIC 등)에 따라 주변 텍셀들의 색상 값을 보간하여 최종 색상을 결정 | 밉맵이 사용되는 경우, 적절한 밉맵 레벨을 선택하거나 여러 밉맵 레벨 간에 보간하는 과정도 포함 | . | 결과 반환: . | 이러한 과정을 거쳐 최종적으로 계산된 색상 값(일반적으로 float4 RGBA)을 반환 | 이 색상 값은 픽셀 셰이더의 출력 색상으로 사용되거나, 다른 계산에 활용 | . | . SamplerState는 텍스처 샘플링의 규칙을 정의하는 객체 . | Sample() 함수는 이 규칙을 사용하여 셰이더 내에서 텍스처로부터 색상을 가져오는 GPU의 하드웨어 기능 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#%EC%9E%91%EB%8F%99-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/12.%20font%20engine.html#작동-과정"
  },"155": {
    "doc": "13. FPS Counter, Direct input",
    "title": "13. FPS Counter, Direct input",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html"
  },"156": {
    "doc": "13. FPS Counter, Direct input",
    "title": "FPS",
    "content": "1초 동안 발생하는 프레임 수를 세고 지속적으로 업데이트 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#fps",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#fps"
  },"157": {
    "doc": "13. FPS Counter, Direct input",
    "title": "timeGetTime()",
    "content": "Windows 시스템이 부팅된 후부터 현재까지 경과된 시간을 밀리초(millisecond, 1/1000초) 단위로 반환 . | 리턴값 : DWORD (32비트 부호 없는 정수, unsigned long) | . #include &lt;mmsystem.h&gt; // 헤더 파일 #pragma comment(lib, \"winmm.lib\") // 라이브러리 링크 // 사용 예시 unsigned long endTime = timeGetTime(); std::cout &lt;&lt; \"작업을 종료합니다... 종료 시간: \" &lt;&lt; endTime &lt;&lt; \"ms\" &lt;&lt; std::endl; // 작업을 종료합니다... 종료 시간: 1236568ms . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#timegettime",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#timegettime"
  },"158": {
    "doc": "13. FPS Counter, Direct input",
    "title": "FPS::Frame()",
    "content": "Frame() 함수는 매 렌더링 프레임마다 호출 . 1초 동안 Frame 함수가 얼마나 불렸나 = 1초 동안 몇 번 화면에 그려졌나 측정 . void FpsClass::Frame() { m_count++; if (timeGetTime() &gt;= (m_startTime + 1000)) { // 1초가 경과하면 프레임 수를 fps에 저장 m_fps = m_count; // 카운트 초기화 m_count = 0; m_startTime = timeGetTime(); } return; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#fpsframe",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#fpsframe"
  },"159": {
    "doc": "13. FPS Counter, Direct input",
    "title": "Direct input",
    "content": "DirectX 입력 장치용 API(Application Programming Interface) . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#direct-input",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#direct-input"
  },"160": {
    "doc": "13. FPS Counter, Direct input",
    "title": "특징",
    "content": ". | 다양한 장치 지원: 키보드, 마우스뿐만 아니라 조이스틱, 게임패드, 레이싱 휠 등 다양한 입력 장치를 지원 | 고급 기능 제공: 축(axis) 데이터, 버튼 입력, 진동(force feedback) 효과 등 단순한 입력을 넘어선 상세한 제어가 가능 | 높은 반응성: Windows 메시지(WM_KEYDOWN 등)를 통하지 않고 하드웨어에 직접 접근하는 방식을 사용하여 반응 속도가 빠름. 이는 프레임 단위의 정밀한 입력이 중요한 게임에 매우 유리 | . ⚠️ 중요 : DirectInput은 현재 레거시(Legacy) API로 분류 . | 최신 게임 개발에서는 키보드/마우스는 Raw Input (WM_INPUT) | 게임패드는 XInput이나 Windows.Gaming.Input을 사용하는 것이 일반적 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#특징"
  },"161": {
    "doc": "13. FPS Counter, Direct input",
    "title": "Direct input 사용",
    "content": "1단계: DirectInput 인터페이스 생성 . | DirectInput 시스템 전체를 관리하는 최상위 객체(COM 인터페이스)를 생성 | . #include &lt;dinput.h&gt; #pragma comment(lib, \"dinput8.lib\") #pragma comment(lib, \"dxguid.lib\") // DirectInput8Create 함수를 호출하여 DirectInput의 메인 인터페이스를 생성 result = DirectInput8Create(hinstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&amp;m_directInput, NULL); if (FAILED(result)) { return false; } . 매개변수 . | hInstance: 프로그램의 인스턴스 핸들입니다. Windows 프로그래밍의 기본 요소 | DIRECTINPUT_VERSION: 사용할 DirectInput의 버전을 지정 | IID_IDirectInput8: 생성할 인터페이스의 ID. IDirectInput8 인터페이스 사용 | (void)&amp;m_directInput**: 생성된 인터페이스 포인터를 저장할 변수의 주소 | NULL: COM 집합(aggregation)에 관련된 것으로, 보통 NULL을 사용 | . 2단계: 장치 인터페이스 생성 . | 사용하고 싶은 특정 장치(예: 키보드)를 제어할 수 있는 인터페이스를 생성 | . IDirectInputDevice8* m_keyboard; HRESULT result; // CreateDevice 함수로 특정 장치의 인터페이스를 생성 result = m_directInput-&gt;CreateDevice(GUID_SysKeyboard, &amp;m_keyboard, NULL); if (FAILED(result)) { return false; } . 매개변수 . | GUID_SysKeyboard: 시스템의 기본 키보드를 의미하는 미리 정의된 전역 고유 식별자(GUID) | &amp;m_keyboard: 생성된 키보드 장치 인터페이스 포인터를 저장할 변수의 주소 | NULL: COM 집합 관련, 역시 NULL을 사용 | . 3단계: 데이터 형식 설정 . 어떤 종류의 데이터를 받을지 알려줘야 함 . HRESULT result; // SetDataFormat 함수로 장치로부터 어떤 데이터를 받을지 형식을 설정 result = m_keyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard); if (FAILED(result)) { return false; } . 매개변수 . | &amp;c_dfDIKeyboard: 이 형식을 지정하면 DirectInput은 256바이트 크기의 배열을 준비 . | 각 바이트는 키보드의 특정 키(예: DIK_A는 ‘A’ 키)에 해당 | 눌렸을 경우 최상위 비트(0x80)가 1이 됨 | . | . 4단계: 협력 수준 설정 . 내 프로그램이 이 장치를 ‘어떻게’ 사용할지 운영체제에게 알려주는 단계 . | 예 : 내 프로그램이 화면 맨 앞에 있을 때만 입력을 받을지, 백그라운드에 있을 때도 받을지 등을 정함 | . HRESULT result; // SetCooperativeLevel 함수로 응용 프로그램이 장치를 어떻게 제어할지 설정 result = m_keyboard-&gt;SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_EXCLUSIVE); if (FAILED(result)) { return false; } . 매개변수 . | hWnd: 입력 처리를 할 윈도우의 핸들 | DISCL_FOREGROUND: 창이 활성화(포그라운드) 상태일 때만 입력을 받겠다는 의미 | DISCL_EXCLUSIVE: 프로그램이 활성화 상태일 때, 해당 장치에 대한 모든 입력을 온전히 해당 프로그램에게만 전달 | DISCL_NONEXCLUSIVE: 다른 응용 프로그램도 이 장치를 사용할 수 있도록 허용 | . 5단계: 장치 제어권 획득 . 설정을 끝내고 실제로 장치로부터 데이터를 받기 위해 ‘제어권’을 획득 . // Acquire 함수를 호출하여 장치에 대한 제어권 얻기 result = m_keyboard-&gt;Acquire(); if (FAILED(result)) { return false; } . 6단계: 장치 상태 읽기 . 게임 루프와 같이 반복적으로 호출되는 곳에서 키보드의 현재 상태를 계속해서 읽어오기 . bool InputClass::ReadKeyboard() { HRESULT result; // GetDeviceState 함수로 현재 키보드의 상태를 읽어옴 result = m_keyboard-&gt;GetDeviceState(sizeof(m_keyboardState), (LPVOID)&amp;m_keyboardState); if (FAILED(result)) { // 만약 다른 창으로 전환되는 등의 이유로 장치의 제어권을 잃었다면 // 다시 제어권을 획득하려고 시도 if ((result == DIERR_INPUTLOST) || (result == DIERR_NOTACQUIRED)) { m_keyboard-&gt;Acquire(); } else { return false; } } return true; } . 7단계: 자원 해제 . 프로그램이 종료될 때는 사용했던 모든 인터페이스를 반드시 해제하여 시스템 자원을 반환한다 . void InputClass::Shutdown() { // Release the keyboard. if (m_keyboard) { // 먼저 제어권 포기 m_keyboard-&gt;Unacquire(); // 인터페이스 객체 해제 m_keyboard-&gt;Release(); m_keyboard = 0; } return; } . 링크 DirectInput을 대체하는 Raw Input(WM_INPUT)에 대한 글 . | Taking Advantage of High-Definition Mouse Movement | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#direct-input-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/13.%20FPS%20Counter,%20Direct%20input.html#direct-input-사용"
  },"162": {
    "doc": "14. Multitexturing",
    "title": "14. Multitexturing",
    "content": "멀티텍스처링은 두 개 이상의 서로 다른 텍스처를 혼합하여 최종 텍스처를 만드는 과정이다 . | 두 텍스처를 혼합하는 데 사용하는 방정식은 원하는 결과에 따라 달라짐 | 우리가 할 것은 두 텍스처의 평균 픽셀 색상을 결합하여 균일하게 혼합된 최종 텍스처 만들기 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html"
  },"163": {
    "doc": "14. Multitexturing",
    "title": "Texture blending",
    "content": "텍스처 혼합 기법 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#texture-blending",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#texture-blending"
  },"164": {
    "doc": "14. Multitexturing",
    "title": "1. Alpha Blending",
    "content": "가장 기본적이고 널리 쓰이는 방식으로, 두 텍스처를 특정 비율로 부드럽게 섞기 . \\[C = \\text{lerp}(T_{base}, T_{decal}, \\alpha)\\\\ = (1 - \\alpha)T_{base} + \\alpha T_{decal}\\] . 1을 빼는 이유? : 두 비율의 합이 항상 1이 되게 하려고 . | 알파 = 0 → \\(C = 1 \\cdot B + 0 \\cdot D = B\\) → (데칼 안보임) | 알파 = 1 → \\(C = 0 \\cdot B + 1 \\cdot D = B\\) → (데칼만 보임) | 알파 = 0.5 → \\(C = 0.5B + 0.5D\\) → (둘이 반반 섞임) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#1-alpha-blending",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#1-alpha-blending"
  },"165": {
    "doc": "14. Multitexturing",
    "title": "2. Modulate2x",
    "content": "곱셈-밝기 보정 방식 . | base 와 color를 곱하기만 하면 어두워져서 2를 곱해 보정하는 방법 | 2를 곱하는 과정을 통해 중간 밝기 영역이 원래 밝기를 유지하게 되어 결과적으로 색감이 과하게 어두워지지 않는 ‘균일한’ 느낌을 줌 | . \\[C = (B \\cdot C) × 2\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#2-modulate2x",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#2-modulate2x"
  },"166": {
    "doc": "14. Multitexturing",
    "title": "3. Screen",
    "content": "곱셈 혼합의 반대 개념. 각 색상을 반전시켜 곱한 후, 그 결과를 다시 반전 . | 여러 장의 사진 슬라이드를 하나의 스크린에 겹쳐서 투영하는 것과 유사 | 이미지가 겹칠수록 밝아지지만, 각 이미지의 형태는 유지 | 결과는 항상 밝아짐 | . \\[C = 1 - (1 - T_{base})(1 - T_{src})\\] . | base와 src의 어두운 정도를 곱해서 겹친 어둠을 구한 다음 다시 빼서 밝기를 얻는 방식 | . 예 : base = 0.7, src = 0.5 . | \\((1-0.7)(1-0.5) = 0.3 × 0.5 = 0.15\\) → \\(1 - 0.15 = 0. 85\\) → 더 밝아짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#3-screen",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#3-screen"
  },"167": {
    "doc": "14. Multitexturing",
    "title": "4. Overlay",
    "content": "밝은 부분은 더 밝게, 어두운 부분은 더 어둡게 만드는 기법 . | 어두운 영역일 때는 곱해서 더 어두워짐 | 밝은 영역일 때는 스크린처럼 1에 가까워 져서 더 밝아짐 | . \\[C = \\begin{cases} 2 × T_{base} × T_{src} \\text{ } (T_{base} &lt; 0.5)\\\\ 1 - 2(1 - T_{base})(1 - T_{src}) \\text{ } (T_{base} \\geqq 0.5) \\end{cases}\\] . 2를 곱하는 이유? : 연산 결과를 색상 값의 전체 범위(0.0 ~ 1.0)로 모두 사용할 수 있도록 동적으로 범위를 확장해주기 때문 . 바탕색의 중간 지점(0.5)을 기준 . | 어두운 영역(0.0 ~ 0.5)을 전체 범위(0.0 ~ 1.0)로 확장 | 밝은 영역(0.5 ~ 1.0) 또한 전체 범위(0.0 ~ 1.0)로 확장 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#4-overlay",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#4-overlay"
  },"168": {
    "doc": "14. Multitexturing",
    "title": "multitexture.ps",
    "content": ". | 텍스쳐 두개 올릴 버퍼 준비 | . bool ModelClass::LoadTextures(ID3D11Device* device, ID3D11DeviceContext* deviceContext, char* filename1, char* filename2) { bool result; // 텍스쳐 오브젝트 생성 및 초기화 m_Textures = new TextureClass[2]; result = m_Textures[0].Initialize(device, deviceContext, filename1); if (!result) { return false; } result = m_Textures[1].Initialize(device, deviceContext, filename2); if (!result) { return false; } return true; } . | Modulate2x 방식으로 혼합 | . //GLOBALS // 두 개의 텍스쳐로 텍스처 생성. base = t0 / src = t1 Texture2D shaderTexture1 : register(t0); Texture2D shaderTexture2 : register(t1); SamplerState SampleType : register(s0); //TYPEDEFS struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; }; //PS float4 MultiTexturePixelShader(PixelInputType input) : SV_TARGET { float4 base; float4 src; float4 blendColor; // Sample the pixel color from the textures using the sampler at this texture coordinate location. base = shaderTexture1.Sample(SampleType, input.tex); src = shaderTexture2.Sample(SampleType, input.tex); // Combine the two textures together. blendColor = base * src * 2.0; // Saturate the final color. blendColor = saturate(blendColor); return blendColor; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#multitextureps",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#multitextureps"
  },"169": {
    "doc": "14. Multitexturing",
    "title": "Alpha Mapping",
    "content": "알파 레이어를 사용하여 각 픽셀의 혼합량을 결정 . Alpha Map . base &amp; src . Texture2D shaderTexture1 : register(t0); Texture2D shaderTexture2 : register(t1); // 알파 맵을 보관하기 위한 세 번째 텍스처를 추가 Texture2D shaderTexture3 : register(t2); SamplerState SampleType : register(s0); struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; }; float4 AlphaMapPixelShader(PixelInputType input) : SV_TARGET { float4 base; float4 src; float4 alphaValue; float4 blendColor; // base에서 텍스쳐 색상 가져옴 base = shaderTexture1.Sample(SampleType, input.tex); // src에서 텍스쳐 색상 가져옴 src = shaderTexture2.Sample(SampleType, input.tex); // 알파 텍스쳐에서 텍스쳐 색상 가져옴 alphaValue = shaderTexture3.Sample(SampleType, input.tex); // 알파 값을 기준으로 두 텍스쳐 섞기 blendColor = (alphaValue * base) + ((1.0 - alphaValue) * src); // Saturate the final color value blendColor = saturate(blendColor); return blendColor; } . result . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#alpha-mapping",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/14.%20Multitexturing.html#alpha-mapping"
  },"170": {
    "doc": "15. Normal Mapping",
    "title": "15. Normal Mapping",
    "content": "노멀 맵은 본질적으로 표면 노멀을 위한 참조 테이블이다 . | 노멀 맵의 각 픽셀은 텍스처 색상 맵의 해당 픽셀에 대한 빛의 방향을 나타낸다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html"
  },"171": {
    "doc": "15. Normal Mapping",
    "title": "Bump Mapping",
    "content": "메시의 기하학적 형태(정점, 폴리곤 수)는 그대로 유지하면서 노멀 벡터를 픽셀 단위로 조작해 광원 계산 시 표면이 울퉁불퉁해 보이도록 만드는 기법 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#bump-mapping",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#bump-mapping"
  },"172": {
    "doc": "15. Normal Mapping",
    "title": "Bump Mapping vs Normal Mapping",
    "content": "노멀 매핑이 범프 매핑의 개념을 발전시킨 것 . | 범프 매핑: 흑백 텍스처(높이 정보)를 사용하며, 셰이더에서 실시간으로 높이 변화를 계산하여 법선을 수정 . | 흰색 : 높은 지점 | 검은색 : 낮은 지점 | . | 노멀 매핑: 처음부터 왜곡된 법선 벡터의 방향(X, Y, Z) 정보를 컬러(R, G, B) 값에 직접 저장한 ‘노멀 맵’ . | 노멀 텍스처를 읽어와서 바로 법선으로 사용하므로 연산이 더 빠르고 효율적 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#bump-mapping-vs-normal-mapping",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#bump-mapping-vs-normal-mapping"
  },"173": {
    "doc": "15. Normal Mapping",
    "title": "Normal Map",
    "content": "노멀 맵에 저장되는 방향 정보 좌표계는 탄젠트 공간(Tangent Space) 기준이다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#normal-map",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#normal-map"
  },"174": {
    "doc": "15. Normal Mapping",
    "title": "Tangent Space",
    "content": "각 픽셀(텍셀)마다 정의되는 작은 좌표축 집합. 모델 표면의 각 정점(Vertex)마다 설정되는 고유의 로컬 좌표계 . | Tangent (T): 표면 위에서 U 텍스처 좌표가 증가하는 방향 벡터 | Bitangent/Binormal (B): 표면 위에서 V 텍스처 좌표가 증가하는 방향 벡터 | Normal (N): 표면에서 수직으로 솟은 벡터 | . (T, B, N)이 한 점의 직교 기저(orthonormal basis)를 이룬다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#tangent-space",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#tangent-space"
  },"175": {
    "doc": "15. Normal Mapping",
    "title": "Normal Map Color value",
    "content": "RGB 색상값은 [0, 255] 범위이고, 법선 벡터는 보통 [-1, 1] 범위를 가짐 . | 벡터의 각 성분(X, Y, Z)은 -1.0에서 +1.0 사이의 범위를 가져야 방향을 제대로 표현 가능 | 따라서 × 2.0 - 1.0 연산을 통해 범위를 확장 | . v_normalized = (color / 255.0) * 2.0 - 1.0 R → X축 성분 X = (R / 255) * 2 - 1 G → Y축 성분 Y = (G / 255) * 2 - 1 B → Z축 성분 Z = (B / 255) * 2 - 1 . 여기서 헷갈린 점 : 벡터를 color 값으로 변환할 때 255가 있는 수식이 있고 없는 수식이 있다는 점이다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#normal-map-color-value",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#normal-map-color-value"
  },"176": {
    "doc": "15. Normal Mapping",
    "title": "Texture.Sample(SampleType, input.tex);",
    "content": "1. 텍스처 저장 형식 . | 이미지 파일에서 픽셀은 0~255 범위의 정수로 저장 | 예: R=128, G=200, B=255 | . 2. 샘플러 동작 . | GPU에서 sampler2D 같은 텍스처 샘플러를 쓰면, 하드웨어가 0~255 정수 값을 자동으로 0.0~1.0 부동소수점으로 정규화해서 쉐이더에 넘겨줌 | 즉, Texture.Sample(SampleType, input.tex) 하면 이미 vec3(0.0~1.0) 범위 값이 나옴 | . 3. 벡터 변환 수식 . 따라서 . | (R / 255) * 2 - 1 → 텍스쳐 원시 데이터(정수) 기준 수식 | (Color Value * 2) - 1 → 샘플러로 불러온 후 쉐이더에서 쓰는 수식 | . 즉, 샘플러가 /255를 이미 해주기 때문에 쉐이더에서는 후자만 쓰면 됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#texturesamplesampletype-inputtex",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#texturesamplesampletype-inputtex"
  },"177": {
    "doc": "15. Normal Mapping",
    "title": "Color → Vector",
    "content": ". \\[\\text{Vector Component} = (\\text{Color Value} × 2.0) − 1.0\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#color--vector",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#color--vector"
  },"178": {
    "doc": "15. Normal Mapping",
    "title": "Vector → Color",
    "content": ". \\[\\text{Color Value} = (\\text{Vector Component} + 1.0) / 2.0\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#vector--color",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/15.%20Normal%20Mapping.html#vector--color"
  },"179": {
    "doc": "2. Applying to Unreal Engine",
    "title": "2. Applying to Unreal Engine",
    "content": "HLSL로 구현한 툰 쉐이더를 언리얼 엔진에 적용해보자 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html"
  },"180": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Custom node",
    "content": "사용해봤으나 HLSL의 Forward redering 방식과 안맞아서 제대로 셀 셰이딩이 그려지지 않음. 노말 각도, 빛 방향 계산하는데서 문제가 있는듯 . 참고 링크 . | custom-material | Using Custom HLSL Code - Advanced Materials | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#custom-node",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#custom-node"
  },"181": {
    "doc": "2. Applying to Unreal Engine",
    "title": "G-buffer",
    "content": "지연 렌더링 (Deferred Rendering) 방식의 Geometry Pass 과정에서 오브젝트를 한번 씩 그리며 렌더링에 필요한 ‘재료’ 정보들을 여러 장의 텍스처에 저장 . 텍스처들의 묶음이 바로 G-Buffer이다 . 텍스처 형태로 저장되는 G-Buffer 안의 정보 . | Base Color: 물체의 기본 색상 | World Normal: 표면의 법선 벡터 (조명 계산에 필수) | Roughness: 표면의 거칠기 | Metallic: 금속성 | Specular: 반사광의 색상 및 강도 | Scene Depth: 카메라로부터의 깊이(거리) 정보 | Custom Data: 그 외 렌더링에 필요한 다양한 데이터 | . | 포스트 프로세스는 바로 이 G-Buffer의 데이터를 입력으로 받아 | 화면 전체에 특수 효과(SSAO, 블룸, 모션 블러 등)를 적용하는 과정 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#g-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#g-buffer"
  },"182": {
    "doc": "2. Applying to Unreal Engine",
    "title": "G-Buffer 직접 확인하기",
    "content": ". | UE5 에디터의 메인 뷰포트 좌측 상단에 있는 [Lit] 버튼을 클릭 | 드롭다운 메뉴에서 [Buffer Visualization] 항목으로 마우스를 가져감 | 다양한 G-Buffer 목록이 나타남. 여기서 보고 싶은 버퍼를 선택 | . 주요 시각화 모드 . | Base Color . | 물체의 기본 색상 정보만 보여줌. 조명 효과가 모두 제거된 순수한 텍스처 색상을 볼 수 있음 | . | World Normal . | 픽셀의 법선 벡터를 색상으로 표현. 주로 조명 계산 디버깅이나 외곽선 검출 같은 효과를 만들 때 이 정보를 사용 | . | Roughness . | 표면의 거칠기를 흑백으로 보여줌. | 검은색(0)에 가까울수록 매끈하고, 흰색(1)에 가까울수록 거칠다 | . | Metallic . | 금속성을 흑백으로 보여줌. | 흰색(1)은 순수 금속, 검은색(0)은 비금속. | . | Scene Depth . | 카메라로부터의 거리를 흑백으로 표현. 가까울수록 어둡고 멀수록 밝게 나타남. | 안개(Fog)나 심도 효과(Depth of Field) 등에 사용. | . | Ambient Occlusion . | 물체가 서로 겹치거나 구석진 곳에 생기는 그림자를 계산한 결과. (만약 SSAO가 켜져 있다면) | . | . G-buffer 데이터를 사용해 HLSL로 써보는 예시 . | UE5의 포스트 프로세스 머티리얼에서는 SceneTexture 노드를 통해 G-Buffer에 접근할 수 있다 | . // G-Buffer 텍스처들을 샘플링하기 위한 선언 (실제 UE 코드는 더 복잡하지만 개념은 동일) Texture2D&lt;float4&gt; GBufferATexture; // BaseColor가 저장된 텍스처 Texture2D&lt;float4&gt; GBufferBTexture; // Roughness, Metallic 등이 저장된 텍스처 Texture2D&lt;float&gt; SceneDepthTexture; // 씬 깊이 텍스처 SamplerState GBufferSampler; // PostProcess 메인 함수 float4 MainPS(float2 UV : SV_Position) : SV_Target0 { // 현재 픽셀의 UV 좌표로 G-Buffer 샘플링 float4 gBufferB = GBufferBTexture.Sample(GBufferSampler, UV); // GBufferB의 특정 채널에서 Roughness 값을 읽어옴 (예: R 채널) float roughness = gBufferB.r; // 최종 화면 색상을 가져옴 (보통 다른 텍스처에 저장되어 있음) float4 finalColor = GetFinalSceneColor(UV); // 조건: Roughness가 0.8 이상인가? if (roughness &gt; 0.8) { // 조건을 만족하면 노란색(1,1,0)과 원래 색상을 섞어줌 finalColor.rgb = lerp(finalColor.rgb, float3(1.0, 1.0, 0.0), 0.5); } return finalColor; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#g-buffer-%EC%A7%81%EC%A0%91-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#g-buffer-직접-확인하기"
  },"183": {
    "doc": "2. Applying to Unreal Engine",
    "title": "외부 그래픽스 디버깅 툴",
    "content": "RenderDoc은 특정 프레임의 모든 렌더링 과정을 ‘캡처’하여, 각 단계(Draw Call)에서 어떤 데이터가 어떻게 처리되는지 분석할 수 있게 해주는 강력한 무료 툴 . | RenderDoc | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#%EC%99%B8%EB%B6%80-%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4-%EB%94%94%EB%B2%84%EA%B9%85-%ED%88%B4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#외부-그래픽스-디버깅-툴"
  },"184": {
    "doc": "2. Applying to Unreal Engine",
    "title": "사용 방법",
    "content": "UE5 에디터와 연동 . | RenderDoc을 실행 | File -&gt; Launch Application을 선택 | Executable Path에 UE5 에디터 실행 파일(…/UE_5.x/Engine/Binaries/Win64/UnrealEditor.exe)을 지정. | Command-line arguments에 분석하고 싶은 프로젝트 파일(.uproject)의 전체 경로를 입력. | [Launch] 버튼을 눌러 RenderDoc을 통해 에디터를 실행합니다. | . 프레임 캡처 . | 에디터가 실행되면 뷰포트에 RenderDoc 오버레이가 표시됨. | F12 또는 지정된 캡처 키를 눌러 원하는 순간의 프레임을 캡처. | . G-Buffer 확인 . | 캡처된 파일이 RenderDoc에서 열림. | 왼쪽의 Event Browser에서 BasePass 또는 Scene/Render/GBuffers 와 관련된 이벤트를 찾음. | 오른쪽의 Texture Viewer 탭을 연다. | Output Merger 섹션에 있는 렌더 타겟(Render Targets) 목록을 확인 | GBufferA, GBufferB, GBufferC 등 이름으로 저장된 텍스처들을 볼 수 있음. | 각 텍스처를 클릭하면 해당 버퍼의 내용을 상세하게 (픽셀 단위로) 확인 가능. | . 각 G-Buffer 텍스처의 채널(R, G, B, A)에 어떤 데이터가 어떻게 압축되어 저장되는지 까지 볼 수 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#사용-방법"
  },"185": {
    "doc": "2. Applying to Unreal Engine",
    "title": "HDR vs LDR",
    "content": "그래픽스 파이프라인을 설계할 때, 빛과 색을 올바르게 다루기 위한 대원칙 . | 입력은 선형으로 (Decode) . | sRGB 텍스처와 같은 감마 인코딩된 애셋은 렌더링에 사용하기 전에 반드시 선형(Linear) 공간으로 변환해야 함 | . | 계산은 선형으로 (Compute) . | 조명, 그림자, 블렌딩 등 모든 물리 기반 계산은 빛의 에너지를 비례적으로 표현하는 선형 공간에서 수행 | . | 출력은 비선형으로 (Encode) . | 모든 계산이 끝난 최종 결과물(선형 HDR 색상)을 모니터에 표시하기 직전에만, 톤매핑과 감마 인코딩을 거쳐 LDR 공간으로 변환 | . | . 즉, . [sRGB 텍스처] → 자동 디코딩 → [선형 공간] → 조명, 블렌딩 등 모든 연산 → [선형 HDR 결과] → 노출 적용 → 톤매핑 → 감마 인코딩 → [최종 LDR 화면 출력] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-vs-ldr",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-vs-ldr"
  },"186": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Dynamic Range VS Precision",
    "content": ". | 동적 범위 (Dynamic Range) . | 이미지가 표현할 수 있는 가장 어두운 값과 가장 밝은 값 사이의 비율 | 이것이 높을수록 HDR에 가깝다 | . | 정밀도 (Precision) . | 하나의 색상 채널을 표현하기 위해 몇 개의 비트(bit)를 사용하는지를 의미 | 이것이 높을수록 색상 띠(Banding) 현상이 줄어든다. | . | . 실시간 렌더링에서는 HDR 연산을 위해 최소 16비트 부동소수점(half-precision float) 버퍼를 사용하는 것이 일반적 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#dynamic-range-vs-precision",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#dynamic-range-vs-precision"
  },"187": {
    "doc": "2. Applying to Unreal Engine",
    "title": "LDR (Low Dynamic Range)",
    "content": "우리가 일상적으로 보는 대부분의 이미지, 영상. 모니터가 사용하는 감마(sRGB) 공간의 결과물 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr-low-dynamic-range",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr-low-dynamic-range"
  },"188": {
    "doc": "2. Applying to Unreal Engine",
    "title": "LDR Color",
    "content": "일반적으로 색상의 각 채널(Red, Green, Blue)을 8비트(bit)로 표현 . | 각 채널은 0부터 255까지의 정수 값을 가짐 (예: R:255, G:0, B:0은 순수한 빨간색) | 그래픽스 프로그래밍에서는 이를 0.0 ~ 1.0 사이의 부동소수점 값으로 정규화(normalize)하여 사용 . | 즉, 0은 0.0으로, 255는 1.0으로 매핑 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr-color",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr-color"
  },"189": {
    "doc": "2. Applying to Unreal Engine",
    "title": "LDR의 한계",
    "content": "1.0이 표현 가능한 최대 밝기이다 . | 태양, 전구, 불꽃 등 1.0을 초과하는 모든 빛 정보는 모두 1.0으로 잘려나가(clamping) 디테일을 잃는다 | . LDR 세계에서는 이 모든 밝은 빛들이 그냥 최대 밝기(255 또는 1.0)로 뭉뚱그려져 버림 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr%EC%9D%98-%ED%95%9C%EA%B3%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#ldr의-한계"
  },"190": {
    "doc": "2. Applying to Unreal Engine",
    "title": "HDR (High Dynamic Range)",
    "content": "컴퓨터가 빛을 물리적으로 사실에 가깝게 시뮬레이션하기 위해 사용하는 방식 . | 이름처럼, 표현할 수 있는 밝기의 폭이 매우 넓어 현실 세계의 빛을 거의 그대로 흉내 낼 수 있음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-high-dynamic-range",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-high-dynamic-range"
  },"191": {
    "doc": "2. Applying to Unreal Engine",
    "title": "HDR Color",
    "content": "색상의 각 채널을 16비트 부동소수점(half) 또는 32비트 부동소수점(float) 으로 표현 . | 실시간 렌더링에서는 메모리와 대역폭 효율을 위해 R16G16B16A16_FLOAT 렌더 타겟을 사용하는 것이 일반적 | . HDR 장점 . 빛의 상호작용을 정보 손실 없이 계산할 수 있다 . | LDR에서는 1.0짜리 빛 두 개를 합쳐도 여전히 1.0이 되어버리지만 | HDR에서는 정보 손실 없이 빛의 상호작용을 그대로 계산할 수 있다 . | 예 : 밝기가 10.0인 빛과 15.0인 빛을 합치면 25.0이 됨 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-color",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#hdr-color"
  },"192": {
    "doc": "2. Applying to Unreal Engine",
    "title": "왜 ‘선형 공간’에서 계산해야 하는가?",
    "content": "우리가 흔히 보는 이미지 파일(JPG, PNG)이나 모니터는 감마 공간(Gamma Space) 또는 sRGB 공간을 사용한다 . 인간의 시각이 어두운 부분의 변화에 더 민감하다는 특성에 맞춰 . | 제한된 비트(주로 8비트)를 효율적으로 사용하기 위해 고안된 비선형적인 방식 | . 하지만 빛은 물리적으로 선형적(Linear)으로 작용한다 . 감마 공간에서의 덧셈: 0.5 + 0.5 = 1.0 (매우 밝아짐) \\\\ 감마 공간의 0.5는 선형 공간의 약 0.214에 해당한다 선형 공간에서의 덧셈: 0.214 + 0.214 = 0.428 \\\\ 위 값을 감마 공간으로 다시 변환하면 약 0.68로 합리적인 밝기 증가를 보임 . 즉 감마 공간에서 색을 더하면 물리적으로 올바르지 않고, 빛이 과도하게 밝아지는 문제가 발생 . 따라서 모든 조명과 블렌딩 연산은 반드시 선형 공간에서 수행해야함 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#%EC%99%9C-%EC%84%A0%ED%98%95-%EA%B3%B5%EA%B0%84%EC%97%90%EC%84%9C-%EA%B3%84%EC%82%B0%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#왜-선형-공간에서-계산해야-하는가"
  },"193": {
    "doc": "2. Applying to Unreal Engine",
    "title": "최종 화면 출력을 위한 후처리 (Post-Processing)",
    "content": "HDR 장면이 가진 풍부한 명암 정보를 바탕으로 인간의 눈이 인식하는 방식에 가깝게 변환하는 과정 . | HDR과 LDR의 간극을 메우고 시각적으로 만족스러운 이미지를 만드는 것 | . 1. 노출 (Exposure) . 톤매핑을 적용하기 전에, 장면의 전반적인 밝기를 조절하는 단계 . | 이는 카메라의 조리개나 셔터 스피드를 조절하는 것과 같음 | 가장 간단한 방식은 렌더링된 HDR 색상에 특정 노출 값을 곱하는 것 . | ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#%EC%B5%9C%EC%A2%85-%ED%99%94%EB%A9%B4-%EC%B6%9C%EB%A0%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%9B%84%EC%B2%98%EB%A6%AC-post-processing",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#최종-화면-출력을-위한-후처리-post-processing"
  },"194": {
    "doc": "2. Applying to Unreal Engine",
    "title": "exposedColor = hdrColor * exposure",
    "content": "| . | . 2. 톤매핑 (Tonemapping) . HDR의 넓은 밝기 범위를 LDR 모니터의 좁은(0.0~1.0) 범위로 자연스럽게 ‘압축’하는 핵심 과정 . 톤매팡 옵션 . | Reinhard 채널별: color/(1+color) 간단하다. 하이라이트가 회색화되기 쉽다 | Reinhard Luma 보존: 휘도 기반으로 스케일. 색 바램을 완화 | Filmic(예: ACES 근사): 하이라이트 롤오프가 자연스럽다. 게임에서 널리 사용 | . 3. 감마/인코딩 (Gamma Encoding) . 선형 공간의 최종 LDR 색상을 비선형적인 모니터에 맞게 변환하는 마지막 단계 . | 백버퍼가 *_SRGB면 하드웨어가 인코딩 . | 셰이더에서 pow(1/2.2)를 하지 않는다 | 최종 출력 타겟의 포맷이 DXGI_FORMAT_*_SRGB | (예: DXGI_FORMAT_B8G8R8A8_UNORM_SRGB)로 설정되었다면 | GPU가 렌더링 결과를 자동으로 sRGB 컬러 스페이스로 변환 | . | 백버퍼가 선형 *_UNORM 포맷이면 . | 셰이더에서 직접 LinearToSRGB 함수를 호출해 변환 | . | . 톤매핑 HLSL 예시 . // Pixel Shader // 상수 버퍼에서 노출값 등을 정의 (CPU에서 조절 가능하게) cbuffer TonemappingCB : register(b0) { float g_Exposure; float3 Padding; } // ... (샘플러 및 텍스처 정의) float4 TonemappingPS(float4 in : SV_Position, float2 uv : TEXCOORD) : SV_Target { // 1. HDR 색상 샘플링 (선형 보간이 일반적) float3 hdrColor = HdrSceneTexture.Sample(LinearSampler, uv).rgb; // 2. 노출 적용 (HDR 색상에 exposure 값을 곱함) hdrColor *= g_Exposure; // 3. Reinhard 톤매핑 공식 적용 // 원공식: color / (color + 1.0) float3 ldrColor = hdrColor / (hdrColor + 1.0f); // 4. 감마 보정 (매직 넘버를 직접 쓰기보다 상수 사용을 권장) const float Gamma = 2.2; ldrColor = pow(ldrColor, 1.0f / Gamma); return float4(ldrColor, 1.0f); } . 링크 . | Filmic Tonemapping Operators | Gamma-Correction | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#exposedcolor--hdrcolor--exposure",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#exposedcolor--hdrcolor--exposure"
  },"195": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Post Process pipeline",
    "content": "UE 5.5 Deferred + Lumen + TSR 기준 후처리 파이프라인의 순서 . | 베이스 렌더링 → DOF → TSR → Motion Blur → Bloom/Flare → Exposure/Local Exposure | → Color Grading 컨트롤 → Tonemapper → LDR 후처리/PPM 기본·FXAA → UI | . | SSAO/SSR/Lumen은 베이스 렌더링 단계에서 빛과 같이 합성됨 (픽셸 셰이더에서 같이 게산) | . 참고 링크 . | rendering-overview | temporal-super-resolution | tonemapper | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#post-process-pipeline",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#post-process-pipeline"
  },"196": {
    "doc": "2. Applying to Unreal Engine",
    "title": "1. 베이스 렌더링",
    "content": ". | G-Buffer Pass . | 렌더링할 씬의 모든 표면 정보를(색상, 노멀, 재질 등) G-Buffer에 기록 | . | 라이팅 합성 + Lumen GI/Reflections . | G-Buffer 정보를 바탕으로 직접광, 간접광을 합산해 HDR SceneColor를 만든다 | 리플렉션은 Lumen Reflections(기본)을 쓰며, 필요 시 SSR(Screen Space Reflections)가 가산됨 | . | SSR은 화면 공간 기반의 동적 포스트 프로세스로, 화면에 보이는 정보만 반영된다. | . | SSAO(Screen Space Ambient Occlusion) . | 코너,틈새의 주변광 감쇠를 근사해 간접광 성분에 곱해 줌 | . | . 용어 . | Lumen: UE5의 동적 GI/리플렉션 시스템 . | GI와 간접 스페큘러를 실시간으로 추정해 SceneColor에 섞음 | . | SSAO: 화면 공간에서 법선·깊이로 근사한 주변광 음영 . | 비직접광을 어둡게 해 입체감을 높임 | . | SSR: 화면에 보이는 색과 깊이만으로 추적하는 반사. 프레임 경계나 화면 밖 정보는 불가 | . 링크 . | Reflections Environment | post-process-effects | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#1-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A0%8C%EB%8D%94%EB%A7%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#1-베이스-렌더링"
  },"197": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Before Tonemapping (HDR/Linear 공간에서 작업)",
    "content": "여기서부터가 진짜 후처리 파이프라인 . 모든 연산은 물리적으로 정확한 HDR/리니어 색상 공간에서 이루어짐 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#before-tonemapping-hdrlinear-%EA%B3%B5%EA%B0%84%EC%97%90%EC%84%9C-%EC%9E%91%EC%97%85",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#before-tonemapping-hdrlinear-공간에서-작업"
  },"198": {
    "doc": "2. Applying to Unreal Engine",
    "title": "2. DOF",
    "content": "DOF는 피사계 심도로 초점이 잡힌 곳은 선명하게 그 밖은 흐리게 하는 작업을 한다. 즉 카메라 초점 기반 블러이다 . DOF는 위 베이스 렌더링이 끝난 후 HDR SceneColor 상에서 수행됨 . 링크 . | cinematic-depth-of-field | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#2-dof",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#2-dof"
  },"199": {
    "doc": "2. Applying to Unreal Engine",
    "title": "3. Translucency Pass (반투명 합성 위치)",
    "content": "반투명 재질은 DOF 심도 적용 전, DOF 적용 후(기본값), 모션 블러 적용 후 등 다양한 반투명 패스로 렌더링 . | DOF 적용 후가 기본값 | . 옵션으로 파이프라인 위치를 바꾸면 TSR/블러/소팅과의 상호작용이 달라짐 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#3-translucency-pass-%EB%B0%98%ED%88%AC%EB%AA%85-%ED%95%A9%EC%84%B1-%EC%9C%84%EC%B9%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#3-translucency-pass-반투명-합성-위치"
  },"200": {
    "doc": "2. Applying to Unreal Engine",
    "title": "4. TSR(Temporal Super Resolution)",
    "content": "DOF 이후에 실행되는 UE의 안티 앨리어싱 작업. | 여기서 출력 해상도로 업스케일되며, 이후 단계 전부가 업스케일된 결과를 입력으로 사용 | . 링크 . | temporal-super-resolution | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#4-tsrtemporal-super-resolution",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#4-tsrtemporal-super-resolution"
  },"201": {
    "doc": "2. Applying to Unreal Engine",
    "title": "5. Motion Blur",
    "content": "모션 블러 는 물체의 움직임에 따라 흐릿하게 보이는 현상 . | 모션 벡터로 잔상을 합성 | 성능을 위해 TSR/MB 입력을 Half/Quarter Res로 운용하는 경로도 존재 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#5-motion-blur",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#5-motion-blur"
  },"202": {
    "doc": "2. Applying to Unreal Engine",
    "title": "6. Bloom/LensFlare/Auto-Exposure/Local Exposure",
    "content": "모션 블러 이후 실행 . | Bloom, 플레어는 밝은 영역의 광학적 확산을 추가 | Eye Adaptation은 장면 휘도 분포로 노출을 동적으로 맞춤 | . 링크 . | bloom | auto-exposure | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#6-bloomlensflareauto-exposurelocal-exposure",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#6-bloomlensflareauto-exposurelocal-exposure"
  },"203": {
    "doc": "2. Applying to Unreal Engine",
    "title": "7. Color Grading (색 보정)",
    "content": "장면 색상을 조정하기 위한 톤 매핑 및 색상 보정 효과 . 언리얼 엔진 내에서 컬러 그레이딩이라는 용어는 . | HDR(High Dynamic Range) 디스플레이 출력과 함께 사용되는 톤 매핑 기능 (HDR 에서 LDR로 변환) | 이미지의 색상 보정(LDR 색상에서 화면 색상으로 변환) 처리를 포괄한다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#7-color-grading-%EC%83%89-%EB%B3%B4%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#7-color-grading-색-보정"
  },"204": {
    "doc": "2. Applying to Unreal Engine",
    "title": "8. Tonemapping - LDR(Low Dynamic Range) 이미지로 변환",
    "content": "톤 매핑 기능의 목적 . | 넓은 범위의 고명암비(HDR) 색상을 | 디스플레이가 출력할 수 있는 저명암비(LDR) 색상으로 매핑하는 것 | . 후처리 과정에서 일반적인 렌더링 후 수행되는 마지막 단계 . 링크 . | color-grading-and-the-filmic-tonemapper | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#8-tonemapping---ldrlow-dynamic-range-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A1%9C-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#8-tonemapping---ldrlow-dynamic-range-이미지로-변환"
  },"205": {
    "doc": "2. Applying to Unreal Engine",
    "title": "After Tonemapping (LDR 공간에서의 작업)",
    "content": "톤매핑이 완료된, 우리가 흔히 보는 이미지 위에서 최종 효과들을 적용 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#after-tonemapping-ldr-%EA%B3%B5%EA%B0%84%EC%97%90%EC%84%9C%EC%9D%98-%EC%9E%91%EC%97%85",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#after-tonemapping-ldr-공간에서의-작업"
  },"206": {
    "doc": "2. Applying to Unreal Engine",
    "title": "9. LDR 후처리/커스텀 PPM",
    "content": "비네트, 필름 그레인, 간단한 컬러 틴트 등 LDR에서 싸게 처리 가능한 효과는 톤매퍼 이후 적용 . | UE의 Post Process Material 기본 삽입점은 After Tonemapping . | 필요 시 옵션을 통해 위치를 바꿀 수 있다 | Scene Color Before/After DOF, Scene Color Before Bloom, Replacing the Tonemapper 등 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#9-ldr-%ED%9B%84%EC%B2%98%EB%A6%AC%EC%BB%A4%EC%8A%A4%ED%85%80-ppm",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#9-ldr-후처리커스텀-ppm"
  },"207": {
    "doc": "2. Applying to Unreal Engine",
    "title": "10. UI 합성(UMG/Slate)",
    "content": "기본적으로 장면 포스트 프로세싱 이후에 그려져 영향을 받지 않는다 . | UI에 후처리 효과를 지원하려면 Slate 포스트 버퍼를 사용한다 | . 링크 . | using-slate-postbuffers | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#10-ui-%ED%95%A9%EC%84%B1umgslate",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#10-ui-합성umgslate"
  },"208": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Post Process material",
    "content": ". | 포스트 프로세스 . | 3D 씬의 렌더링이 모두 끝난 최종 2D 이미지를 가지고 추가적인 효과를 적용하는 기술 | 화면 전체에 필터를 씌우거나, 색감을 보정하는 등의 작업이 여기에 해당 | 컴퓨터 그래픽스에서는 이를 ‘스크린 스페이스(Screen Space)’ 연산이라고 부름 | . | . 참고 링크 . | post-process-materials-in-unreal-engine | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#post-process-material",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#post-process-material"
  },"209": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Material Domain",
    "content": "머티리얼의 근본적인 용도가 무엇인가? 를 정의 . | Domain 설정에 따라 머티리얼 에디터에서 사용할 수 있는 입력 핀과 출력 노드가 바뀜 | 엔진이 셰이더를 컴파일하는 방식 자체가 달라짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#material-domain",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#material-domain"
  },"210": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Domain 속성",
    "content": ". | Surface (표면) . | 가장 기본값. 3D 모델의 표면에 칠하는 일반적인 재질 | Base Color, Metallic, Roughness 등의 물리 기반 렌더링(PBR) 입력들을 가짐 | . | Post Process (포스트 프로세스) . | 렌더링이 완료된 최종 2D 화면 이미지에 적용하는 필터 용도 | 입력으로 SceneTexture 노드를 통해 화면 색상, 깊이, 노멀 등의 데이터를 가져올 수 있음 | 최종 결과물은 Emissive Color로 출력 | . | UI . | UMG(Unreal Motion Graphics) 위젯에 사용되는 2D 인터페이스용 머티리얼 | . | Light Function (라이트 함수) . | 광원의 빛에 패턴이나 마스크를 적용하여 그림자를 만들거나(예: 창살 그림자), 프로젝터처럼 이미지를 투사하는 효과를 낼 때 사용 | . | Deferred Decal (디퍼드 데칼) . | 벽에 붙은 포스터, 핏자국, 총알 자국처럼 다른 표면 위에 추가로 이미지를 덧씌울 때 사용 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#domain-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#domain-속성"
  },"211": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Blendable Location",
    "content": "Material Domain이 Post Process일 때만 활성화 . 포스트 프로세싱 과정의 여러 단계 중 정확히 어느 시점에 이 머티리얼을 적용할 것인가?를 결정 . | 렌더링 후처리 파이프라인 | . [HDR/리니어 공간] G-Buffer -&gt; 조명 -&gt; AO/반사 -&gt; 블룸 -&gt; 노출 -&gt; 색 보정 -&gt; [톤매핑] | V [LDR/sRGB 공간] 모션블러 -&gt; 안티에일리어싱 -&gt; 필름 효과 -&gt; UI -&gt; 최종 화면 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#blendable-location",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#blendable-location"
  },"212": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Blendable Location 종류",
    "content": ". | Before Tonemapping (톤매핑 이전) . | 사진 원본(RAW) 파일을 편집하는 것과 같음 | 아직 색상 정보가 압축되거나 왜곡되지 않은, 물리적으로 정확한 HDR/선형 공간에서 머티리얼 연산을 수행 | 색상을 더하거나 곱하는 등의 수학적 계산이 예측한 대로 정확하게 나옴 | 대부분의 포스트 프로세스 효과(색상 보정, 커스텀 필터 등)에 권장되는 기본값이자 가장 정확한 옵션 | . | After Tonemapping (톤매핑 이후) . | 최종 결과물(JPG) 파일을 편집하는 것과 같음 | 이미 모니터에 맞게 색이 압축되고 보정된 LDR 공간의 이미지에 효과를 적용 | 이 상태에서 색상을 연산하면, 감마 보정(Gamma Correction) 등의 영향으로 인해 결과가 어두워지거나 색이 틀어지는 등 수학적으로 부정확하고 예측하기 어려운 결과를 낳을 수 있음 | 주로 화면에 디버그 정보를 그리거나, 최종 화면 위에 덧씌우는 스크린 이펙트(예: 빗방울, 필름 그레인)처럼 톤매핑의 영향을 받으면 안 되는 특수한 경우에 사용 | . | Replacing the Tonemapper (톤매퍼 대체) . | 가장 고급 옵션으로, 언리얼의 기본 톤매핑 과정을 통째로 무시하고 내가 만든 머티리얼로 톤매핑을 직접 구현할 때 사용 | 아주 독특한 색감의 아트 스타일을 만들 때 사용됨 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#blendable-location-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#blendable-location-종류"
  },"213": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Custom Depth-Stencil Pass (커스텀 깊이-스텐실 패스)",
    "content": "특정 오브젝트만 선별하여 특별한 시각 효과를 적용하기 위한 마스킹(Masking) 데이터를 만드는 기능 . Custom Depth Pass . | 특수 효과를 줄 거라고 체크한 오브젝트들만 따로 모음 | 화면상의 깊이 값 (카메라로부터의 거리)을 흑백 이미지처럼 별도의 버퍼(메모리 공간)에 그려두는 과정 | . Stencil 옵션 . | 스텐실 버퍼는 픽셀마다 0부터 255까지의 정수 값을 저장할 수 있는, 화면과 똑같은 크기의 디지털 도안 | ‘Enabled with Stencil’ 옵션 ON . | Custom Depth Pass를 진행할 때 단순히 깊이 값만 그리는 게 아니라 | 지정한 스텐실 값(정수)을 이 스텐실 도안에 함께 기록함 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#custom-depth-stencil-pass-%EC%BB%A4%EC%8A%A4%ED%85%80-%EA%B9%8A%EC%9D%B4-%EC%8A%A4%ED%85%90%EC%8B%A4-%ED%8C%A8%EC%8A%A4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#custom-depth-stencil-pass-커스텀-깊이-스텐실-패스"
  },"214": {
    "doc": "2. Applying to Unreal Engine",
    "title": "사용 목적",
    "content": "효율적인 오브젝트 구별을 할 때 사용 . 게임에 ‘아군’, ‘적군’, ‘중립 NPC’가 있고 각각 다른 색의 외곽선을 그리고 싶다고 가정 . 스텐실 미사용 시 . | 모든 캐릭터를 Custom Depth 버퍼에 일단 다 그림 | 그 후 포스트 프로세스에서 이들이 아군인지, 적군인지 다시 판별하는 복잡한 로직을 짜야 함 . | 매우 비효율적 | . | . 스텐실 사용 시 . | 캐릭터 메시의 렌더링 설정에서 Render CustomDepth Pass를 켬 | ‘아군’ 캐릭터 메시의 CustomDepth Stencil Value를 1로 설정 | ‘적군’ 캐릭터는 스텐실 값을 2로 설정 | ‘중립 NPC’는 스텐실 값을 3으로 설정 | . 포스트 프로세스 외곽선 머티리얼에서 스텐실 버퍼를 사용해 아래의 로직 구현 가능 . | 픽셀의 스텐실 값이 1이면 파란색 외곽선, 2면 빨간색 외곽선을, 3이면 초록색 외곽선을 그림 | . 즉 오브젝트 그룹별로 픽셀에 ‘꼬리표(Tag)’를 붙여두는 것과 같다 . | 특정 그룹의 오브젝트만 흑백으로 만든다거나 | 특정 무기에 맞았을 때만 잠시 빛나게 하는 등 응용이 가능 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#사용-목적"
  },"215": {
    "doc": "2. Applying to Unreal Engine",
    "title": "MPC (Material Parameter Collection)",
    "content": "언리얼 엔진에서 여러 머티리얼과 블루프린트에서 전역적으로(Global) 참조하고 제어할 수 있는 파라미터(매개변수)들의 집합 . 참고 링크 . | Material Parameter Collections | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc-material-parameter-collection",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc-material-parameter-collection"
  },"216": {
    "doc": "2. Applying to Unreal Engine",
    "title": "MPC의 특징",
    "content": ". | 전역 스코프 (Global Scope) . | 하나의 MPC에 정의된 파라미터는 프로젝트 내의 어떤 머티리얼, 어떤 블루프린트에서든 동일한 이름으로 접근할 수 있음 | . | 중앙 관리 (Centralized Control) . | 여러 머티리얼에 영향을 주는 값을 단 하나의 에셋에서 관리할 수 있어 유지보수가 용이 | . | 런타임 실시간 제어 . | 게임 실행 중에도 블루프린트나 C++을 통해 값을 변경하면, 해당 값을 사용하는 모든 머티리얼에 즉시 반영 | 셰이더 프로그래밍에서 전역 유니폼 버퍼(Global Uniform Buffer)와 유사한 개념 | . | 구성 . | 스칼라(Scalar, 1float) 값 | 벡터(Vector, 4float) 값 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc의-특징"
  },"217": {
    "doc": "2. Applying to Unreal Engine",
    "title": "MPC 사용 목적",
    "content": ". | 환경 효과 일괄 제어 . | 낮과 밤 사이클에서 TimeOfDay라는 하나의 스칼라 값(0.0~1.0)을 MPC로 만들어서 | 하늘, 조명, 머티리얼의 노출 정도 등을 동시에 제어 | . | 월드 효과 . | 강력한 폭풍우, 독가스, 매트릭스 같은 디지털 효과 등 | 월드 전체에 퍼지는 것을 하나의 Intensity(강도) 값으로 조절 | . | 게임 플레이 연동 . | 플레이어의 체력이 낮아지면 화면 전체에 붉은 끼가 돌게 하거나 | 특정 지역에 진입하면 채도가 바뀌는 등의 효과를 구현할 때 유용 | . | 아티스트와 프로그래머의 협업 . | 프로그래머는 C++나 블루프린트로 MPC 값을 바꾸는 로직을 구현 | 아티스트는 그 값을 머티리얼에서 어떻게 시각적으로 표현할지 자유롭게 디자인 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc-사용-목적"
  },"218": {
    "doc": "2. Applying to Unreal Engine",
    "title": "MPC와 연동되는 것",
    "content": ". | 머티리얼 에디터 . | 머티리얼 그래프에서 Material Parameter Collection 노드를 추가 | MPC 에셋을 선택하고 원하는 파라미터를 연결 | . | 블루프린트 . | Set Scalar Parameter Value on Collection | Set Vector Parameter Value on Collection 노드를 사용하여 값을 변경 | . | Niagara 시스템 . | 파티클 시스템에서도 MPC의 값을 읽어와 파티클의 색상, 크기, 생성률 등을 제어하는 데 사용 | . | C++ . | UMaterialParameterCollectionInstance 클래스를 통해 프로그래밍적으로 접근 및 제어가 가능 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc%EC%99%80-%EC%97%B0%EB%8F%99%EB%90%98%EB%8A%94-%EA%B2%83",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#mpc와-연동되는-것"
  },"219": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Collection vs Instance",
    "content": ". | UMaterialParameterCollection . | 이것은 콘텐츠 브라우저에 있는 에셋 그 자체 | 어떤 파라미터들이 있는지를 정의하는 클래스와 같음 | . | UMaterialParameterCollectionInstance . | 설계도를 바탕으로 만들어진 인스턴스에 해당 | C++나 블루프린트에서 값을 변경할 때 실제로 제어하는 대상은 바로 이 인스턴스 | GetWorld()-&gt;GetParameterCollectionInstance(MyMPC) 월드에 생성된 인스턴스를 가져오기 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#collection-vs-instance",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#collection-vs-instance"
  },"220": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Level Blueprint (레벨 블루프린트)",
    "content": "특정 레벨(맵)에 종속적인 비주얼 스크립팅 . | 각 레벨(.umap)마다 하나씩 존재 | 각 레벨의 전반적인 이벤트와 로직을 관리하기 위한 특별한 종류의 블루프린트 | . 참고 링크 . | Level Blueprint | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-%EB%A0%88%EB%B2%A8-%EB%B8%94%EB%A3%A8%ED%94%84%EB%A6%B0%ED%8A%B8",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-레벨-블루프린트"
  },"221": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Level Blueprint 특징",
    "content": ". | 레벨 종속성 . | 오직 자신이 속한 레벨에서만 작동 | 다른 레벨에서는 존재하지도, 실행되지도 않음 | . | 직접적인 액터 참조 . | 레벨에 배치된 어떤 액터(캐릭터, 조명, 카메라 등)라도 직접 선택하여 참조를 가져올 수 있음 | 다른 블루프린트와 구별되는 가장 큰 특징 | 블루프린트 클래스에서는 일반적으로 Get All Actors Of Class나 Get Overlapping Actors와 같은 방법으로 Actor를 찾아야 함 | . | 전역 이벤트 처리 . | 레벨의 시작(BeginPlay), 종료(EndPlay)와 같은 레벨 단위의 이벤트를 처리 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-특징"
  },"222": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Level Blueprint VS Actor Blueprint",
    "content": "|   | Level Blueprint | Actor Blueprint | . | 소속 | 특정 레벨 (.umap) | 독립적인 에셋 (.uasset) | . | 재사용성 | 해당 레벨에만 존재하고 영향을 줌 | 여러 레벨에 배치하여 재사용 가능 | . | Actor 참조 | 레벨 내 배치된 Actor를 직접 드래그 앤 드롭으로 참조 가능 | Get All Actors of Class 등으로 검색하거나, 변수에 담아 전달받아야 함 | . | 용도 | 레벨 시퀀스, 레벨 배치 Actor 간 통신 | 플레이어 캐릭터, 무기, 상자, 퍼즐 등 범용적인 객체 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-vs-actor-blueprint",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-vs-actor-blueprint"
  },"223": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Level Blueprint에서 직접적인 액터 참조가 가능한 이유",
    "content": "레벨 블루프린트의 로직이 레벨 파일(.umap) 자체에 직접 저장되기 때문 . | 레벨에 배치된 ‘액터 A’와 레벨 블루프린트의 ‘A에 대한 참조 노드’는 모두 같은 레벨 파일 안에 존재 | 따라서 레벨을 저장할 때 이들 사이의 연결 관계(포인터)가 깨지지 않고 그대로 보존될 수 있음 | . 반면, 독립적인 에셋인 액터 블루프린트는 어떤 레벨에 배치될지 미리 알 수 없으므로 이런 방식의 직접 참조가 불가능 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint%EC%97%90%EC%84%9C-%EC%A7%81%EC%A0%91%EC%A0%81%EC%9D%B8-%EC%95%A1%ED%84%B0-%EC%B0%B8%EC%A1%B0%EA%B0%80-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint에서-직접적인-액터-참조가-가능한-이유"
  },"224": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Level Blueprint 사용 목적",
    "content": ". | 시네마틱 시퀀스 . | 레벨 시작 시 시네마틱 카메라를 재생하거나, 특정 이벤트가 발생했을 때 시퀀서를 재생하는 등의 연출을 구현 | . | 레벨 고유의 퍼즐 로직 . | “A 스위치를 누르고 B 문을 통과하면 C 플랫폼이 움직인다” 와 같이 레벨에 배치된 특정 액터들 간의 상호작용을 구현할 때 매우 편리 | . | 전역 시스템 트리거 . | MPC의 값을 변경하는 로직을 레벨 블루프린트의 BeginPlay 이벤트에 넣으면 | 해당 레벨이 시작될 때 전역 시각 효과를 특정 상태로 설정 | . | 레벨 스트리밍 제어 . | 다른 서브 레벨을 로드하거나 언로드하는 타이밍을 조절 | . | 특정 레벨의 GameMode 초기화 . | 해당 레벨에서만 특별한 규칙을 적용할 때 초기 설정을 함 | . | . 프로젝트가 커져 레벨 블루프린트에 지나치게 많은 로직을 넣으면 유지보수가 어려움 . | 가능하면 재사용 가능한 블루프린트 클래스로 기능을 분리하는 것이 좋다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#level-blueprint-사용-목적"
  },"225": {
    "doc": "2. Applying to Unreal Engine",
    "title": "Event Manager 패턴",
    "content": "실무에서는 레벨의 주요 로직을 처리하는 BP_LevelManager 와 같은 일반 액터 블루프린트를 하나 만들어서 레벨에 배치하는 방식을 자주 사용 . | 레벨 블루프린트는 BeginPlay 이벤트가 발생했을 때 레벨에 배치된 이 BP_LevelManager를 찾아 초기화시켜주는 역할을 맡음 | 복잡한 레벨 로직 (퍼즐, 시퀀스 트리거 등)은 BP_LevelManager 안에서 처리 | . 로직이 특정 레벨 파일에 묶이지 않고, 에셋 기반으로 관리되어 재사용 및 협업이 훨씬 용이 . | ‘Single Point of Entry’ 또는 ‘Manager Pattern’ 이라고도 부름 | . 한번씩은 봐둬야할 링크 목록 . | adding-global-shaders-to-unreal-engine | overview-of-shaders-in-plugins-unreal-engine | new-shading-models-and-changing-the-gbuffer | . | how-to-add-post-process-material | filmic-tonemapping-with-piecewise-power-curves | luts-complete-guide | . | Articles | Global shaders in Unreal without engine modification | UE4ShadersIntroduction | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#event-manager-%ED%8C%A8%ED%84%B4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/2.%20Applying%20to%20Unreal%20Engine.html#event-manager-패턴"
  },"226": {
    "doc": "2. Cauchy-Schwarz inequality",
    "title": "2. Cauchy-Schwarz inequality",
    "content": "코시-슈바르츠 부등식 . \\[|\\vec{u} \\cdot \\vec{v}| \\leq \\|\\vec{u}\\| \\|\\vec{v}\\|\\] . | 두 벡터의 내적 절댓값 ≤ 각 벡터 노름의 곱 | = 성립 : 선형 종속 | &lt; 성립 : 선형 독립 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html"
  },"227": {
    "doc": "2. Cauchy-Schwarz inequality",
    "title": "코시-슈바르츠 부등식으로 선형 독립/종속 판별 예시",
    "content": "\\[\\vec{u} = (3, 4) \\\\ \\vec{v} = (-6, -8)\\] . \\[\\begin{aligned} \\vec{u} \\cdot \\vec{v} &amp;= 3 \\times (-6) + 4 \\times (-8) = -18 -32 = -50 \\\\ \\|\\vec{u}\\| &amp;= \\sqrt{3^2 + 4^2} = \\sqrt{25} = 5 \\\\ \\|\\vec{v}\\| &amp;= \\sqrt{(-6)^2 + (-8)^2} = \\sqrt{100} = 10 \\\\ |\\vec{u} \\cdot \\vec{v}| &amp;= 50 \\\\ \\|\\vec{u}\\| \\|\\vec{v}\\| &amp;= 5 \\times 10 = 50 \\\\ \\end{aligned}\\] . \\[50 = 50\\] 따라서 두 벡터는 선형종속 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#%EC%BD%94%EC%8B%9C-%EC%8A%88%EB%B0%94%EB%A5%B4%EC%B8%A0-%EB%B6%80%EB%93%B1%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD%EC%A2%85%EC%86%8D-%ED%8C%90%EB%B3%84-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#코시-슈바르츠-부등식으로-선형-독립종속-판별-예시"
  },"228": {
    "doc": "2. Cauchy-Schwarz inequality",
    "title": "Vector triangle inequality",
    "content": "벡터 삼각형 부등식 . \\[\\|\\vec{u} + \\vec{v}\\| \\leq \\|\\vec{u}\\| + \\|\\vec{v}\\|\\] . | 벡터 합의 노름 ≤ 각 벡터 노름의 합 | = 성립 : 선형 종속 | &lt; 성립 : 선형 독립 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#vector-triangle-inequality",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#vector-triangle-inequality"
  },"229": {
    "doc": "2. Cauchy-Schwarz inequality",
    "title": "벡터 삼각형 부등식으로 선형 독립/종속 판별 예시",
    "content": "\\[\\vec{u} = (2, -1) \\\\ \\vec{v} = (-1, 4)\\] . \\[\\begin{aligned} \\vec{u} + \\vec{v} &amp;= (1, 3) \\\\ \\|\\vec{u} + \\vec{v}\\| &amp;= \\sqrt{1^2 + 3^2} = \\sqrt{10} \\approx 3.162 \\\\ \\|\\vec{u}\\| &amp;= \\sqrt{2^2 + (-1)^2} = \\sqrt{5} \\approx 2.236 \\\\ \\|\\vec{v}\\| &amp;= \\sqrt{(-1)^2 + 4^2} = \\sqrt{17} \\approx 4.123 \\\\ \\|\\vec{u}\\| + \\|\\vec{v}\\| &amp;\\approx 6.359 \\\\ \\end{aligned}\\] . \\[3.162 &lt; 6.359\\] . 따라서 두 벡터는 선형독립 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#%EB%B2%A1%ED%84%B0-%EC%82%BC%EA%B0%81%ED%98%95-%EB%B6%80%EB%93%B1%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD%EC%A2%85%EC%86%8D-%ED%8C%90%EB%B3%84-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/2.%20Cauchy-Schwarz%20inequality.html#벡터-삼각형-부등식으로-선형-독립종속-판별-예시"
  },"230": {
    "doc": "2. Direct3D Getting Started",
    "title": "2. Direct3D Getting Started",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html"
  },"231": {
    "doc": "2. Direct3D Getting Started",
    "title": "Understanding Graphics Concepts",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#understanding-graphics-concepts",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#understanding-graphics-concepts"
  },"232": {
    "doc": "2. Direct3D Getting Started",
    "title": "Graphics Hardware",
    "content": ". | CPU : 계산을 수행하고 컴퓨터 전체를 제어 | GPU : GPU는 그래픽/병렬 연산을 수행하고, 결과를 프레임버퍼에 기록하고 출력은 OS/드라이버/디스플레이엔진을 통해 전송 . | CPU가 GPU를 지휘한다 | . | . | GPU는 별도의 프로세서를 가지며 비디오 메모리라는 분리된 메모리 영역을 사용함 | 비디오 메모리 . | 비디오 카드에 위치하여 GPU가 빠르게 접근 가능 | 비디오 메모리는 화면에 표시되는 현재 이미지를 저장한다 | 비디오 메모리는 다음 이미지를 생성하는데 사용될 수 있는 데이터도 저장한다 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#graphics-hardware",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#graphics-hardware"
  },"233": {
    "doc": "2. Direct3D Getting Started",
    "title": "DirectX Graphics Infrastructure (DXGI)",
    "content": "Direct3D가 GPU와 효율적으로 통신할 수 있게 관리하는 Microsoft의 API . 주요 역할 . | 스왑 체인(SwapChain) 관리 . | 더블/트리플 버퍼링을 지원하여 화면 깜빡임을 줄이고 부드러운 렌더링을 가능하게 함 | . | 디스플레이 모드 및 출력 관리 . | 연결된 모니터의 해상도, 새로 고침 빈도, 픽셀 형식(RGB, YUV 등) 등을 설정/조회 | IDXGIOutput을 통해 다중 모니터 환경을 지원 | . | 하드웨어 어댑터(GPU) 정보 조회 . | 시스템에 설치된 GPU(IDXGIAdapter)를 열거하고, VRAM 크기, 지원 기능 등을 확인 . | 예: NVIDIA/AMD/Intel GPU 식별 | . | . | 리소스 공유 및 형식 호환성 . | Direct3D 리소스(텍스처, 버퍼 등)를 다른 API(예: Direct2D) 또는 프로세스 간에 공유할 수 있게 함 | DXGI_FORMAT으로 픽셀 데이터 형식을 표준화 | . | HDR 및 고급 출력 기능 지원 . | HDR(High Dynamic Range) 및 Wide Color Gamut 출력 관리 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#directx-graphics-infrastructure-dxgi",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#directx-graphics-infrastructure-dxgi"
  },"234": {
    "doc": "2. Direct3D Getting Started",
    "title": "SwapChain (스왑 체인)",
    "content": "GPU가 렌더링한 프레임을 모니터에 안정적으로 출력하기 위한 버퍼 관리 시스템 . | 티어링 현상을 방지할 수 있다 | . ❓티어링이 뭐야? . | 화면에 두 개 이상의 프레임이 동시에 나타나며 이미지가 찢어져 보이는 현상 | GPU가 모니터의 갱신 주기와 맞지 않게 프레임을 빠르게 생성하면, 모니터가 화면을 업데이트하는 도중에 새로운 프레임이 전송됨 | 결과 : 상반부는 이전 프레임, 하반부는 새 프레임으로 표시되며 “찢어진” 화면이 나타남 | . | DXGI는 새 이미지를 모니터에 직접 렌더링 하지 않는다 . | 이미지를 백 버퍼라고 하는 보조 픽셀 버퍼에 그린다 | . | 프런트 버퍼는 현재 모니터에 표시되고 있는 이미지 버퍼이다 . | 모든 이미지를 백 버퍼에 그려 작업이 완료되면 | DXGI는 백 버퍼의 내용으로 프런트 버퍼를 업데이트하고 이전 이미지는 삭제한다 | . | DXGI는 각 버퍼 (프런트 버퍼와 백 버퍼 모두)의 포인터 교체(Flip)로 구현하여 값을 간단히 바꾼다 . | 백 버퍼가 프런트 버퍼가 되고 (또는 그 반대가 될 수도 있다) 이는 티어링 발생을 방지한다 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#swapchain-%EC%8A%A4%EC%99%91-%EC%B2%B4%EC%9D%B8",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#swapchain-스왑-체인"
  },"235": {
    "doc": "2. Direct3D Getting Started",
    "title": "Primitives topology",
    "content": ". | 버퍼에 있는 버텍스 데이터를 어떻게 연결하여 어떤 형태로 구성할것인지 정의하는 규칙 | Input Assembler (IA) 단계에서 토폴로지 규칙을 설정하여 GPU에게 정점들을 어떻게 묶어 도형으로 변환할지 지시함 | 실제 프리미티브로 묶이는 것은 Vertex Shader 처리 후 래스터라이저 직전 단계에서 이루어진다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#primitives-topology",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#primitives-topology"
  },"236": {
    "doc": "2. Direct3D Getting Started",
    "title": "primitive topology 유형",
    "content": "1. Point Lists . | 정점을 개별 점으로 렌더링 | 사용 예시 : 파티클 효과, 별빛 표현 | . 2. Line Lists . | 정점을 2개씩 묶어 독립적인 선분으로 렌더링 | 정점 개수는 반드시 짝수여야 한다 | 사용 예시 : 와이어 프레임 모델, 그리드 표시 | . 3. Line Strips . | 연속된 정점을 이어 하나의 폴리라인(Polyline)으로 렌더링 | 정점 n개는 n-1개의 선분을 생성한다 | 사용 예시 : 경로 추적 | . 4. Triangle Lists . | 정점을 3개씩 묶어 독립적인 삼각형으로 렌더링 | 정점 개수는 3의 배수여야 함 | 사용 예시 : 폭발, 물체 조각 맞추기 등 다양한 효과 | . 5. Triangle Strips . | 서로 연결된 일련의 삼각형을 생성 | 정점 n개 → n-2개의 삼각형 생성 | 사용 예시 : 게임의 3D 모델 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#primitive-topology-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#primitive-topology-유형"
  },"237": {
    "doc": "2. Direct3D Getting Started",
    "title": "Backface Culling",
    "content": ". | 3D 모델은 대부분 닫힌 메쉬(Closed Mesh)로 구성됨 | 즉, 내부는 보이지 않으므로 불필요한 내부 면 렌더링을 생략 . | 예: 큐브의 안쪽 면, 구의 내부는 그리지 않음 | . | . 따라서 삼각형을 그릴 때 정점이 시계방향 (CW)인 경우 렌더링 (첫번째 삼각형) . | 반시계 방향인 경우 렌더링하지 않음 (두번째 삼각형) | . | D3D는 기본이 CW, OpenGL은 기본이 CCW | . Backface Culling 으로 인한 문제 . | 평면이나 원판 등 한쪽 면만 있는 오브젝트는 뒤집히면 사라짐 (뒷면이 렌더링 되지 않기 때문) | . 해결 방법 . | 백페이스 컬링 비활성화 . | 간단하지만 비효율적 | . | 양면 메쉬 생성 . | 정점 순서를 뒤집은 복사본을 추가한다 | . | 셰이더에서 강제 렌더링 . | 프래그먼트 셰이더에서 뒷면을 강제로 색상 지정하는 경우 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#backface-culling",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/2.%20Direct3D%20Getting%20Started.html#backface-culling"
  },"238": {
    "doc": "2. pivot and Echelon Form",
    "title": "2. pivot and Echelon Form",
    "content": "피벗 성분과 행 사다리꼴 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html"
  },"239": {
    "doc": "2. pivot and Echelon Form",
    "title": "피벗의 정의",
    "content": ". | 피벗 성분 : 행렬에서 해당 행의 첫 번째 0이 아닌 성분 (선행 계수, Leading Coefficient) | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%ED%94%BC%EB%B2%97%EC%9D%98-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#피벗의-정의"
  },"240": {
    "doc": "2. pivot and Echelon Form",
    "title": "사다리꼴 행렬  (Echelon Form)",
    "content": "사다리꼴 행렬의 정의 . | 모든 성분이 0인 행은 가장 아래에 위치함 | 모든 행에서 처음으로 나타나는 0이 아닌 성분(선행 계수)은 아래 행보다 왼쪽에 위치함 | 선행 계수보다 아래쪽에 있는 성분은 모두 0임 | . 사다리꼴 행렬 예시 . 예시 1 . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 0 &amp; 4 &amp; 5 \\\\ 0 &amp; 0 &amp; 6 \\end{pmatrix}\\] 예시 2 . \\[\\begin{pmatrix} 2 &amp; -1 &amp; 0 &amp; 3 \\\\ 0 &amp; 0 &amp; 5 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 4 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC--echelon-form",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#사다리꼴-행렬--echelon-form"
  },"241": {
    "doc": "2. pivot and Echelon Form",
    "title": "기약 사다리꼴 행렬 (Reduced Echelon Form)",
    "content": "기약 사다리꼴 행렬의 정의 . | 사다리꼴 행렬의 조건을 만족함 | 모든 선행 계수는 1이며, 해당 열의 다른 모든 성분은 0임 | . 기약 사다리꼴 행렬 예시 . 예시 1 . \\[\\begin{pmatrix} 1 &amp; 0 &amp; 5 \\\\ 0 &amp; 1 &amp; -3 \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix}\\] 예시 2 . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EA%B8%B0%EC%95%BD-%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC-reduced-echelon-form",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#기약-사다리꼴-행렬-reduced-echelon-form"
  },"242": {
    "doc": "2. pivot and Echelon Form",
    "title": "연립 방정식을 사다리꼴 행렬로 변환하여 해 구하기",
    "content": "문제 . \\[\\begin{cases} x + 2y +3z = 9 \\\\ 2x - y + z = 8 \\\\ 3x - z = 3 \\end{cases}\\] . 행렬 형태로 표현 . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9\\\\ 2 &amp; -1 &amp; 1 &amp; 8 \\\\ 3 &amp; 0 &amp; -1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 첫 번째 행 기준으로 아래 행 x 계수 제거 . | \\[{R_2 \\leftarrow R_2 - 2R_1}\\] | \\[{R_3 \\leftarrow R_3 - 3R_1}\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9 \\\\ 0 &amp; -5 &amp; -5 &amp; -10 \\\\ 0 &amp; -6 &amp; -10 &amp; -24 \\end{array} \\end{pmatrix}\\] . 두 번째 행을 정규화 (y의 선행 계수를 1로 만들기) . | \\[{R_2 \\leftarrow R_2 / (-5)}\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; -6 &amp; -10 &amp; -24 \\end{array} \\end{pmatrix}\\] . 두 번째 행을 이용해 y항 제거 . | \\[R_1 \\leftarrow R_1 - 2R_2\\] | \\[R_3 \\leftarrow R_3 + 6R_2\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; -4 &amp; -12 \\end{array} \\end{pmatrix}\\] . 세 번째 행을 정규화 (z의 선행 계수를 1로 만들기) . | \\[R_3 \\leftarrow R_3 / (-4)\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; 1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 세 번째 행을 이용해 z 항 제거 . | \\[R_1 \\leftarrow R_1 - R_3\\] | \\[R_2 \\leftarrow R_2 - R_3\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; 2 \\\\ 0 &amp; 1 &amp; 0 &amp; -1 \\\\ 0 &amp; 0 &amp; 1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 결과 . \\[\\begin{cases} x = 2\\\\ y = -1\\\\ z = 3 \\end{cases}\\] . 참고하면 좋은 링크 . | 행 축약 및 (기약)사다리꼴 행렬 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EC%97%B0%EB%A6%BD-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%84-%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EC%97%AC-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#연립-방정식을-사다리꼴-행렬로-변환하여-해-구하기"
  },"243": {
    "doc": "2. GPU 메모리",
    "title": "2. GPU 메모리",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html"
  },"244": {
    "doc": "2. GPU 메모리",
    "title": "1. Memory Levels",
    "content": " ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels"
  },"245": {
    "doc": "2. Initializing DirectX 11",
    "title": "2. Initializing DirectX 11",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html"
  },"246": {
    "doc": "2. Initializing DirectX 11",
    "title": "프레임 워크 요소",
    "content": "D3DClass 추가 . | applicationclass : 그래픽 코드를 처리하여 렌더링. d3dclass 포함 . | D3DClass : direct3D 시스템 함수의 모든 기능을 처리 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#프레임-워크-요소"
  },"247": {
    "doc": "2. Initializing DirectX 11",
    "title": "KEYWORD NOTE",
    "content": "D3DClass 소스 코드에서 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#keyword-note"
  },"248": {
    "doc": "2. Initializing DirectX 11",
    "title": "pragma comment",
    "content": "C++ 전처리기 지시어 중 하나로, 링커(Linker)에게 특정 라이브러리 파일을 링크하라고 알려주는 역할 . | 컴파일이 끝난 후, 최종 실행 파일(.exe)을 만드는 ‘링크’ 단계에서 d3d11.lib 같은 라이브러리 파일들을 자동으로 찾아 연결 | . #pragma comment를 사용하여 소스 코드 내에서 필요한 라이브러리를 명시하면 다른 환경에서 이 코드를 빌드할 때 프로젝트 설정을 다시 만질 필요 없다는 이점이 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#pragma-comment",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#pragma-comment"
  },"249": {
    "doc": "2. Initializing DirectX 11",
    "title": "XMMATRIX",
    "content": "DirectXMath 라이브러리에서 제공하는 4x4 행렬을 다루기 위한 데이터 타입 . 주요 행렬 . | m_worldMatrix (월드 행렬) . | 3D 모델(정점들)을 월드 공간의 특정 위치에 배치하고 회전, 확대/축소하는 역할 | . | m_projectionMatrix (투영 행렬) . | 3D 공간의 물체를 2D 화면에 원근감을 적용하여 그리는 역할 | 멀리 있는 물체는 작게, 가까이 있는 물체는 크게 보이게 만듦 | . | m_orthoMatrix (직교 행렬) . | 원근감을 무시하고 3D 공간의 물체를 2D 화면에 그릴 때 사용 | 주로 UI나 2D 게임을 만들 때 사용 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#xmmatrix",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#xmmatrix"
  },"250": {
    "doc": "2. Initializing DirectX 11",
    "title": "DESC",
    "content": "DESC는 Description(설명)의 약자 . DXGI_SWAP_CHAIN_DESC swapChainDesc; . | DirectX와 같은 복잡한 API에서는 특정 객체(Object)를 생성할 때 수많은 설정값이 필요 | 관련 설정들을 모아놓은 구조체(DESC)를 만들고 이 구조체의 포인터를 함수에 한 번에 전달하는 방식을 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#desc"
  },"251": {
    "doc": "2. Initializing DirectX 11",
    "title": "DXGI_FORMAT",
    "content": "리소스 데이터 형식을 지정 . | dxgi_format | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#dxgi_format",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#dxgi_format"
  },"252": {
    "doc": "2. Initializing DirectX 11",
    "title": "Vsync",
    "content": "VSync (Vertical Synchronization, 수직 동기화)는 게임의 프레임 생성률(FPS)을 모니터의 주사율(Refresh Rate, 보통 60Hz)에 강제로 맞추는 기능 . | vsync를 켜 화면 찢어짐(Screen Tearing) 현상을 방지 | 프레임이 모니터 주사율 (예: 60FPS)로 고정되며, 경우에 따라 입력 지연(Input Lag)이 발생할 수 있다 | . pSwapChain-&gt;Present(SyncInterval, Flags); . | Vsync는 스왑 체인(SwapChain)의 Present 메서드의 SyncInterval 매개변수로 설정 . | 0 : Vsync Off | 1 : Vsync ON (모니터 주기와 동기화. 60Hz면 60FPS로 제한) | 2~4 : 프레임 스로틀링 (1/n 프레임률로 제한) . | 예: 60Hz 모니터에서 SyncInterval=2로 설정 시, 모니터의 수직 동기 신호를 두 번에 한 번꼴로 기다리므로 프레임이 30FPS로 제한됨 | . | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#vsync",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#vsync"
  },"253": {
    "doc": "2. Initializing DirectX 11",
    "title": "device vs deviceContext",
    "content": "Device는 생성을, DeviceContext는 실행을 담당 . | ID3D11Device (장치) . | 역할: 리소스 생성(Creation) 및 GPU 기능 점검 | GPU라는 공장에서 텍스처, 버퍼, 셰이더 같은 제품(리소스)을 만들어내는 역할을 함 | 사용 시점: 주로 초기화 단계에서 리소스를 생성할 때 사용 (CreateTexture2D, CreateBuffer 등) | . | ID3D11DeviceContext (장치 컨텍스트) . | 역할: 렌더링 명령(Command) 실행 | Device가 만든 리소스를 가지고 “이 버퍼를 입력으로 설정해라”, “이 셰이더를 사용해라”, “이제 그려라” 같은 실제 렌더링 명령을 내리는 역할 | 사용 시점: 매 프레임 렌더링 루프에서 상태를 설정하고, 그리기 명령을 호출할 때 사용(IASetVertexBuffers, PSSetShaderResources, DrawIndexed 등) | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#device-vs-devicecontext",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#device-vs-devicecontext"
  },"254": {
    "doc": "2. Initializing DirectX 11",
    "title": "graphics interface factory",
    "content": "DXGI(DirectX Graphics Infrastructure)의 핵심 컴포넌트로 하드웨어 디스플레이 어댑터(GPU)와 출력 장치(모니터)를 관리하기 위해 사용 . IDXGIFactory* factory; result = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&amp;factory); if (FAILED(result)) { return (false); } . 주 사용 목적 . | GPU 어댑터(디바이스) 열거 . | 시스템에 설치된 모든 그래픽 카드(NVIDIA, AMD, Intel 등)를 검색하고 속성(VRAM, 성능 등)을 확인 | 예: IDXGIFactory::EnumAdapters()로 어댑터 목록을 얻어와 특정 GPU를 선택 | . | 스왑 체인(SwapChain) 생성 . | 렌더링 결과를 화면에 출력하기 위한 스왑 체인을 생성 | 예: IDXGIFactory::CreateSwapChain()으로 IDXGISwapChain 객체를 생성 | . | 다중 모니터 관리 . | 연결된 모니터 정보를 조회하거나 전체 화면(Fullscreen) 모드를 제어 | 예: IDXGIOutput을 통해 해상도, 주사율 등을 설정 | . | DXGI 객체 간의 관계 관리 . | 팩토리는 DXGI 리소스(어댑터, 출력 장치, 스왑 체인)의 생명주기를 관리 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#graphics-interface-factory",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#graphics-interface-factory"
  },"255": {
    "doc": "2. Initializing DirectX 11",
    "title": "__uuidof",
    "content": "특정 COM 인터페이스(Interface)의 고유 ID를 가져옴 . // 백 버퍼 포인터 가져오기 result = m_swapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;backBufferPtr); . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#__uuidof",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#__uuidof"
  },"256": {
    "doc": "2. Initializing DirectX 11",
    "title": "Adapter",
    "content": "그래픽 카드(Video Card)나 CPU에 내장된 GPU 같은 물리적인 그래픽 장치를 나타내는 객체 . | 어댑터를 통해 연결된 모니터(Output) 정보를 얻거나 장치의 성능(예: 비디오 메모리)을 확인할 수 있다 | . factory-&gt;EnumAdapters(0, &amp;adapter); . | 시스템의 첫 번째 주 그래픽 카드를 가져오는 코드 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapter",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapter"
  },"257": {
    "doc": "2. Initializing DirectX 11",
    "title": "adapter vs adapterOutput",
    "content": "adapter(그래픽 카드)는 여러 개의 Output(모니터)를 가질 수 있음 . | 구분 | IDXGIAdapter | IDXGIOutput | . | 개념 | 그래픽 처리 하드웨어 | 화면 출력 장치 | . | 비유 | 그래픽 카드 | 모니터 (또는 연결된 포트) | . | 역할 | 3D 연산, 메모리 관리 | 화면 표시, 해상도/주사율 정보 제공 | . | 관계 | 1개의 어댑터가 N개의 출력을 가질 수 있음 | 1개의 출력은 1개의 어댑터에 속함 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapter-vs-adapteroutput",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapter-vs-adapteroutput"
  },"258": {
    "doc": "2. Initializing DirectX 11",
    "title": "GetDisplayModeList()",
    "content": "모니터가 지원하는 디스플레이 모드(해상도, 주사율 등)의 목록을 가져옴 . result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, NULL); . | DXGI_FORMAT_R8G8B8A8_UNORM . | 픽셀 하나를 빨강(R), 초록(G), 파랑(B), 투명도(A) 각각 8비트로 표현하는 32비트 색상 형식을 의미 | . | DXGI_ENUM_MODES_INTERLACED . | 디스플레이 모드 목록을 가져올 때 ‘인터레이스’ 방식도 포함하라는 플래그 | 인터레이스는 화면의 홀수 줄과 짝수 줄을 번갈아 그리는 오래된 방식임 | 현재는 대부분 전체 화면을 한 번에 그리는 ‘프로그레시브(Progressive)’ 방식을 사용 | . | . 호출 패턴 . // 어댑터 출력(모니터)에서 DXGI_FORMAT_R8G8B8A8_UNORM 디스플레이 형식에 맞는 모드 수를 가져오기 result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, NULL); . | 첫 번째 호출: 목록을 저장할 메모리 주소(세 번째 인자)에 NULL을 전달 | 함수는 실제 목록을 반환하는 대신, 목록에 몇 개의 항목이 있는지 그 개수(numModes)만 알려줌 | . // 모니터와 비디오 카드가 조합 가능한 모든 디스플레이 모드 리스트를 생성 displayModeList = new DXGI_MODE_DESC[numModes]; if (!displayModeList) { return (false); } . | 메모리 할당: 알아낸 개수만큼 디스플레이 모드 구조체를 저장할 수 있는 메모리 공간을 동적으로 할당 (new DXGI_MODE_DESC[numModes]) | . result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, displayModeList); . | 두 번째 호출: 이번에는 실제로 할당한 메모리의 주소(displayModeList)를 전달 | 함수가 그 공간에 디스플레이 모드 목록을 채워 넣도록 함 | . 두 번에 나눠서 호출하면 필요한 만큼만 정확하게 메모리를 할당할 수 있음 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#getdisplaymodelist",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#getdisplaymodelist"
  },"259": {
    "doc": "2. Initializing DirectX 11",
    "title": "adapterDesc.DedicatedVideoMemory",
    "content": "adapterDesc.DedicatedVideoMemory가 반환하는 값의 단위는 바이트(Byte) . m_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024); . | 1024 / 1024 두번 나눠서 저장하는 이유? . | bytes / 1024 = 킬로바이트(KB) | KB / 1024 = 메가바이트(MB) | . | . 그래픽 카드의 전용 비디오 메모리 용량을 우리가 흔히 사용하는 메가바이트 단위로 변환하여 저장 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapterdescdedicatedvideomemory",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#adapterdescdedicatedvideomemory"
  },"260": {
    "doc": "2. Initializing DirectX 11",
    "title": "wcstombs_s()",
    "content": "Wide Character String(유니코드, wchar_t*)를 Multi-Byte String(char*)으로 변환하는 C++ 표준 라이브러리 함수 . | _s 접미사는 ‘Secure’를 의미하며, 버퍼 오버플로우를 방지하기 위해 복사할 최대 길이를 지정하는 등 보안이 강화된 버전임 | DirectX/Windows API는 주로 유니코드 문자열을 사용함 . | 코드 내부에서는 일반 char 배열에 저장하고 싶을 때 이 함수를 사용 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#wcstombs_s",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#wcstombs_s"
  },"261": {
    "doc": "2. Initializing DirectX 11",
    "title": "ScanlineOrdering",
    "content": "swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; . | ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED . | 이미지를 그릴 때 위에서 아래로 순차적으로 그릴지(Progressive) | 홀수/짝수 줄을 번갈아 그릴지(Interlaced) 등을 선택 | UNSPECIFIED는 드라이버가 알아서 최적의 방식을 선택하라는 의미 | . | Scaling = DXGI_MODE_SCALING_UNSPECIFIED . | 백 버퍼의 해상도와 실제 출력되는 화면의 해상도가 다를 때, 이미지를 어떻게 확대/축소할지 정함 | UNSPECIFIED는 특별한 스케일링을 지정하지 않겠다는 의미 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#scanlineordering",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#scanlineordering"
  },"262": {
    "doc": "2. Initializing DirectX 11",
    "title": "Depth Buffer",
    "content": "렌더 타겟 (컬러 버퍼 = 백버퍼) 과 동일한 크기를 가지며, 각 픽셀의 색상(Color) 대신 깊이(Depth) 정보를 저장하는 버퍼 . | Z-버퍼(Z-Buffer)라고도 불림 | 깊이는 보통 카메라로부터의 거리를 의미 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#depth-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#depth-buffer"
  },"263": {
    "doc": "2. Initializing DirectX 11",
    "title": "깊이 버퍼가 픽셀에 관여하는 과정",
    "content": "3D 공간에서는 어떤 물체가 다른 물체보다 앞에 있는지, 뒤에 있는지 판단해야 함 . | 기존에 뎁스 버퍼에 저장된 깊이 값과 새로 그릴 픽셀의 깊이 값을 비교 | 새 픽셀의 깊이 값이 더 작으면 (즉, 카메라에 더 가까우면) . | 컬러 버퍼 = 백버퍼에 새 픽셀의 색을 칠하고 뎁스 버퍼의 값도 새 깊이 값으로 업데이트 | . | 새 픽셀의 깊이 값이 더 크면 (더 멀리 있으면) . | 해당 픽셀은 다른 물체에 가려진 것이므로 그냥 무시 | . | . 뎁스 버퍼가 없으면, 나중에 그려진 물체가 무조건 앞에 보이게 되어 3D 공간이 제대로 표현되지 않는다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#%EA%B9%8A%EC%9D%B4-%EB%B2%84%ED%8D%BC%EA%B0%80-%ED%94%BD%EC%85%80%EC%97%90-%EA%B4%80%EC%97%AC%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#깊이-버퍼가-픽셀에-관여하는-과정"
  },"264": {
    "doc": "2. Initializing DirectX 11",
    "title": "Stencil Buffer",
    "content": "깊이 버퍼와 함께 사용되며, 픽셀 단위로 특정 작업을 제어하기 위한 마스킹 기법을 제공함 . // 뎁스 24bit + 스텐실 8bit 깊이 버퍼 생성 depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL; . | 깊이 테스트와 함께 ‘스텐실 테스트’를 수행 | 개발자는 특정 조건을 설정하고, 그 조건의 통과 여부에 따라 스텐실 버퍼의 값을 바꾸거나 픽셀을 그릴지 말지 결정함 | . 스텐실 버퍼 사용 예 . | 거울/포탈 : 거울 영역에만 반사된 세계를 그릴 때 . | 거울 모양으로 스텐실 버퍼에 표시 | 스텐실 버퍼에 표시된 곳에만 반사된 장면을 그림 | . | 평면 그림자(Planar Shadows) : 특정 영역에 그림자 효과를 줄 때 | UI 마스킹: 원형 미니맵처럼 사각형이 아닌 UI 영역을 만들 때 | 물체 외곽선(Outline) 그리기 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#stencil-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#stencil-buffer"
  },"265": {
    "doc": "2. Initializing DirectX 11",
    "title": "FrontFace / BackFace",
    "content": "물체의 앞면과 뒷면을 구분하여 다른 연산을 적용해야 하는 경우 설정 . | 스텐실 버퍼 외에도, 래스터라이저 스테이트의 컬링(Culling) 설정 | 픽셀 셰이더에서 양면 재질을 다르게 렌더링하는 등 3D 렌더링 전반에서 사용되는 근본적인 개념 | . // 픽셀이 앞에 향하는 경우 스텐실 작업 depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP; depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR; depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP; depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // 픽셀이 뒤에 향하는 경우 스텐실 작업 depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP; depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR; depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP; depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS; . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#frontface--backface",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#frontface--backface"
  },"266": {
    "doc": "2. Initializing DirectX 11",
    "title": "Rasterizer State",
    "content": "3D 정점 데이터로 이루어진 삼각형을 2D 화면의 실제 픽셀들로 변환 . | 래스터라이저 스테이트는 이 변환 과정의 규칙을 정하는 설정들의 묶음이다 | . rasterDesc.AntialiasedLineEnable = false; rasterDesc.CullMode = D3D11_CULL_BACK; rasterDesc.DepthBias = 0; rasterDesc.DepthBiasClamp = 0.0f; rasterDesc.DepthClipEnable = true; rasterDesc.FillMode = D3D11_FILL_SOLID; rasterDesc.FrontCounterClockwise = false; rasterDesc.MultisampleEnable = false; rasterDesc.ScissorEnable = false; rasterDesc.SlopeScaledDepthBias = 0.0f; //레스터라이저 스테이트 생성 result = m_device-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;m_rasterState); // 레스터라이저 속성 세팅 deviceContext-&gt;RSSetState(m_rasterState); . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#rasterizer-state",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#rasterizer-state"
  },"267": {
    "doc": "2. Initializing DirectX 11",
    "title": "주요 속성",
    "content": ". | FillMode = D3D11_FILL_SOLID . | 삼각형의 내부를 단색으로 채움 | D3D11_FILL_WIREFRAME으로 바꾸면 선으로만 나옴 | . | CullMode = D3D11_CULL_BACK . | 카메라의 반대 방향을 보는 (뒷면) 삼각형은 그리지 않고 버림 | . | FrontCounterClockwise = false . | 정점들이 시계 방향(Clockwise)으로 정의된 삼각형을 앞면으로 간주 (true면 반시계 방향을 앞면으로 봄) | . | DepthClipEnable = true . | 너무 가깝거나 너무 멀리 있어 절두체(Frustum)를 벗어나는 픽셀들을 잘라내는 (clip) 여부를 결정 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#주요-속성"
  },"268": {
    "doc": "2. Initializing DirectX 11",
    "title": "fieldOfView",
    "content": "fieldOfView = 3.141592654f / 4.0f; screenAspect = (float)screenWidth / (float)screenHeight; . | screenAspect (화면 비율) . | 화면의 너비 / 높이 값입니다 | 이 값을 올바르게 설정해야 3D 공간의 물체가 화면에서 찌그러져 보이지 않음 | . | fieldOfView (시야각, FOV) . | 카메라 렌즈의 화각 | 즉, 카메라가 한 번에 얼마나 넓은 범위를 볼 수 있는지 결정 | 값이 클수록 넓은 영역이 보이지만(광각 렌즈) 화면 가장자리가 왜곡됨 | 값이 작을수록 좁은 영역이 확대되어 보입니다(망원 렌즈) | . | . 3.141592654f / 4.0f를 넣는 이유 . | DirectXMath 함수들은 각도를 도(degree)가 아닌 라디안(radian) 단위로 받는다 | 3.141592654f는 원주율(π)의 근사값 . | π 라디안 = 180도 | 따라서 PI / 4.0 라디안 = 180 / 4.0 = 45도 | . | . 45도는 3D 게임에서 가장 흔하게 사용되는 기본 시야각 중 하나 . | 너무 왜곡되지도 않고 너무 답답하지도 않은 자연스러운 시야를 제공하기 때문에 표준값처럼 사용됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#fieldofview",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#fieldofview"
  },"269": {
    "doc": "2. Initializing DirectX 11",
    "title": "swapChain-&gt;Present()",
    "content": "swapChain-&gt;Present() 함수는 실제로 백 버퍼를 화면에 표시하는 역할을 한다 . void D3DClass::EndScene() { // 렌더링이 완료되었으므로 백 버퍼를 화면에 표시 // vsync가 켜져있다면 (수직 동기화 on) if (m_vsync_enabled) { // 모니터의 수직 동기 신호를 기다렸다가 버퍼를 교체하라 m_swapChain-&gt;Present(1, 0); } else { // 즉시 버퍼 교체 m_swapChain-&gt;Present(0, 0); } return; } . 이 함수는 즉시 반환되지 않고 시간이 걸릴 수 있는데, VSync 설정 때문에 모니터의 갱신 타이밍을 기다려야 할 수 있기 때문 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#swapchain-present",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/2.%20Initializing%20DirectX%2011.html#swapchain-present"
  },"270": {
    "doc": "2. Lighting and Atmosphere",
    "title": "2. Lighting and Atmosphere",
    "content": "조명과 대기/환경광 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html"
  },"271": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Place Actors 창 꺼내기",
    "content": ". | 상단의 프로젝트에 빠르게 추가하기 버튼 (네모 박스 모양+) 클릭 | 액터 배치 패널 클릭 (리스트 최하단에 있음) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#place-actors-%EC%B0%BD-%EA%BA%BC%EB%82%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#place-actors-창-꺼내기"
  },"272": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Lighting 조명",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#lighting-%EC%A1%B0%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#lighting-조명"
  },"273": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Directional Light",
    "content": "무한히 멀리 있는 광원(태양, 달 등)을 모델링하는 방향광 (실제로는 방향만 존재, 위치는 의미 없음) . | 장면 전체에 균일한 방향으로 평행하게 빛을 투사 . | 그림자 방향, 광원의 각도에 따라 환경 전체의 조명 분위기 결정 | . | Sky Atmosphere, Sky Light와 상호작용 . | 태양광이 대기에 산란, 전체 하늘/환경에 영향 | . | . 이동 단축키 . | 첫 번째 태양 이동: Ctrl + L을 누른 채 마우스를 움직임 | 두 번째 태양 이동: Ctrl + Shift + L을 누른 채 마우스를 움직임 . | 짐벌락 현상으로 이동이 안될 때 회전 값 0으로 리셋하면 해결됨 | . | . Mobility 속성 . | Static . | 게임 중 이동/색상/강도 변화 불가 | 그림자와 라이팅 정보를 ‘베이크’(Bake, 미리 계산하여 저장) | 가장 빠르지만 동적인 변화 불가 | . | Stationary . | 색상/강도 변화 가능, 위치/회전은 불가 | 정적인 오브젝트에만 베이크, 동적 오브젝트는 실시간 그림자 | 부분적으로 베이크와 동적 그림자 혼합 | . | Movable . | 위치, 회전, 색상, 강도 모두 실시간 변화 가능 | 그림자도 모두 실시간 계산(가장 비용이 크지만 동적으로 활용 가능) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#directional-light",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#directional-light"
  },"274": {
    "doc": "2. Lighting and Atmosphere",
    "title": "광원 온도 조절",
    "content": ". | Details 패널에서 Use Temperature를 활성화 | 온도값을 변경해 광원의 색감 조절 (낮음: 빨강, 높음: 파랑) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EA%B4%91%EC%9B%90-%EC%98%A8%EB%8F%84-%EC%A1%B0%EC%A0%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#광원-온도-조절"
  },"275": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Atmosphere 대기/환경광",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#atmosphere-%EB%8C%80%EA%B8%B0%ED%99%98%EA%B2%BD%EA%B4%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#atmosphere-대기환경광"
  },"276": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Sky Atmosphere",
    "content": "현실적인 하늘과 대기 산란 효과를 구현하는 대기 렌더링 시스템 . | 최대 두 개의 Directional Light 사용 . | 예 : 하나는 태양, 또 하나는 달 / 두 번째 태양을 시뮬레이션 | . | Sky Atmosphere는 Directional Light와 매우 밀접하게 동작한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-atmosphere",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-atmosphere"
  },"277": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Sky Light",
    "content": "씬의 먼 배경(하늘, 산 등)에서 오는 간접광을 씬 전체에 균일하게 적용하는 광원 . Mobility . 속성에 따라 캡처 시점이 다름 . | Static: 라이팅 빌드 시 캡처 | Stationary/Movable: 한 번만 캡처하거나, 수동으로 캡처 가능 | Real-time Capture 활성화 시, 장면 변화(예: 낮/밤)에 맞춰 항상 업데이트 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-light",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-light"
  },"278": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Exponential Height Fog",
    "content": "고도에 따라 점진적으로 농도가 짙어지는 대기 안개 표현 . | 지면 기준, 카메라 거리 기준으로 안개 농도 조절 . | 거리 감쇠(attenuation), 높이 감쇠(height falloff) 파라미터 제공 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#exponential-height-fog",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#exponential-height-fog"
  },"279": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Volumetric Clouds",
    "content": "실제 부피감을 가지는 3D 볼륨 클라우드(입체 구름) 렌더링 시스템 . | 기존 스카이 스피어 메시에 머티리얼을 씌우던 방식에서 진화 | 동적으로 움직이며, 3D 볼륨 형태의 실시간/동적 구름 | 머티리얼 기반으로 효과 변형 가능 | 대기와 같이 빛 산란 효과 적용 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#volumetric-clouds",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#volumetric-clouds"
  },"280": {
    "doc": "2. Lighting and Atmosphere",
    "title": "물리 단위 참조 테이블",
    "content": "| 파라미터 | 물리 단위 | UE5 기본값 | . | Directional Light | Lux | 100,000 | . | Sky Light | cd/m² | 1.0 | . | Fog Density | 1/m | 0.02 | . | Cloud Albedo | 반사율 | 0.8 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EB%AC%BC%EB%A6%AC-%EB%8B%A8%EC%9C%84-%EC%B0%B8%EC%A1%B0-%ED%85%8C%EC%9D%B4%EB%B8%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#물리-단위-참조-테이블"
  },"281": {
    "doc": "2. Lighting and Atmosphere",
    "title": "환경광/대기 효과 렌더링 파이프라인",
    "content": ". | UE5는 Defered Rendering (지연 렌더링) 기반 | . 전체 플로우의 순차적 구조 . | Geometry Pass에서 GBuffer에 모든 기초 정보 기록 → | Lighting Pass에서 모든 라이트와 GI 적용 → | Atmosphere/Clouds/Fog 등 대기 및 볼륨 효과 순차 합성 → | Post Processing에서 각종 시각효과 추가 → | Tone Mapping/Color Grading으로 최종 색상 보정 → | Final Frame으로 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%ED%99%98%EA%B2%BD%EA%B4%91%EB%8C%80%EA%B8%B0-%ED%9A%A8%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#환경광대기-효과-렌더링-파이프라인"
  },"282": {
    "doc": "2. Lighting and Atmosphere",
    "title": "환경광/대기 효과 렌더링 파이프라인 도식화 (UE 5.3 이상)",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%ED%99%98%EA%B2%BD%EA%B4%91%EB%8C%80%EA%B8%B0-%ED%9A%A8%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EB%8F%84%EC%8B%9D%ED%99%94-ue-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#환경광대기-효과-렌더링-파이프라인-도식화-ue-53-이상"
  },"283": {
    "doc": "2. Lighting and Atmosphere",
    "title": "주요 단계 요약",
    "content": ". | Geometry Pass (Base Pass) . | 모든 메쉬의 표면 정보를 G-buffer에 기록 | Normal, Albedo, Roughness, Metallic, Depth 등 | . | Lighting Pass . | Directional Light . | 직접광, 그림자 처리 | . | Point/Spot Lights (지역 광원) | Sky Light . | 환경광 및 HDRI 반사 적용 | 하늘/환경 정보로부터 간접광 샘플링 | . | . | Atmospheric Pass . | Sky Atmosphere . | 기본 하늘 색상, 대기 산란 계산 | 뷰 방향, 태양 각도, 대기 매개변수로 실시간 산란 연산 | . | . | Volumetric Pass . | Volumetric Clouds . | 구름 및 3D 볼륨 안개, 빛 산란 효과 | 최종적으로 구름 효과 합성 | . | . | Fog Pass . | Exponential Height Fog (안개, 빛줄기) . | 카메라 거리/고도 기반 대기 안개 | 공간 깊이감 추가 | . | . | Post Process Pass . | SSAO/GTAO (앰비언트 오클루전) | Bloom/Lens Flare (광학 효과) | TAA/FSR/DLSS (안티앨리어싱) | . | Tone Mapping . | Color Grading/LUT (색 보정 및 최종 합성) | . | Final Frame Output . | 최종 이미지 출력 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EC%A3%BC%EC%9A%94-%EB%8B%A8%EA%B3%84-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#주요-단계-요약"
  },"284": {
    "doc": "2. Linear independence",
    "title": "Linear independence",
    "content": ". ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#linear-independence",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#linear-independence"
  },"285": {
    "doc": "2. Linear independence",
    "title": "선형 독립",
    "content": ". | 벡터 집합 \\(\\{v1, v2 ... , v_n\\}\\)이 다음을 만족할 때 선형 독립 | . \\[c_1\\mathbf{v}_1 + c_2\\mathbf{v}_2 + \\cdots + c_n\\mathbf{v}_n = \\mathbf{0} \\quad \\text{을 만족하는 유일한 해는}\\\\ \\quad c_1 = c_2 = \\cdots = c_n = 0\\] . | 예: \\(\\Reals^2\\)에서 (1, 0)과 (0, 1)은 선형 독립 | . 즉, . | 집합 내 어떤 벡터도 다른 벡터들의 선형 조합으로 표현될 수 없음 | 각 벡터가 고유한 방향성을 가짐 | 벡터 공간의 기저(basis)를 구성하는 핵심 성질 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#선형-독립"
  },"286": {
    "doc": "2. Linear independence",
    "title": "선형 종속",
    "content": ". | 벡터 집합이 선형 독립이 아닐 때 선형 종속 | . \\[\\text{선형 종속} \\iff \\exists \\, c_1, c_2, \\dots, c_n \\ (\\text{모두 0은 아니며, 적어도 하나는 0이 아님})\\] . | 예: \\(\\Reals^2\\)에서에서 (1,2)와 (2,4)는 선형 종속 (∵ (2,4)=2×(1,2)) | . 즉, . | 집합 내 적어도 하나의 벡터가 다른 벡터들의 선형 조합으로 표현 가능 | “중복된” 방향 정보를 포함 | 벡터 공간의 차원을 낮추는 효과 | . | 선형 종속은 비자명해(non-trivial solution)가 존재한다 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EC%84%A0%ED%98%95-%EC%A2%85%EC%86%8D",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#선형-종속"
  },"287": {
    "doc": "2. Linear independence",
    "title": "중요 성질",
    "content": ". | \\(\\Reals^{n}\\)에서 n+1개 이상의 벡터는 항상 선형 종속 | 기저 벡터들은 선형 독립 | 선형 변환 후에도 선형 관계는 보존됨 | 기저(basis)의 정의: . | 벡터 공간 V의 기저는 V를 생성하는 선형 독립인 벡터들의 집합 | . | 랭크(rank)와의 관계: . | 행렬의 랭크 = 선형 독립인 열(또는 행) 벡터의 최대 개수 | . | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EC%A4%91%EC%9A%94-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#중요-성질"
  },"288": {
    "doc": "2. Linear independence",
    "title": "기하학적 의미 (2D/3D 예시)",
    "content": "2차원에서 . | 두 벡터가 평행하지 않음 ⇔ 선형 독립 (예: (1,0)과 (0,1)) | 두 벡터가 평행 ⇔ 선형 종속 (예: (2,2)와 (4,4)) | . 3차원에서 . | 세 벡터가 동일 평면 상에 있지 않음 ⇔ 선형 독립 | 세 벡터가 한 평면 상에 있음 ⇔ 선형 종속 (예: (1,0,0), (0,1,0), (1,1,0)) | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EA%B8%B0%ED%95%98%ED%95%99%EC%A0%81-%EC%9D%98%EB%AF%B8-2d3d-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#기하학적-의미-2d3d-예시"
  },"289": {
    "doc": "2. Linear independence",
    "title": "선형 독립 판별 방법",
    "content": ". | 벡터 개수와 차원 비교 | . \\[\\text{ℝ}^n \\text{에서}: \\begin{cases} \\text{벡터 개수} &gt; n \\Rightarrow \\text{무조건 선형 종속} \\\\ \\text{벡터 개수} = n \\Rightarrow \\text{행렬식 또는 RREF로 판별} \\\\ \\text{벡터 개수} &lt; n \\Rightarrow \\text{RREF로 판별} \\end{cases}\\] . | 행렬식(det)을 이용한 판별 . | n×n 행렬 (정사각형) 에 대해 적용 가능한 방법 | . | . \\[2×2 \\ det \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} = ad - bc\\] . | 가우스-조던 소거법을 이용한 판별 . | m×n 행렬에 대해 일반적으로 적용 가능한 방법 | . | . \\[\\text{벡터 } \\mathbf{v}_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 2 \\end{bmatrix}, \\mathbf{v}_2 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 3 \\end{bmatrix}, \\mathbf{v}_3 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 5 \\end{bmatrix}\\] \\[A = \\begin{bmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 2 &amp; 3 &amp; 5 \\end{bmatrix} \\xrightarrow{\\text{RREF}} \\begin{bmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}\\] . \\[\\text{3번째 열이 피벗 열 아님} \\Rightarrow \\text{선형 종속}\\] . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD-%ED%8C%90%EB%B3%84-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#선형-독립-판별-방법"
  },"290": {
    "doc": "2. Linear independence",
    "title": "동차 시스템에서 해의 유일성 판별",
    "content": ". 1.선형 독립인 경우 (유일 해) . | 동차 방정식의 해가 자명해만 존재 . | \\[c_1 = c_2 = 0\\] | . | . | 예시 | . \\[v_1 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} v_2 = \\begin{bmatrix} 0 \\\\ 6 \\end{bmatrix}\\] . | 동차 선형 방정식 | . \\[c_1\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} + c_2 \\begin{bmatrix} 0 \\\\ 6 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . | 해 구하기 | . \\[\\begin{cases} c_1\\cdot 1 + c_2\\cdot 0 = 0 \\ (1)\\\\ c_1\\cdot 1 + c_2 \\cdot 6 = 0 \\ (2) \\end{cases}\\] . | (1) 식 : \\(c_1 = 0\\) | (2) 식에 대입 : \\(- + 6c_2 = 0 \\Rightarrow c_2 = 0\\) | . 즉, . | 유일한 해는 \\(c_1 = c_2 = 0\\) 이므로 \\(v_1, v_2\\) 는 선형 독립 | . 2.선형 종속인 경우 (비자명 해) . | 예시 | . \\[v_1 = \\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} v_2 = \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix}\\] . | 동차 선형 방정식 | . \\[c_1\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} + c_2 \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . | 해 구하기 | . \\[\\begin{cases} 2\\cdot c_1 + 4 \\cdot c_2 = 0 \\ (1)\\\\ 2\\cdot c_1 + 4 \\cdot c_2 = 0 \\ (2) \\end{cases}\\] . | 하나의 자유 변수가 존재 | . \\[c_1 = -2c_2\\] \\[c_2 = 1 \\text{이면} \\ c_1 = -2\\] . \\[-2\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} + 1 \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} -4+4 \\\\ -4+4 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . 즉, 영벡터를 만드는 0이 아닌 계수 조합이 존재 . | \\(c_1 = c_2 = 0\\) 이 영벡터를 만드는 유일한 해가 아니므로 \\(v_1, v_2\\) 는 선형 종속 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#%EB%8F%99%EC%B0%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C-%ED%95%B4%EC%9D%98-%EC%9C%A0%EC%9D%BC%EC%84%B1-%ED%8C%90%EB%B3%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html#동차-시스템에서-해의-유일성-판별"
  },"291": {
    "doc": "2. Linear independence",
    "title": "2. Linear independence",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence.html"
  },"292": {
    "doc": "2. Master Material",
    "title": "2. Master Material",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html"
  },"293": {
    "doc": "2. Master Material",
    "title": "1. Master Material",
    "content": "마스터 머티리얼을 만들고 이 마스터 머티리얼의 여러 인스턴스만 사용하는 방법을 통해 공간 절약, 씬의 성능 상향이 가능함. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material"
  },"294": {
    "doc": "2. Master Material",
    "title": "2. Albedo vs Diffuse",
    "content": "베이스 컬러에 쓰이는 텍스쳐가 두 가지 용어를 혼합하여 쓰길래 두 키워드의 차이점이 무엇인지 궁금해졌다. ❓베이스 컬러에 들어가는 알베도와 디퓨즈의 차이점이 뭐지? . | Albedo : 물리 기반 렌더링(PBR)에서 도입. 표면이 반사하는 확산 반사 비율 또는 색상을 의미 | Diffuse : 전통적인 3D 그래픽스에서 디퓨즈 맵은 표면의 기본 색상을 정의한다. 빛의 영향을 받아 명암이 생기는 재질 표현에 사용 | . Albedo vs Diffuse 정리 . | 항목 | Albedo | Diffuse | . | 정의 | 순수한 반사율 (빛의 간섭 없음) | 빛의 난반사로 인한 색상 + 명암 | . | 사용 예 | PBR (물리 기반 렌더링) | 전통적 라이팅 모델 (램버트 반사 등) | . | 데이터 | 환경광의 영향이 제거된 순수 색상 | 그림자/광택 일부 포함 가능 | . | 예시 | Unreal, Unity등에서 PBR 재질의 Base Color로 사용 | Photoshop 등에서 조명까지 표현한 diffuse map 제작 가능 | . | Diffuse 텍스처에는 실제 광원이 없어도 명암이 들어감. | 조명 대응 불가 (광원 위치를 바꿔도 그림자는 바뀌지 않음) | . | . | 텍스처에 조명, 그림자, 반사 등을 “베이크”해서 포함시킨 것 = diffuse map | 조명과 독립적인 순수한 색상. 빛은 셰이더에서 계산함 = Albedo | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse"
  },"295": {
    "doc": "2. Master Material",
    "title": "3. Texture Coordinate",
    "content": "UV 매핑을 제어하는 노드로 머티리얼이 메시 표면에 어떻게 텍스쳐를 투영할지 결정한다. | 모델의 각 정점(Vertex)에는 UV 좌표(0~1 범위의 2D 좌표)가 할당되어 있으며, 이 노드는 해당 좌표를 조정하거나 변형할 때 사용할 수 있다. | . | 기본 출력: UV 채널의 2D 벡터(X, Y). 각 성분은 일반적으로 0.0 ~ 1.0 범위 . | X(U): 가로 축 좌표 (좌 → 우) | Y(V): 세로 축 좌표 (하 → 상) | . | Coordinate Index: 다중 UV 채널을 선택할 수 있다. | 정적 메시의 Lightmap UV(UV1) 등 추가 좌표 계층을 활용할 때 유용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate"
  },"296": {
    "doc": "2. Master Material",
    "title": "4. Vector4",
    "content": ". | Vector4 노드의 R,G,B,A에 각각 U tile, V tile, U offset, V offset 이라고 이름을 붙여 텍스쳐 타일링에 사용할 수 있다. | 타일링 *= multiply | 오프셋 += add | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4"
  },"297": {
    "doc": "2. Master Material",
    "title": "5. static swich parameter",
    "content": "머티리얼 그래프 내에서 분기를 정의하고, 머티리얼 인스턴스 에디터에서 체크박스로 설정 가능하게 해준다. | 정적(static) 이 붙은 이유 : 런타임에 변경되지 않고 머티리얼 컴파일 타임에 결정됨 | 사용되지 않는 쪽의 분기는 완전히 제거되어 실행 시간이 최적화 | . | 입력 A : A 로직 (스위치가 True일 때 적용) | 입력 B : B 로직 (스위치가 False일 때 적용) | 출력 : True는 A, False는 B 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter"
  },"298": {
    "doc": "2. Master Material",
    "title": "RGB 표현",
    "content": "❓언리얼 엔진에서는 RGB가 0~255 값이 아니라고? . | 언리얼에서는 RGB 표현을 정규화된 0~1 범위로 사용한다. | 0~255 와 0~1 두 범위 모두 동일한 색상을 나타내지만, 사용하는 컨텍스트와 시스템에 따라 다른 스케일로 표현된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-표현"
  },"299": {
    "doc": "2. Master Material",
    "title": "왜 언리얼 엔진은 0~1 범위를 사용할까?",
    "content": ". | 수학적 일관성 . | 3D 그래픽스에서는 벡터 연산이 빈번하게 일어남 | 0~1 범위는 퍼센트 개념과 연결되며, 모든 계산을 비율 기반으로 통일할 수 있다. | 예: 0.5 = 50% 밝기 -&gt; 0.5 * 2.0 = 1.0 (100%) | . | . | HDR (High Dynamic Range) 지원 . | 0~1 범위를 벗어나는 값 (예: 2.0) 으로 더 밝은 빛을 표현할 수 있다. | . | GPU 친화적 . | 현대 GPU는 부동소수점(float) 계산에 최적화되어 있어 0~1 범위가 셰이더 연산과 호환성이 좋다. | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%99%9C-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84%EC%9D%80-01-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#왜-언리얼-엔진은-01-범위를-사용할까"
  },"300": {
    "doc": "2. Master Material",
    "title": "RGB 정규화 방법",
    "content": ". | 0~255 -&gt; 0~1 (정규화) = 값 / 255 | . RGB(255, 127, 0) -&gt; RGB(1.0, 0.498, 0.0) . | 0~1 -&gt; 0~255 (역정규화) = 값 * 255 (반올림 적용) | . RGB(0.5, 0.75, 1.0) -&gt; RGB(128, 191, 255) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-정규화-방법"
  },"301": {
    "doc": "2. Master Material",
    "title": "Color Control",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control"
  },"302": {
    "doc": "2. Master Material",
    "title": "1. 밝기: Brightness",
    "content": ". | RGB 값에 1보다 큰 수를 곱하는 것으로 설정 가능. | RGB는 0.0 ~ 1.0 범위로 표현됨 . | 0.0 = 완전한 어둠 (검정) | 1.0 = 최대 밝기 (순수한 색상) | . | R * 2 = R의 밝기 2배 증가 | R * 0.5 = R의 밝기 50% 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-%EB%B0%9D%EA%B8%B0-brightness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-밝기-brightness"
  },"303": {
    "doc": "2. Master Material",
    "title": "2. 채도: Satration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-%EC%B1%84%EB%8F%84-satration",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-채도-satration"
  },"304": {
    "doc": "2. Master Material",
    "title": "desaturation (탈색)",
    "content": "특정 색상을 흑백(grayscale)에 가깝게 변환하는 데 사용되는 노드. 이 노드를 사용하여 채도를 조절한다. | 입력 input (V3) : 일반적으로 텍스쳐의 RGB가 입력됨 | 입력 Fraction (V1) : 채도를 얼마나 줄일지 결정하는 값. | 0 : 원본 색상 유지 | 1 : 완전히 회색 | . | 출력 (V3) : desaturation 적용 결과 | . 내부 연산 공식 . Gray = R * 0.3 + G * 0.59 + B * 0.11 Output = lerp(Input, Gray, Fraction) . | Gray는 NTSC 표준 기반의 가중 평균. 인간의 눈이 가장 민감한 녹색에 높은 가중치를 둠 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-%ED%83%88%EC%83%89",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-탈색"
  },"305": {
    "doc": "2. Master Material",
    "title": "3. 대비: Contrast",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-%EB%8C%80%EB%B9%84-contrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-대비-contrast"
  },"306": {
    "doc": "2. Master Material",
    "title": "power",
    "content": "입력 값의 지수 승(power/exponentiation) 을 계산하는 노드 . Output = Base ^ Exponent . | 입력 Base (V,V3) : 일반적으로 RGB 텍스쳐 입력 | 입력 Exponent (V) : 지수 값. | 출력 (V, V3): 계산된 결과 값 (Base의 Exponent 승) | . ❓왜 Contrast 조절에 Power를 쓰는거야? . | power는 단순 곱셈으로는 할 수 없는 비선형적인 변화를 제공하기 때문이다 | . 곱셈 (Multiply) vs 지수승 (Power) . | 특성 | 곱셈 | 지수승 | . | 수학적 표현 | RGB × Scale | RGB ^ Gamma | . | 연산 유형 | 모든 픽셀의 밝기를 균일하게 스케일링 어두운 영역과 밝은 영역이 동일한 비율로 변화 | 비선형변환으로 밝기 분포를 비균형적으로 조정 | . | 밝기 변화 | 모든 픽셀 균일하게 스케일링 | 밝은 픽셀은 더 밝게 어두운 픽셀은 더 어둡게 (분포 왜곡) | . | 대비(Contrast) 영향 | 대비 유지 | 대비 증가 (Gamma &gt; 1) 대비 감소 (Gamma &lt; 1) | . | 시각적 효과 | 전체적으로 밝아지거나 어두워짐 | 어두운 영역과 밝은 영역의 차이 강조 or 완화 | . | 사용 예시 | 밝기 조정, 라이트 강도 증감 | Contrast 조정, 감마 보정 | . RGB (0.2, 0.5, 0.8) Power(2.0) -&gt; RGB(0.04, 0.25, 0.64) // 어두운 부분은 급격히 어두워지고 밝은 픽셀은 상대적으로 덜 영향받음. = 대비 강해짐 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power"
  },"307": {
    "doc": "2. Master Material",
    "title": "4. 색조: Tint",
    "content": "Base color의 RGB에 다른 색상의 RGB를 곱해서 얻을 수 있다. | 채널별 스케일링 . | 곱해지는 색상의 각 채널 값이 원본 색상의 해당 채널을 강화하거나 약화시킴 | 1.0 : 해당 채널 100% 유지 | 0.5 : 해당 채널 50% 감소 | 0.0 : 해당 채널 완전히 제거 | . | . // 원본 색상 RGB(0.8, 0.5, 0.2) // Tint 색상 RGB(1.0, 0.3, 0.3) // 결과 -&gt; R은 유지, G/B는 감소 (0.8*1.0, 0.5*0.3, 0.2*0.3) = (0.8, 0.15, 0.06) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-%EC%83%89%EC%A1%B0-tint",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-색조-tint"
  },"308": {
    "doc": "2. Master Material",
    "title": "6. MI Organize Paramaters",
    "content": "파라미터 노드를 그룹화 하여 마테리얼 인스턴스의 파라미터들을 원하는 순서대로 분류할 수 있다. | 파라미터 노드 클릭 | Details 창의 Material Expression 에서 Group 설정 . | 그룹은 0 - Z 알파벳 네임 순서대로 정렬되므로 00 Global Control, 01 Base Color 등으로 순서를 정함. | . | 그룹에 들어가길 원하는 파라미터 노드를 설정한 그룹에 넣어줌 | 그룹 하위 파라미터 노드들은 Sort Priority (정렬 우선순위)의 낮은 수 순서대로 마테리얼 인스턴스 그룹 목록에 정렬됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters"
  },"309": {
    "doc": "2. Master Material",
    "title": "7. Metallic",
    "content": "머티리얼 에디터에서 Metallic 소켓은 표면이 금속성인지 여부를 정의하는 입력값이다. 입력 값 범위: 0.0에서 1.0 사이의 스칼라(float) 값. | 0.0: 비금속(non-metal) 재질. (예: 나무, 플라스틱, 돌 등.) | 1.0: 금속(metal) 재질. (예: 철, 금, 알루미늄 등.) | 0.0과 1.0 사이의 값: 녹슨 금속과 같은 재질을 표현할 때 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic"
  },"310": {
    "doc": "2. Master Material",
    "title": "8. Specular",
    "content": "표면이 반사하는 거울 반사(specular reflection)의 강도를 조절하는 소켓. 디폴트 값은 0.5이다. Specular 값은 비금속 재질의 반사 특성을 조절하며, 금속 재질(Metallic)에는 영향을 주지 않는다. | 0.0: 표면이 전혀 반사하지 않음 (완전한 확산 반사) | 0.5: 표면이 약 4%의 빛을 반사함 (일반적인 비금속 재질의 기본값) | 1.0: 표면이 최대 8%의 빛을 반사함 (매우 반짝이는 비금속 재질) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular"
  },"311": {
    "doc": "2. Master Material",
    "title": "9. Roughness",
    "content": "표면의 거칠기를 정의하는 소켓으로 빛이 표면에 어떻게 반사되는지를 결정한다. 디폴트 값은 0.5이다. | 0.0: 매우 매끄러운 표면. 반사가 거울처럼 선명함 (예: 유리, 금속) | 0.5: 중간 정도 거칠기 반사가 흐릿하고 부드럽게 번짐 | 1.0: 매우 거친 표면. 반사가 거의 없거나 전혀 없음 (예: 콘크리트, 모래) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness"
  },"312": {
    "doc": "2. Master Material",
    "title": "Metallic vs Specular Workflow",
    "content": "메탈릭 워크플로우와 스페큘러 워크플로우는 PBR에서 재질을 표현하는 두 가지 다른 방식이며, 계산 공식과 입력값이 근본적으로 다르다. | UE5는 메탈릭/러프니스(Metallic/Roughness) 워크플로우에 최적화되어있다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow"
  },"313": {
    "doc": "2. Master Material",
    "title": "Metallic/Roughness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | BaseColor | 비금속: 재질의 기본 색상(Diffuse) 금속: 반사 색상(Fresnel F₀) | RGB | 금속은 diffuse(산란) 사용 X. 반사 색상이 사용됨 | . | Metallic | 재질이 금속인지 여부를 정의. 0: 비금속 1: 금속 | Grayscale | - 흰색: 금속 - 검은색: 비금속 | . | Roughness | 표면의 거칠기를 정의 0: 매끄러움 1: 거칠음 | Grayscale | Glossiness와 반대 | . | 메탈릭은 Metallic 맵으로 금속/비금속을 강제 분리해 물리적 일관성을 확보함 . | Metallic 파라미터 (0,1)로 재질 타입을 이진화 | 금속 (Metallic = 1) . | BaseColor = Fresnel 반사 색상 (F0). | Diffuse 성분 = 0 (물리적으로 정확한 금속 모델). | . | 비금속 (Metallic = 0) . | BaseColor = Diffuse 알베도. | Specular는 고정값 (~0.04) 또는 Specular 입력으로 미세 조정 | . | . | 메모리 효율적 (Specular 맵 불필요), 실시간 렌더링에 최적화. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-주요-맵-설명"
  },"314": {
    "doc": "2. Master Material",
    "title": "Specular/Glossiness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | Diffuse | 비금속 재질의 기본 색상. 금속: 디퓨즈 맵 사용 X | RGB | 메탈릭 워크플로우의 BaseColor와 유사하지만, 금속에서는 무시됨. | . | Specular | 모든 재질의 반사 색상 및 강도 금속: RGB 비금속: Grayscale | RGB / Grayscale | 메탈릭 워크플로우의 Metallic + BaseColor 역할을 동시에 함. | . | Glossiness | 표면 광택도 0: 거칠음 1: 매끄러움 | Grayscale | Roughness와 반대 | . | 스페큘라는 Specular 맵으로 반사 색상과 강도를 직접 제어함 | 반사 색상의 자유도 높음, 오프라인 렌더링(V-Ray)과 호환됨 | . 참고하면 좋은 링크 . | Metalness Maps and Workflow Explained . | PBR: metallic vs specular workflow . | Specular vs Metalness Workflows for PBR Shading in Blender . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-주요-맵-설명"
  },"315": {
    "doc": "2. Master Material",
    "title": "sRGB (standard Red Green Blue)",
    "content": "sRGB는 모니터, TV 등 대부분의 디스플레이에서 사용하는 표준 색 공간이다. | 사람이 인지하는 색감을 기준으로 설계됨 . | 인간의 눈은 어두운 색상의 변화에 더 민감함 | sRGB는 이를 반영해 암부(어두운 영역)의 색상 정보를 강조하는 비선형 곡선을 사용 | . | 감마 보정이 포함되어 있음 (약 γ = 2.2) . | 즉 색상 데이터가 밝게 저장됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue"
  },"316": {
    "doc": "2. Master Material",
    "title": "Gamma vs inear Workflow",
    "content": ". | 감마 워크플로우 (Gamma Workflow) . | 전통적인 방식으로, sRGB 공간에서 렌더링을 수행 | 텍스처와 최종 출력이 sRGB로 가정되기 때문에, 라이팅 계산 시 자동으로 리니어로 변환되지 않음 | 실시간 라이팅 계산이 부정함 (예: 어두운 영역에서 색상 밴딩 발생) | PBR(물리 기반 렌더링)과 호환성이 떨어짐 | . | 리니어 워크플로우 (Linear Workflow) . | 리니어 컬러 스페이스에서 렌더링을 수행 | 텍스처는 sRGB에서 로드될 때 자동으로 리니어로 변환되고, 최종 출력 시 다시 sRGB로 감마 보정 | 물리적으로 정확한 라이팅 계산이 가능 | . | . 감마, 리니어 워크플로우 처리과정 . | 감마 워크플로우 . | 텍스처(sRGB) → (감마 보정 해제 없음) → 라이팅 계산 → 출력(sRGB) | . | 리니어 워크플로우 . | 텍스처(sRGB) → 자동 리니어 변환 → 물리적 라이팅 계산 → sRGB로 출력 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow"
  },"317": {
    "doc": "2. Master Material",
    "title": "☑️결론",
    "content": "언리얼 엔진 5에서의 동작 . 텍스처 . | sRGB 플래그가 켜진 텍스처 (알베도, 디퓨즈)는 리니어로 변환되어 쉐이더에서 사용 | sRGB 플래그가 꺼진 텍스처 (메탈릭, 러프니스)는 변환 없이 리니어로 읽힘 | . 라이팅 계산 . | 모든 쉐이더 연산은 리니어 공간에서 이루어짐 | 실시간 광원, GI, 반사 등이 물리적으로 정확하게 계산 | . 최종 출력 . | 최종 프레임 버퍼는 모니터 표준(sRGB)에 맞게 자동 감마 보정되어 출력 | . 참고하면 좋은 링크 . | computer color is broken | Gamma Vs. Linear Workflow for KeyShot Users | UNDERSTANDING GAMMA CORRECTION | Gamma Color space와 Linear Color space란? | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EF%B8%8F%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#️결론"
  },"318": {
    "doc": "2. Master Material",
    "title": "Texture Compression Settings (텍스쳐 압축 세팅)",
    "content": "텍스쳐를 더블 클릭하면 열리는 창으로 텍스쳐 압축 세팅 설정 가능. | 알파가 없는 텍스쳐는 알파 없이 압축 체크 (Compress Without Alpha) | sRGB가 아닌 텍스쳐는 sRGB 체크 해제 | Compression Settings 에서 세팅 설정 . | Masks (no sRGB) | . | . 텍스쳐 샘플러 노드의 설정으로 샘플러 타입 설정 가능. | 텍스쳐가 sRGB라면 Sampler Type = color | 텍스쳐가 sRGB가 아니아면 Sampler Type = Linear color . | BlackPlaceholder | . | . 압축 설정과 샘플러 타입 설정이 모두 같게 설정 되어야 한다. (sRGB가 아닌경우 샘플러 Linear) . 참고하면 좋은 링크 . | Texture Compression Settings | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-%ED%85%8D%EC%8A%A4%EC%B3%90-%EC%95%95%EC%B6%95-%EC%84%B8%ED%8C%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-텍스쳐-압축-세팅"
  },"319": {
    "doc": "2. Master Material",
    "title": "10. Normal",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal"
  },"320": {
    "doc": "2. Master Material",
    "title": "로우 폴리 vs 하이 폴리 모델",
    "content": ". | 로우 폴리 모델은 표면이 평평하고 법선이 단순. | 하이 폴리 모델은 표면이 복잡하고 법선이 다양. | . 노멀 맵은 하이 폴리 모델의 법선 정보를 로우 폴리 모델에 “옮기는” 기술이다. | 로우 폴리 모델의 정점 법선은 평평해 보이지만, 노멀 맵으로 인해 픽셀 단위로 법선이 조정되어 하이 폴리 같은 디테일이 나온다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%A1%9C%EC%9A%B0-%ED%8F%B4%EB%A6%AC-vs-%ED%95%98%EC%9D%B4-%ED%8F%B4%EB%A6%AC-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#로우-폴리-vs-하이-폴리-모델"
  },"321": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 좌표계 (탄젠트 공간)",
    "content": "노멀 맵은 탄젠트 공간에 저장된다. | 노멀 맵의 픽셀 값 (R, G, B)은 탄젠트 공간에서의 법선 방향을 나타냄 | Z축은 “표면 바깥쪽”을 가리킨다. (일반적으로 (0,0,1)이 기본 법선) | 탄젠트 공간은 각 정점마다 다르다. | 노멀 맵의 법선 벡터는 각 정점의 탄젠트 공간(= 각 정점의 로컬 좌표계) 기준으로 저장된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%A2%8C%ED%91%9C%EA%B3%84-%ED%83%84%EC%A0%A0%ED%8A%B8-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-좌표계-탄젠트-공간"
  },"322": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 생성 과정",
    "content": "노멀 맵은 하이 폴리 모델의 법선을 로우 폴리 모델의 탄젠트 공간에 투영하여 저장한다. 1.하이 폴리 모델의 법선 추출 . | 하이 폴리 모델의 각 정점 법선을 계산 | 하이 폴리 모델의 법선은 월드 공간 또는 오브젝트 공간에 있음 | . 2.로우 폴리 모델의 탄젠트 공간 계산 . | 로우 폴리 모델의 각 정점에서 TBN 기저(basis)를 계산 | 로우 폴리 모델의 각 정점은 자신만의 T, B, N 벡터를 가진다. | 노멀 맵을 탄젠트 공간에 저장하기 위한 기준 좌표계를 제공 . | T (Tangent): UV의 U 방향 (텍스처 가로) | B (Bitangent): UV의 V 방향 (텍스처 세로) | N (Normal): 로우 폴리 모델의 표면 법선 | . | . 3.하이 폴리의 법선 → 로우 폴리의 탄젠트 공간으로 변환 . | 하이 폴리 법선을 로우 폴리 모델의 TBN 행렬의 역행렬로 변환한다. | 하이 폴리 법선을 탄젠트 공간으로 변환한 결과 값은 -1 ~ 1 범위를 가짐 | 변환된 법선을 RGB 값 (0 ~ 1)으로 리매핑해 저장 | . // 하이 폴리 법선 (오브젝트 공간) vec3 normal_high = normalize(hitNormal); // 탄젠트 공간으로 변환 (TBN은 로우 폴리의 기저) vec3 normal_tangent = transpose(TBN) * normal_high; // 노멀 맵 저장 (0~1 리매핑) vec3 normalMapValue = normal_tangent * 0.5 + 0.5; . | 채널 | 벡터 구성요소 | 설명 | . | R | X | Tangent(가로) 방향의 법선 벡터 성분 | . | G | Y | Bitangent(세로) 방향의 법선 벡터 성분 | . | B | Z | Surface Normal(법선) 방향의 법선 벡터 성분 | . 4.노멀 맵 데이터 생성 . | 노멀 맵에 “하이 폴리 법선이 로우 폴리 모델의 탄젠트 공간에서 어떻게 변형되어야 하는지”가 데이터로 저장됨. | . 5.노멀 맵의 사용 . 렌더링 시에는 노멀맵의 값을 다시 TBN 행렬을 통해 월드 공간 법선으로 복원한다. | 노말맵은 법선을 0 ~ 1로 리매핑해 저장된 상태. | 실제로 렌더링에 사용할 때는 다시 -1 ~ 1로 복원 | . // 노멀 맵에서 법선 추출 (0~1 → -1~1) vec3 normal_tangent = texture(normalMap, uv).rgb * 2.0 - 1.0; // 월드 공간 법선으로 변환 vec3 normal_world = normalize(TBN * normal_tangent); // 조명 계산 (예: Lambertian Diffuse) float diffuse = max(0.0, dot(normal_world, lightDir)); . 추가로 알면 좋은 점 . | 노멀맵이 대부분 파란 이유 . | 평평한 표면의 벡터가 (0, 0, 1)이기 때문 | 색 변화가 의미하는 것 = 파랑 외의 색은 법선이 좌우(X), 상하(Y)로 기울어진 정도를 의미 | . | 스무딩 그룹(Smoothing Groups) . | 로우 폴리 모델의 정점 법선을 보간할지 말지 결정 | 보간 O (같은 스무딩 그룹): 정점 사이가 부드럽게 연결 | 보간 X (다른 스무딩 그룹): 정점 사이가 날카롭게 끊어짐 | 로우 폴리의 법선이 스무딩 그룹에 따라 변하면 노멀맵에 저장되는 차이도 달라진다. | . | . 참고하면 좋은 링크 . | Tutorial: How Normal Maps Work &amp; Baking Process | Deconstructing a Normal Map | Normal Mapping | OpenGL Tutorial - Normal Maps | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-생성-과정"
  },"323": {
    "doc": "2. Master Material",
    "title": "Flatten Normal",
    "content": "노멀 벡터의 Z(Depth) 성분을 조절해 노멀맵을 평탄화 하는 노드 . | 입력 Normal (V3) (XYZ) : 탄젠트 공간에서의 노멀 벡터. 원본 노말 맵 | 입력 Flatten Strength (Scalr) : Float (0.0 ~ 1.0), 평탄화 강도 (1.0에 가까울수록 Z가 약해짐) | 출력 Result (V3) : 평탄화가 완료된 노멀 벡터터 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal"
  },"324": {
    "doc": "2. Master Material",
    "title": "Flip Green Channel",
    "content": "텍스처의 노멀 맵에서 G(Green) 채널을 반전시키는 옵션 . | 노멀 맵이 OpenGL 방식과 DirectX 방식 중 어떤 포맷으로 저장되었는지에 따라 옵션 사용 유무가 달라진다. | OpenGL과 DirectX는 Y(Green) 좌표계가 반대기 때문 | . 언리얼 엔진은 DirectX 기반이다. | OpenGL 기반 툴 (Blender, Substance Painter 등)에서 내보낸 노멀 맵을 언리얼에서 사용할 때 . | Flip Green Channel ☑️ (체크) | . | DirectX 기반 툴 (3ds Max, Maya 등)에서 내보낸 노멀 맵 . | Flip Green Channel ❌ (체크하지 않음) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel"
  },"325": {
    "doc": "2. Master Material",
    "title": "11. Ambient Occlusion",
    "content": "광원과 관계없이, 환경 전체에서 모든 방향에서 들어오는 간접광(Ambient Light) 이 차폐되는 정도에 따라 어두움을 표현하는 기법 . | AO는 순수히 기하학적 구조(geometry)에 의해 결정되는 그림자 차폐 효과 | AO는 오직 모델의 형태와 표면 간 거리만으로 차폐 정도를 계산 | 광원이 움직여도 AO 결과는 변하지 않음 (방향성 없음) | 깊이감이나 접촉면 강조를 통해 공간 인지를 높임 | . 그림자와 AO의 차이 . | 항목 | 그림자 (Shadow) | 앰비언트 오클루전 (AO) | . | 광원 의존성 | 광원의 위치와 방향에 따라 달라짐 | 광원과 상관없이 항상 동일함 | . | 생성 원리 | 광원에서 물체까지 직진하는 빛이 막혔을 때 발생 | 공간적 차폐 정도에 따라 빛이 덜 도달하는 효과 | . | 형태 | 명확한 실루엣 형태 | 부드러운 음영 효과 | . | 변화 여부 | 광원이 움직이면 그림자도 변화 | 광원이 움직여도 AO는 고정됨 | . | 렌더링 목적 | 광원 존재감, 선명한 명암 표현 | 깊이감, 접촉 강조, 사실감 부여 | . AO는 오프라인 렌더링과 실시간 렌더링이 있는데 계산 방식이 다르다. 아래는 오프라인 렌더링 AO MAP 생성 과정이다. | 계산 기반 : 표면 점에서 주변 반구(헤미스피어)로 발사된 광선이 차단되는 비율”을 계산 | 실제 빛의 동작을 단순화한 모델이지만, 레이 트레이싱과 유사한 광선 충돌 검사를 사용 | 차폐 정도(Occlusion Factor)는 0.0(완전히 열림)에서 1.0(완전히 차폐됨) 사이의 값으로 표현 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion"
  },"326": {
    "doc": "2. Master Material",
    "title": "오프라인 AO 맵 생성 과정",
    "content": "AO 맵은 “표면 점 → 반구형 광선 발사 → 충돌 검사 → 차폐 비율 계산” 과정으로 생성됨 . 1.모델 준비 . 2.표면 점(Surface Point) 선택 . | 모델의 각 버텍스 또는 텍셀에서 AO를 계산 | 예시: 4K 텍스처(4096×4096)라면 1,600만 개 이상의 점을 처리. | . 3.반구형 샘플링(Hemispheric Sampling) . | 표면 법선(Normal) 기반 반구 정의 : 점의 법선 벡터(N)를 기준으로 반구(헤미스피어)를 생성 . | 광선은 이 반구 내에서만 무작위 방향으로 발사됨 | . | 광선 발사(Ray Casting) . | 각 점에서 N개 광선을 무작위 방향(θ, φ)으로 발사 | θ(세타) : 법선 기준 각도 (0°~90°). | φ(피) : 방위각 (0°~360°). | 광선 거리(Ray Distance): 일반적으로 장면 크기의 10~20%로 제한 | . | 광선 충돌 검사: 발사된 광선이 다른 지오메트리와 충돌하는지 확인 . | 충돌 시 : “차폐됨(Occluded)” | 충돌 없음 : “개방됨(Open)” | . | 차폐 비율 계산: AO 값 = (차폐된 광선 수) / (전체 광선 수) . | 예: 100개 광선 중 30개가 차폐됐다면 AO = 0.3 | . | . 4.텍스처 베이킹 . | 계산된 AO 값을 흑백 텍스처로 저장함 | 픽셀 보간: 버텍스 기반 결과를 텍스처 픽셀에 매핑할 때 보간(Interpolation)이 일어남 | . 참고하면 좋은 링크 ambient occlusion in unrealengine5 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-ao-%EB%A7%B5-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#오프라인-ao-맵-생성-과정"
  },"327": {
    "doc": "2. Master Material",
    "title": "픽셀 보간(Interpolation)",
    "content": "텍스처 베이킹에서 “픽셀 보간(Interpolation)”이란? . | 3D 모델의 버텍스(정점)에서 계산된 값을 텍스처의 픽셀에 자연스럽게 채우기 위해 평활화하는 과정 | . ❓왜 보간(Interpolation)이 필요해? . | 버텍스는 한정적이지만, 텍스처는 고해상도라 픽셀 수가 훨씬 많음 | 버텍스 값만으로는 텍스처가 계단 현상(Aliasing)이나 뚝뚝 끊긴 패턴이 생길 수 있음 | . 버텍스(Vertex) vs 텍셀(Texel) . | 버텍스 : 3D 모델의 꼭짓점. AO는 보통 버텍스 단위로 먼저 계산됨 (각 버텍스에서 광선 발사) | 텍셀 : 텍스처의 픽셀. UV 맵으로 매핑될 때 버텍스 사이의 빈 공간을 채워야 함 | . 픽셀 보간 과정 . | 버텍스 AO 값 생성 모델의 각 버텍스에서 AO 계산이 완료되면, 다음과 같은 값이 만들어짐 . | 버텍스 A : AO = 0.2 | 버텍스 B : AO = 0.7 | 버텍스 C : AO = 0.5 | . | UV 공간에서의 보간 . | 삼각형 내부 픽셀 처리 : UV 맵에서 삼각형(Face) 내부의 픽셀은 주변 버텍스의 AO 값의 가중 평균으로 채워짐 | 예시 : 아래 그림에서 P 픽셀의 AO는 A, B, C 버텍스 값의 Barycentric Coordinates(무게중심좌표)로 보간됨 P의 AO = (A의 AO × 가중치₁) + (B의 AO × 가중치₂) + (C의 AO × 가중치₃) . | 결과 : A(0.2), B(0.7), C(0.5) 사이의 픽셀은 0.2~0.7 사이의 부드러운 그레이드로 채워짐 | . | 보간 알고리즘 . | Bilinear Interpolation : 인접한 4개 버텍스 값으로 2D 평면 보간 | Barycentric Interpolation : 삼각형 내부에서 3개 버텍스 기반 보간 (가장 흔함) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%ED%94%BD%EC%85%80-%EB%B3%B4%EA%B0%84interpolation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#픽셀-보간interpolation"
  },"328": {
    "doc": "2. Master Material",
    "title": "12. channel packing",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing"
  },"329": {
    "doc": "2. Master Material",
    "title": "RMA MAP / ARM MAP",
    "content": "하나의 RGB 텍스처에 Grayscale 속성 맵 3개를 각각의 채널(R/G/B)에 패킹해서 저장하는 방식이다. 실시간 렌더링에서 텍스처 메모리와 샘플 호출을 절약하는 데 매우 유리하다. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map"
  },"330": {
    "doc": "2. Master Material",
    "title": "RMA 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 | 설명 | . | R | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | G | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | B | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-텍스쳐-구성"
  },"331": {
    "doc": "2. Master Material",
    "title": "ARM 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 |   | . | R | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . | G | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | B | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | 경우에 따라 Alpha 채널에 다른 정보(예: Height, Opacity)를 저장하기도 한다. | 텍스쳐쳐 패킹 시 원본 맵의 명암비, 선명도가 유지되는지 확인해야 한다. | . | 장점 . | 메모리 절약: 3개의 별도 텍스처 대신 단일 텍스처로 관리 → VRAM 사용량 감소. | 성능 향상: 쉐이더에서 텍스처 샘플링 횟수 줄어듦 → 실시간 렌더링(게임)에 유리. | . | 단점 . | 텍스쳐 압축 알고리즘 특성 상 채널 간 데이터가 서로 영향을 미침 → Metallic(G) 채널의 강한 경계가 Roughness(R) 채널의 값을 흐리게 만들 수 있음 | 8비트 텍스처 (0~255)는 채널당 256단계만 표현 가능하므로 각 채널의 정밀도가 떨어진다. | 예: AO(B) 값의 127과 128 사이의 미세한 차이를 잃을 수 있음 | . | . | . 따라서 고퀄리티 아트워크에서는 RMA 대신 별도 맵 사용을 고려해야 한다. | 모바일 게임: RMA로 메모리 절약. | 시네마틱 렌더링: Roughness, Metallic, AO를 별도로 관리. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-텍스쳐-구성"
  },"332": {
    "doc": "2. Master Material",
    "title": "12. displacement MAP",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map"
  },"333": {
    "doc": "2. Master Material",
    "title": "13. project template",
    "content": "마테리얼 우클릭 -&gt; 에셋 액션 -&gt; migrate(마이그레이션) / 노드 그래프만 가져오고 싶으면 베이스 컬러 텍스쳐 -&gt; 디폴트 텍스쳐로 바꿔서 가져오면 됨 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template"
  },"334": {
    "doc": "2. Vertex Shader",
    "title": "2. Vertex Shader",
    "content": "가상의 3D 공간에 있는 꼭지점(vertex)들의 위치를 2차원 화면의 좌표로 변환하는 작업을 수행 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html"
  },"335": {
    "doc": "2. Vertex Shader",
    "title": "Vertex Shader Overview",
    "content": "버텍스 쉐이더의 흐름 . | 로컬 좌표(local coordinates) . | 오브젝트의 로컬 원점(local origin)을 기준으로 한 좌표를 의미 | 오브젝트가 처음 위치하는 좌표계 | . | 월드 좌표(World-space coordinates) . | 더 큰 세계의 글로벌 원점(global origin)을 기준으로 한 좌표 | 여러 오브젝트들이 모두 이 원점을 기준으로 위치함 | . | 뷰 공간 좌표 (view-space coordinates) . | 카메라나 뷰어의 시점에서 바라본 좌표 | . | 클립 좌표(clip coordinates) . | -1.0 과 1.0 범위로 정규화된 좌표 | 어떤 버텍스가 화면에 나타날지 결정하는 역할을 한다 | . | 스크린 좌표(screen coordinates) . | Viewport | 에서 정의한 화면 좌표계 범위로 변환된 좌표 | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-shader-overview",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-shader-overview"
  },"336": {
    "doc": "2. Vertex Shader",
    "title": "Fundamental Transformations",
    "content": "기본 변환 행렬 . | 좌표 변환을 이해하기 위해 기본이 되는 크기(Scale), 회전(Rotation), 이동(Translation) 변환 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#fundamental-transformations",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#fundamental-transformations"
  },"337": {
    "doc": "2. Vertex Shader",
    "title": "Scaling (크기 변환)",
    "content": "오브젝트의 크기를 각 축(x, y, z) 방향으로 조절 . \\[S = \\begin{pmatrix} S_x &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_y &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; S_z &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] 정점의 각 요소 \\((V_x, V_y, V_z)\\) 는 대응하는 크기 조절 값 \\((S_x, S_y, S_z)\\)와 곱해짐 . | 예 : \\(S_x\\) 가 2이면 x축 방향으로 2배 커짐 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#scaling-%ED%81%AC%EA%B8%B0-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#scaling-크기-변환"
  },"338": {
    "doc": "2. Vertex Shader",
    "title": "Rotation (회전 변환)",
    "content": "오브젝트를 특정 축을 기준으로 회전 . X축 기준 회전 . \\[R_x(\\theta) = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ 0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] Y축 기준 회전 . \\[R_y(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] Z축 기준 회전 . \\[R_z(\\theta) = \\begin{pmatrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] 삼각함수(sin, cos)를 사용하여 정점의 좌표를 회전 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#rotation-%ED%9A%8C%EC%A0%84-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#rotation-회전-변환"
  },"339": {
    "doc": "2. Vertex Shader",
    "title": "Translation (이동 변환)",
    "content": "오브젝트를 특정 방향으로 일정 거리만큼 이동 . \\[T = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; T_x \\\\ 0 &amp; 1 &amp; 0 &amp; T_y \\\\ 0 &amp; 0 &amp; 1 &amp; T_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] 이 행렬을 정점 벡터와 곱하면 정점의 각 좌표에 \\((T_x, T_y, T_z)\\)가 더해지는 결과 . | 동차 좌표의 w요소(보통 1) 덕분에 행렬의 마지막 열이 이동 값으로 작용하여 덧셈 연산을 곱셈으로 구현 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#translation-%EC%9D%B4%EB%8F%99-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#translation-이동-변환"
  },"340": {
    "doc": "2. Vertex Shader",
    "title": "Vertex Transformation Pipeline",
    "content": "실제 셰이더 코드에서는 이 모든 행렬을 미리 CPU에서 곱한 후, 하나의 최종 행렬(WVP 행렬)을 GPU로 보내는 경우가 많음 . | 정점마다 여러 번의 행렬 곱셈을 하지 않고 한 번만 수행하여 효율을 높이기 위함 | . \\[V_{clip} = M_{projection} \\cdot M_{view} \\cdot M_{world} \\cdot V_{local}\\] . \\[M_{wvp} = M_{projection} \\cdot M_{view} \\cdot M_{world}\\] . \\[V_{clip} = M_{wvp} \\cdot V_{local}\\] 버텍스 셰이더가 로컬 좌표를 최종 클립 공간 좌표로 변환하는 전체적인 수학적 흐름 . | \\(V_{clip}\\) : 최종 클립 공간 좌표 (Clip Space Position) | \\(V_{local}\\) : 로컬 공간 좌표 (Local Space Position) | \\(M_{world}\\) : 월드 행렬 (World Matrix) | \\(M_{view}\\) : 뷰 행렬 (View Matrix) | \\(M_{projection}\\) : 투영 행렬 (Projection Matrix) | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-transformation-pipeline",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-transformation-pipeline"
  },"341": {
    "doc": "2. Vertex Shader",
    "title": "Local to World (로컬 공간 → 월드 공간)",
    "content": "오브젝트의 고유 좌표계(로컬 공간)에서 게임 세계 전체의 공통 좌표계(월드 공간)로 변환 . \\[V_{world} = M_{world} \\cdot V_{local}\\] . | \\(V_{local}\\): 로컬 공간의 정점 좌표 \\((x, y, z, 1)\\) | \\(M_{world}\\): 월드 변환 행렬 | \\(V_{world}\\): 월드 공간으로 변환된 정점 좌표 | . 월드 행렬(World Matrix) : 보통 크기, 회전, 이동 변환 행렬의 조합으로 만들어 짐 . | (\\(M_{world} = T \\cdot R \\cdot S\\)) | 3D 모델 오브젝트가 게임 월드의 특정 위치에, 특정 크기와 방향을 가지고 배치됨 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#local-to-world-%EB%A1%9C%EC%BB%AC-%EA%B3%B5%EA%B0%84--%EC%9B%94%EB%93%9C-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#local-to-world-로컬-공간--월드-공간"
  },"342": {
    "doc": "2. Vertex Shader",
    "title": "Local to World 예시",
    "content": ". | 오브젝트를 y축으로 45도 회전(\\(R_y\\)) | 월드 공간의 (10, 0, 5) 위치로 이동(\\(T\\))시킨다고 가정 | (크기 변환 S는 단위 행렬로 생략) | . \\[R_y(45^{\\circ}) = \\begin{pmatrix} \\cos(45) &amp; 0 &amp; \\sin(45) &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin(45) &amp; 0 &amp; \\cos(45) &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 0.707 &amp; 0 &amp; 0.707 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -0.707 &amp; 0 &amp; 0.707 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . \\[T(10, 0, 5) = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 10 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . \\[M_{world} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 10 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\cdot \\begin{pmatrix} 0.707 &amp; 0 &amp; 0.707 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -0.707 &amp; 0 &amp; 0.707 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} = \\begin{pmatrix} 0.707 &amp; 0 &amp; 0.707 &amp; 10 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -0.707 &amp; 0 &amp; 0.707 &amp; 5 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . | 월드 행렬은 \\(M_{world} = T \\cdot R_y\\) 순서로 곱함 (오브젝트를 먼저 회전시킨 후 이동) | . | 참고: 행렬 곱셈은 오른쪽에서 왼쪽으로 적용됨 | V_world = (T * R) * V_local 은 V_local을 먼저 회전(R)시키고, 그 결과를 이동(T)시키는 것과 같다 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#local-to-world-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#local-to-world-예시"
  },"343": {
    "doc": "2. Vertex Shader",
    "title": "World to View (월드 공간 → 뷰 공간)",
    "content": "월드 공간의 정점들을 카메라의 시점으로 변환 . \\[V_{view} = M_{view} \\cdot V_{world}\\] . | \\(V_{world}\\): 월드 공간의 정점 좌표 | \\(M_{view}\\): 뷰 변환 행렬 | \\(V_{view}\\): 뷰 공간(카메라 시점)으로 변환된 정점 좌표 | . | 뷰 매트릭스 : “모든 정점을 카메라 좌표계로 이동시키는 변환 도구” | 카메라 위치 : 월드 공간에서 카메라의 실제 좌표 (뷰 매트릭스 계산에 사용) | . 화면은 고정되어 있고 배경이 움직이면 움직이는 듯한 착시효과를 일으킨다. (카메라 이동 ≠ 뷰 매트릭스) . \\[\\mathbf{M}_{view} = (\\mathbf{M}_{camera})^{-1}\\] . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#world-to-view-%EC%9B%94%EB%93%9C-%EA%B3%B5%EA%B0%84--%EB%B7%B0-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#world-to-view-월드-공간--뷰-공간"
  },"344": {
    "doc": "2. Vertex Shader",
    "title": "World to View 예시",
    "content": ". | 카메라가 월드 좌표계에서 (X=5, Y=3, Z=-2) 에 위치한다고 가정 | 뷰 매트릭스 생성 | . \\[\\mathbf{M}_{view} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -5 \\\\ 0 &amp; 1 &amp; 0 &amp; -3 \\\\ 0 &amp; 0 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . | -5, -3, +2 이동 : 모든 오브젝트들이 카메라 반대 방향으로 움직임 . | 따라서 카메라 공간에서 카메라는 항상 0,0,0 | 오브젝트들은 월드 좌표에서 (-5,-3,+2) 만큼 이동한 위치로 변환 | . | . | 좌표계 | 카메라 위치 | 큐브 위치 | 설명 | . | 월드 공간 | (5,3,-2) | (7,3,-2) | 카메라에서 큐브는 오른쪽 2m | . | 카메라 공간 | (0,0,0) | (2,0,0) | 큐브가 카메라 기준 +X 방향에 있음 | . | 모든 정점을 카메라 기준으로 재배치하는 이 과정이 다음 단계인 투영 변환을 훨씬 간단하게 만들어 줌 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#world-to-view-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#world-to-view-예시"
  },"345": {
    "doc": "2. Vertex Shader",
    "title": "View Matrix 구성 요소",
    "content": "| 벡터 | 설명 | 시각적 비유 | . | eye | 카메라의 월드 공간 위치 | “카메라의 렌즈” | . | at | 카메라가 바라보는 목표점 | “사진작가가 렌즈를 조준하는 점” | . | up | 카메라의 머리 부분 위치 | “카메라를 들 때 위쪽을 가리키는 방향” | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-matrix-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-matrix-구성-요소"
  },"346": {
    "doc": "2. Vertex Shader",
    "title": "eye, at, up의 수학적 의미와 역할",
    "content": ". | eye - 공간의 원점(Origin) . | 월드 공간 내에서 정의된 카메라 좌표계의 원점 . | 뷰 공간의 (0, 0, 0)이 월드 공간의 어느 지점에 위치하는지를 나타내는 위치 벡터(Position Vector) | . | . | at - Z축을 정의하는 점 . | eye 벡터와 함께 카메라 좌표계의 한 축(Z축)의 방향을 결정하는 데 사용되는 월드 공간 상의 위치 벡터 | at 자체는 방향이 아니며, 오직 eye와의 관계를 통해서만 의미를 가짐 . | 벡터 (at - eye)는 eye에서 at을 향하는 방향 벡터를 생성함 | 이 벡터를 정규화(normalize)하면 카메라의 로컬 Z축이 됨 | z_axis = normalize(at - eye) | . | . | up - 평면을 결정하여 나머지 축들을 정의 . | 카메라의 Z축에 대한 회전을 결정하기 위해 기준 평면을 정의하는 방향 벡터(Direction Vector) | . | X축 정의 : up 벡터는 Z축과 외적(cross product)하여, Z축과 up 벡터 모두에 수직인 새로운 벡터를 생성함 . | 이 벡터가 바로 카메라의 로컬 X축 | x_axis = normalize(cross(up, z_axis)) | up 벡터가 Z축과 평행하지만 않다면, 이 계산을 통해 항상 유일한 X축을 결정할 수 있다 | . | Y축 정의: Z축과 X축이 결정되면, 이 두 축에 모두 수직인 마지막 축, 즉 카메라의 로컬 Y축을 외적을 통해 계산할 수 있다 . | y_axis = cross(z_axis, x_axis) | . | . | . | 좌표계 | ‘앞’ 방향 (Forward) | Z축 계산 (z_axis) | 이유 | . | DirectX (왼손) | +Z | normalize(at - eye) | 바라보는 방향(at - eye) = +Z | . | OpenGL (오른손) | -Z | normalize(eye - at) | 바라보는 방향(at - eye) = -Z | . ⚠️주의 . | up 벡터가 z_axis와 완전히 평행하면 외적(cross) 계산이 실패함 | 평행한 경우, up을 (0,1,0.001)처럼 미세하게 변경하여 계산 | . 결론 . | 우리가 직관적으로 이해하기 쉬운 eye(위치), at(목표), up(방향) 정보로 카메라를 정의 | 이 세 가지 정보를 이용해 카메라 축 계산 | . | eye와 at로부터 z_axis (방향)를 구함 | up과 z_axis로부터 x_axis (오른쪽)를 구함 | z_axis와 x_axis로부터 y_axis (위쪽)를 구함 | . | 이렇게 얻어진 x_axis, y_axis, z_axis는 서로 수직이며 크기가 1인 벡터 | 카메라의 3차원 회전을 정의하는 회전 행렬(Rotation Matrix)의 기반이 됨 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#eye-at-up%EC%9D%98-%EC%88%98%ED%95%99%EC%A0%81-%EC%9D%98%EB%AF%B8%EC%99%80-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#eye-at-up의-수학적-의미와-역할"
  },"347": {
    "doc": "2. Vertex Shader",
    "title": "view matrix 구하기",
    "content": ". | 회전(Rotation) . | 월드 전체를 돌려서, 월드의 X, Y, Z축이 카메라의 로컬 축(xaxis, yaxis, zaxis)과 나란히 정렬되도록 함 | . | 이동(Translation) . | 회전된 월드 전체를 다시 이동시켜, 월드에 있던 카메라의 위치(eye)가 월드 원점(0,0,0)으로 오도록 함 | . | . 이 두가지 변환을 하나의 행렬로 표현한 것이 View Matrix . | view matrix | . \\[M_{view} = \\begin{pmatrix} \\color{#1E90FF}{x_{axis}.x} &amp; \\color{#1E90FF}{x_{axis}.y} &amp; \\color{#1E90FF}{x_{axis}.z} &amp; \\color{orange}{-dot(x_{axis}, eye)} \\\\ \\color{#32CD32}{y_{axis}.x} &amp; \\color{#32CD32}{y_{axis}.y} &amp; \\color{#32CD32}{y_{axis}.z} &amp; \\color{orange}{-dot(y_{axis}, eye)} \\\\ \\color{#FF4500}{z_{axis}.x} &amp; \\color{#FF4500}{z_{axis}.y} &amp; \\color{#FF4500}{z_{axis}.z} &amp; \\color{orange}{-dot(z_{axis}, eye)} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . | eye(0, 5, -10) | at(0, 0, 0) | up(0, 1, 0)이라고 가정 (왼손 좌표계 기준) . | 카메라의 로컬 축 계산: . | zaxis = normalize(at - eye) = normalize((0, -5, 10)) = (0, -0.447, 0.894) | xaxis = normalize(cross(up, zaxis)) = normalize((0.894, 0, 0)) = (1, 0, 0) | yaxis = cross(zaxis, xaxis) = (0, 0.894, 0.447) | . | . | 회전 : 회전의 역변환을 수행 . | 계산한 카메라의 로컬 축 벡터들을 그대로 행렬의 각 행(row)에 넣은 것 | . | . \\[\\begin{pmatrix} \\color{#1E90FF}{x_{axis}.x} &amp; \\color{#1E90FF}{x_{axis}.y} &amp; \\color{#1E90FF}{x_{axis}.z} \\\\ \\color{#32CD32}{y_{axis}.x} &amp; \\color{#32CD32}{y_{axis}.y} &amp; \\color{#32CD32}{y_{axis}.z} \\\\ \\color{#FF4500}{z_{axis}.x} &amp; \\color{#FF4500}{z_{axis}.y} &amp; \\color{#FF4500}{z_{axis}.z} \\end{pmatrix}\\] . | 1행: 카메라의 오른쪽 방향인 xaxis 벡터 (1, 0, 0) | 2행: 카메라의 위쪽 방향인 yaxis 벡터 (0, 0.894, 0.447) | 3행: 카메라의 앞쪽 방향인 zaxis 벡터 (0, -0.447, 0.894) | . ❓ 회전 행렬이 이런 구조인 이유? . | 어떤 오브젝트를 특정 축으로 회전시키는 행렬은 그 축 벡터들을 열(column)에 배치 | 하지만 View Marix는 반대인 역회전을 해야함 | 회전 행렬의 역행렬은 원래 행렬의 행과 열을 뒤집은 전치 행렬(Transpose Matrix)과 같음 | . 따라서 축 벡터들을 행(row)에 배치하는 것만으로 간단하게 역회전 행렬을 만들 수 있다 . ⚠️ 주의 : 위 설명은 직교행렬(Orthogonal Matrix)일 때만 성립 . | 이동 : 이동의 역변환을 수행 . | 세상을 -eye 만큼 평행이동 시키는 것과 같은 효과 | 이미 세상이 회전된 후이므로, 회전된 축에 대해 얼마나 이동해야 하는지를 계산 | . | . \\[\\begin{pmatrix} \\color{orange}{-dot(x_{axis}, eye)} \\\\ \\color{orange}{-dot(y_{axis}, eye)} \\\\ \\color{orange}{-dot(z_{axis}, eye)} \\end{pmatrix}\\] . | dot(xaxis, eye) : “카메라의 위치 eye가, 카메라의 새로운 X축 방향으로 얼마나 떨어져 있는가?” | 음수(-) : 그 거리만큼 정확히 반대로 이동시켜 eye의 X축 성분을 0으로 만듦 | Y축, Z축에 대해서도 똑같이 계산하여 최종적으로 eye를 원점(0, 0, 0)으로 가져옴 | . | 최종 : eye(0, 5, -10)에서 원점을 바라보는 카메라의 뷰 행렬 . | 월드의 모든 정점에 곱해짐 | . | . \\[M_{view} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0.894 &amp; 0.447 &amp; 0 \\\\ 0 &amp; -0.447 &amp; 0.894 &amp; 11.175 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . | 이 계산은 XMMatrixLookAtLH와 같은 라이브러리 함수가 자동으로 처리 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-matrix-%EA%B5%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-matrix-구하기"
  },"348": {
    "doc": "2. Vertex Shader",
    "title": "View to Clip/Projection (뷰 공간 → 클립 공간)",
    "content": "3차원 뷰 공간의 정점들을 2차원 화면에 최종적으로 보여주기 위한 준비 단계로, 카메라의 시야 범위(절두체) 안에 있는 정점들을 정규화된 클립 공간(NDC, Normalized Device Coordinates)으로 변환 . \\[V_{clip} = M_{projection} \\cdot V_{view}\\] . | \\(V_{view}\\) : 뷰 공간의 정점 좌표 | \\(M_{projection}\\) : 투영 변환 행렬 | \\(V_{clip}\\) : 클립 공간으로 변환된 정점 좌표 \\((x_c, y_c, z_c, w_c)\\) | . 참고 링크 . | pinholeCamera | projection-matrix | Perspective Projection Matrix | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-to-clipprojection-%EB%B7%B0-%EA%B3%B5%EA%B0%84--%ED%81%B4%EB%A6%BD-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#view-to-clipprojection-뷰-공간--클립-공간"
  },"349": {
    "doc": "2. Vertex Shader",
    "title": "Projection Matrix 목표",
    "content": ". | 카메라의 시야각과 종횡비로 정의되는 ‘뷰 절두체(View Frustum)’ 라는 삐뚤어진 육면체 공간을 | 가로, 세로, 깊이가 모두 -1에서 1 사이인 ‘NDC’ 라는 정육면체 공간으로 ‘찌그러뜨리는’ 것 | . \\[\\mathbf{M}_{projection} = \\text{f(FOV, Aspect Ratio, Near, Far)}\\] . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#projection-matrix-%EB%AA%A9%ED%91%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#projection-matrix-목표"
  },"350": {
    "doc": "2. Vertex Shader",
    "title": "Projection Matrix 구성 요소",
    "content": ". | 뷰 절두체(View Frustum) : 카메라가 볼 수 있는 3D 공간 영역. 가까운 평면(Near Plane)과 먼 평면(Far Plane)으로 잘린 피라미드 형태 | NDC (Normalized Device Coordinates) : 최종적으로 2D 화면에 표시될 좌표를 계산하기 위한 표준화된 3D 공간. x, y는 -1에서 1, z는 0에서 1의 범위를 가 . | n: 카메라에서 가까운 클리핑 평면까지의 거리 (Near Plane) | f: 카메라에서 먼 클리핑 평면까지의 거리 (Far Plane) | fov: 카메라가 세로 방향으로 볼 수 있는 각도 | aspect: 화면의 가로세로 비율 (화면 너비 / 화면 높이) | . | . 변환 목표 . 뷰 공간의 한 점 \\(P(x, y, z)\\)를 NDC 공간의 점 \\(P_ndc(x_ndc, y_ndc, z_ndc)\\)로 변환하기 . | 나중에 더 추가하기 | . 투영행렬 참고 링크 . | pinholeCamera | projection-matrix | Perspective Projection Matrix | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#projection-matrix-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#projection-matrix-구성-요소"
  },"351": {
    "doc": "2. Vertex Shader",
    "title": "Clip to Screen (클립 공간 → 스크린 공간)",
    "content": "이 단계는 버텍스 셰이더 이후 래스터라이저(Rasterizer) 단계에서 자동으로 처리 . | 원근 분할 (Perspective Division) . | 클립 공간 좌표를 \\(w_c\\)로 나누어 정규화된 장치 좌표(Normalized Device Coordinates, NDC)로 변환 | . | . \\[V_{ndc} = (x_c/w_c, y_c/w_c, z_c/w_c)\\] . | 뷰포트 변환 (Viewport Transform) . | NDC 좌표를 실제 창(window)의 픽셀 좌표인 스크린 좌표로 변환 | . | . 참고 링크 . | learnopengl : CoordinateSystems | songho.ca : gl_transform | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#clip-to-screen-%ED%81%B4%EB%A6%BD-%EA%B3%B5%EA%B0%84--%EC%8A%A4%ED%81%AC%EB%A6%B0-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#clip-to-screen-클립-공간--스크린-공간"
  },"352": {
    "doc": "3. Angle between vectors",
    "title": "3. Angle between vectors",
    "content": "벡터 사이의 각도 . 내적은 벡터의 크기와 방향을 모두 활용해 직접적으로 각도를 표현할 수 있는 연산이다 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html"
  },"353": {
    "doc": "3. Angle between vectors",
    "title": "삼각형의 코사인 법칙 (Cosine Law)",
    "content": ". | 일반적인 삼각형에서 변과 각도의 관계는 다음과 같다 | . \\[c^2 = a^2 + b^2 - 2ab \\cos \\gamma\\] . | 코사인 법칙에서 C가 직각일 경우 \\(\\cos\\gamma = 0\\) 이므로 다음과 같은 피타고라스 정리를 얻음 | . \\[c^2 = a^2 + b^2\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%98-%EC%BD%94%EC%82%AC%EC%9D%B8-%EB%B2%95%EC%B9%99-cosine-law",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#삼각형의-코사인-법칙-cosine-law"
  },"354": {
    "doc": "3. Angle between vectors",
    "title": "1. 벡터에 코사인 법칙 적용",
    "content": "두 벡터 \\(\\vec{u}\\) 와 \\(\\vec{v}\\) 가 이루는 각도를 \\(\\theta\\)를 분석하기 위해 . 두 벡터의 차 \\(\\vec{u} - \\vec{v}\\) 로 삼각형을 형성 . | 변의 길이 . | \\(\\|\\vec{u}\\|\\) : 벡터 \\(\\vec{u}\\)의 크기 | \\(\\|\\vec{v}\\|\\) : 벡터 \\(\\vec{v}\\)의 크기 | \\(\\|\\vec{u} - \\vec{v}\\|\\) : 두 벡터 차의 크기 | . | . | 코사인 법칙 적용 | . \\[\\|\\vec{u} - \\vec{v}\\|^2 = \\|\\vec{u}\\|^2 + \\|\\vec{v}\\|^2 - 2 \\|\\vec{u}\\| \\|\\vec{v}\\| \\cos \\theta\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#1-%EB%B2%A1%ED%84%B0%EC%97%90-%EC%BD%94%EC%82%AC%EC%9D%B8-%EB%B2%95%EC%B9%99-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#1-벡터에-코사인-법칙-적용"
  },"355": {
    "doc": "3. Angle between vectors",
    "title": "2. 내적을 이용한 전개",
    "content": ". | 좌변 $|\\vec{u} - \\vec{v}|^2$을 내적으로 풀기 . | 벡터의 길이 제곱은 내적으로 표현 가능 | . | . \\[(\\vec{u} - \\vec{v}) \\cdot (\\vec{u} - \\vec{v}) = \\\\ \\vec{u} \\cdot \\vec{u} - \\vec{u} \\cdot \\vec{v} - \\vec{v} \\cdot \\vec{u} + \\vec{v} \\cdot \\vec{v}\\] . \\[\\|\\vec{u}\\|^2 - 2(\\vec{u}\\cdot \\vec{v}) + \\|\\vec{v}\\|^2\\] . | 우변의 코사인 법칙과 풀이 | . \\[\\|\\vec{u}\\|^2 - 2(\\vec{u}\\cdot \\vec{v}) + \\|\\vec{v}\\|^2 = \\|\\vec{u}\\|^2 + \\|\\vec{v}\\|^2 - 2 \\|\\vec{u}\\| \\|\\vec{v}\\| \\cos \\theta\\] . \\[\\cancel{\\|\\vec{u}\\|^2} - 2(\\vec{u}\\cdot \\vec{v}) + \\cancel{\\|\\vec{v}\\|^2} = \\cancel{\\|\\vec{u}\\|^2} + \\cancel{\\|\\vec{v}\\|^2} - 2 \\|\\vec{u}\\| \\|\\vec{v}\\| \\cos \\theta\\] . \\[-2(\\vec{u}\\cdot \\vec{v}) = -2 \\|\\vec{u}\\| \\|\\vec{v}\\| \\cos \\theta\\] . | 남은 좌우변을 2로 나눈 후 | . \\[\\vec{u} \\cdot \\vec{v} = \\|\\vec{u}\\| \\|\\vec{v}\\| \\cos \\theta\\] 따라서 두 벡터와 사이의 각은 두 벡터의 내적과 각 벡터의 크기 사이의 관계로 정의된다 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#2-%EB%82%B4%EC%A0%81%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A0%84%EA%B0%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#2-내적을-이용한-전개"
  },"356": {
    "doc": "3. Angle between vectors",
    "title": "\\(\\cos\\theta 계산 공식\\)",
    "content": "\\[\\cos\\theta = \\frac{\\vec{u}\\cdot\\vec{v}} {\\|\\vec{u}\\| \\|\\vec{v}\\|}\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#costheta-%EA%B3%84%EC%82%B0-%EA%B3%B5%EC%8B%9D",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#costheta-계산-공식"
  },"357": {
    "doc": "3. Angle between vectors",
    "title": "각도 계산 공식",
    "content": "\\[\\theta = \\cos^{-1} \\left( \\frac{\\vec{u} \\cdot \\vec{v}}{\\|\\vec{u}\\| \\|\\vec{v}\\|} \\right)\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#%EA%B0%81%EB%8F%84-%EA%B3%84%EC%82%B0-%EA%B3%B5%EC%8B%9D",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#각도-계산-공식"
  },"358": {
    "doc": "3. Angle between vectors",
    "title": "내적의 기하학적 의미",
    "content": ". | 내적은 두 벡터의 방향 유사성을 수치화 한다 | cosθ는 방향 유사성의 척도이다 | . \\[\\vec{u}\\cdot\\vec{v} &gt; 0 \\\\ \\rightarrow 예각 \\ (\\theta &lt; 90\\degree)\\] . | 예시 | . \\[\\vec{u} = \\begin{bmatrix}3\\\\1\\end{bmatrix}, \\quad \\vec{v} = \\begin{bmatrix}2\\\\2\\end{bmatrix}\\] . | 내적 계산 | . \\[\\vec{u} \\cdot \\vec{v} = (3 \\times 2) + (1 \\times 2) = 8\\] . | 각도 계산 | . \\[\\cos \\theta = \\frac{8}{\\sqrt{3^2 + 1^2} \\times \\sqrt{2^2 + 2^2}} = \\frac{8}{\\sqrt{10} \\times \\sqrt{8}} \\approx 0.894\\] . \\[\\theta \\approx \\cos^{-1}(0.894) \\approx 26.6^\\circ\\] . \\[\\vec{u}\\cdot\\vec{v} = 0 \\\\ \\rightarrow 직각 \\ (\\theta = 90\\degree)\\] . | 예시 | . \\[\\vec{u} = \\begin{bmatrix}1\\\\0\\end{bmatrix}, \\quad \\vec{v} = \\begin{bmatrix}0\\\\2\\end{bmatrix}\\] . | 내적 계산 | . \\[\\vec{u} \\cdot \\vec{v} = (1 \\times 0) + (0 \\times 2) = 0\\] . | 각도 계산 | . \\[\\cos \\theta = \\frac{0}{\\sqrt{1^2 + 0^2} \\times \\sqrt{0^2 + 2^2}} = 0\\] . \\[\\theta = 90^\\circ\\] . \\[\\vec{u}\\cdot\\vec{v} &lt; 0 \\\\ \\rightarrow 둔각 \\ (\\theta &gt; 90\\degree)\\] . | 예시 | . \\[\\vec{u} = \\begin{bmatrix}-2\\\\-1\\end{bmatrix}, \\quad \\vec{v} = \\begin{bmatrix}1\\\\1\\end{bmatrix}\\] . | 내적 계산 | . \\[\\vec{u} \\cdot \\vec{v} = (-2 \\times 1) + (-1 \\times 1) = -3\\] . | 각도 계산 | . \\[\\cos \\theta = \\frac{-3}{\\sqrt{(-2)^2 + (-1)^2} \\times \\sqrt{1^2 + 1^2}} = \\frac{-3}{\\sqrt{5} \\times \\sqrt{2}} \\approx -0.948\\] . \\[\\theta \\approx \\cos^{-1}(-0.948) \\approx 161.6^\\circ\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#%EB%82%B4%EC%A0%81%EC%9D%98-%EA%B8%B0%ED%95%98%ED%95%99%EC%A0%81-%EC%9D%98%EB%AF%B8",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#내적의-기하학적-의미"
  },"359": {
    "doc": "3. Angle between vectors",
    "title": "내적과 각 계산 예시",
    "content": "\\[\\vec{u} = (3, 0), \\ \\vec{v} = (1, 2)\\] . 1.내적 계산 . \\[\\vec{u} \\cdot \\vec{v} = 3 \\times 1 + 0 \\times 2 = 3\\] . 2.벡터 길이 . \\[\\|\\vec{u}\\| = 3, \\quad \\|\\vec{v}\\| = \\sqrt{5}\\] . 3.코사인 값 . \\[\\cos \\theta = \\frac{3}{3 \\times \\sqrt{5}} = \\frac{1}{\\sqrt{5}}\\] . 4.각도 . \\[\\theta = \\cos^{-1}\\left(\\frac{1}{\\sqrt{5}}\\right) \\approx 63.43^\\circ\\] . 참고하면 좋은 링크 . | 코사인 법칙 | 벡터 사이의 각 정의하기 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#%EB%82%B4%EC%A0%81%EA%B3%BC-%EA%B0%81-%EA%B3%84%EC%82%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/3.%20Angle%20between%20vectors.html#내적과-각-계산-예시"
  },"360": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "3. Buffers, Shaders, and HLSL",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html"
  },"361": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "프레임 워크 요소",
    "content": "Application Class에 하위 클래스 (ModelClass, CameraClass, ColorShaderClass) 추가 . | applicationclass : 그래픽 코드를 처리하여 렌더링 . | D3DClass : direct3D 시스템 함수의 모든 기능을 처리 | ModelClass : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화 | CameraClass : 씬(Scene)을 바라보는 시점(Viewpoint) 관리 | ColorShaderClass : 특정 셰이더 파일(color.vs, color.ps)을 사용하여 모델을 렌더링하는 모든 과정을 총괄 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#프레임-워크-요소"
  },"362": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "ModelClass",
    "content": ". | 모델을 구성하는 정점(위치, 색상 등)과 인덱스 데이터를 메모리에 정의 | 이 데이터로 정점 버퍼(Vertex Buffer)와 인덱스 버퍼(Index Buffer)를 생성하고 GPU에 로드 | 자신의 버퍼를 렌더링 파이프라인에 설정하여 그릴 수 있도록 Render() 함수를 제공 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#modelclass",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#modelclass"
  },"363": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "CameraClass",
    "content": ". | 카메라의 위치(Position)와 회전(Rotation) 값을 추적 | 카메라 위치와 회전 값을 바탕으로 매 프레임마다 뷰 행렬(View Matrix)을 계산하여 제공 . | 뷰 행렬은 월드 공간의 모든 물체를 카메라의 시점으로 변환하는 역할 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#cameraclass",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#cameraclass"
  },"364": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "ColorShaderClass",
    "content": ". | HLSL 셰이더 파일을 컴파일하고 GPU에 로드하여 정점 셰이더와 픽셀 셰이더 객체를 생성 | C++ 코드에서 정점 데이터를 셰이더로 넘겨주기 위한 입력 레이아웃(Input Layout)을 생성 | 월드, 뷰, 투영 행렬을 담을 상수 버퍼(Constant Buffer)를 생성 | Render() 함수를 통해 필요한 행렬들을 상수 버퍼에 업데이트하고, 최종적으로 셰이더를 활성화하여 모델의 DrawIndexed()를 호출, 렌더링을 실행 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#colorshaderclass",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#colorshaderclass"
  },"365": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "핵심 개념 정의",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#핵심-개념-정의"
  },"366": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "정점 버퍼 (Vertex Buffer)",
    "content": "3D 모델을 구성하는 모든 점(Vertex, 정점)들의 데이터를 담고 있는 GPU 메모리 공간 . | 각 정점은 위치(Position) 정보(x, y, z)를 필수로 가짐 | 필요에 따라 색상(Color), 법선(Normal), 텍스처 좌표(UV) 등 추가 정보를 가짐 이 모든 정점 데이터를 배열 형태로 GPU에 보내기 위한 버퍼입 . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%EC%A0%95%EC%A0%90-%EB%B2%84%ED%8D%BC-vertex-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#정점-버퍼-vertex-buffer"
  },"367": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "인덱스 버퍼 (Index Buffer)",
    "content": "정점 버퍼에 있는 정점들의 순서(Index, 색인)를 저장하여, 어떤 정점들을 연결해서 삼각형을 만들지 알려주는 메모리 공간 . | 정점 데이터의 중복을 제거하여 메모리를 절약하고, GPU 캐시 효율을 높여 렌더링 성능을 향상 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%B2%84%ED%8D%BC-index-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#인덱스-버퍼-index-buffer"
  },"368": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "상수 버퍼 (Constant Buffer)",
    "content": "월드/뷰/투영 행렬, 빛의 위치, 시간 등 렌더링 시 필요한 부가 정보를 담는 공간 . | 상수 버퍼에 담긴 데이터는 매 프레임, 또는 매 오브젝트마다 계속해서 변하는 동적인(Dynamic) 데이터임 . | (예: 카메라가 움직이면 뷰 행렬이 바뀌고, 모델이 움직이면 월드 행렬이 바뀜) | . | . | Map/Unmap 함수를 통해 상수 버퍼의 내용을 새로운 행렬 값으로 업데이트 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%EC%83%81%EC%88%98-%EB%B2%84%ED%8D%BC-constant-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#상수-버퍼-constant-buffer"
  },"369": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "HLSL (High-Level Shading Language)",
    "content": "GPU에서 실행되는 프로그램인 셰이더(Shader)를 작성하기 위한 C-스타일 프로그래밍 언어 . | 프로그래머가 렌더링 파이프라인의 특정 단계를 직접 제어하여 원하는 그래픽 효과를 만들 수 있게 함 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#hlsl-high-level-shading-language",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#hlsl-high-level-shading-language"
  },"370": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "정점 셰이더 (Vertex Shader)",
    "content": "정점 버퍼에 있는 모든 정점 각각에 대해 한 번씩 실행되는 HLSL 프로그램 . | 3D 모델의 정점 좌표를 2D 화면 좌표로 변환하는 좌표 변환을 수행 | . | 입력: 단일 정점 데이터 (위치, 색상 등), 월드/뷰/투영 행렬 (상수 버퍼) | 출력: 변환된 정점의 위치 (SV_POSITION), 픽셀 셰이더로 전달할 데이터 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%EC%A0%95%EC%A0%90-%EC%85%B0%EC%9D%B4%EB%8D%94-vertex-shader",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#정점-셰이더-vertex-shader"
  },"371": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "픽셀 셰이더 (Pixel Shader)",
    "content": "화면에 그려질 모든 픽셀 각각에 대해 한 번씩 실행되는 HLSL 프로그램 . | 픽셀의 최종 색상을 결정. 조명, 텍스처 매핑 등 복잡한 효과를 이 단계에서 처리 | . | 입력: 정점 셰이더에서 보간된 데이터 (색상, 텍스처 좌표 등) | 출력: 해당 픽셀의 최종 색상 (SV_TARGET) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%ED%94%BD%EC%85%80-%EC%85%B0%EC%9D%B4%EB%8D%94-pixel-shader",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#픽셀-셰이더-pixel-shader"
  },"372": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "Row-major vs Column-major",
    "content": "C++ 코드(DirectXMath)와 셰이더 코드(HLSL)가 행렬을 메모리에 저장하는 기본 방식이 다르므로 행렬을 전치해야 한다 . [ m11, m12, m13 // 첫 번째 행 m21, m22, m23 // 두 번째 행 m31, m32, m33 ] // 세 번째 행 // c++에서 행렬 생성 XMFLOAT4X4 mat( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12, 13,14,15,16 ); // 메모리 레이아웃: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] . [ m11, m12, m13 // 첫 번째 열 m21, m22, m23 // 두 번째 열 m31, m32, m33 ] // 네 번째 열 // 실제 HLSL에서의 행렬: [1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16] . | DirectXMath (C++) . | 행렬을 행 우선(Row-major) 순서로 메모리에 저장 | (즉, 첫 번째 행의 모든 원소가 메모리에 연달아 놓임) | . | HLSL (셰이더) . | 행렬을 열 우선(Column-major) 순서로 다루는 것이 기본값 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#row-major-vs-column-major",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#row-major-vs-column-major"
  },"373": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "해결 방법",
    "content": ". | 전치(Transpose) 사용 | . XMMATRIX mat = XMMatrixTranspose(mat); // HLSL에 전달 전에 전치 . | HLSL에서 행렬 선언 시 row_major/column_major 지정 | . row_major float4x4 rMatrix; // row-major로 해석 column_major float4x4 cMatrix; // column-major로 해석 (기본값) . | mul(vector, matrix) 같은 셰이더 내장 함수는 행렬이 열 우선이라고 가정하고 계산함 | 따라서 행 우선으로 저장된 C++의 행렬을 그대로 셰이더로 보내면 계산 결과가 틀리게 됨 | 그러므로 셰이더로 보내기 전에 XMMatrixTranspose 함수를 호출하여 행과 열을 뒤집어 줌 | . 참고하면 좋은 링크 . | Row- and column-major order | row-major (행 우선), column-major(열 우선)가 왜 중요한가? | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#해결-방법"
  },"374": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "HLSL keyword",
    "content": ". | 자료형 | . | 자료형 | 설명 | 예시 | . | float, int, bool | 단일 스칼라 값 (C언어와 유사) | float time; | . | float2, float3, float4 | 2, 3, 4개의 float를 갖는 벡터. GPU는 벡터 연산에 특화되어 있음 | float4 position; | . | int2, int3, int4 | 2, 3, 4개의 int를 갖는 벡터 | int2 textureCoords; | . | matrix | 4x4 크기의 행렬. float4x4와 동일하며 좌표 변환에 필수 | matrix worldMatrix; | . | sampler, Texture2D | 텍스처 샘플링 및 텍스처 객체를 위한 자료형 | Texture2D shaderTexture; | . | 구조 | . | 구조 | 설명 | 예시 | . | struct | 여러 변수를 묶는 사용자 정의 자료형. 셰이더 스테이지 간 데이터 전달에 사용 | struct VertexInputType { ... }; | . | cbuffer | 상수 버퍼(Constant Buffer). CPU에서 GPU로 데이터를 전달하는 주된 방법 | cbuffer MatrixBuffer { ... }; | . | 시맨틱 | . | 시맨틱 | 설명 | 예시 | . | : POSITION, : COLOR | 정점 입력 데이터의 용도를 지정하는 꼬리표. C++의 입력 레이아웃과 연결됨 | float4 pos : POSITION; | . | : TEXCOORD0, : NORMAL | 텍스처 좌표, 법선 벡터(조명 계산용) 데이터 용도를 지정 | float2 tex : TEXCOORD0; | . | : SV_POSITION | System-Value 시맨틱. 정점 셰이더의 필수 ‘출력’으로, 클립 공간 좌표를 의미 | float4 pos : SV_POSITION; | . | : SV_TARGET | System-Value 시맨틱. 픽셀 셰이더의 필수 ‘출력’으로, 최종 픽셀 색상을 의미 | float4 color : SV_TARGET; | . | 내장 함수 | . | 함수 | 설명 | 예시 | . | mul(a, b) | 벡터-행렬, 행렬-행렬 곱셈. 좌표 변환의 핵심 | mul(pos, worldMatrix) | . | dot(a, b) | 두 벡터의 내적(dot product). 조명 계산 시 빛의 각도를 구할 때 사용 | dot(lightVec, normal) | . | cross(a, b) | 두 벡터의 외적(cross product). 법선 벡터를 계산할 때 사용 | cross(vec1, vec2) | . | normalize(v) | 벡터 v를 정규화 (길이를 1로 만듦). 방향 벡터 계산에 필수 | normalize(lightVec) | . | saturate(x) | x의 값을 0.0 ~ 1.0 사이로 제한. 색상이나 조명 계수를 범위 안에 둘 때 사용 | saturate(dotResult) | . | lerp(a, b, x) | a와 b를 x 비율(0~1)로 선형 보간. 부드러운 전환 효과에 사용 | lerp(color1, color2, 0.5) | . | tex2D(sampler, uv) | 2D 텍스처에서 uv좌표의 색상 값을 샘플링(추출) | tex2D(mySampler, texCoord) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#hlsl-keyword",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#hlsl-keyword"
  },"375": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "KEYWORD NOTE",
    "content": "ModelClass, CameraClass, ColorShaderClass 소스 코드에서 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#keyword-note"
  },"376": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "colorShaderclass KEYWORD",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#colorshaderclass-keyword",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#colorshaderclass-keyword"
  },"377": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "L”./color.vs”",
    "content": "L은 C++에서 와이드 문자열 리터럴(Wide-Character String Literal)을 의미 . error = wcscpy_s(vsFilename, 128, L\"./color.vs\"); . | wchar_t는 2바이트(Windows) 또는 4바이트(Linux) 크기로 유니코드(Unicode) 문자를 저장 | wcscpy_s 함수 이름의 wcs가 “wide character string”의 약자인 것도 같은 이유 | . | L 접두사는 컴파일러에게 이 문자열을 char의 배열이 아닌 wchar_t의 배열로 만들라고 알려주는 역할 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#lcolorvs",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#lcolorvs"
  },"378": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "ID3D10Blob",
    "content": "Blob은 “Binary Large Object”의 약자임. ID3D10Blob (또는 ID3DBlob)은 메모리 블록을 관리하는 범용 데이터 버퍼 객체를 뜻함 . ID3D10Blob* vertexShaderBuffer; D3DCompileFromFile(vsFilename, NULL, NULL, \"ColorVertexShader\", \"vs_5_0\", D3D10_SHADER_ENABLE_STRICTNESS, 0, &amp;vertexShaderBuffer, &amp;errorMessage); . | 특정 형식에 얽매이지 않는 순수한 데이터 덩어리를 담는 역할 | 따라서 vertexShaderBuffer에 버텍스 셰이더를 저장한다는 것은, 사람이 읽을 수 있는 HLSL 코드가 아닌, 컴파일된 기계어 코드를 메모리 버퍼에 담고 있다는 의미 | 이후 이 버퍼의 포인터와 크기를 CreateVertexShader 같은 함수에 전달하여 실제 GPU에서 사용할 셰이더 객체를 생성함 | . | D3DCompileFromFile 함수로 셰이더 코드를 컴파일하면, 그 결과물인 GPU가 실행할 수 있는 바이트코드(bytecode)가 생성됨 | 이 바이트코드가 ID3D10Blob 객체 안에 저장 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#id3d10blob",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#id3d10blob"
  },"379": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "ID3D11InputLayout",
    "content": "C++ 코드의 정점(Vertex) 데이터 구조를 GPU의 셰이더가 어떻게 해석해야 하는지 알려주는 설명서 . | 버텍스 버퍼에는 위치, 색상, 노멀 등 여러 데이터가 연속된 메모리 덩어리로 들어있음 | 입력 레이아웃은 이 메모리 덩어리의 어디부터 어디까지가 위치 정보이고, 그 다음은 색상 정보인지 등을 정의 | . 셰이더와 연결 방식 . | C++ 코드의 VertexType 구조체로 버텍스 데이터의 메모리 구조를 정의 | D3D11_INPUT_ELEMENT_DESC 배열을 사용해 이 구조체 각 멤버의 의미(Semantic), 형식(Format), 순서 등을 설명하는 입력 레이아웃을 정의 | 버텍스 셰이더 코드(color.vs)의 입력 구조체(VertexInputType)에도 동일한 의미(Semantic)를 지정 (POSITION, COLOR) | . // modelclass.h 모델 클래스 헤더 // 버텍스 타입 구조체 struct VertexType { XMFLOAT3 position; XMFLOAT4 color; }; // color.vs 컬러 버텍스 쉐이더 // typedefs struct VertexInputType { float4 position : POSITION; float4 color : COLOR; }; . | C++의 데이터 구조와 셰이더의 입력 구조체 사이에 의미(Semantic Name)를 기반으로 연결해주는 다리 역할을 입력 레이아웃이 수행 | 이 덕분에 Direct3D는 버텍스 버퍼의 데이터를 셰이더의 올바른 입력 변수로 전달할 수 있음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#id3d11inputlayout",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#id3d11inputlayout"
  },"380": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3D11_INPUT_ELEMENT_DESC",
    "content": "단일 버텍스를 구성하는 각 요소(element)를 설명 (입력 레이아웃 정의) . D3D11_INPUT_ELEMENT_DESC polygonLayout[2]; polygonLayout[0].SemanticName = \"POSITION\"; polygonLayout[0].SemanticIndex = 0; polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT; polygonLayout[0].InputSlot = 0; polygonLayout[0].AlignedByteOffset = 0; polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; polygonLayout[0].InstanceDataStepRate = 0; polygonLayout[1].SemanticName = \"COLOR\"; polygonLayout[1].SemanticIndex = 0; polygonLayout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT; polygonLayout[1].InputSlot = 0; polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT; polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; polygonLayout[1].InstanceDataStepRate = 0; . | SemanticName . | 요소의 의미를 나타내는 문자열 . | (예: “POSITION”, “COLOR”, “NORMAL”) | . | 셰이더의 입력 시맨틱과 일치해야 함 | . | SemanticIndex . | 같은 시맨틱을 여러 개 사용할 때 구분하기 위한 인덱스 | (예: 텍스처 좌표가 2개일 때 “TEXCOORD0”, “TEXCOORD1”) | . | Format . | 요소의 데이터 형식 | (예: 3개의 float 벡터는 DXGI_FORMAT_R32G32B32_FLOAT) | . | InputSlot . | 이 데이터를 가져올 버텍스 버퍼 슬롯의 인덱스 | 보통 버퍼를 하나만 쓰므로 0 | . | AlignedByteOffset . | 버텍스의 시작점부터 이 요소까지의 거리(byte) | D3D11_APPEND_ALIGNED_ELEMENT를 사용하면 이전 요소에 맞춰 자동으로 계산해 편리하다 | . | InputSlotClass . | 데이터가 버텍스별 데이터인지(D3D11_INPUT_PER_VERTEX_DATA) | 인스턴스별 데이터인지(D3D11_INPUT_PER_INSTANCE_DATA) 지정 | . | InstanceDataStepRate . | 인스턴스별 데이터일 경우, 다음 인스턴스 데이터로 넘어가기 전에 몇 개의 인스턴스를 그릴지 지정 | 버텍스별 데이터는 0 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_input_element_desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_input_element_desc"
  },"381": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3D11_BUFFER_DESC",
    "content": "버텍스, 인덱스, 상수 버퍼 등 모든 종류의 버퍼를 생성할 때 필요한 정보를 담는 구조체 . D3D11_BUFFER_DESC matrixBufferDesc; matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC; matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType); matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER; matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; matrixBufferDesc.MiscFlags = 0; matrixBufferDesc.StructureByteStride = 0; . | Usage . | 버퍼의 주된 사용 방식을 지정 | D3D11_USAGE_DYNAMIC은 CPU가 내용을 자주 업데이트하는 버퍼임을 의미 | . | ByteWidth . | 버퍼의 총 크기(byte) | . | BindFlags . | 버퍼를 파이프라인의 어느 부분에 연결할지 지정 | D3D11_BIND_CONSTANT_BUFFER는 상수 버퍼로 사용하겠다는 의미 | . | CPUAccessFlags . | CPU가 이 버퍼에 어떻게 접근할지 지정 | D3D11_CPU_ACCESS_WRITE는 CPU가 버퍼에 데이터를 쓸 수 있어야 함을 의미 | . | MiscFlags . | 기타 플래그이며, 보통 0으로 설정 | . | StructureByteStride . | 구조화된 버퍼(Structured Buffer)에서 요소 하나의 크기를 지정 | 상수 버퍼에서는 0 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_buffer_desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_buffer_desc"
  },"382": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3D11_MAPPED_SUBRESOURCE",
    "content": "D3D11_MAPPED_SUBRESOURCE 구조체를 통해 매핑된 메모리의 정보를 얻음 . D3D11_MAPPED_SUBRESOURCE mappedResource; // 상수 버퍼를 잠그어 쓰기 가능하게 만듦 result = deviceContext-&gt;Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource); // 상수 버퍼에 있는 데이터의 포인터 얻기 dataPtr = (MatrixBufferType*)mappedResource.pData; // 행렬을 상수 버퍼에 복사 dataPtr-&gt;world = worldMatrix; dataPtr-&gt;view = viewMatrix; dataPtr-&gt;projection = projectionMatrix; // 상수 버퍼 해제 deviceContext-&gt;Unmap(m_matrixBuffer, 0); . | ID3D11DeviceContext::Map() 함수를 통해 맵핑 . | CPU에서 GPU 메모리(버퍼 등)에 데이터를 쓰기 위해서는 Map() 함수를 써야함 | . | ` D3D11_MAPPED_SUBRESOURCE` 구조체를 통해 맵핑된 데이터 메모리 포인터 얻기 | 해당 포인터를 통해 쓰기 작업 후 ID3D11DeviceContext::UnMap()으로 맵핑 해제 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_mapped_subresource",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_mapped_subresource"
  },"383": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "VSSetConstantBuffers()",
    "content": "버텍스 셰이더(Vertex Shader)에 상수 버퍼(Constant Buffer)를 바인딩하는 데 사용되는 함수 . void VSSetConstantBuffers( [in] UINT StartSlot, [in] UINT NumBuffers, [in] ID3D11Buffer *const *ppConstantBuffers ); // ... map,unmap으로 constant buffer에 데이터 씀 // 정수 버퍼의 위치를 버텍스 셰이더에 설정 bufferNumber = 0; // 최종적으로 정점 셰이더에서 업데이트된 값으로 상수 버퍼를 설정 deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_matrixBuffer); . | StartSlot . | 상수 버퍼를 바인딩하기 시작할 슬롯 인덱스 (0부터 시작) | 버텍스 셰이더의 0번 상수 버퍼 슬롯에 연결하겠다는 의미 | 일반적으로 HLSL의 register(b#) 지시어와 대응됨 . | HLSL 셰이더 코드의 cbuffer MatrixBuffer : register(b0) 에서 b0과 일치해야 함 | . | . | NumBuffers . | 바인딩할 상수 버퍼의 개수 | . | ppConstantBuffers . | n번 슬롯에 연결할 상수 버퍼 객체의 주소 | . | . | GPU의 셰이더 스테이지(버텍스 셰이더, 픽셀 셰이더 등)는 여러 개의 “입력 슬롯(slot)”을 가지고 있다 | 상수 버퍼도 이 슬롯에 연결해야만 셰이더가 접근할 수 있다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#vssetconstantbuffers",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#vssetconstantbuffers"
  },"384": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "DrawIndexed()",
    "content": "인덱스 버퍼(Index Buffer)를 사용하여 모델을 그리는 핵심적인 Direct3D 함수 . | Draw() : 버텍스 버퍼에 있는 정점들을 순서대로 그림 | DrawIndexed() . | 인덱스 버퍼에 정의된 순서에 따라 버텍스 버퍼에서 정점을 가져와 도형을 그림 | 정점을 재사용할 수 있어 메모리와 성능이 크게 향상됨 | . | . void ColorShaderClass::RenderShader(ID3D11DeviceContext* deviceContext, int indexCount) { // 버텍스 인풋 레이아웃 설정 deviceContext-&gt;IASetInputLayout(m_layout); // 이 삼각형을 렌더링하는 데 사용될 버텍스 셰이더와 픽셀 셰이더를 설정 deviceContext-&gt;VSSetShader(m_vertexShader, NULL, 0); deviceContext-&gt;PSSetShader(m_pixelShader, NULL, 0); // 삼각형 그리기 deviceContext-&gt;DrawIndexed(indexCount, 0, 0); } . | IndexCount . | 그리기에 사용할 인덱스의 개수 (예: 삼각형 하나는 3) | . | StartIndexLocation . | 인덱스 버퍼의 몇 번째 인덱스부터 읽을지를 지정. 보통 0 | . | BaseVertexLocation . | 인덱스 버퍼에서 읽은 값에 이 값을 더해서 실제 버텍스 버퍼의 인덱스를 찾음 | 하나의 큰 버퍼에 여러 모델을 넣고 특정 모델만 그릴 때 유용. 보통 0 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#drawindexed",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#drawindexed"
  },"385": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "modelclass KEYWORD",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#modelclass-keyword",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#modelclass-keyword"
  },"386": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3D11_SUBRESOURCE_DATA",
    "content": "버퍼나 텍스처 같은 리소스를 생성할 때 초기 데이터를 제공하기 위해 사용되는 구조체 . | CreateBuffer나 CreateTexture2D 같은 함수를 호출할 때 | 이 구조체에 초기화할 데이터의 메모리 주소를 담아 전달하면, Direct3D는 새로 생성하는 GPU 리소스에 해당 데이터를 복사해줌 | . typedef struct D3D11_SUBRESOURCE_DATA { const void *pSysMem; UINT SysMemPitch; UINT SysMemSlicePitch; } D3D11_SUBRESOURCE_DATA; . | pSysMem . | 초기화할 데이터가 들어있는 시스템 메모리(C++ 코드의 배열 등)의 포인터 | 실제 리소스 데이터가 저장된 메모리 블록을 가리킴 | . | SysMemPitch . | 2D 텍스처 : 데이터의 한 행(row)의 크기(byte) | 1D 리소스 : 1D 에서는 사용되지 않음 (버텍스/인덱스 버퍼에서는 0) | . | SysMemSlicePitch . | 3D 텍스처 : 데이터의 한 슬라이스(slice)의 크기(byte) . | 슬라이스 사이에 패딩이 있을 경우 이를 포함한 값 | . | 1D/2D : 1D/2D 에서는 사용되지 않음 | . | . 사용 예시 . | 버퍼 생성 시 | . // 정점 버퍼 생성 예제 struct Vertex { XMFLOAT3 Pos; XMFLOAT4 Color; }; Vertex vertices[] = { { XMFLOAT3(0.0f, 0.5f, 0.5f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) }, { XMFLOAT3(0.5f, -0.5f, 0.5f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) }, { XMFLOAT3(-0.5f, -0.5f, 0.5f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) } }; D3D11_SUBRESOURCE_DATA initData = {}; initData.pSysMem = vertices; // 버퍼에는 Pitch/SlicePitch가 필요 없음 initData.SysMemPitch = 0; initData.SysMemSlicePitch = 0; // ID3D11Device::CreateBuffer 호출 시 사용 . | 텍스처 생성 시 | . // 2D 텍스처 생성 예제 const UINT width = 2, height = 2; UINT32 pixels[width * height] = { 0xFFFF0000, 0xFF00FF00, // 빨강, 초록 0xFF0000FF, 0xFFFFFF00 // 파랑, 노랑 }; D3D11_SUBRESOURCE_DATA initData = {}; initData.pSysMem = pixels; initData.SysMemPitch = width * sizeof(UINT32); // 한 행의 바이트 크기 initData.SysMemSlicePitch = 0; // 2D 텍스처에서는 사용 안 함 // ID3D11Device::CreateTexture2D 호출 시 사용 . | 리소스 생성 함수: CreateBuffer, CreateTexture1D, CreateTexture2D, CreateTexture3D 등에서 사용 | 주로 리소스 생성 시 초기 데이터를 한 번에 업로드할 때 사용 | 리소스 생성 후에는 Map/Unmap 또는 UpdateSubresource를 사용하여 데이터를 업데이트 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_subresource_data",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_subresource_data"
  },"387": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "Stride",
    "content": "그래픽 파이프라인의 IA(Input Assembler, 입력 조립기) 단계에서 버텍스 버퍼에 있는 단일 정점(vertex) 하나의 크기(byte)를 의미 . IA 단계 . 버텍스 버퍼에서 정점 데이터를 읽어와 조립하는 역할 . | Stride 값은 IA에게 다음 정점으로 이동하기 위해 메모리에서 몇 바이트를 건너뛰어야 하는지 알려주는 중요한 정보 | Stride 값은 보통 버텍스 데이터를 정의하는 구조체 하나의 크기와 같다 | . //정점 버퍼 스트라이드, 오프셋 설정 stride = sizeof(VertexType); deviceContext-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBuffer, &amp;stride, &amp;offset); . | 코드에서는 VertexType 구조체를 사용하므로, stride는 sizeof(VertexType)으로 간단히 계산할 수 있음 | 이 값을 IASetVertexBuffers 함수에 전달하여 파이프라인에 버텍스 구조를 알림 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#stride",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#stride"
  },"388": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "Clarity Notes",
    "content": "공부하며 헷갈렸던 부분 명료화 하기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#clarity-notes",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#clarity-notes"
  },"389": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3DCompileFromFile과 GPU 업로드 시점",
    "content": "❓D3DCompileFromFile() 함수로 쉐이더를 컴파일 하는 순간 GPU에 올라가나? . | D3DCompileFromFile() 함수는 순수하게 컴파일만 수행함 | 즉, 사람이 읽을 수 있는 HLSL 셰이더 코드(.vs, .ps 파일)를 GPU가 이해할 수 있는 기계어(바이트코드)로 번역 | 그 결과를 CPU의 메인 메모리에 ID3D10Blob이라는 버퍼 형태로 저장할 뿐임 | . 그렇다면 GPU에는 언제 올라갈까? . 바로 ID3D11Device::CreateVertexShader() 또는 CreatePixelShader() 함수를 호출하는 순간 . | D3DCompileFromFile(): . | HLSL 코드를 바이트코드로 컴파일하여 vertexShaderBuffer(CPU 메모리에 있는 임시 버퍼)에 저장 | . | device-&gt;CreateVertexShader(vertexShaderBuffer-&gt;…, &amp;m_vertexShader) . | vertexShaderBuffer에 담긴 바이트코드를 GPU 드라이버에 전달 | 드라이버는 이 코드를 받아 GPU 메모리(VRAM)에 실제 셰이더 객체를 생성 | 우리는 m_vertexShader라는 핸들(포인터)을 통해 이 객체를 제어할 수 있게 됨 | . | vertexShaderBuffer-&gt;Release() . | GPU에 셰이더 생성이 완료됨 | 따라서 원본 바이트코드를 담고 있던 CPU 메모리의 임시 버퍼(vertexShaderBuffer)는 더 이상 필요가 없음 | Release()를 호출하여 메모리 해제 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3dcompilefromfile%EA%B3%BC-gpu-%EC%97%85%EB%A1%9C%EB%93%9C-%EC%8B%9C%EC%A0%90",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3dcompilefromfile과-gpu-업로드-시점"
  },"390": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "D3D11_SUBRESOURCE_DATA 구조체 사용 목적",
    "content": "❓ cpu에 있는 데이터를 gpu 메모리로 전송하기 위해 사용한다 라고 생각하면 되나? . | D3D11_SUBRESOURCE_DATA는 CPU 메모리에 있는 데이터를 GPU 리소스로 전송하기 위한 다리 역할을 하는 구조체 | 3D 모델의 버텍스 데이터나 2D 텍스처 픽셀 데이터 등을 GPU가 이해할 수 있는 형태로 전달할 때 사용 | . uint32_t pixels[4] = { 0xFF0000FF, 0x00FF00FF, ... }; // RGBA 픽셀 데이터 D3D11_SUBRESOURCE_DATA initData = {}; initData.pSysMem = pixels; initData.SysMemPitch = 4 * sizeof(uint32_t); // 한 행의 바이트 수 (가로 4픽셀) initData.SysMemSlicePitch = 0; // 2D는 SlicePitch 불필요 // 텍스처 생성 device-&gt;CreateTexture2D(&amp;textureDesc, &amp;initData, &amp;texture); . | CPU → GPU 데이터 전송의 “설명서” . | GPU는 데이터의 레이아웃(행/열 정렬, 패딩 등)을 모르기 때문에, | D3D11_SUBRESOURCE_DATA로 메모리 구조를 명시해야 함 | . | 다양한 리소스에 적용 가능 . | 버텍스 버퍼, 인덱스 버퍼, 1D/2D/3D 텍스처, 큐브맵 등 모든 리소스 초기화에 사용 | . | 리소스 생성 시 “초기 데이터”로 사용 . | CreateBuffer(), CreateTexture2D() 등의 함수와 함께 전달됨 | . | 위 함수는 GPU 리소스 생성 + 데이터 복사를 동시에 수행함 | 따라서 실시간 업데이트가 필요한 데이터는 동적 리소스로 생성하고 Map()/Unmap()을 사용하는 것이 효율적 | . | . 단일 리소스를 생성할 때 그 리소스의 초기 데이터를 지정하는 용도 (초기값 역할) . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_subresource_data-%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#d3d11_subresource_data-구조체-사용-목적"
  },"391": {
    "doc": "3. Buffers, Shaders, and HLSL",
    "title": "Input Assembler(입력 조립기) 단계와 함수 역할",
    "content": "입력 조립기(IA)는 3D 렌더링 파이프라인의 가장 첫 번째 단계 . | 버텍스 버퍼와 인덱스 버퍼로부터 데이터를 읽어와, 이를 기하학적 기본 단위(Primitive) 즉 점, 선, 삼각형 등으로 조립 | 조립 후 다음 단계(버텍스 셰이더)로 넘겨줌 | . IA 스테이지 설정 함수 . // colorshaderclass deviceContext-&gt;IASetInputLayout(m_layout); //modelclass deviceContext-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBuffer, &amp;stride, &amp;offset); deviceContext-&gt;IASetIndexBuffer(m_indexBuffer, DXGI_FORMAT_R32_UINT, 0); deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); . | deviceContext-&gt;IASetInputLayout(m_layout); . | “버텍스 하나가 어떻게 생겼는지” IA에게 알림 | layout은 ‘버텍스는 12바이트짜리 위치 정보와 16바이트짜리 색상 정보로 구성되어 있다’ 와 같은 버텍스의 구조 설명서 | IA는 이 설명서를 보고 버텍스 버퍼 메모리를 올바르게 해석 | . | deviceContext-&gt;IASetVertexBuffers(0, 1, &amp;m_vertexBuffer, &amp;stride, &amp;offset); . | “버텍스 데이터는 어디에 있는지” IA에게 알림 | m_vertexBuffer라는 실제 데이터가 담긴 버퍼를 버텍스 쉐이더의 0번 입력 슬롯에 연결 | stride(버텍스 하나의 크기)와 offset(버퍼의 어디서부터 읽을지) 정보도 함께 제공 | . | deviceContext-&gt;IASetIndexBuffer(m_indexBuffer, DXGI_FORMAT_R32_UINT, 0); . | “버텍스들을 어떤 순서로 연결할지” IA에게 알림 | m_indexBuffer라는 연결 순서 정보가 담긴 버퍼를 설정 | IA는 버텍스 버퍼를 순차적으로 읽는 대신, 인덱스 버퍼에 적힌 순서대로 버텍스를 가져옴 | . | deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); . | “조립된 버텍스들로 무엇을 만들지” IA에게 알림 | TRIANGLELIST는 3개의 정점을 묶어 독립된 삼각형 하나로 만들라는 의미 | LINE_LIST(선), POINT_LIST(점), TRIANGLE_STRIP(연결된 삼각형) 등 다른 형식으로 설정 가능 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#input-assembler%EC%9E%85%EB%A0%A5-%EC%A1%B0%EB%A6%BD%EA%B8%B0-%EB%8B%A8%EA%B3%84%EC%99%80-%ED%95%A8%EC%88%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/3.%20Buffers,%20Shaders,%20and%20HLSL.html#input-assembler입력-조립기-단계와-함수-역할"
  },"392": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "3. Gauss-Jordan elimination",
    "content": "연립일차방정식의 해를 구하거나 행렬의 역행렬을 계산하는 데 사용되는 체계적인 알고리즘 . 행렬을 기약 행 사다리꼴(RREF, Reduced Row Echelon Form)로 변환하는 과정을 수행함 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html"
  },"393": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "기본 행 연산",
    "content": "가우스-조던 소거법에서 사용하는 세 가지 기본 행 연산 . | 행 교환 | . \\[R_i \\leftrightarrow R_j\\] . | 행 스칼라 곱 | . \\[R_i \\rightarrow kR_i \\quad (k \\neq 0)\\] . | 행 합 | . \\[R_i \\rightarrow R_i + kR_j\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EA%B8%B0%EB%B3%B8-%ED%96%89-%EC%97%B0%EC%82%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#기본-행-연산"
  },"394": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "가우스-조던 소거법의 알고리즘 단계",
    "content": ". | (선택 사항) 각 행의 스칼라 값에 공통 인수가 있는 경우 공통 인수를 통해 약분함 . | 예 : 1행이 2 4 8 10 일 경우, 1 2 4 5 로 만듦 | . | 첫번째 행의 첫번째 원소가 0 이라면 첫 번째 열에 0이 아닌 원소가 있는 다른 행과 위치를 교환한다 | 첫번째 행의 첫번째 원소를 1로 만든다 | 첫번째 열의 다른 모든 요소를 0으로 만든다 | 다음 열과 행에 대해 위 과정을 반복한다 | 모든 선행 계수가 1이 되고, 각 열에서 선행 계수 외의 다른 요소들이 모두 0이 될 때 까지 진행한다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EA%B0%80%EC%9A%B0%EC%8A%A4-%EC%A1%B0%EB%8D%98-%EC%86%8C%EA%B1%B0%EB%B2%95%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#가우스-조던-소거법의-알고리즘-단계"
  },"395": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "선형 시스템 해의 개수",
    "content": "선형계에는 세 가지의 가능성이 존재한다 . | 유일해 (Unique Solution) | 해 없음 (no solution) | 무수히 많은 해 (infinitely many solutions) | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EC%84%A0%ED%98%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%95%B4%EC%9D%98-%EA%B0%9C%EC%88%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#선형-시스템-해의-개수"
  },"396": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "유일해",
    "content": ". | 행렬을 RREF로 만들었을 때 아래와 같은 형태가 나오면 해가 하나 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; a\\\\ 0 &amp; 1 &amp; 0 &amp; b \\\\ 0 &amp; 0 &amp; 1 &amp; c \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 한 점에서 만남 | 3차원 : 세 평면이 한 점에서 만남 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EC%9C%A0%EC%9D%BC%ED%95%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#유일해"
  },"397": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "해가 없음",
    "content": ". | 마지막 행이 0 ... 0 | c (c≠0) 이면 방정식 0 = c가 되어 모순이므로 해가 없음 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; a\\\\ 0 &amp; 1 &amp; 0 &amp; b \\\\ 0 &amp; 0 &amp; 0 &amp; c \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 평행 | 3차원 : 두 평면이 평행한 상황 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%ED%95%B4%EA%B0%80-%EC%97%86%EC%9D%8C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#해가-없음"
  },"398": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "무한히 많은 해",
    "content": ". | RREF에서 피벗 열의 개수 &lt; 변수의 개수 . | 피벗 열 : 각 행의 첫 번째 0이 아닌 성분이 있는 열 | 변수의 개수 : 행렬에서 계수 행렬의 열 수 | . | 예를들어 마지막 행이 전부 0인 상태라면 (예: 0 0 0 | 0) | 0z = 0이 성립하므로 z에 어떤 값을 넣어도 성립하게 된다 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 2 &amp; a\\\\ 0 &amp; 1 &amp; -1 &amp; b \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 완전히 겹침 | 3차원 : 세 평면이 한 직선에서 만나거나, 두 평면이 일치하는 경우 | . 참고하면 좋은 링크 . | 가우스-조던 행렬 소거법이란? | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EB%AC%B4%ED%95%9C%ED%9E%88-%EB%A7%8E%EC%9D%80-%ED%95%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#무한히-많은-해"
  },"399": {
    "doc": "3. Initializing Direct3D",
    "title": "3. Initializing Direct3D",
    "content": ". ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html"
  },"400": {
    "doc": "3. Initializing Direct3D",
    "title": "COM (Component Object Model)",
    "content": "컴파일 단위를 넘어(다른 DLL/언어/컴파일러) 동일하게 호출할 수 있도록 설계된 바이너리 수준의 객체 모델 . | DirectX 또한 COM 객체의 시리즈이다 | Direct3D는 내부적으로 다른 COM 객체를 포함하는 COM 객체이다 . | 즉 2D 및 3D 그래픽을 실행하기 위해 필요한 모든 것을 포함하는 COM 집합이다 | . | . device-&gt;CreateRenderTargetView() device-&gt;Release() . | COM 객체는 인터페이스로 제어되는 클래스 또는 클래스 집합이다 . | 인터페이스는 COM 객체를 제어하는 함수 집합이다 | 위 예시에서 device는 COM 객체이며, 함수들이 이를 제어한다 | . | COM 객체는 고유한 ID를 가지고 있다 . | Direct3D 객체 또한 자체 ID를 가지고 있으며 코드에서 이 ID를 사용한다 | . | COM 객체를 사용한 후에는 Release() 함수를 호출해야 한다 . | Release() 함수는 COM 객체가 메모리를 해제하고 스레드를 닫도록 지시한다 | . | COM 객체는 I로 시작하여 쉽게 식별할 수 있다 . | 예 : ID3D10Device | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#com-component-object-model",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#com-component-object-model"
  },"401": {
    "doc": "3. Initializing Direct3D",
    "title": "Direct3D Headers",
    "content": "#include &lt;windows.h&gt; #include &lt;windowsx.h&gt; #include &lt;d3d11.h&gt; #include &lt;d3d10.h&gt; // direct3D 라이브러리 링크 #pragma comment (lib, \"d3d11.lib\") #pragma comment (lib, \"d3d10.lib\") // 전역 선언 IDXGISwapChain* swapchain; // 스왑 체인 인터페이스 포인터 ID3D11Device* dev; // direct3D 장치 인터페이스에 대한 포인터 ID3D11DeviceContext* devcon; // direct3D 장치 컨텍스트에 대한 포인터 // 함수 프로토 타입 void InitD3D(HWND hWnd); // direct3D 설정하고 초기화 void CleanD3D(void); // direct3D 닫고 메모리 해제 . | #pragma comment (lib, “d3d11.lib”) . | 오브젝트 파일에 라이브러리 파일 추가 | . | ID3D11Device *dev . | direct3D에서 장치는 비디오 어댑터의 가상 표현으로 사용되는 객체이다 | ID3D11Device라는 이름의 COM 객체를 생성한다는 의미의 코드이다 | 주로 비디로 메모리를 처리한다 | . | ID3D11DeviceContext *devcon . | GPU와 렌더링 파이프라인을 관리하는 역할을 한다 | 이 객체는 그래픽을 렌더링하고 어떻게 렌더링 될 지 결정한다 | . | IDXGISwapChain *swapchain . | 스왑체인이란 렌더링이 순차적으로 이루어지는 버퍼의 연속이다 | 이 객체는 direct3D에 속하지 않으며 direct3D의 기반이 되는 DXGI의 일부이다 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#direct3d-headers",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#direct3d-headers"
  },"402": {
    "doc": "3. Initializing Direct3D",
    "title": "Launching Direct3D",
    "content": "Direct3D를 실제로 코딩하기 위해서는 위에서 작성한 세 가지 COM 객체를 생성하고 초기화해야 한다 . // direct3D 초기화 함수 void InitD3D(HWND hWnd) { // 스왑체인 정보 보관하는 구조체 만들기 DXGI_SWAP_CHAIN_DESC scd; // 데이터 초기화 ZeroMemory(&amp;scd, sizeof(DXGI_SWAP_CHAIN_DESC)); // 구조체 데이터 초기화 scd.BufferCount = 1; // 백 버퍼 1개 scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; //32비트 색상 사용 scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // 스왑 체인 사용 방식 scd.OutputWindow = hWnd; // 사용할 창 scd.SampleDesc.Count = 4; // 멀티 샘플 수 scd.Windowed = TRUE; // 창모드, 전체 화면 모드 선택 // scd 구조체에 있는 정보를 사용하여 장치 컨텍스트 및 스왑 체인 생성 D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, NULL, NULL, NULL, D3D11_SDK_VERSION, &amp;scd, &amp;swapchain, &amp;dev, NULL, &amp;devcon); } . DXGI_SWAP_CHAIN_DESC scd . 스왑 체인에 대한 설명을 포함하는 멤버를 갖는 구조체 . | scd.BufferCount . | 스왑 체인에서 사용할 백 버퍼의 개수. 더 많이 사용할 수도 있음 | . | scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM . | 색상 형식을 설정하는 데 사용 | 프런트 버퍼와 백 버퍼에서 각 픽셀은 색상별로 저장되는데 이 값은 데이터가 저장되는 형식을 결정한다 | . | scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT . | 스왑 체인을 어떻게 사용할지 설정. 플래그들은 | 연산으로 함께 사용할 수 있음 | DXGI_USAGE_RENDER_TARGET_OUTPUT : 백 버퍼에 그래픽을 그릴 때 사용 | DXGI_USAGE_SHARED : 여러 장치 객체에서 버퍼를 공유할 수 있음 | . | scd.OutputWindow = hWnd . | Direct3D가 그려야 하는 창의 핸들을 설정 | . | scd.SampleDesc.Count = 4 . | direct3D가 멀티샘플 앤티앨리어싱(MSAA)을 수행할 때 얼마나 많은 디테일을 적용할지 설정 | 숫자가 높을수록 좋음 (D3D 11은 최대 4까지 지원) | . | scd.Windowed = TRUE . | 창 모드 : TURE | 전체 화면 모드 : FALSE | . | . D3D11CreateDeviceAndSwapChain() . 장치, 장치 컨텍스트, 스왑 체인 COM 객체를 생성하는 함수 . | 함수 프로토 타입 | . HRESULT D3D11CreateDeviceAndSwapChain( IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE DriverType, HMODULE Software, UINT Flags, D3D_FEATURE_LEVEL *pFeatureLevels, UINT FeatureLevels, UINT SDKVersion, DXGI_SWAP_CHAIN_DESC *pSwapChainDesc, IDXGISwapChain **ppSwapChain, ID3D11Device **ppDevice, D3D_FEATURE_LEVEL *pFeatureLevel, ID3D11DeviceContext **ppDeviceContext); . | IDXGIAdapter *pAdapter . | Direct3D가 사용해야 하는 그래픽 어댑터를 나타내는 값 | 그래픽 어댑터는 일반적으로 GPU와 비디오 메모리, 디지털-아날로그 변환기 등을 의미 | DXGI가 알아서 처리하게끔 하려면 NULL을 사용하여 기본 어탭터로 지정한다 | . | D3D_DRIVER_TYPE DriverType . | Direct3D가 렌더링에 하드웨어를 사용할지, 소프트웨어를 사용할지 결정하는 데 사용 | . | HMODULE Software . | 위 드라이버 타입의 D3D_DRIVER_TYPE_SOFTWARE 플래그와 함께 사용되어 소프트웨어 코드를 설정 | . | UINT Flags . | Direct3D 실행 방식을 변경할 수 있는 플래그 값 . | D3D11_CREATE_DEVICE_SINGLETHREADED : 멀티스레드 렌더링이 기본. 멀티스레드를 사용하지 않으려면 이 플래그 설정 | D3D11_CREATE_DEVICE_DEBUG : 디버깅 활성화. 디버그 메시지는 컴파일러의 출력 창에 표시 | D3D11_CREATE_DEVICE_SWITCH_TO_REF : 디버깅을 위해 런타임 중에 하드웨어 모드에서 참조 모드로 전환 | D3D11_CREATE_DEVICE_BGRA_SUPPORT : 이 플래그를 통해 Direct2D가 Direct3D와 함께 작동할 수 있음 | . | . | D3D_FEATURE_LEVEL *pFeatureLevels . | 기능 수준 생성 목록을 설정 | 이 목록은 direct3D에 프로그램이 지원해야 할 기능을 알려줌 | . | UINT FeatureLevels . | 기능 수준 생성 목록에 있는 피처 레벨의 개수 | . | UINT SDKVersion . | 다른 기기와의 호환성에 중요한 요소 | 사용자의 DirectX에 게임을 개발한 버전을 알려줌 | . | DXGI_SWAP_CHAIN_DESC *pSwapChainDesc . | 스왑 체인 설명 구조체에 대한 포인터 | . | IDXGISwapChain **ppSwapChain . | 스왑 체인 객체의 포인터를 가리키는 포인터 | 이 함수는 객체를 생성하고, 객체의 주소는 매개변수 포인터(&amp;swapchain)에 저장됨 | . | ID3D11Device **ppDevice . | 장치 객체를 가리키는 포인터 | 스왑 체인과 마찬가지로 이 함수는 장치를 생성하고 주소를 매개변수 포인터 &amp;dev에 저장 | . | D3D_FEATURE_LEVEL *FeatureLevel . | 기능 수준 변수에 대한 포인터 | 리스트 중 가장 높은 수준의 플래그로 채워짐 (이를 통해 프로그래머는 사용 가능한 하드웨어를 알 수 있음) | . | ID3D11DeviceContext **ppDeviceContext . | 장치 컨텍스트 객체에 대한 포인터 (&amp;devcon) | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#launching-direct3d",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#launching-direct3d"
  },"403": {
    "doc": "3. Initializing Direct3D",
    "title": "Closing Direct3D",
    "content": "direct3D를 생성한 후 종료하기 . // direct3D와 COM 객체 정리 함수 void CleanD3D(void) { // 기존 COM 객체를 닫고 해제하기 swapchain-&gt;Release(); dev-&gt;Release(); devcon-&gt;Release(); } . | 각각의 COM 인터페이스를 Release() 함수를 통해 해제하기 | . 참고하면 좋은 링크 . | COM을 사용하여 DirectX 프로그래밍 | 장치(Direct3D 11 그래픽) | A trip through the Graphics Pipeline 2011 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#closing-direct3d",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/3.%20Initializing%20Direct3D.html#closing-direct3d"
  },"404": {
    "doc": "3. Landscape",
    "title": "3. Landscape",
    "content": "대규모 지형(terrain)을 생성, 편집, 텍스처링, 디테일 배치까지 한 번에 관리할 수 있는 도구 . | 하이트맵(Heightmap) 기반의 지형 생성 | 높이 정보(흑백 이미지)만으로 입체적인 지형 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html"
  },"405": {
    "doc": "3. Landscape",
    "title": "시작하기",
    "content": ". | 우측 상단의 Select Mode 패널에서 Landscape 선택 | 단축키 : Shift + 2 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#시작하기"
  },"406": {
    "doc": "3. Landscape",
    "title": "Tool 구성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#tool-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#tool-구성"
  },"407": {
    "doc": "3. Landscape",
    "title": "1. Manage 관리",
    "content": "랜드 스케이프 생성, 관리 . | 사이즈는 컴포넌트 수로 결정 . | 랜드 스케이프 크기 조절 (가로 x 세로) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#1-manage-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#1-manage-관리"
  },"408": {
    "doc": "3. Landscape",
    "title": "2. Sculpt 조형",
    "content": "지형을 올리거나 내리고, 평평하게 만들고, 자연스러운 노이즈를 추가 . | 우클릭 : 시점 이동 | 좌클릭 : 쌓기 | Shift + 좌클릭 : 파기 | . 랜드 스케이프 브러쉬 . | 브러시 이름 | 적용 영역/방식 | 용도 | 주요 설정값 | . | Circle(원형) | 중심점 기준 원 범위 | 자연스러운 지형 변화, 기본 조형 | Size, Falloff, Strength | . | Alpha(알파) | 마스크 이미지 범위 | 독특한 무늬, 디테일, 자연스러운 불규칙 조형 | Image, Size, Rotation, Strength | . | Pattern(패턴) | 반복 무늬 타일 전체 | 논, 밭, 도로 등 규칙적/반복적 구조물 | Tile Size, Offset, Rotation, Strength | . | Component(컴포넌트) | Landscape 컴포넌트 전체 영역 | 구획별 일괄 편집, 성능 테스트, 대규모 영역 빠른 조형 | 선택 영역, Falloff, Strength | . | 랜드 스케이프 브러쉬 : 자세한 내용은 이 링크 참조 | . 스컬프팅 툴 . | 툴 이름 | 기본 목적 | 주 용도 | 기타 특성 | . | Sculpt | 높이 올리기/내리기 | 자연 조형, 산/언덕/계곡 | 강도, 크기, falloff 조절 | . | Smooth | 부드럽게 | 날카로운 곳 완화, 경계 다듬기 | 여러 번 적용할수록 더 부드러움 | . | Flatten | 평탄화 | 도로, 인공 구조물, 절벽 | 기준 높이 설정 | . | Ramp | 경사로 | 슬로프, 산길, 언덕길 | 시작/끝 지점 지정 | . | Noise | 노이즈 추가 | 자연스러운 거칠기, 바위, 산 | 세기, 패턴 조절 | . | Erosion | 침식 | 자연 계곡, 골짜기, 침식 표면 | 반복 적용 효과 누적 | . | Hydro Erosion | 수분 침식 | 리얼 수로, 강줄기, 침식 계곡 | 실제 수분 흐름 기반 결과 | . | Retopologize | 메쉬 최적화 | LOD 개선, 삼각형 분포 정리 | 대규모 지형 작업 후 주로 사용 | . | 스컬프팅 모드 : 스컬프팅 툴 설명 목록 참조 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#2-sculpt-%EC%A1%B0%ED%98%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#2-sculpt-조형"
  },"409": {
    "doc": "3. Landscape",
    "title": "3. Paint 페인팅",
    "content": "레이어 기반 텍스처 페인팅 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#3-paint-%ED%8E%98%EC%9D%B8%ED%8C%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#3-paint-페인팅"
  },"410": {
    "doc": "3. Landscape",
    "title": "Landscape Material",
    "content": "랜드스케이프(Landscape)에만 적용되는 특별한 머티리얼 . | 여러 종류의 텍스처(흙, 잔디, 바위, 눈 등)를 ‘레이어’로 분리해 페인팅(칠하기) 방식으로 조합 | 레이어 개수는 가급적 4~6개 이하 권장 | . ??? sampler source shared wrap . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material"
  },"411": {
    "doc": "3. Landscape",
    "title": "Landscape Material 생성하기",
    "content": ". | Material Editor에서 Layer Blend 노드 생성 . | 속성에서 어드밴스 : 완전 러프 체크 | . | Layer Blend 노드에서 인덱스 생성 -&gt; 레이어 이름 지정 | 랜드 스케이프에 사용할 텍스쳐, 노말 맵 들고 와서 각각 지정된 인덱스에 연결 | . | 랜드 스케이프 머티리얼 : 랜드 스케이프 머티리얼 생성 시 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material-생성하기"
  },"412": {
    "doc": "3. Landscape",
    "title": "Layer info object",
    "content": "랜드스케이프에 칠할 수 있는 각 페인트 레이어(지형 재질 레이어)의 데이터를 저장하는 오브젝트 . | Landscape Material에는 여러 개의 레이어(예: Grass, Dirt, Sand 등)를 쓸 수 있다 | . ❓ 레이어 인포 오브젝트가 필요한 이유? . | 어느 위치에 어떤 레이어가 얼마나 칠해졌는지 정보를 저장하기 위해서 사용된다 | 즉, 브러시로 칠한 모든 정보(텍스처, 마스크, 웨이트맵)가 레이어 인포 오브젝트 에셋으로 보존된다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object"
  },"413": {
    "doc": "3. Landscape",
    "title": "Layer Info Object 종류",
    "content": ". | Weight-Blended Layer (가중치 기반) . | 여러 레이어가 한 영역에 겹칠 수 있음 | 대표적으로 흙(Soil), 풀(Grass), 눈(Snow) 등 자연스럽게 블렌딩 | . | Non-Weight-Blended Layer (마스크 기반, 단일 값) . | 한 영역에 단 하나의 레이어만 활성 | 주로 인공 구조물, 길 등 명확히 구분해야 할 경우 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-종류"
  },"414": {
    "doc": "3. Landscape",
    "title": "Layer info object 생성하기",
    "content": ". | 랜드 스케이프 머티리얼 생성 및 레이어 노드 추가 . | Landscape Material에 Layer Blend 노드를 통해 레이어 지정 | . | Landscape 선택 → 페인트 모드 진입 . | Paint 탭에서 머티리얼에 정의된 레이어 목록 확인 . | UE5.5이상 : 할당된 머티리얼에서 레이어 생성 아이콘 클릭 | . | . | 각 레이어에 Layer Info Object 할당 . | ‘None’ 상태인 레이어 옆의 ‘+’ 버튼 클릭 | Weight-Blended 혹은 Non-Weight-Blended 생성 | 경로 및 파일명 지정 후 프로젝트에 저장 (에셋 형태로 관리) | . | 브러시로 페인팅 . | 각 레이어 별로 칠해진 영역, 강도(Weight) 등 정보가 자동 저장됨 | . | . | 랜드 스케이프 페인트 모드 : 레이어 인포 오브젝트 생성 시 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-생성하기"
  },"415": {
    "doc": "3. Landscape",
    "title": "직접 만들어본 랜드 스케이프",
    "content": ". 참고하면 좋은 링크 . | Tiling In Landscape Textures | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B8-%EB%9E%9C%EB%93%9C-%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#직접-만들어본-랜드-스케이프"
  },"416": {
    "doc": "3. Linear Subspaces",
    "title": "Linear Subspaces",
    "content": "선형 부분공간 . | 주어진 벡터 공간 내에서 특정 조건을 만족하는 “더 작은 벡터 공간”을 의미 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#linear-subspaces",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#linear-subspaces"
  },"417": {
    "doc": "3. Linear Subspaces",
    "title": "부분 공간 정의",
    "content": "벡터 공간 V의 부분집합 W가 다음 세 조건을 만족할 때 부분 공간이 됨 . | 영 벡터 포함 : \\(\\mathbf{0} \\in W\\) | 덧셈에 닫힘 : \\(\\mathbf{u}, \\mathbf{v} \\in W \\implies \\mathbf{u} + \\mathbf{v} \\in W\\) | 스칼라 곱에 닫힘 : \\(\\mathbf{u} \\in W, \\, c \\in \\mathbb{R} \\implies c\\mathbf{u} \\in W\\) | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#%EB%B6%80%EB%B6%84-%EA%B3%B5%EA%B0%84-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#부분-공간-정의"
  },"418": {
    "doc": "3. Linear Subspaces",
    "title": "핵심 요약",
    "content": ". | 부분공간: 원래 공간의 구조를 보존하는 닫힌 집합 | 기저: 부분공간을 생성하는 최소한의 독립 벡터 집합 | 생성: 기저 벡터의 선형 결합으로 모든 부분공간의 원소를 표현 . | 4개 주요 부분 공간 간의 관계 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#핵심-요약"
  },"419": {
    "doc": "3. Linear Subspaces",
    "title": "3. Linear Subspaces",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html"
  },"420": {
    "doc": "3. Scene create",
    "title": "3. Scene create",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html"
  },"421": {
    "doc": "3. Scene create",
    "title": "1. 씬 계획하기",
    "content": ". | Find Reference Image : 컨셉 이미지 찾아보기 | block out : 대략적인 레이아웃 잡기 | Layering : 디테일 쌓기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-%EC%94%AC-%EA%B3%84%ED%9A%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-씬-계획하기"
  },"422": {
    "doc": "3. Scene create",
    "title": "fab export",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export"
  },"423": {
    "doc": "3. Scene create",
    "title": "2. post process vlome",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome"
  },"424": {
    "doc": "3. Scene create",
    "title": "lumen",
    "content": "이머시브 마테리얼도 라이트에 영향을 줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen"
  },"425": {
    "doc": "3. Scene create",
    "title": "nanite ? what",
    "content": "이 설정 꺼야 버텍스 페인팅 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what"
  },"426": {
    "doc": "3. Scene create",
    "title": "3. material blend",
    "content": "베이스, 중간, 탑 . 버텍스 브러쉬 . | 검정 : 칠해짐 | 흰색 : 지워짐 | r : 중간 텍스쳐 | g : 탑 텍스쳐 | b : puddle 레이어 (젖은 웅덩이 생성) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend"
  },"427": {
    "doc": "3. Scene create",
    "title": "vertex painting",
    "content": "표면의 꼭짓점에 어떠한 것을 칠할 수 있도록 해줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting"
  },"428": {
    "doc": "3. Scene create",
    "title": "4. decal",
    "content": ". | 표면에 붙일 수 있는 스티커 | 메시에 투사시킬수 있는 머티리얼 | sort order : 레이어 순서 (데칼이 겹쳤을 때 어느것이 위인지 결정) | wet decal : 데칼이 웅덩이에 영향을 받게 하고싶으면 마스터 머티리얼 복사해서 wet_decal 만든 뒤 러프니스 연결 끊기 | 스태틱 메시가 데칼의 영향을 받지 않게끔 하려면 Advanced의 Receives Decals 옵션 끄기 decal | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal"
  },"429": {
    "doc": "3. Scene create",
    "title": "Editor Utility Tool / Editor Scripting",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . cpp-quick-start . | g: 뷰포트 아이콘 끄기 켜기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting"
  },"430": {
    "doc": "4. Foliage",
    "title": "4. Foliage",
    "content": "자연 환경을 빠르고 효율적으로 구현하기 위한 식생(풀, 나무, 관목 등) 배치 툴 . | Foliage 모드로 진입 : Shift + 3 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html"
  },"431": {
    "doc": "4. Foliage",
    "title": "Paint",
    "content": "다수의 폴리지를 선택하여 브러시 형태로 칠해 배치한다 . | 여러 식생 동시에 배치 가능 | 페인트 밀도가 중요함 | . | 전체 선택 : Ctrl + A . | 배치 후 선택 해제 꼭 하기 | . | 지우기 : Shift | 폴리지 수직 정렬 : 폴리지 메시 더블 클릭 -&gt; 설정 창의 배치 -&gt; 노멀에 정렬 체크 해제 | . Paint 세부 옵션 . | 밀도(Density): 브러시 당 배치 빈도 (0~100%) | 반경(Radius): 인스턴스 간 최소 간격 | Scale Randomness: 크기 랜덤화 (자연스러운 변이 감소) | Align to Normal: 지형 노멀 방향 정렬 (경사면 적용 시 중요) | Random Yaw: Y축 회전 랜덤화 (단조로움 방지) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#paint",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#paint"
  },"432": {
    "doc": "4. Foliage",
    "title": "프레임 저하 현상 발생할 때",
    "content": ". | 상단 툴바의 edit 클릭 | 프로젝트 세팅 클릭 | 프로젝트 세팅의 렌더링에서 shadow 검색 | shadow의 Map Method -&gt; shadow map으로 변경 | Anti-Aliasing method -&gt; TAA로 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%A0%80%ED%95%98-%ED%98%84%EC%83%81-%EB%B0%9C%EC%83%9D%ED%95%A0-%EB%95%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#프레임-저하-현상-발생할-때"
  },"433": {
    "doc": "4. Foliage",
    "title": "나무 충돌 설정",
    "content": ". | 충돌 설정할 나무 폴리지 우클릭 | 에셋 액션 -&gt; 프로퍼티 매트릭스에서 선택 편집 | Display 탭에서 collision 검색 | Collision Profile Name : BlockAll 로 설정 | . | 충돌 설정 안될 때, 페인트 툴 옆 재적용 브러시 사용하기 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%EB%82%98%EB%AC%B4-%EC%B6%A9%EB%8F%8C-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#나무-충돌-설정"
  },"434": {
    "doc": "4. Foliage",
    "title": "Foliage 모드의 성능 최적화 원리",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#foliage-%EB%AA%A8%EB%93%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#foliage-모드의-성능-최적화-원리"
  },"435": {
    "doc": "4. Foliage",
    "title": "1. Instanced Static Mesh 시스템",
    "content": ". | Foliage가 배치하는 오브젝트는 Instanced Static Mesh Actor로 묶여서 관리됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#1-instanced-static-mesh-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#1-instanced-static-mesh-시스템"
  },"436": {
    "doc": "4. Foliage",
    "title": "ISM 구조",
    "content": ". | 동일한 Mesh Asset의 모든 오브젝트는 하나의 Instanced Static Mesh 컴포넌트로 관리 | 각 오브젝트(Instance)는 개별 위치, 회전, 스케일 등 변환(transform) 정보만 다름 | 메시 데이터(Vertex, Index, 머티리얼 등)는 공유됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#ism-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#ism-구조"
  },"437": {
    "doc": "4. Foliage",
    "title": "효과",
    "content": ". | CPU → GPU Draw Call 감소 . | Static Mesh Actor 1개는 1개의 드로우 콜 발생 . | 예: Static Mesh Actor 나무 1000 그루 -&gt; 1000 개의 드로우 콜 | . | Instanced Static Mesh는 한 번의 드로우콜로 10,000개를 모두 처리 | . | GPU의 Instancing 기능을 이용해 한 번에 여러 오브젝트 렌더링 | . | 메모리 사용량 절감 . | 메시와 머티리얼이 공유되어 각 인스턴스는 transform 정보(16~32 bytes)만 별도로 저장 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%9A%A8%EA%B3%BC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#효과"
  },"438": {
    "doc": "4. Foliage",
    "title": "2. Hierarchical Instanced Static Mesh (HISM) 시스템",
    "content": "Foliage Tool은 일반 ISM보다 더 고성능의 HISM을 기본적으로 사용 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#2-hierarchical-instanced-static-mesh-hism-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#2-hierarchical-instanced-static-mesh-hism-시스템"
  },"439": {
    "doc": "4. Foliage",
    "title": "HISM 구조",
    "content": "각 인스턴스를 공간으로 분할하여 Scene의 특정 영역에 속한 인스턴스만 빠르게 선택, 제거 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#hism-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#hism-구조"
  },"440": {
    "doc": "4. Foliage",
    "title": "효과",
    "content": ". | View Frustum Culling . | 화면 밖에 있는 인스턴스는 GPU에서 자동으로 렌더링에서 제외 | . | Cluster 단위로 Draw Call 발생 . | 화면에 보이는 인스턴스만 묶어서 최소 Draw Call로 처리 | . | LOD(레벨 오브 디테일) 최적화 . | 거리에 따라 LOD를 다르게 적용, 멀리서는 저해상도/심지어 안 보이게 처리 | . | Occlusion Culling . | 다른 오브젝트에 가려진 인스턴스도 렌더링 생략 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%9A%A8%EA%B3%BC-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#효과-1"
  },"441": {
    "doc": "4. Foliage",
    "title": "직접 해본 폴리지",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%EC%A7%81%EC%A0%91-%ED%95%B4%EB%B3%B8-%ED%8F%B4%EB%A6%AC%EC%A7%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#직접-해본-폴리지"
  },"442": {
    "doc": "4. Matrix addition & subtraction",
    "title": "4. Matrix addition &amp; subtraction",
    "content": "행렬의 덧셈과 뺄셈 . 행렬의 덧셈과 뺄셈은 같은 크기의 행렬에 대해서만 수행가능 하다 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#4-matrix-addition--subtraction",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#4-matrix-addition--subtraction"
  },"443": {
    "doc": "4. Matrix addition & subtraction",
    "title": "Matrix addition",
    "content": "행렬 덧셈 . \\[A + B = \\begin{pmatrix} a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \\cdots &amp; a_{1n} + b_{1n} \\\\ a_{21} + b_{21} &amp; a_{22} + b_{22} &amp; \\cdots &amp; a_{2n} + b_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \\cdots &amp; a_{mn} + b_{mn} \\end{pmatrix}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-addition",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-addition"
  },"444": {
    "doc": "4. Matrix addition & subtraction",
    "title": "Matrix subtraction",
    "content": "행렬 뺄셈 . \\[A - B = \\begin{pmatrix} a_{11} - b_{11} &amp; a_{12} - b_{12} &amp; \\cdots &amp; a_{1n} - b_{1n} \\\\ a_{21} - b_{21} &amp; a_{22} - b_{22} &amp; \\cdots &amp; a_{2n} - b_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} - b_{m1} &amp; a_{m2} - b_{m2} &amp; \\cdots &amp; a_{mn} - b_{mn} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-subtraction",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-subtraction"
  },"445": {
    "doc": "4. Matrix addition & subtraction",
    "title": "결합법칙",
    "content": ". | 행렬 덧셈은 결합 법칙이 성립한다 | . \\[(A + B) + C = A + (B + C)\\] . 결합법칙 증명 계산 . \\(A = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 5 &amp; 6 \\\\ 7 &amp; 8 \\end{pmatrix}, \\quad C = \\begin{pmatrix} 9 &amp; 10 \\\\ 11 &amp; 12 \\end{pmatrix}\\) . | \\((A + B) + C\\) 계산 | . \\[A + B = \\begin{pmatrix} 1+5 &amp; 2+6 \\\\ 3+7 &amp; 4+8 \\end{pmatrix} = \\begin{pmatrix} 6 &amp; 8 \\\\ 10 &amp; 12 \\end{pmatrix}\\] \\[(A + B) + C = \\begin{pmatrix} 6+9 &amp; 8+10 \\\\ 10+11 &amp; 12+12 \\end{pmatrix} = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . | \\(A + (B + C)\\) 계산 | . \\[B + C = \\begin{pmatrix} 5+9 &amp; 6+10 \\\\ 7+11 &amp; 8+12 \\end{pmatrix} = \\begin{pmatrix} 14 &amp; 16 \\\\ 18 &amp; 20 \\end{pmatrix}\\] \\[A + (B + C) = \\begin{pmatrix} 1+14 &amp; 2+16 \\\\ 3+18 &amp; 4+20 \\end{pmatrix} = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . | 결론 | . \\[(A + B) + C = A + (B + C) = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#결합법칙"
  },"446": {
    "doc": "4. Matrix addition & subtraction",
    "title": "행렬 뺄셈과 결합법칙",
    "content": ". | 행렬 뺄셈은 결합법칙이 성립하지 않는다 | 행렬 뺄셈은 결합 방향에 따라 결과가 달라진다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%ED%96%89%EB%A0%AC-%EB%BA%84%EC%85%88%EA%B3%BC-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#행렬-뺄셈과-결합법칙"
  },"447": {
    "doc": "4. Matrix addition & subtraction",
    "title": "뺄셈은 결합법칙이 성립하지 않는 이유",
    "content": ". | \\((A - B) - C\\) : 먼저 A에서 B를 빼고, 그 결과에서 C를 다시 뺌 | \\(A - (B - C)\\) : 먼저 B에서 C를 빼고, A에서 그 결과를 뺌 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EB%BA%84%EC%85%88%EC%9D%80-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#뺄셈은-결합법칙이-성립하지-않는-이유"
  },"448": {
    "doc": "4. Matrix addition & subtraction",
    "title": "뺄셈에서 결합법칙이 성립하지 않는 이유 예시",
    "content": "\\[A = \\begin{pmatrix} 5 &amp; 7 \\\\ 3 &amp; 2 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 2 &amp; 3 \\\\ 1 &amp; 4 \\end{pmatrix}, \\quad C = \\begin{pmatrix} 1 &amp; 2 \\\\ 1 &amp; 1 \\end{pmatrix}\\] . | \\((A - B) - C\\) 계산 | . \\[A - B = \\begin{pmatrix} 5-2 &amp; 7-3 \\\\ 3-1 &amp; 2-4 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; -2 \\end{pmatrix}\\] \\[(A - B) - C = \\begin{pmatrix} 3-1 &amp; 4-2 \\\\ 2-1 &amp; -2-1 \\end{pmatrix} = \\begin{pmatrix} 2 &amp; 2 \\\\ 1 &amp; -3 \\end{pmatrix}\\] . | \\(A - (B - C)\\) 계산 | . \\[B - C = \\begin{pmatrix} 2-1 &amp; 3-2 \\\\ 1-1 &amp; 4-1 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 3 \\end{pmatrix}\\] \\[A - (B - C) = \\begin{pmatrix} 5-1 &amp; 7-1 \\\\ 3-0 &amp; 2-3 \\end{pmatrix} = \\begin{pmatrix} 4 &amp; 6 \\\\ 3 &amp; -1 \\end{pmatrix}\\] – . | 결과 비교 | . \\[(A - B) - C = \\begin{pmatrix} 2 &amp; 2 \\\\ 1 &amp; -3 \\end{pmatrix} \\neq A - (B - C) = \\begin{pmatrix} 4 &amp; 6 \\\\ 3 &amp; -1 \\end{pmatrix}\\] . | 결론 | . 행렬 뺄셈은 결합법칙이 성립하지 않음 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EB%BA%84%EC%85%88%EC%97%90%EC%84%9C-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#뺄셈에서-결합법칙이-성립하지-않는-이유-예시"
  },"449": {
    "doc": "4. Matrix addition & subtraction",
    "title": "Vector subtraction",
    "content": "벡터의 뺄셈 . | 두 벡터 \\(\\vec{a}\\)와 \\(\\vec{b}\\)의 뺄셈은 | 한 벡터에 다른 벡터의 반대 방향 벡터를 더하는 것과 같다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#vector-subtraction",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#vector-subtraction"
  },"450": {
    "doc": "4. Matrix addition & subtraction",
    "title": "\\(\\vec{a} - \\vec{b}\\)",
    "content": ". | 벡터 \\(\\vec{a}\\)에서 벡터 \\(\\vec{b}\\)를 빼는 것은 벡터 \\(\\vec{a}\\)에 벡터 \\(\\vec{b}\\)의 반대 방향인 \\(-\\vec{b}\\)를 더하는 것과 같다 | . \\[\\vec{a} - \\vec{b} = \\vec{a} + (-\\vec{b})\\] . 결과 . 벡터는 \\(\\vec{b}\\)의 끝점에서 \\(\\vec{a}\\)의 끝점을 향하는 벡터가 된다 . | 2차원 평면 위의 두 벡터 \\(\\vec{a} = (2, 1)\\) 와 \\(\\vec{b} = (10, -3)\\) 가 있다고 가정 | . \\[\\vec{a} - \\vec{b} = (2, 1) - (10, -3) = (2 - 10, 1 - (-3)) = (-8, 4)\\] . | 벡터 \\((-8, 4)\\) 는 | 점 \\((10, -3)\\)에서 시작하여 점 \\((2, 1)\\)을 향하는 벡터 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#veca---vecb",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#veca---vecb"
  },"451": {
    "doc": "4. Matrix addition & subtraction",
    "title": "\\(\\vec{b} - \\vec{a}\\)",
    "content": "반대로 벡터 \\(\\vec{b}\\)에서 벡터 \\(\\vec{a}\\)를 빼는 것은, 벡터 \\(\\vec{b}\\)에 벡터 \\(\\vec{a}\\)의 반대 방향인 \\(-\\vec{a}\\)를 더하는 것과 같다 . \\[\\vec{b} - \\vec{a} = \\vec{b} + (-\\vec{a})\\] 결과 . 벡터는 \\(\\vec{a}\\)의 끝점에서 \\(\\vec{b}\\)의 끝점을 향하는 벡터가 된다 . | 2차원 평면 위의 두 벡터 \\(\\vec{a} = (2, 1)\\) 와 \\(\\vec{b} = (10, -3)\\) 가 있다고 가정 | . \\[\\vec{b} - \\vec{a} = (10, -3) - (2, 1) = (10 - 2, -3 - 1) = (8, -4)\\] . | 벡터 \\((8, -4)\\)는 | 점 \\((2, 1)\\)에서 시작하여 점 \\((10, -3)\\)을 향하는 벡터 | . 두 연산의 결과 벡터는 크기는 같지만 방향이 정반대 . \\[\\vec{a} - \\vec{b} = -(\\vec{b} - \\vec{a})\\] 이는 뺄셈의 교환 법칙이 성립하지 않기 때문이며, 벡터의 시작점과 끝점이 서로 바뀌기 때문이다 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#vecb---veca",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#vecb---veca"
  },"452": {
    "doc": "4. Matrix addition & subtraction",
    "title": "4. Matrix addition & subtraction",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html"
  },"453": {
    "doc": "4. Normal Vectors",
    "title": "4. Normal Vectors",
    "content": "법선 벡터 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html"
  },"454": {
    "doc": "4. Normal Vectors",
    "title": "Equation of a Plane",
    "content": "평면의 방정식 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#equation-of-a-plane",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#equation-of-a-plane"
  },"455": {
    "doc": "4. Normal Vectors",
    "title": "평면이란?",
    "content": ". | 3차원 공간에서 모든 방향으로 끝없이 이어지는 완전히 평평한 표면 | 실제로는 무한히 펼쳐진 모습을 그릴 수 없으므로, 스케치할 때는 그 일부만 그림 . | 수학적으로 평면은 어떤 하나의 법선(normal) 벡터에 서로 수직인 모든 벡터들의 집합으로 정의됨 | . | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#%ED%8F%89%EB%A9%B4%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#평면이란"
  },"456": {
    "doc": "4. Normal Vectors",
    "title": "점을 사용한 평면의 방정식 유도",
    "content": ". | 평면 위의 한 점 \\(P_0(x_1,y_1,z_1)\\) | 평면에 수직인 법선 벡터 \\(n = (a,b,c)\\) 두개가 주어졌다고 가정 | . | 평면 위의 임의이 점 \\(P(x,y,z)\\) 에 대해 \\(\\vec{P_0P} = (x - x_0, y - y_0, z - z_0)\\)은 평면에 평행 | 법선 벡터 n은 평면에 수직이므로 \\(\\vec{P_0P}\\) 과 n은 수직 . | 따라서 두 벡터의 내적은 0 이어야 함 | . | . \\[n \\cdot \\vec{P_0P} = 0\\] . \\[a(x - x_0) + b (y - y_0) + c(z - z_0) = 0\\] \\[ax + by + cz - (ax_0 + by_0 + c_z0)= 0\\] . | 상수항을 \\(d = -(ax_0 + by_0 + c_z0)\\) 로 치환하면 최종적으로 평면의 방정식을 얻을 수 있다 | . \\[ax + by + cz + d = 0\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#%EC%A0%90%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%ED%8F%89%EB%A9%B4%EC%9D%98-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EC%9C%A0%EB%8F%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#점을-사용한-평면의-방정식-유도"
  },"457": {
    "doc": "4. Normal Vectors",
    "title": "평면의 방정식 구하기 예시",
    "content": ". | 법선 벡터 \\(\\vec{n} = (-2,-1,3)\\) | 점 \\(P_0 = (1, 0 ,-2)\\) | . | 벡터 \\(\\vec{P_0P}\\) 꼴로 만들기 | . \\[\\vec{P_0P} = (x - 1, y - 0, z + 2)\\] . | 내적 | . \\[2(x−1)−1(y−0)+3(z+2) = 0\\] . | 전개 | . \\[2x−2−y+3z+6=0\\] . | 평면의 방정식 | . \\[2x−y+3z+4=0 \\\\ \\Rightarrow 2x−y+3z=-4\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#%ED%8F%89%EB%A9%B4%EC%9D%98-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EA%B5%AC%ED%95%98%EA%B8%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#평면의-방정식-구하기-예시"
  },"458": {
    "doc": "4. Normal Vectors",
    "title": "평면의 방정식과 법선 벡터 유도",
    "content": ". | 평면의 방정식 | . \\[ax + by + cz + d = 0\\] . | 평면 위의 두 점 \\(P_1(x_1,y_1,z_1), P_2(x_2,y_2,z_2)\\) 를 잡는다 | 이 점들은 평면의 방정식을 만족하므로 | . \\[\\begin{aligned} ax_1 + by_1 + cz_1 + d &amp;= 0 \\\\ ax_2 + by_2 + cz_2 + d &amp;= 0 \\end{aligned}\\] . | 두 식을 빼기 | . \\[a(x_2 - x_1) + b(y_2 - y_1) + c(z_2 - z_1) = 0\\] . | 벡터 \\(\\vec{v} = (x_2 - x_1, y_2 - y_1, z_2 - z_1)\\) 가 평면에 평행함을 의미 | 따라서 \\(n = (a, b, c)\\) 는 \\(\\vec{v}\\) 와 수직 | . \\[\\mathbf{n} \\cdot \\mathbf{v} = a(x_2 - x_1) + b(y_2 - y_1) + c(z_2 - z_1) = 0\\] . 평면 \\(ax + by + cz + d = 0\\) 의 법선 벡터는 평면에 수직이며 계수 a,b,c로 구성된다 . \\[\\mathbf{n} = \\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#%ED%8F%89%EB%A9%B4%EC%9D%98-%EB%B0%A9%EC%A0%95%EC%8B%9D%EA%B3%BC-%EB%B2%95%EC%84%A0-%EB%B2%A1%ED%84%B0-%EC%9C%A0%EB%8F%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#평면의-방정식과-법선-벡터-유도"
  },"459": {
    "doc": "4. Normal Vectors",
    "title": "평면의 방정식에서 법선 벡터 구하기 예시",
    "content": ". | 평면의 방정식 \\(-3x + 2y + 5z = -13\\) | 법선 벡터 \\(\\vec{n} = (-3, 2 , 5)\\) | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#%ED%8F%89%EB%A9%B4%EC%9D%98-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%97%90%EC%84%9C-%EB%B2%95%EC%84%A0-%EB%B2%A1%ED%84%B0-%EA%B5%AC%ED%95%98%EA%B8%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/4.%20Normal%20Vectors.html#평면의-방정식에서-법선-벡터-구하기-예시"
  },"460": {
    "doc": "4. Rendering Frames",
    "title": "4. Rendering Frames",
    "content": "direct3D 초기화 후 실제 렌더링을 시작하기 위해 두가지 사전 작업을 수행해야 한다 . | GPU에게 최종 이미지를 생성할 메모리 위치를 알려주기 . | 대부분의 경우 백 버퍼 | . | GPU에게 백 버퍼의 어느 위치에 그리도록 지시하기 | . 위 작업이 완료되면 렌더링을 수행할 수 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html"
  },"461": {
    "doc": "4. Rendering Frames",
    "title": "Setting the Render Target",
    "content": "direct3D에서 렌더링을 하기 위해서는 렌더 타겟을 설정해야 한다 . | 렌더 타겟 설정 과정 . | 백 버퍼의 주소 확인하기 | 백 버퍼 주소를 사용하여 렌더 타겟을 나타내는 COM 객체 생성하기 | 하당 객체를 활성 렌더 타겟으로 설정하기 | . | . ID3D11RenderTargetView *backbuffer; // COM 객체 전역 선언 // 이 함수는 Direct3D를 초기화하고 사용할 준비를 합니다 void InitD3D(HWND hWnd) { // Direct3D 초기화 // ... // 렌더 타겟 설정 시작 // 백 버퍼의 주소 가져오기 ID3D11Texture2D* pBackBuffer; swapchain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;pBackBuffer); // 백 버퍼의 주소 사용하여 렌더 타겟 생성 dev-&gt;CreateRenderTargetView(pBackBuffer, NULL, &amp;backbuffer); pBackBuffer-&gt;Release(); // 렌더 타겟을 백 버퍼로 설정 devcon-&gt;OMSetRenderTargets(1, &amp;backbuffer, NULL); } . | ID3D11RenderTargetView *backbuffer . | 렌더 타겟에 대한 모든 정보를 담고 있는 객체를 가리키는 포인터 | 백버퍼에 렌더링 할 것이므로 변수 이름을 backbuffer로 지정했다 | . | ID3D11Texture2D *pBackBuffer . | 평면 이미지를 저장하는 객체 | . | swapchain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;pBackBuffer) . | GetBuffer() 함수가 하는 일 : 스왑 체인에서 백 버퍼를 찾아 pBackBuffer 텍스처 객체를 생성 | 첫 번째 매개변수 : 가져올 백 버퍼의 번호 (백 버퍼를 1개만 사용하기 때문에 백 버퍼는 0) | 두 번째 매개변수 : ID3D11Texture2D 객체를 식별하는 숫자 . | __uuidof()는 COM 객체의 고유한 ID를 얻는 연산자 | LPVOID : 모든 형식에 대한 포인터 (typedef void *LPVOID;) | . | . | dev-&gt;CreateRenderTargetView(pBackBuffer, NULL, &amp;backbuffer) . | 렌더 타겟 객체 생성 | 첫 번째 매개변수 : 텍스처 객체에 대한 포인터 | 두 번째 매개변수 : 렌더 타겟을 설명하는 구조체. 백 버퍼는 이 구조체를 채울 필요가 없다 | 세 번째 매개변수 : 렌더 타겟 객체 포인터 주소 (&amp;backbuffer) | . | pBackBuffer-&gt;Release() . | 백 버퍼에 접근하는데 사용했던 텍스처 객체의 메모리 해제 후 스레드 닫기 | . | devcon-&gt;OMSetRenderTargets(1, &amp;backbuffer, NULL) . | 렌더 타겟 설정. 여러 렌더 타겟을 설정할 수 있음 | 첫 번째 매개변수 : 설정한 렌더 타겟의 개수 | 두 번째 매개변수 : 렌더 타겟 뷰 객체 목록을 가리키는 포인터 | 세 번째 매개변수 : 고급 매개변수로 이후 글에서 자세히 다룸 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#setting-the-render-target",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#setting-the-render-target"
  },"462": {
    "doc": "4. Rendering Frames",
    "title": "Setting the Viewport",
    "content": "뷰포트 설정하기 . | 픽셀 좌표 : 왼쪽 모서리 0,0에서 시작하여 한 픽셀씩 증가 | 정규화 좌표 : 백 버퍼 크기에 관계없이 -1,-1 에서 시작하여 1,1로 증가 | . void InitD3D(HWND hWnd) { // Direct3D 초기화 // ... // 렌더 대상 설정 // ... // 뷰포트 설정 D3D11_VIEWPORT viewport; ZeroMemory(&amp;viewport, sizeof(D3D11_VIEWPORT)); viewport.TopLeftX = 0; viewport.TopLeftY = 0; viewport.Width = 800; viewport.Height = 600; devcon-&gt;RSSetViewports(1, &amp;viewport); } . | RSSetViewports() . | 뷰포트 설정 구조체를 활성화하는 함수 | 첫 번째 매개변수 : 사용 중인 뷰포트의 개수 | 두 번째 매개변수 : 뷰포트 구조체 포인터 목록의 주소 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#setting-the-viewport",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#setting-the-viewport"
  },"463": {
    "doc": "4. Rendering Frames",
    "title": "Rendering Frames",
    "content": "단일 프레임을 렌더링 하는 함수 구현 . // 단일 프레임을 렌더링 하는데 사용되는 함수 void RenderFrame(void) { // D3DXCOLOR 함수 더 이상 지원안함 //devcon-&gt;ClearRenderTargetView(backbuffer, D3DXCOLOR(0.0f, 0.2f, 0.4f, 1.0f)); // 컬러 지정 const float clearColor[4] = { 0.0f, 0.2f, 0.4f, 1.0f }; // RGBA devcon-&gt;ClearRenderTargetView(backbuffer, clearColor); // 백 버퍼에 3D 렌더링 수행 // 백 버퍼와 프론트 버퍼 스왑 swapchain-&gt;Present(0, 0); } // ... while (TRUE) { if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { // 키 입력 메시지 형식 변환 TranslateMessage(&amp;msg); // 메시지를 WindowProc 함수로 보냄 DispatchMessage(&amp;msg); // 종료 확인 if (msg.message == WM_QUIT) break; } // 메인 루프에 렌더링 함수 넣기 RenderFrame(); } . | devcon-&gt;ClearRenderTargetView(backbuffer, clearColor) . | 렌더 타겟 버퍼를 특정 색상으로 채우는 함수 | 첫 번째 매개변수 : 렌더 타겟 객체의 주소 | 두 번째 매개변수 : 백 버퍼에 채울 색상 | . | swapchain-&gt;Present(0, 0) . | 스왑 체인에서 스왑 작업을 수행하여 백 버퍼를 프론트 버퍼로 전환하는 함수 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#rendering-frames",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/4.%20Rendering%20Frames.html#rendering-frames"
  },"464": {
    "doc": "4. Texturing",
    "title": "4. Texturing",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html"
  },"465": {
    "doc": "4. Texturing",
    "title": "프레임 워크 요소",
    "content": ". | application class 에 하위 클래스 (TextureShaderClass) 추가 | Model Class에 하위 클래스 (TextureClass) 추가 | ColorShaderClass 제거 . | applicationclass : 그래픽 코드를 처리하여 렌더링 . | D3DClass : direct3D 시스템 함수의 모든 기능을 처리 | ModelClass : 3D 모델의 기하학적 데이터(Geometry)를 캡슐화 . | TextureClass : TGA 파일을 디스크에서 읽고, 파싱하고, CPU 메모리에 RGB(A) 데이터로 변환한 뒤, . | 이 데이터를 기반으로 Direct3D 텍스처 리소스(ID3D11Texture2D)와 셰이더 리소스 뷰(ID3D11ShaderResourceView)를 생성 | . | . | CameraClass : 씬(Scene)을 바라보는 시점(Viewpoint) 관리 | TextureShaderClass : 매 프레임 렌더링 시점에, TextureClass가 만들어 놓은 셰이더 리소스 뷰를 GPU의 픽셀 셰이더로 전달하는 역할 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#프레임-워크-요소"
  },"466": {
    "doc": "4. Texturing",
    "title": "Texel Coordinate System (텍셀 좌표계)",
    "content": "Texel은 “Texture Element”의 줄임말 . | 픽셀(Picture Element)이 화면의 한 점이라면, Texel은 텍스처 이미지의 한 점을 의미 | 3D 모델의 위치를 나타내는 XYZ 좌표와 구분하기 위해, 텍스처의 2D 좌표는 일반적으로 U와 V를 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#texel-coordinate-system-%ED%85%8D%EC%85%80-%EC%A2%8C%ED%91%9C%EA%B3%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#texel-coordinate-system-텍셀-좌표계"
  },"467": {
    "doc": "4. Texturing",
    "title": "UV 좌표",
    "content": ". | U축 : 텍스처의 수평 방향(가로) | V축 : 텍스처의 수직 방향(세로) | . 좌표 범위: 일반적으로 U와 V 좌표는 0.0에서 1.0 사이의 값으로 정규화(Normalize) 됨 . | (0.0, 0.0): 텍스처의 왼쪽 상단 모서리 | (1.0, 1.0): 텍스처의 오른쪽 하단 모서리 | (0.5, 0.5): 텍스처의 정중앙 | . // 정점 위치(-1, -1, 0)는 텍스처의 왼쪽 하단(0, 1)에 매핑 vertices[0].position = XMFLOAT3(-1.0f, -1.0f, 0.0f); vertices[0].texture = XMFLOAT2(0.0f, 1.0f); // 정점 위치(0, 1, 0)는 텍스처의 위쪽 중앙(0.5, 0)에 매핑 vertices[1].position = XMFLOAT3(0.0f, 1.0f, 0.0f); vertices[1].texture = XMFLOAT2(0.5f, 0.0f); // 정점 위치(1, -1, 0)는 텍스처의 오른쪽 하단(1, 1)에 매핑 vertices[2].position = XMFLOAT3(1.0f, -1.0f, 0.0f); vertices[2].texture = XMFLOAT2(1.0f, 1.0f); . | u, v 좌표를 이용해 3D 모델의 특정 정점이 텍스처의 어느 부분에 해당하는지를 매핑(mapping) | 매핑을 통해 렌더링 시 삼각형의 각 정점 사이의 공간은 텍스처의 해당 좌표들 사이의 픽셀들로 채워짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#uv-%EC%A2%8C%ED%91%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#uv-좌표"
  },"468": {
    "doc": "4. Texturing",
    "title": "UV Coordinate Interpolation",
    "content": "사용자가 정점(vertex)에 UV 좌표를 지정하면 그 정점들로 이루어진 면 내부의 공간은 GPU가 텍스처 픽셀(texel)로 채움 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#uv-coordinate-interpolation",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#uv-coordinate-interpolation"
  },"469": {
    "doc": "4. Texturing",
    "title": "렌더링 파이프 라인 단계",
    "content": ". 1.데이터 준비 (CPU -&gt; GPU) . | 정점 버퍼(Vertex Buffer): 3D 모델을 구성하는 각 정점의 데이터를 GPU에 보냄 . | 위치 좌표 (X, Y, Z): 3D 공간에서의 정점 위치 | 텍스처 좌표 (U, V): 2D 텍스처 맵에서의 정점 위치 (U는 가로, V는 세로) | . | . 2.버텍스 셰이더 (Vertex Shader) . | GPU는 모델의 모든 정점에 대해 버텍스 셰이더를 실행 | 이때, UV 좌표는 계산하지 않고 그대로 다음 단계로 전달 | 각 정점은 변환된 화면 좌표와 함께 자신의 UV 좌표를 계속 가지고 있음 | . 3.래스터화 (Rasterization) - 핵심 단계! . | GPU는 3개의 변환된 정점을 보고, 이 삼각형 내부에 포함될 모든 픽셀(pixel)들을 찾아냄(Scan Conversion) . | 이 때 각 픽셀(프래그먼트)에 대해 깊이 값도 함께 계산된다 | . | 이렇게 찾아낸 픽셀 하나하나를 프래그먼트(Fragment)라고 부름 | 이제 GPU는 이 수많은 프래그먼트 각각의 색상을 결정해야 함 | . 4.UV 좌표 보간 (UV Coordinate Interpolation) . | GPU는 각 프래그먼트의 색상을 결정하기 위해, 해당 프래그먼트가 삼각형의 세 꼭짓점으로부터 얼마나 떨어져 있는지를 계산 | 이때 무게중심 좌표(Barycentric Coordinates)라는 기술이 사용됨 . | 예를 들어, 어떤 프래그먼트가 삼각형의 한가운데에 있다면, 세 꼭짓점의 영향을 동일하게(각각 1/3씩) 받음 | . | . GPU는 가중치(weight)를 그대로 각 꼭짓점의 UV 좌표에 적용함 . - 프래그먼트의 U = (A정점 가중치 * A정점 U) + (B정점 가중치 * B정점 U) + (C정점 가중치 * C정점 U) - 프래그먼트의 V = (A정점 가중치 * A정점 V) + (B정점 가중치 * B정점 V) + (C정점 가중치 * C정점 V) . | 이 계산을 통해, 삼각형 내부의 모든 프래그먼트(픽셀)는 자신만의 고유한 보간된 UV 좌표를 갖게 됨 | 꼭짓점 사이의 공간이 자연스럽게 연속적인 UV 값으로 채워짐 | . 5.픽셀 셰이더 (Pixel Shader / Fragment Shader) . | 이제 각 프래그먼트는 자신만의 보간된 UV 좌표를 가지고 픽셀 셰이더로 전달됨 | 텍스처 샘플링(Texture Sampling) 시작 . | 픽셀 셰이더가 보간된 UV 좌표를 사용하여 텍스처 맵에서 텍셀 (Texel)을 읽어옴 | SamplerState에서 설정한 필터링 방식(Filtering) (예: D3D11_FILTER_MIN_MAG_MIP_LINEAR)에 따라, 주변의 여러 텍셀(760,761번 등)의 색상을 혼합(Blend) 해서 최종 색상을 만들어냄 | . | 가져온 텍셀 색상은 조명 등 다른 요소와 결합되어 프래그먼트의 최종 색상이 결정됨 | . 6.최종 출력 . | 색상이 결정된 모든 프래그먼트들이 화면에 그려지면서, 매끄럽게 텍스처가 입혀진 3D 모델을 보게 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84-%EB%9D%BC%EC%9D%B8-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#렌더링-파이프-라인-단계"
  },"470": {
    "doc": "4. Texturing",
    "title": "texturing Process",
    "content": "direct3D에서 텍스처링은 크게 데이터 준비 → D3D 리소스 생성 → 셰이더에서 샘플링의 3단계로 진행 . 1.데이터 준비 . | 3D 모델링 및 텍스쳐 제작 후 모델의 정점 정보(위치, 법선 등)와 UV 좌표를 함께 파일(예: .fbx, .obj)로 저장하고 제작한 텍스처 이미지(예: .png, .dds)도 저장 | . 2.D3D 리소스 생성 및 설정 (C++ 코드) . | 텍스처 파일 로드 및 ID3D11Texture2D 생성 . | 디스크에 있는 이미지 파일(.png, .jpg, .dds 등)을 읽어 GPU 메모리에 올림 | 이 결과물로 ID3D11Texture2D라는 리소스 객체가 생성 | 이 과정은 복잡하기 때문에 보통 DirectXTex 라이브러리 같은 도우미 라이브러리를 사용 | . | 셰이더 리소스 뷰 (ID3D11ShaderResourceView, SRV) 생성 . | GPU가 텍스처 리소스(ID3D11Texture2D)를 셰이더에서 읽을 수 있도록 “뷰(View)”를 만들어야 함 | SRV는 셰이더에게 “이 텍스처를 이런 방식으로 읽어가라”고 알려주는 역할 | 텍스처를 사용하려면 반드시 필요 | . | 샘플러 상태 (ID3D11SamplerState) 생성 . | 셰이더가 텍스처의 색상 값을 “어떻게 가져올지(Sampling)”에 대한 규칙을 정하는 객체 | 필터링(Filtering) . | UV 좌표가 텍스처의 픽셀(텍셀)과 정확히 일치하지 않을 때, 주변 픽셀 색을 어떻게 섞어서 부드럽게 표현할지 결정 | (예: LINEAR 필터링 - 부드럽게, POINT 필터링 - 픽셀이 보이게) | . | 주소 지정 모드(Addressing Mode) . | UV 좌표가 0.0 ~ 1.0 범위를 벗어났을 때 어떻게 처리할지 결정 | (예: WRAP - 바둑판식으로 반복, CLAMP - 가장자리 색으로 채움) | . | . | GPU에 리소스 전달 . | 렌더링을 하기 직전에, 지금까지 만든 SRV와 SamplerState를 픽셀 셰이더에 전달 | context-&gt;PSSetShaderResources(...) 함수로 SRV를 설정 | context-&gt;PSSetSamplers(...) 함수로 SamplerState를 설정 | . | . 3.셰이더에서 텍스처 샘플링 (HLSL 코드) . | 픽셀 셰이더 (Pixel Shader) . | 정점 셰이더에서 넘어온 UV 좌표는 래스터라이저에 의해 삼각형 내부의 모든 픽셀에 대해 보간(interpolated)된 값으로 들어옴 | HLSL 코드에 텍스처와 샘플러를 위한 변수를 선언 | . | . 전체 흐름 요약 . | (C++) 텍스처 파일을 로드해 ID3D11Texture2D를 만든다 | (C++) 텍스처를 셰이더에서 읽을 수 있도록 ID3D11ShaderResourceView를 만든다 | (C++) 텍스처를 읽는 규칙인 ID3D11SamplerState를 만든다 | (C++) 렌더링 전, 위에서 만든 View와 Sampler를 픽셀 셰이더(PS)에 설정한다 | (GPU-PS) 픽셀 셰이더는 전달받은 UV 좌표와 Sample() 함수를 이용해 텍스처에서 색상 값을 “뽑아온다” | (GPU-PS) 뽑아온 색상을 최종 픽셀 색상으로 출력한다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#texturing-process",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#texturing-process"
  },"471": {
    "doc": "4. Texturing",
    "title": "Targa Parsing",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-parsing",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-parsing"
  },"472": {
    "doc": "4. Texturing",
    "title": "Targa Header 설정",
    "content": "Targa(.tga) 이미지 파일의 헤더(header) 정보를 파일에 저장된 바이너리(binary) 형식 그대로 읽어오기 위해 정의 . | TGA Image description | . struct TargaHeader { unsigned char data1[12]; unsigned short width; unsigned short height; unsigned char bpp; unsigned char data2; }; . | 현재 필요한 정보(width, bpp 등)만 가져오기 위해 data1, data2로 축약 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-header-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-header-설정"
  },"473": {
    "doc": "4. Texturing",
    "title": "fopen_s()",
    "content": "Targa 파일을 열고 파일 포인터를 연결 . int error; // Open the targa file for reading in binary. error = fopen_s(&amp;filePtr, filename, \"rb\"); if(error != 0) { return false; } . | fopen_s(&amp;filePtr, filename, “rb”) . | &amp;filePtr : 파일을 성공적으로 열었을 때 파일 포인터를 저장할 변수의 주소 | filename : 열고자 하는 파일의 경로와 이름 | “rb”: 파일을 읽기 전용(“r”), 바이너리 모드(“b”)로 염 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#fopen_s",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#fopen_s"
  },"474": {
    "doc": "4. Texturing",
    "title": "fread()",
    "content": "파일 스트림에서 지정된 크기의 데이터 블록을 읽어와 메모리에 저장 . FILE* filePtr; TargaHeader targaFileHeader; unsigned char* targaImage; int imageSize; // 1. 파일을 바이너리 모드로 열기 error = fopen_s(&amp;filePtr, filename, \"rb\"); if(error != 0) { return false; } // 2. Targa 헤더 읽기 (18 바이트) // 이 fread가 끝나면 filePtr의 위치는 이미지 데이터 시작점으로 이동 count = (unsigned int)fread(&amp;targaFileHeader, sizeof(TargaHeader), 1, filePtr); if(count != 1) { return false; } m_height = (int)targaFileHeader.height; m_width = (int)targaFileHeader.width; imageSize = m_width * m_height * 4; // 3. 이미지 데이터 읽기 (헤더를 제외한 순수 픽셀 데이터) count = (unsigned int)fread(targaImage, 1, imageSize, filePtr); if(count != imageSize) { return false; } // Close the file. error = fclose(filePtr); if(error != 0) { return false; } . | fread(&amp;targaFileHeader, sizeof(TargaHeader), 1, filePtr) . | void *ptr: 읽어온 데이터를 저장할 메모리 버퍼의 포인터 | size_t size: 읽어올 데이터 항목 1개의 크기 (바이트 단위) | size_t nmemb: size 매개변수에서 지정한 크기의 요소를 몇 개나 읽을지(개수)를 지정 . | size * nmemb 바이트만큼의 데이터를 읽으려고 시도 | . | FILE *stream: 데이터를 읽어올 파일 스트림의 포인터 | . | . | filePtr이 가리키는 파일에서 TargaHeader 구조체 크기만큼 1번 읽어서 targaFileHeader 변수에 저장 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#fread",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#fread"
  },"475": {
    "doc": "4. Texturing",
    "title": "bpp (Bits Per Pixel)",
    "content": "하나의 픽셀(Pixel) 당 사용되는 비트(Bit)의 수 . 점 하나의 색상 정보를 얼마나 정밀하게 표현할 것인가를 나타내는 단위 . | bpp 값이 클수록 더 많은 비트를 사용하여 색상을 표현하므로, 표현할 수 있는 색상이 늘어남 | . // Get the important information from the header. m_height = (int)targaFileHeader.height; m_width = (int)targaFileHeader.width; bpp = (int)targaFileHeader.bpp; // Check that it is 32 bit and not 24 bit. if(bpp != 32) { return false; } // Calculate the size of the 32 bit image data. imageSize = m_width * m_height * 4; . 8-bpp (8 bits per pixel) . 하나의 픽셀을 8비트로 표현 (2⁸ = 256가지의 정보를 표현) . | 흑백 (Grayscale) . | 0(검은색) 부터 255(흰색) 까지 256단계의 명암을 표현 | . | 인덱스 컬러 (Indexed Color) . | 256개의 색상으로 구성된 ‘색상 팔레트(Color Palette)’를 미리 정의해 둠 | 픽셀 데이터에는 실제 색상 값(RGB)이 아닌, 팔레트의 몇 번째 색인지를 나타내는 번호(인덱스)만 저장 | TGA 파일의 ‘컬러맵’이 바로 이 방식 | . | . 24-bpp (24 bits per pixel) . 하나의 픽셀을 24비트로 표현 (2²⁴ ≈ 1670만 가지의 색상을 표현) . | 인간의 눈으로 구분할 수 있는 거의 모든 색을 표현할 수 있다고 해서 ‘트루 컬러’라고 부름 | 빛의 삼원색인 RGB 채널로 나뉨 . | Red (빨강): 8비트 (256 단계) | Green (초록): 8비트 (256 단계) | Blue (파랑): 8비트 (256 단계) . | 총 8 + 8 + 8 = 24비트 | . | . | . | TGA 파일에서 bpp가 24라면, 이미지 데이터는 (B, G, R), (B, G, R), … 순서로 3바이트짜리 색상 덩어리가 반복되는 구조 | . 32-bpp (32 bits per pixel) . 하나의 픽셀을 32비트로 표현. 24-bpp의 RGB 채널에 알파(Alpha) 채널이 추가 . | Red (빨강): 8비트 | Green (초록): 8비트 | Blue (파랑): 8비트 | Alpha (알파): 8비트 (투명도) . | 총 8 + 8 + 8 + 8 = 32비트 | . | 알파 채널은 해당 픽셀의 투명도를 저장. 0은 완전 투명, 255는 완전 불투명을 의미 | 유리, 불꽃, 연기, UI 아이콘의 배경 등 부분적으로 투명한 텍스처를 만들 때 반드시 필요 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#bpp-bits-per-pixel",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#bpp-bits-per-pixel"
  },"476": {
    "doc": "4. Texturing",
    "title": "bpp가 왜 중요한가",
    "content": "bpp는 다음 두 가지를 결정하기 위해 필수적이다 . - 이미지 데이터 크기(바이트) = 가로(width) * 세로(height) * (bpp / 8) . | 메모리 크기 계산 . | 이미지 데이터 전체를 담을 버퍼의 크기를 계산할 때 bpp가 사용됨 | bpp는 ‘비트’ 단위이므로 8로 나누어 ‘바이트’ 단위로 변환해야 함 | . | 파싱 방식 결정 . | 이미지 데이터를 읽어 들이는 for 루프 안에서, 한 픽셀을 몇 바이트씩 읽어야 할지 결정 | if (bpp == 24) 이면 3바이트씩, if (bpp == 32) 이면 4바이트씩 데이터를 처리하고 다음 픽셀로 넘어감 | . | Direct3D 포맷 결정 . | Direct3D 텍스처를 생성할 때, DXGI_FORMAT을 지정해야 함 | 일반적으로 32-bpp(RGBA) 데이터는 DXGI_FORMAT_R8G8B8A8_UNORM 포맷에 해당 | . | . 현대의 GPU는 24비트 포맷을 잘 지원하지 않는다. 그래서 TGA 로더는 bpp가 24인 파일을 읽더라도, 메모리에는 32비트 공간을 할당하고 알파 채널 값을 255(불투명)로 채워서 32비트 데이터로 만들어 처리하는 경우가 매우 흔하다. ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#bpp%EA%B0%80-%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%9C%EA%B0%80",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#bpp가-왜-중요한가"
  },"477": {
    "doc": "4. Texturing",
    "title": "targa 데이터 처리",
    "content": "targa 이미지 데이터를 direct3D에 맞게 가공하기 . | 많은 이미지 포맷(TGA, BMP 등)은 데이터 저장 시 이미지의 가장 아래쪽 줄(bottom row)부터 위쪽 줄(top row) 순서로 저장함 . | 파일에 가장 먼저 저장된 픽셀 데이터는 이미지의 가장 아래쪽 줄에 해당 | 그래픽스 API가 화면을 위에서 아래로 그리는 방식과 반대 | 따라서 읽은 데이터를 그대로 텍스처에 넣으면 이미지가 상하로 뒤집혀 보임 | . | TGA 파일은 픽셀의 색상 정보를 BGRA(Blue, Green, Red, Alpha) 순서로 저장 . | 그래픽스 API는 일반적으로 RGBA 순서를 표준으로 사용 | . | . // targa 이미지 데이터의 시작점을 마지막 줄의 시작으로 초기화 k = (m_width * m_height * 4) - (m_width * 4); // 이미지의 모든 픽셀을 반복 for(j=0; j&lt;m_height; j++) { for(i=0; i&lt;m_width; i++) { // Targa 이미지(targaImage)에서 m_targaData로 픽셀 데이터를 복사하며 색상 순서를 바꿈 m_targaData[index + 0] = targaImage[k + 2]; // Red m_targaData[index + 1] = targaImage[k + 1]; // Green. m_targaData[index + 2] = targaImage[k + 0]; // Blue m_targaData[index + 3] = targaImage[k + 3]; // Alpha // 다음 픽셀로 이동 k += 4; index += 4; } // 한 줄(row) 처리가 끝나면, 원본 이미지(targaImage)의 포인터(k)를 이전 줄의 시작점으로 이동시킴 k -= (m_width * 8); } . | 이미지 상하 반전 (위에서 아래 순서(Top-to-Bottom)로 저장하기) . | k = (m_width * m_height * 4) - (m_width * 4); . | k를 원본 Targa 이미지 데이터(targaImage)의 마지막 줄 시작 위치로 설정 | 이미지의 가장 아랫줄부터 읽기 시작 | . | k -= (m_width * 8); . | 한 줄을 처리하면서 k는 m_width * 4 만큼 이미 증가 | 따라서 이전 줄로 가려면 현재 증가한 만큼(m_width * 4), 이전 줄의 길이(m_width * 4)를 합쳐 총 m_width * 8 만큼을 빼줌 | . | . | 색상 순서 변경 (BGRA → RGBA) . | m_targaData[index + 0] = targaImage[k + 2]; . | 원본의 3번째 바이트(Red)를 목적지의 1번째(Red)로 | . | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#targa-데이터-처리"
  },"478": {
    "doc": "4. Texturing",
    "title": "texture.ps",
    "content": "//GLOBALS Texture2D shaderTexture : register(t0); SamplerState SampleType : register(s0); //typedefs struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; }; //pixel shader float4 TexturePixelShader(PixelInputType input) : SV_TARGET { float4 textureColor; // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처의 픽셀 색상을 샘플링 textureColor = shaderTexture.Sample(sampleType, input.tex); return textureColor; } . | Texture2D shaderTexture : register(t0) . | HLSL(셰이더 언어)에서 2D 텍스처 리소스를 담을 변수를 선언하는 코드 | GPU의 특정 리소스 슬롯(slot)에 바인딩(연결)되도록 지정하는 구문 . | t : Texture를 의미 | 0 : 0번째 슬롯을 의미 | . | C++ 코드에서 deviceContext-&gt;PSSetShaderResources(0, ...) 함수를 호출할 때, 첫 번째 인자인 0이 바로 이 register(t0)의 0과 일치해야 함 | . | SamplerState SampleType : register(s0) . | 텍스처를 어떻게 샘플링 (텍스처에서 픽셀 색상 값을 읽어오는 방법) 할지에 대한 규칙(필터링, 주소 지정 모드 등)을 정의하는 객체를 담을 변수 | GPU의 샘플러 슬롯 0번에 바인딩하라는 의미 . | s : Sampler를 의미 | 0 : 0번째 슬롯을 의미 | . | C++ 코드의 deviceContext-&gt;PSSetSamplers(0, ...) 함수의 첫 번째 인자인 0과 매칭됨 . | 이를 통해 C++에서 설정한 샘플링 방식을 셰이더로 전달 | . | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#textureps",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#textureps"
  },"479": {
    "doc": "4. Texturing",
    "title": "KEYWORD NOTE",
    "content": "textureShaderclass, textureClass에서 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#keyword-note"
  },"480": {
    "doc": "4. Texturing",
    "title": "D3D11_TEXTURE2D_DESC",
    "content": "ID3D11Texture2D 리소스를 생성할 때 필요한 모든 속성을 정의 . D3D11_TEXTURE2D_DESC textureDesc; textureDesc.Height = m_height; textureDesc.Width = m_width; textureDesc.MipLevels = 0; textureDesc.ArraySize = 1; textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; textureDesc.SampleDesc.Count = 1; textureDesc.SampleDesc.Quality = 0; textureDesc.Usage = D3D11_USAGE_DEFAULT; textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET; textureDesc.CPUAccessFlags = 0; textureDesc.MiscFlags = D3D11_RESOURCE_MISC_GENERATE_MIPS; . | Height, Width : 텍스처의 높이와 너비 (픽셀 단위) | MipLevels : 밉맵(Mipmap) 레벨의 수. 0으로 설정하면 전체 밉맵 체인이 자동 생성 | ArraySize : 텍스처 배열의 크기. 일반적인 2D 텍스처는 1 | Format: 텍스처의 픽셀 형식 (DXGI_FORMAT_R8G8B8A8_UNORM은 8비트 RGBA 채널을 가진 정규화된 형식) | SampleDesc: 멀티샘플링(MSAA) 설정 . | Count=1, Quality=0으로 설정하여 멀티샘플링을 사용하지 않음을 의미 | . | Usage : 리소스의 주된 사용 방식 (D3D11_USAGE_DEFAULT는 GPU가 읽고 쓰는 가장 일반적인 리소스) | BindFlags : 리소스를 파이프라인의 어느 단계에 바인딩할지 지 . | D3D11_BIND_SHADER_RESOURCE : 셰이더에서 읽을 수 있음 | D3D11_BIND_RENDER_TARGET : 렌더링 결과를 저장 | . | CPUAccessFlags : CPU가 이 리소스에 접근하는 방식. 0은 CPU 접근이 없음을 의미 | MiscFlags : 기타 플래그 (D3D11_RESOURCE_MISC_GENERATE_MIPS는 밉맵을 자동으로 생성하도록 허용) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_texture2d_desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_texture2d_desc"
  },"481": {
    "doc": "4. Texturing",
    "title": "D3D11_USAGE",
    "content": "D3D11_USAGE 플래그와 메모리 위치 . D3D11_USAGE_DEFAULT (가장 일반적인 경우) . | 메모리 위치: GPU 메모리 (VRAM) | 설명: . | GPU가 가장 빠르게 읽고 쓸 수 있도록 VRAM에 리소스를 생성 | CPU는 이 메모리에 직접 접근할 수 없음 (읽기/쓰기 불가) | CPU가 이 리소스의 데이터를 업데이트하려면 UpdateSubresource 또는 CopySubresourceRegion 같은 함수를 통해 드라이버에게 데이터 복사를 “요청”해야 함 | . | 용도: 한 번 로드된 후 거의 변경되지 않는 대부분의 텍스처, 모델 데이터 등에 사용 | . D3D11_USAGE_DYNAMIC . | 메모리 위치: 주로 GPU 메모리에 있지만, CPU가 매우 빠르게 쓸 수 있도록 특별한 경로가 마련된 메모리 | 설명: . | CPU가 데이터를 자주 업데이트해야 하는 리소스를 위해 사용 | CPU는 Map 함수를 호출하여 이 리소스에 대한 포인터를 얻어와서 쓰기 작업을 할 수 있음 | (Map과 Unmap 사이에서 데이터를 쓴 후, 드라이버가 효율적으로 GPU로 전송) | UpdateSubresource보다 훨씬 빠름 | . | 용도: 매 프레임 내용이 바뀌는 UI 텍스처, 비디오 텍스처, CPU에서 계산된 파티클 데이터 등에 사용 | . D3D11_USAGE_STAGING . | 메모리 위치: 시스템 메모리 (RAM) | 설명: . | CPU가 자유롭게 읽고 쓸 수 있는 RAM에 리소스를 생성 | 중요: 이 리소스는 셰이더 파이프라인에 직접 바인딩할 수 없음 . | 즉, STAGING 텍스처에 대한 ShaderResourceView를 셰이더에 설정할 수 없음 | . | . | 용도: GPU와 CPU 간에 데이터를 전송하는 역할을 함 | 예를 들어, GPU에 있는 DEFAULT 텍스처의 내용을 CPU로 다시 읽어오고 싶을 때 (스크린샷 저장 등) | DEFAULT 리소스 -&gt; STAGING 리소스로 복사한 다음, CPU가 STAGING 리소스를 Map하여 데이터를 읽음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_usage",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_usage"
  },"482": {
    "doc": "4. Texturing",
    "title": "D3D11_SHADER_RESOURCE_VIEW_DESC",
    "content": "특정 리소스(예: 텍스처)를 어떤 형식과 차원으로 셰이더에게 보여줄지를 정의 . typedef struct D3D11_SHADER_RESOURCE_VIEW_DESC { DXGI_FORMAT Format; D3D11_SRV_DIMENSION ViewDimension; union { D3D11_BUFFER_SRV Buffer; D3D11_TEX1D_SRV Texture1D; D3D11_TEX1D_ARRAY_SRV Texture1DArray; D3D11_TEX2D_SRV Texture2D; D3D11_TEX2D_ARRAY_SRV Texture2DArray; D3D11_TEX2DMS_SRV Texture2DMS; D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray; D3D11_TEX3D_SRV Texture3D; D3D11_TEXCUBE_SRV TextureCube; D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray; D3D11_BUFFEREX_SRV BufferEx; }; } D3D11_SHADER_RESOURCE_VIEW_DESC; . | Format: 셰이더가 리소스 데이터를 어떤 데이터 형식으로 읽을지 결정 . | DXGI_FORMAT 열거형 값을 사용 (채널, 비트수, 데이터 타입 등. DXGI_FORMAT_R8G8B8A8_UNORM) | . | ViewDimension: 이 뷰를 어떤 차원의 리소스로 해석할지 결정 . | D3D11_SRV_DIMENSION 열거형 값을 사용 | . | union : ViewDimension 값에 따라 활성화되는 멤버가 달라짐. 뷰의 구체적인 속성 설정 . | ViewDimension 값으로 리소스의 모양을 결정 (예: D3D11_SRV_DIMENSION_TEXTURE2D) | 컴파일러와 Direct3D에서 union 안에 있는 여러 멤버 중에 Texture2D 멤버를 사용해서 세부 정보 읽기 판단 | 개발자는 union의 여러 멤버 중 ViewDimension에 맞는 하나만 골라서 값을 채우면 됨 | . | . D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc; srvDesc.Format = textureDesc.Format; srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D; srvDesc.Texture2D.MostDetailedMip = 0; srvDesc.Texture2D.MipLevels = -1; hResult = device-&gt;CreateShaderResourceView(m_texture, &amp;srvDesc, &amp;m_textureView); . | Format: 뷰의 형식. 보통 텍스처의 형식과 동일하게 설정 | ViewDimension: 리소스를 어떤 차원으로 볼 것인지 지정 (D3D11_SRV_DIMENSION_TEXTURE2D는 2D 텍스처로 보겠다는 의미) | Texture2D.MostDetailedMip: 뷰가 접근할 수 있는 가장 상세한 밉맵 레벨. 0은 원본 이미지를 의미. | Texture2D.MipLevels: 뷰를 통해 접근할 밉맵의 총 개수 . | -1은 MostDetailedMip부터 모든 하위 밉맵 레벨에 접근 가능함을 의미 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_shader_resource_view_desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_shader_resource_view_desc"
  },"483": {
    "doc": "4. Texturing",
    "title": "PSSetShaderResources()",
    "content": "ID3D11ShaderResourceView* texture; deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture); . | deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture) . | 0: 리소스를 바인딩할 시작 슬롯 번호. 픽셀 셰이더의 register(t0)에 해당 | 1: 바인딩할 리소스 뷰의 개수 | &amp;texture: 바인딩할 셰이더 리소스 뷰(SRV) 배열의 포인터 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#pssetshaderresources",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#pssetshaderresources"
  },"484": {
    "doc": "4. Texturing",
    "title": "D3D11_SAMPLER_DESC",
    "content": "샘플러 상태(Sampler State)를 생성할 때 사용되는 구조체로, 셰이더에서 텍스처를 샘플링할 때의 방식을 정의 . | 텍스처 좌표가 텍셀 사이에 놓였을 때 어떻게 보간할지 | 텍스처 경계를 어떻게 처리할지 등을 설정 | . typedef struct D3D11_SAMPLER_DESC { D3D11_FILTER Filter; D3D11_TEXTURE_ADDRESS_MODE AddressU; D3D11_TEXTURE_ADDRESS_MODE AddressV; D3D11_TEXTURE_ADDRESS_MODE AddressW; FLOAT MipLODBias; UINT MaxAnisotropy; D3D11_COMPARISON_FUNC ComparisonFunc; FLOAT BorderColor[4]; FLOAT MinLOD; FLOAT MaxLOD; } D3D11_SAMPLER_DESC; . | Filter (D3D11_FILTER) : 텍셀 필터링 방식을 결정 . | D3D11_FILTER_MIN_MAG_MIP_POINT - 최근접 이웃 필터링 | D3D11_FILTER_MIN_MAG_MIP_LINEAR - 양선형 필터링 (가장 일반적) | D3D11_FILTER_ANISOTROPIC - 이방성 필터링 (고품질) | . | . | AddressU, AddressV, AddressW : 텍스처 좌표 (u, v, w)가 0.0에서 1.0 범위를 벗어났을 때 어떻게 처리할지를 결정하는 텍스처 주소 지정 모드 . | D3D11_TEXTURE_ADDRESS_MODE 값 사용 | D3D11_TEXTURE_ADDRESS_WRAP : 텍스처가 타일처럼 반복됨. (예: 바닥, 벽지) | D3D11_TEXTURE_ADDRESS_MIRROR : 텍스처가 거울처럼 반사되어 반복 | D3D11_TEXTURE_ADDRESS_CLAMP : 0.0 미만은 0.0으로, 1.0 초과는 1.0으로 처리하여 텍스처의 가장자리 색상으로 채움 | D3D11_TEXTURE_ADDRESS_BORDER: BorderColor에 지정된 색상으로 텍스처 외부를 채움 | . | . | MipLODBias : 밉맵 레벨(LOD, Level of Detail)을 계산할 때 적용할 오프셋 값 . | 양수 값은 더 낮은 해상도의 밉맵을, | 음수 값은 더 높은 해상도의 밉맵을 사용하게 하여 텍스처의 선명도를 조절할 수 있음 | . | MaxAnisotropy : 비등방성 필터링(D3D11_FILTER_ANISOTROPIC)을 사용할 때의 최대 샘플링 값 . | 값이 1일때 비활성화 | 값이 높을수록 비스듬한 표면의 텍스처 품질이 향상되지만 성능 비용이 증가 | . | ComparisonFunc : 비교 샘플러를 위한 비교 함수를 지정 . | 그림자 맵핑(shadow mapping)과 같은 기법에서 사용되며, 샘플링된 텍스처 데이터와 특정 기준 값을 비교하는 데 사용 | . | BorderColor : D3D11_TEXTURE_ADDRESS_BORDER로 설정된 경우 사용될 테두리 색상을 지정 . | RGBA 순서의 4개 부동소수점 값으로 구성 | . | MinLOD, MaxLOD : 밉맵 사용을 제한하는 최소 및 최대 레벨을 지정 . | MinLOD: 사용할 수 있는 가장 상세한 밉맵 레벨(가장 높은 해상도). 0.0이 기본값 | MaxLOD: 사용할 수 있는 가장 덜 상세한 밉맵 레벨(가장 낮은 해상도) . | D3D11_FLOAT32_MAX로 설정하면 모든 밉맵 레벨을 사용할 수 있음 | . | . | . D3D11_SAMPLER_DESC samplerDesc; samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR; samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.MipLODBias = 0.0f; samplerDesc.MaxAnisotropy = 1; samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS; samplerDesc.BorderColor[0] = 0; samplerDesc.BorderColor[1] = 0; samplerDesc.BorderColor[2] = 0; samplerDesc.BorderColor[3] = 0; samplerDesc.MinLOD = 0; samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; // 텍스처 샘플러 상태를 생성 result = device-&gt;CreateSamplerState(&amp;samplerDesc, &amp;m_sampleState); . | MipLODBias = 0.0f : 밉맵 레벨(LOD)을 선택할 때 어떠한 편향(Bias)도 주지 않음 . | GPU가 현재 픽셀에 가장 적합하다고 판단하는 밉맵 레벨을 그대로 사용 | . | MaxAnisotropy = 1 : 비등방성 필터링(Anisotropic Filtering)을 사용하지 않음 . | 이 값은 1일 때 비활성화 | 비스듬한 각도에서 텍스처를 볼 때 흐릿하게 보일 수 있음 | . | ComparisonFunc = D3D11_COMPARISON_ALWAYS : 비교 샘플링 기능을 사용하지 않음 . | ALWAYS는 비교 테스트가 항상 통과함을 의미 | 그림자 맵핑과 같은 특수 용도가 아닌, 일반적인 텍스처 색상을 가져오는 용도로 사용됨 | . | MinLOD = 0 &amp; MaxLOD = D3D11_FLOAT32_MAX : 밉맵 레벨 사용에 제한을 두지 않음 . | 가장 높은 해상도(LOD 0)부터 가장 낮은 해상도의 밉맵까지 모든 밉맵 레벨을 자유롭게 사용할 수 있음 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_sampler_desc",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#d3d11_sampler_desc"
  },"485": {
    "doc": "4. Texturing",
    "title": "PSSetSamplers()",
    "content": "// 픽셀 셰이더에서 샘플러 설정 deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState); . | deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState); . | 0 : 샘플러를 바인딩할 시작 슬롯 번호. 픽셀 셰이더의 register(s0)에 해당 | 1: 바인딩할 샘플러의 개수 | &amp;m_sampleState: 바인딩할 샘플러 상태 객체 배열의 포인터 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#pssetsamplers",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/4.%20Texturing.html#pssetsamplers"
  },"486": {
    "doc": "5. Cross products",
    "title": "5. Cross products",
    "content": "벡터의 외적 . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html"
  },"487": {
    "doc": "5. Cross products",
    "title": "외적의 개념",
    "content": ". | 외적(Cross Product)은 3차원 공간에서 두 벡터에 대해 정의되는 연산 | 두 벡터에 모두 수직인 새로운 벡터를 생성한다 | 외적은 행렬식을 통해 정의된다 | . \\[\\vec{a} \\times \\vec{b} = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ a_1 &amp; a_2 &amp; a_3 \\\\ b_1 &amp; b_2 &amp; b_3 \\end{vmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81%EC%9D%98-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적의-개념"
  },"488": {
    "doc": "5. Cross products",
    "title": "외적의 성질",
    "content": "\\[\\mathbf{a},\\mathbf{b}\\in\\mathbb{R}^3 \\Rightarrow \\begin{cases} \\mathbf{a}\\times\\mathbf{b}\\ \\perp\\ \\mathbf{a},\\ \\mathbf{b}\\\\[2pt] \\|\\mathbf{a}\\times\\mathbf{b}\\|=\\|\\mathbf{a}\\|\\ \\|\\mathbf{b}\\|\\sin\\theta\\\\[2pt] \\text{방향은 오른손 법칙으로 결정} \\end{cases}\\] . | \\(\\mathbb{R}^3\\) 에서만 정의되는 이항 연산 | \\(\\mathbf{a} \\times \\mathbf{b}\\) 는 \\(\\mathbf{a}\\)와 \\(\\mathbf{b}\\) 에 모두 수직 | \\(\\mathbf{a} \\times \\mathbf{b}\\) 의 크기는 \\(\\mathbf{a}\\) 와 \\(\\mathbf{b}\\) 두 벡터가 만드는 평행사변형의 넓이 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81%EC%9D%98-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적의-성질"
  },"489": {
    "doc": "5. Cross products",
    "title": "외적 공식",
    "content": "\\[\\vec{a} \\times \\vec{b} = \\\\\\] . \\[\\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ a_1 &amp; a_2 &amp; a_3 \\\\ b_1 &amp; b_2 &amp; b_3 \\end{vmatrix} = \\\\\\] . \\[\\mathbf{i} \\begin{vmatrix} a_2 &amp; a_3 \\\\ b_2 &amp; b_3 \\end{vmatrix} - \\mathbf{j} \\begin{vmatrix} a_1 &amp; a_3 \\\\ b_1 &amp; b_3 \\end{vmatrix} + \\mathbf{k} \\begin{vmatrix} a_1 &amp; a_2 \\\\ b_1 &amp; b_2 \\end{vmatrix} =\\] . \\[\\mathbf{i}(a_2 b_3 - a_3 b_2) - \\mathbf{j}(a_1 b_3 - a_3 b_1) + \\mathbf{k}(a_1 b_2 - a_2 b_1)\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81-%EA%B3%B5%EC%8B%9D",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적-공식"
  },"490": {
    "doc": "5. Cross products",
    "title": "외적 행렬식 계산 요령",
    "content": ". | 행렬식은 체커보드 패턴을 따른다 | . \\[\\begin{vmatrix} + &amp; - &amp; + \\\\ - &amp; + &amp; - \\\\ + &amp; - &amp; + \\end{vmatrix}\\] . | 따라서 첫번째 행의 i는 양수, j는 음수, k는 양수 | . | i, j, k 계수에 해당되지 않는 2×2 행렬식은 해당 계수가 있는 열과 행을 제외하고 계산한다 . | i 의 경우 . | . \\[\\begin{vmatrix} i &amp; . &amp; . \\\\ . &amp; a_2 &amp; a_3 \\\\ . &amp; b_2 &amp; b_3 \\end{vmatrix}\\] . | j 의 경우 | . \\[\\begin{vmatrix} . &amp; j &amp; . \\\\ a_1 &amp; . &amp; a_3 \\\\ b_1 &amp; . &amp; b_3 \\end{vmatrix}\\] . | k 의 경우 | . \\[\\begin{vmatrix} . &amp; . &amp; k \\\\ a_1 &amp; a_2 &amp; . \\\\ b_1 &amp; b_2 &amp; . \\end{vmatrix}\\] . | 2×2 행렬식은 대각선으로 곱하여 서로 뺀다 | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81-%ED%96%89%EB%A0%AC%EC%8B%9D-%EA%B3%84%EC%82%B0-%EC%9A%94%EB%A0%B9",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적-행렬식-계산-요령"
  },"491": {
    "doc": "5. Cross products",
    "title": "외적 계산 예시",
    "content": ". | \\[\\vec{a} = (1,2,3)\\] | \\[\\vec{b} = (-1,0,3)\\] | . \\[\\vec{a} \\times \\vec{b} = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ 1 &amp; 2 &amp; 3 \\\\ -1 &amp; 0 &amp; 3 \\end{vmatrix} = \\mathbf{i} \\begin{vmatrix} 2 &amp; 3 \\\\ 0 &amp; 3 \\end{vmatrix} - \\mathbf{j} \\begin{vmatrix} 1 &amp; 3 \\\\ -1 &amp; 3 \\end{vmatrix} + \\mathbf{k} \\begin{vmatrix} 1 &amp; 2 \\\\ -1 &amp; 0 \\end{vmatrix}\\] . \\[\\mathbf{i}((2)(3) - (3)(0)) \\\\ \\\\ - \\mathbf{j}((1)(3) - (3)(-1)) \\\\ \\\\ + \\mathbf{k}((1)(0) - (2)(-1)) \\\\\\] . \\[= 6\\mathbf{i} - 6\\mathbf{j} + 2\\mathbf{k}\\] . 따라서 . \\[\\vec{a} × \\vec{b} = (6, −6, 2)\\] . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81-%EA%B3%84%EC%82%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적-계산-예시"
  },"492": {
    "doc": "5. Cross products",
    "title": "외적 크기 설명 추가하기!!!",
    "content": "참고하면 좋은 링크 . | Engineering Statics : Cross Products | . ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#%EC%99%B8%EC%A0%81-%ED%81%AC%EA%B8%B0-%EC%84%A4%EB%AA%85-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/5.%20Cross%20products.html#외적-크기-설명-추가하기"
  },"493": {
    "doc": "5. Diffuse Lighting",
    "title": "5. Diffuse Lighting",
    "content": ". | Introduction to Shading | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html"
  },"494": {
    "doc": "5. Diffuse Lighting",
    "title": "프레임 워크 요소",
    "content": ". | LightClass 추가: 장면에 있는 빛의 특성(방향, 색상)을 캡슐화 | LightShaderClass 추가: 모델에 조명 셰이딩을 적용하는 역할. 기존의 TextureShaderClass를 대체 | ModelClass 수정: 정점(vertex) 데이터에 법선(normal) 벡터를 포함하도록 VertexType 구조체를 확장 | ApplicationClass 수정: LightClass와 LightShaderClass를 사용하도록 초기화 및 렌더링 로직을 업데이트 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#프레임-워크-요소"
  },"495": {
    "doc": "5. Diffuse Lighting",
    "title": "조명을 배우기 전 알아두면 좋은 사전 지식",
    "content": "조명 계산은 본질적으로 벡터 연산 . 벡터 정규화 (Vector Normalization) . 벡터의 방향은 그대로 유지한 채, 길이를 1로 만드는 과정 . | 길이가 1인 벡터를 단위 벡터(Unit Vector)라고 부름 | 조명 계산 시 ‘방향’ 정보만을 원할 때가 많음 . | 벡터의 길이가 계산에 영향을 주면 안 되기 때문 | . | 정규화된 벡터를 사용하면 아래에 설명할 내적(Dot Product) 계산이 매우 간편해짐 | . 정점 법선 (Vertex Normal) . 3D 모델의 각 정점(vertex)이 어느 방향을 향하고 있는지를 나타내는 단위 벡터 . | 표면에 수직인 방향을 가리킴 | 법선 벡터가 있어야만 빛과 표면이 이루는 각도를 계산할 수 있음 | 평평한 삼각형 면이라도 각 정점의 법선 벡터 값을 다르게 주면, 픽셀 셰이더에서 보간(interpolate)되어 부드러운 곡면처럼 보이게 할 수 있다 | . 내적 (Dot Product) . | \\[A · B = |A||B| cos(θ)\\] | . 두 벡터가 얼마나 “같은 방향을 바라보는지”를 나타내는 연산 . | 결과값은 스칼라 (숫자 하나) | 두 벡터 A와 B가 모두 정규화된 단위 벡터라면, A와 B는 모두 1이 됨 . | 따라서 \\(A · B = cos(θ)\\) 가 됨 | . | . cos(θ) 값은 -1에서 1 사이의 값을 가짐 . | 두 벡터가 같은 방향이면 (θ=0°), 결과는 1 (최대 밝기). | 두 벡터가 90° 각도이면 (θ=90°), 결과는 0 (빛을 받지 않음). | 두 벡터가 반대 방향이면 (θ=180°), 결과는 -1 (빛의 반대편을 향함). | . “표면의 법선 벡터”와 “빛의 방향 벡터”를 내적하면 표면이 빛을 얼마나 정면으로 받고 있는지를 0~1 사이의 값으로 간단히 계산할 수 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EC%A1%B0%EB%AA%85%EC%9D%84-%EB%B0%B0%EC%9A%B0%EA%B8%B0-%EC%A0%84-%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%82%AC%EC%A0%84-%EC%A7%80%EC%8B%9D",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#조명을-배우기-전-알아두면-좋은-사전-지식"
  },"496": {
    "doc": "5. Diffuse Lighting",
    "title": "Directional Lighting (방향성 조명)",
    "content": "아주 멀리 있는 광원을 시뮬레이션 (예 : 태양) . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#directional-lighting-%EB%B0%A9%ED%96%A5%EC%84%B1-%EC%A1%B0%EB%AA%85",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#directional-lighting-방향성-조명"
  },"497": {
    "doc": "5. Diffuse Lighting",
    "title": "특징",
    "content": ". | 씬(Scene) 안의 모든 물체에 빛이 동일한 방향에서 평행하게 들어온다고 가정 | 따라서 Directional Light는 위치(Position)가 없고, 오직 방향(Direction)만 가짐 | 모든 픽셀 셰이더에서 동일한 빛의 방향 벡터를 사용하므로 계산이 매우 효율적입니다. | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#특징"
  },"498": {
    "doc": "5. Diffuse Lighting",
    "title": "계산법",
    "content": ". | Diffuse Lighting 계산에 사용되는 빛의 방향 벡터(L)가 씬의 모든 곳에서 상수(constant)가 됨 | 예를 들어, “하늘 위에서 아래로” 비추는 빛을 만들고 싶다면, 빛의 방향 벡터를 (0, -1, 0)과 같이 하나로 고정해둠 | 모든 조명 계산에 사용 | . Directional Lighting은 태양처럼 “모든 곳에 동일한 방향으로 내리쬐는 빛”을 표현하는 방법 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EA%B3%84%EC%82%B0%EB%B2%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#계산법"
  },"499": {
    "doc": "5. Diffuse Lighting",
    "title": "Diffuse Lighting (난반사 조명)",
    "content": "빛이 표면에 닿았을 때, 모든 방향으로 균일하게 흩어지는(scattering) 현상을 모델링 페인트 벽, 종이처럼 반짝이지 않는 대부분의 물체 표면에서 일어나는 빛의 반사 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#diffuse-lighting-%EB%82%9C%EB%B0%98%EC%82%AC-%EC%A1%B0%EB%AA%85",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#diffuse-lighting-난반사-조명"
  },"500": {
    "doc": "5. Diffuse Lighting",
    "title": "특징",
    "content": ". | 어느 각도에서 보아도 반사되는 빛의 양이 동일. 즉, 시점(카메라 위치)에 영향을 받지 않음 | 오직 표면이 빛을 얼마나 정면으로 마주하고 있는지에만 영향을 받음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#특징-1"
  },"501": {
    "doc": "5. Diffuse Lighting",
    "title": "계산법",
    "content": ". | 표면의 법선 벡터(N)를 구함 | 표면에서 광원(Light)으로 향하는 빛의 방향 벡터(L)를 구함 | N과 L을 모두 정규화(Normalize) | 두 단위 벡터를 내적(Dot Product)함 (diffuse_intensity = dot(N, L)) | 내적 결과가 음수이면 (즉, 표면이 빛의 반대 방향을 향하고 있으면) 빛을 받지 못하므로, 결과값을 0으로 처리. (보통 max(0, dot(N, L)) 함수를 사용) | diffuse_intensity (0~1 사이의 값)에 빛의 색상과 물체의 색상을 곱하면 최종적인 난반사 색상이 결정 | . Diffuse Lighting은 “이 표면이 빛을 얼마나 직접적으로 받고 있는가?”를 계산하는 것 . | diffuse Light 구하기 | . // --- 입력 값 --- // gLightColor: 광원의 색상 (예: (1,1,1) 백색광) // input.normal: 표면의 법선 벡터 N // lightVec: 표면에서 광원으로 향하는 벡터 L // --- 계산 과정 --- // 1. '표면이 빛을 얼마나 정면으로 마주보는가'를 계산 (빛의 세기 인자) // 결과는 0.0 ~ 1.0 사이의 스칼라(float) 값 float diffuseFactor = saturate(dot(input.normal, lightVec)); // 2. Diffuse Light(분산광)의 최종 색상과 세기를 계산 // 광원 자체의 색상에 위에서 구한 인자를 곱함 float3 diffuseLight = gLightColor * diffuseFactor; // 3. 텍스처에서 Diffuse Color(Albedo)를 읽어옴 float4 albedoColor = txDiffuse.Sample(samLinear, input.tex); // 4. 최종 분산 반사 색상 계산 // (계산된 빛) * (재질의 반사율) float3 finalDiffuseColor = diffuseLight * albedoColor.rgb; . | ResterTek 예시 코드 | . float4 LightPixelShader(PixelInputType input) : SV_TARGET { float4 textureColor; float3 lightDir; float4 lightIntensity; float4 color; // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처에서 픽셀 색상을 샘플링 textureColor = shaderTexture.Sample(SampleType, input.tex); // 계산 위해 빛 방향을 반전 lightDir = -lightDirection; // 이 픽셀에 대한 빛의 양을 계산 lightIntensity = saturate(dot(input.normal, lightDir)); // 조명 강도와 결합된 확산 색상을 기반으로 최종 확산 색상의 양을 결정 color = saturate(diffuseColor * lightIntensity); // 텍스처 픽셀과 최종 확산 색상을 곱하여 최종 픽셀 색상 결과를 얻음 color = color * textureColor; return color; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EA%B3%84%EC%82%B0%EB%B2%95-1",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#계산법-1"
  },"502": {
    "doc": "5. Diffuse Lighting",
    "title": "빛 방향을 반전 시키는 이유?",
    "content": "직관적 사고 (물리적 관점) . | 광원 → 표면 방향 (“빛이 광원에서 나와 표면을 향해 날아가는 방향”) | . 예시 램버트 공식인 dot(N, L)에 직관적 광원 → 표면 방향을 넣을 경우 . | 노멀 벡터 N: 표면이 똑바로 위로 향함 (0, 1) | 빛 벡터 L: 광원이 표면의 정면 위쪽 (0, -1) | . \\[dot(N, L) = (Nx * Lx) + (Ny * Ly) = (0 * 0) + (1 * -1) = 0 - 1 = -1\\] 가장 밝아야 할 상황이 가장 어두워지는 모순이 발생 . 램버트 조명 확산에서 필요한 관점 . | 표면 → 광원 방향 (“표면이 바라보는 방향” 을 기준으로 “광원이 있는 방향”) | L 벡터는 표면 입장에서 광원이 있는 방향을 나타내는 ‘상대 위치 벡터’ | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EB%B9%9B-%EB%B0%A9%ED%96%A5%EC%9D%84-%EB%B0%98%EC%A0%84-%EC%8B%9C%ED%82%A4%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#빛-방향을-반전-시키는-이유"
  },"503": {
    "doc": "5. Diffuse Lighting",
    "title": "diffuseColor VS textureColor",
    "content": ". | diffuseColor . | 물체 재질의 고유한 기본 색상 | 해당 물체의 모든 픽셀에 동일하게 적용 | 조명 계산의 기본이 되는 색으로, 물체가 어떤 색의 빛을 반사할지를 결정 | . | textureColor . | 이미지 파일(텍스처)에서 가져온 픽셀별 색상 | 물체 표면의 각기 다른 위치(UV 좌표)에 따라 다른 색상 값을 가짐 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#diffusecolor-vs-texturecolor",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#diffusecolor-vs-texturecolor"
  },"504": {
    "doc": "5. Diffuse Lighting",
    "title": "조명 효과와 표면의 디테일을 자연스럽게 합치기 위한 과정",
    "content": ". | lightIntensity = saturate(dot(input.normal, lightDir)); . | 먼저 픽셀이 빛을 얼마나 받는지를 0과 1 사이의 값으로 계산 (1이면 정면, 0이면 측면) | . | color = saturate(diffuseColor * lightIntensity); . | 물체의 기본 색상(diffuseColor)에 방금 구한 조명 세기를 곱함 . | 결과: 조명이 적용된 단색의 음영이 나옴 | 예를 들어 diffuseColor가 빨간색이고 빛을 정면으로 받으면(intensity=1) 밝은 빨간색 | 비스듬히 받으면(intensity=0.5) 어두운 빨간색 | 아직 표면의 디테일은 없는 상태 | . | . | color = color * textureColor; . | 위에서 계산한 ‘조명 받은 기본색’에 ‘표면의 무늬 색’(textureColor)을 곱함 | . | . 조명 계산으로 생긴 자연스러운 명암은 유지하면서, 그 위에 텍스처의 세밀한 무늬와 색상 변화를 함께 표현할 수 있게 됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EC%A1%B0%EB%AA%85-%ED%9A%A8%EA%B3%BC%EC%99%80-%ED%91%9C%EB%A9%B4%EC%9D%98-%EB%94%94%ED%85%8C%EC%9D%BC%EC%9D%84-%EC%9E%90%EC%97%B0%EC%8A%A4%EB%9F%BD%EA%B2%8C-%ED%95%A9%EC%B9%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#조명-효과와-표면의-디테일을-자연스럽게-합치기-위한-과정"
  },"505": {
    "doc": "5. Diffuse Lighting",
    "title": "Radians",
    "content": "각도를 표현하는 단위를 그래픽스 라이브러리(Direct3D, OpenGL)나 수학 함수(sin, cos)는 라디안(radian)이라는 단위를 사용 . 설명이 잘 되어있는 링크 : radians - 왜 π radians이 180도인지 잘 보여줌 . | 도(Degree)를 라디안(Radian)으로 변환 | . \\[\\text{Radian} = \\text{Degree} \\times \\frac{\\pi}{180}\\] . | 라디안(Radian)을 도(Degree)로 변환 | . \\[\\text{Degree} = \\text{Radian} \\times \\frac{180}{\\pi}\\] . bool ApplicationClass::Frame() { static float rotation = 0.0f; bool result; // 각 프레임 마다 회전 업데이트 rotation -= 0.0174532925f * 0.7f; if (rotation &lt; 0.0f) { rotation += 360.0f; } // 그래픽 장면 렌더링 result = Render(rotation); if (!result) { return false; } return true; } . | rotation -= 0.0174532925f * 0.7f; . | 0.0174532925f는 PI / 180 값으로, 1도를 라디안으로 변환한 값 | 1도에 0.7f을 곱하여 매 프레임마다 회전하는 속도를 조절 . | 즉 매 프레임마다 0.7도씩 회전 | . | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#radians",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#radians"
  },"506": {
    "doc": "5. Diffuse Lighting",
    "title": "rotation direction",
    "content": "축을 정하는 데 사용한 손과 똑같은 손을 사용해 회전 규칙을 정한다 . 설명이 잘 되어있는 링크 . | 왼손, 오른손 좌표계 설명 | 벡터 외적 : ‘오른손법칙’ 정확하게 이해하기 | . 외적(Cross Product)에서 a × b와 b × a의 순서에 따라 회전 방향이 결정되는 것이 바로 핵심 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#rotation-direction",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#rotation-direction"
  },"507": {
    "doc": "5. Diffuse Lighting",
    "title": "오른손 좌표계의 회전",
    "content": "오른손 좌표계에서는 ‘오른손 법칙’을 사용해 회전의 양(+)의 방향을 정함 . | 오른손 엄지를 회전하려는 축의 양(+)의 방향으로 향하게 함 . | 예: Z축을 중심으로 회전한다면 엄지를 +Z 방향으로 | . | 이때 나머지 네 손가락이 감기는 방향이 바로 ‘양(+)의 회전’ 방향 . | +Z축 중심 회전: 오른손 엄지를 +Z축으로 향하면, 손가락은 +X축에서 +Y축 방향으로 감김 . | 이것이 바로 Z축에 대한 양(+)의 회전 (반시계 방향) | . | +X축 중심 회전: 엄지를 +X축으로 향하면, 손가락은 +Y축에서 +Z축 방향으로 감김 | +Y축 중심 회전: 엄지를 +Y축으로 향하면, 손가락은 +Z축에서 +X축 방향으로 감김 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EC%98%A4%EB%A5%B8%EC%86%90-%EC%A2%8C%ED%91%9C%EA%B3%84%EC%9D%98-%ED%9A%8C%EC%A0%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#오른손-좌표계의-회전"
  },"508": {
    "doc": "5. Diffuse Lighting",
    "title": "왼손 좌표계의 회전",
    "content": "왼손 좌표계에서도 원리는 똑같다. 단지 사용하는 손이 왼손일 뿐 . | 왼손 엄지를 회전하려는 축의 양(+)의 방향으로 향하게 함 | 이때 나머지 네 손가락이 감기는 방향이 ‘양(+)의 회전’ 방향 | . 결과가 어떻게 달라지는지 Z축을 중심으로 살펴보기 . | +Z축 중심 회전: 왼손 엄지를 +Z축으로 향하면, 손가락은 +X축에서 -Y축 방향으로 감김 | 즉, 오른손 좌표계와 회전 방향이 정반대 (시계 방향) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#%EC%99%BC%EC%86%90-%EC%A2%8C%ED%91%9C%EA%B3%84%EC%9D%98-%ED%9A%8C%EC%A0%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#왼손-좌표계의-회전"
  },"509": {
    "doc": "5. Diffuse Lighting",
    "title": "mul()",
    "content": "행렬 곱셈(Matrix Multiplication)을 위한 내장 함수 . | dx-graphics-hlsl-mul | . | 입력으로 어떤 값이 오느냐에 따라 여러 가지 곱셈을 수행 (입력 인자에 따라 동작 방식이 다른 오버로드 함수) | . 벡터와 행렬의 곱셈 (좌표 변환) . mul(vector, matrix); // vector가 첫번째 인자일 경우 행 벡터(1 x N)로 간주하여 계산 // 수학적 계산: (1 x N) 벡터 * (N x M) 행렬 = (1 x M) 벡터 float3 myVector; // (1x3) 행 벡터 float3x4 myMatrix; // (3x4) 행렬 float4 result = mul(myVector, myMatrix); // (1x3) * (3x4) = (1x4) // 결과 벡터의 차원은 행렬의 열 개수인 4가 된다. mul(matrix, vector); // matrix가 첫번째 인자일 경우 vector를 열 벡터 ((N x 1)로 간주하여 계산 // 수학적 계산: (M x N) 행렬 * (N x 1) 벡터 = (M x 1) 벡터 float4x3 myMatrix; // (4x3) 행렬 float3 myVector; // (3x1) 열 벡터 // (4x3) * (3x1) = (4x1) // 결과 벡터의 차원은 행렬의 행 개수인 4가 된다. float4 result = mul(myMatrix, myVector); . | 벡터를 행렬과 곱해서 다른 좌표 공간으로 변환(Transform)하는, 3D 그래픽에서 가장 핵심적인 연산 | 위치 벡터나 방향 벡터(법선 등)를 모델 공간에서 월드 공간으로, 또는 월드 공간에서 뷰 공간 등으로 옮길 때 사용 | . | 연산 | 벡터 처리 방식 | 리턴 벡터의 차원 | . | mul(vector, matrix) | 행 벡터 | 입력 matrix의 열(column) 개수 | . | mul(matrix, vector) | 열 벡터 | 입력 matrix의 행(row) 개수 | . 행렬과 행렬의 곱셈 (변환 결합) . mul(matrixA, matrixB) . | 여러 개의 변환을 하나로 합칠 때 사용 | 예를 들어, World * View * Projection 행렬을 미리 계산해서 | WVP라는 최종 행렬 하나를 만들 때 mul(mul(World, View), Projection)과 같이 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#mul",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#mul"
  },"510": {
    "doc": "5. Diffuse Lighting",
    "title": "KEYWORD NOTE",
    "content": "lightclass, lightShaderclass에서 모르는 키워드 공부 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#keyword-note"
  },"511": {
    "doc": "5. Diffuse Lighting",
    "title": "D3DCompileFromFile()",
    "content": "HLSL 셰이더 코드 파일을 컴파일하여 Direct3D에서 사용할 수 있는 바이트코드로 변환하는 함수 . HRESULT D3DCompileFromFile( LPCWSTR pFileName, const D3D_SHADER_MACRO *pDefines, ID3DInclude *pInclude, LPCSTR pEntrypoint, LPCSTR pTarget, UINT Flags1, UINT Flags2, ID3DBlob **ppCode, ID3DBlob **ppErrorMsgs ); . | pFileName: 컴파일할 셰이더 파일의 경로 (예: L”./light.vs”) | pDefines: 셰이더 매크로 정의. 사용하지 않을 경우 NULL | pInclude: include 처리기 인터페이스. 기본값을 사용하려면 NULL로 설정 | pEntrypoint: 셰이더 진입점 함수의 이름 . | 이 이름은 셰이더 파일 내의 함수 이름과 정확히 일치해야 함 | . | pTarget: 셰이더 모델을 지정 . | “vs_5_0” - Vertex Shader 5.0 | “ps_5_0” - Pixel Shader 5.0 | “gs_5_0” - Geometry Shader 5.0 | “cs_5_0” - Compute Shader 5.0 | . | Flags1, Flags2: 컴파일 옵션 플래그 | ppCode: 컴파일된 셰이더 코드를 저장할 ID3DBlob 포인터의 주소 | ppErrorMsgs: 오류 메시지를 저장할 ID3DBlob 포인터의 주소 | . // 컴파일 : 버텍스 쉐이더 코드 result = D3DCompileFromFile(vsFilename, NULL, NULL, \"LightVertexShader\", \"vs_5_0\", D3D10_SHADER_ENABLE_STRICTNESS, 0, &amp;vertexShaderBuffer, &amp;errorMessage); if (FAILED(result)) { // 셰이더가 컴파일 실패 시 오류 메시지에 해당 내용을 기록 if (errorMessage) { OutputShaderErrorMessage(errorMessage, hwnd, vsFilename); } else { // 오류 메시지에 아무 내용도 없다면 단순히 셰이더 파일을 찾을 수 없었던 것 MessageBox(hwnd, vsFilename, L\"Missing Shader File\", MB_OK); } return false; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#d3dcompilefromfile",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/5.%20Diffuse%20Lighting.html#d3dcompilefromfile"
  },"512": {
    "doc": "5. Going Fullscreen",
    "title": "5. Going Fullscreen",
    "content": "창을 전체 화면으로 전환하기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html"
  },"513": {
    "doc": "5. Going Fullscreen",
    "title": "Setting Up the Screen Size",
    "content": "화면 크기를 표준화하기 . // 화면 해상도 정의 #define SCREEN_WIDTH 800 #define SCREEN_HEIGHT 600 // 창 만드는 함수 매개변수 변경 hWnd = CreateWindowEx(NULL, L\"WindowClass\", L\"Our Direct3D Program\", WS_OVERLAPPEDWINDOW, 300, 300, SCREEN_WIDTH, SCREEN_HEIGHT, // set window to new resolution NULL, NULL, hInstance, NULL); // 뷰포트도 정의 값으로 변경 viewport.TopLeftX = 0; viewport.TopLeftY = 0; viewport.Width = SCREEN_WIDTH; viewport.Height = SCREEN_HEIGHT; . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html#setting-up-the-screen-size",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html#setting-up-the-screen-size"
  },"514": {
    "doc": "5. Going Fullscreen",
    "title": "Changing to Fullscreen Mode",
    "content": "Alt-Enter키로 전체 화면과 창 모드를 쉽게 전환할 수 있게 하기 . 전체 화면으로 업그레이드 하기 위한 작업 목록 . | 창에 배경을 적용하지 않도록 수정 | 백 버퍼를 특정 크기로 설정 | Alt-Enter키를 누르면 directX가 자동으로 전환되도록 설정 | CleanD3D() 함수를 수정하여 창을 닫을 때 전체 화면 모드 해제하기 | . 창에 배경 적용 지우기 . | wc.hbrBackground 주석 처리 | 배경 색상이 변경되지 않아 게임 시작 1~2초 동안 창으로 표시되지 않음 | . wc.cbSize = sizeof(WNDCLASSEX); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = WindowProc; wc.hInstance = hInstance; wc.hCursor = LoadCursor(NULL, IDC_ARROW); //wc.hbrBackground = (HBRUSH)COLOR_WINDOW; wc.lpszClassName = L\"WindowClass1\"; . 백 버퍼를 특정 크기로 설정 . | 스왑체인 구조체에 백 버퍼 크기 설정 추가 | . scd.BufferCount = 1; // 백 버퍼 1개 scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; //32비트 색상 사용 scd.BufferDesc.Width = SCREEN_WIDTH; // 백 버퍼 너비 설정 추가 scd.BufferDesc.Height = SCREEN_HEIGHT; // 백 버퍼 높이 설정 추가 . Alt-Enter 키 설정 . | 스왑체인 구조체에 플래그 설정 | . scd.Windowed = TRUE; // 창모드, 전체 화면 모드 선택 scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; // 전체 화면 전환 허용 . 창 닫을 때 전체 화면 끄기 . | direct3D는 전체 화면 모드에서 종료할 수 없음 (내부 특정 스레드 문제) | 따라서 제대로 종료하려면 창 모드인지 확인하여야 함 (SetFullscreenState() 함수 사용) | . // direct3D와 COM 객체 정리 함수 void CleanD3D(void) { swapchain-&gt;SetFullscreenState(FALSE, NULL); // 창 모드로 전환 // 기존 COM 객체를 닫고 해제하기 swapchain-&gt;Release(); backbuffer-&gt;Release(); dev-&gt;Release(); devcon-&gt;Release(); } . | swapchain-&gt;SetFullscreenState(FALSE, NULL) . | 첫 번째 매개변수 : 전환하려는 상태. FALSE - 창모드, TRUE - 전체 화면 | 두 번째 매개변수 : 사용할 비디오 어댑터를 선택하는 기능 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html#changing-to-fullscreen-mode",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/5.%20Going%20Fullscreen.html#changing-to-fullscreen-mode"
  },"515": {
    "doc": "5. Post Process Volume",
    "title": "5. Post Process Volume",
    "content": "시각적 효과 후처리 도구. 장면의 전체적인 모습과 분위기를 바꾸는데 사용된다 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html"
  },"516": {
    "doc": "5. Post Process Volume",
    "title": "특징",
    "content": ". | 범위 기반 효과 적용 . | 특정 볼륨 내부에서만 효과가 적용되도록 설정 가능 | 무한 범위로 설정하면 전체 레벨에 적용 가능 | . | 다양한 시각 효과 . | 색조, 대비, 채도 조정 | 블룸(빛 번짐 효과), 렌즈 플레어 | 모션 블러, 피사계 심도(DOF) | 안개, 색상 분위기(Grading) | 글로벌 일루미네이션 강도 조정 | . | 블렌딩 기능 . | 여러 볼륨이 겹칠 경우 효과를 부드럽게 혼합 | 우선순위 설정으로 어떤 효과가 먼저 적용될지 결정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#특징"
  },"517": {
    "doc": "5. Post Process Volume",
    "title": "동작 방식",
    "content": ". | 카메라 위치를 기준으로 활성화된 Post Process Volume 결정 . | 매 프레임마다 카메라 위치 검사 | 카메라가 볼륨 경계 내에 있거나 “무한 범위(Unbound)”로 설정된 볼륨 선택 | . | 여러 볼륨이 겹칠 경우 . | 우선순위(Priority), 블렌드 가중치(Blend Weight)에 따라 효과 혼합 | . | . | Intro to Post-processing | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#동작-방식"
  },"518": {
    "doc": "5. Post Process Volume",
    "title": "주요 설정 항목",
    "content": "| 카테고리 | 설정 항목 | 기본값 | 설명 | . | 기본 설정 | bEnabled | true | 볼륨 효과 활성화/비활성화 | . |   | bUnbound | false | true 시 전체 월드에 효과 적용 (볼륨 경계 무시) | . |   | Priority | 0 | 효과 적용 우선순위 (높을수록 우선 적용) | . | 블렌딩 | Blend Radius | 100 | 볼륨 경계에서 효과가 부드럽게 혼합되는 범위 | . |   | Blend Weight | 1.0 | 효과 강도 (0.0 ~ 1.0) | . | 렌즈 효과 | Vignette Intensity | 0.0 | 화면 모서리 어둡게 처리 (비네팅 효과) | . |   | Depth of Field (DOF) | - | 피사계 심도 설정 (Focal Distance, Aperture 등 하위 옵션 존재) | . | Bloom | Intensity | 0.675 | 빛 번짐 효과 강도 | . | 색조/대비 | Color Contrast | 1.0 | 색상 대비 조정 (1.0 = 기본값) | . |   | Color Saturation | 1.0 | 채도 조정 (0.0 = 흑백) | . |   | Color Gamma | 1.0 | 감마 보정 | . |   | White Balance | 6500K | 화이트 밸런스 (색온도 조절) | . | 글로벌 일루미네이션 | Global Illumination Intensity | 1.0 | Lumen 또는 Lightmass GI 강도 조정 | . | 안개/대기 | Fog Density | 0.02 | 볼륨트릭 안개 밀도 | . |   | Atmospheric Fog Intensity | 1.0 | 대기 효과 강도 | . | 모션 효과 | Motion Blur Amount | 0.5 | 모션 블러 강도 (0.0 = 비활성화) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%EC%A3%BC%EC%9A%94-%EC%84%A4%EC%A0%95-%ED%95%AD%EB%AA%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#주요-설정-항목"
  },"519": {
    "doc": "5. Zero Matrix",
    "title": "5. Zero Matrix",
    "content": "영행렬은 모든 성분이 0인 행렬 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html"
  },"520": {
    "doc": "5. Zero Matrix",
    "title": "정의",
    "content": "m × n 영행렬 O는 모든 i (1 ≤ i ≤ m)와 j (1 ≤ j ≤ n)에 대해 다음을 만족한다 . \\[O_{ij} = 0\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#정의"
  },"521": {
    "doc": "5. Zero Matrix",
    "title": "주요 성질",
    "content": ". | 행렬 덧셈의 항등원 : 어떤 행렬 A에 대해 A + O = A와 O + A = A가 성립 | . \\[A + O = O + A = A\\] . | 행렬 뺄셈 : 같은 크기의 행렬 A에 대해 A - A = O 와 A - O = A 성립 | . \\[A - A = O\\] \\[A − O = A\\] . | 스칼라 곱 : 어떤 스칼라 k에 대해 kO = O 이다 | . \\[kO = O\\] . | 행렬 곱 : A가 m × n 행렬일 때 | . \\[A_{m \\times n}O_{n \\times p} = O_{m \\times p}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#%EC%A3%BC%EC%9A%94-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#주요-성질"
  },"522": {
    "doc": "5. Zero Matrix",
    "title": "opposite matrix &amp; Zero matrix",
    "content": "역행렬과 영행렬 . | 역행렬 : 임의의 행렬 K에 -1을 곱한 행렬 | . \\[-K = (-1)K\\] . | 행렬과 행렬의 역행렬을 더하면 같은 차원의 영행렬이 됨 | . \\[K + (-K) = O_{m×n}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#opposite-matrix--zero-matrix",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#opposite-matrix--zero-matrix"
  },"523": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "6. 3D Model Scaling, Rotation, Translation",
    "content": "3D 모델 렌더링 및 크기 조정(Scale), 회전(Rotation), 이동(Translation) . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html"
  },"524": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "LoadModel",
    "content": "모델 데이터 파싱해서 데이터 읽기 . | 모델 구조체 | . struct ModelType { float x, y, z; float tu, tv; // texture uv float nx, ny, nz; // normal x,y,z; }; . | 모델 데이터 (파싱할 데이터) | . Vertex Count: 36 Data: -1.0 1.0 -1.0 0.0 0.0 0.0 0.0 -1.0 1.0 1.0 -1.0 1.0 0.0 0.0 0.0 -1.0 -1.0 -1.0 -1.0 0.0 1.0 0.0 0.0 -1.0 -1.0 -1.0 -1.0 0.0 1.0 0.0 0.0 -1.0 1.0 1.0 -1.0 1.0 0.0 0.0 0.0 -1.0 1.0 -1.0 -1.0 1.0 1.0 0.0 0.0 -1.0 1.0 1.0 -1.0 0.0 0.0 1.0 0.0 0.0 1.0 1.0 1.0 1.0 0.0 1.0 0.0 0.0 1.0 -1.0 -1.0 0.0 1.0 1.0 0.0 0.0 1.0 -1.0 -1.0 0.0 1.0 1.0 0.0 0.0 1.0 1.0 1.0 1.0 0.0 1.0 0.0 0.0 1.0 -1.0 1.0 1.0 1.0 1.0 0.0 0.0 1.0 1.0 1.0 0.0 0.0 0.0 0.0 1.0 -1.0 1.0 1.0 1.0 0.0 0.0 0.0 1.0 1.0 -1.0 1.0 0.0 1.0 0.0 0.0 1.0 1.0 -1.0 1.0 0.0 1.0 0.0 0.0 1.0 -1.0 1.0 1.0 1.0 0.0 0.0 0.0 1.0 -1.0 -1.0 1.0 1.0 1.0 0.0 0.0 1.0 -1.0 1.0 1.0 0.0 0.0 -1.0 0.0 0.0 -1.0 1.0 -1.0 1.0 0.0 -1.0 0.0 0.0 -1.0 -1.0 1.0 0.0 1.0 -1.0 0.0 0.0 -1.0 -1.0 1.0 0.0 1.0 -1.0 0.0 0.0 -1.0 1.0 -1.0 1.0 0.0 -1.0 0.0 0.0 -1.0 -1.0 -1.0 1.0 1.0 -1.0 0.0 0.0 -1.0 1.0 1.0 0.0 0.0 0.0 1.0 0.0 1.0 1.0 1.0 1.0 0.0 0.0 1.0 0.0 -1.0 1.0 -1.0 0.0 1.0 0.0 1.0 0.0 -1.0 1.0 -1.0 0.0 1.0 0.0 1.0 0.0 1.0 1.0 1.0 1.0 0.0 0.0 1.0 0.0 1.0 1.0 -1.0 1.0 1.0 0.0 1.0 0.0 -1.0 -1.0 -1.0 0.0 0.0 0.0 -1.0 0.0 1.0 -1.0 -1.0 1.0 0.0 0.0 -1.0 0.0 -1.0 -1.0 1.0 0.0 1.0 0.0 -1.0 0.0 -1.0 -1.0 1.0 0.0 1.0 0.0 -1.0 0.0 1.0 -1.0 -1.0 1.0 0.0 0.0 -1.0 0.0 1.0 -1.0 1.0 1.0 1.0 0.0 -1.0 0.0 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#loadmodel",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#loadmodel"
  },"525": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "ifstream",
    "content": "‘input file stream’의 약자로, C++ 표준 라이브러리( 헤더)에 포함된 클래스 . | 파일로부터 데이터를 읽어올 때 사용 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#ifstream",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#ifstream"
  },"526": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "read file",
    "content": ". | ifstream fin;: ifstream 타입의 객체 fin을 선언 | fin.open(filename);: filename에 해당하는 파일을 열어 fin 객체와 연결 | if (fin.fail()): 파일 열기에 실패했는지 확인 | fin &gt;&gt; variable; 또는 fin.get(char_var);: 파일에서 데이터를 읽음 . | &gt;&gt; 연산자는 공백(스페이스, 탭, 개행)을 무시하고 데이터를 읽음 | get() 함수는 한 글자씩(공백 포함) 읽음 | . | fin.close();: 파일 사용이 끝나면 닫음 | . bool ModelClass::LoadModel(char* filename) { ifstream fin; char input; int i; //모델 파일 열기 fin.open(filename); // 파일 열기 실패시 exit if (fin.fail()) { return false; } // 정점 개수의 값까지 읽기 fin.get(input); while (input != ':') { fin.get(input); } // 버텍스 카운트 읽기 fin &gt;&gt; m_vertexCount; // 인덱스 개수를 정점 개수와 동일하게 설정 m_indexCount = m_vertexCount; // 읽은 버텍스 카운트를 사용해 모델 생성 m_model = new ModelType[m_vertexCount]; // 데이터의 시작 부분까지 읽기 fin.get(input); while (input != ':') { fin.get(input); } fin.get(input); fin.get(input); for (i = 0; i &lt; m_vertexCount; i++) { fin &gt;&gt; m_model[i].x &gt;&gt; m_model[i].y &gt;&gt; m_model[i].z; fin &gt;&gt; m_model[i].tu &gt;&gt; m_model[i].tv; fin &gt;&gt; m_model[i].nx &gt;&gt; m_model[i].ny &gt;&gt; m_model[i].nz; } // Close the model file. fin.close(); return true; } . | fin.get(input) . | 함수는 파일 스트림에서 단 한 개의 문자(character)를 읽어서 변수 input에 저장 | . | &gt;&gt; 연산자 . | 스페이스, 탭, 개행 문자와 같은 공백 문자는 패스함 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#read-file",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#read-file"
  },"527": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "Scaling, Rotation, Translation",
    "content": "일반적으로 스케일(Scale) → 회전(Rotation) → 이동(Translation) 순서로 변환 행렬을 적용한다 . XMMATRIX rotateMatrix, translateMatrix, scaleMatrix, srMatrix; scaleMatrix = XMMatrixScaling(0.5f, 0.5f, 0.5f); // 크기 조정 행렬을 만들기 rotateMatrix = XMMatrixRotationY(rotation); // 회전 행렬을 만들기 translateMatrix = XMMatrixTranslation(2.0f, 0.0f, 0.0f); // 이동 ​​행렬을 만들기 // 크기 조정, 회전, 이동 행렬을 곱하여 최종적인 월드 변환 행렬을 만들기 srMatrix = XMMatrixMultiply(scaleMatrix, rotateMatrix); worldMatrix = XMMatrixMultiply(srMatrix, translateMatrix); // 모델 정점 및 인덱스 버퍼를 그래픽 파이프라인에 배치하여 그리기를 준비 m_Model-&gt;Render(m_Direct3D-&gt;GetDeviceContext()); // 조명 셰이더를 사용하여 모델을 렌더링 result = m_LightShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Model-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_Model-&gt;GetTexture(), m_Light-&gt;GetDirection(), m_Light-&gt;GetDiffuseColor()); . ❓ 왜 SRT(Scale → Rotate → Translate) 순서인가? . 객체 자신의 로컬 좌표계(Local Space)에서 변환을 시작하여 최종적으로 월드 좌표계(World Space)에 배치하는 자연스러운 과정이다 . | 스케일: 먼저 객체 고유의 크기를 정함 (로컬 공간) | 회전: 그 다음 객체 회전 방향을 정함 (로컬 공간) | 이동: 마지막으로 월드 공간의 최종 위치로 옮김 (월드 공간) | . 이동을 먼저 한 후 회전시키면, 객체는 제자리에서 회전하는 것이 아니라 공전을 하게됨 . | 예: 객체가 월드 공간의 원점을 기준으로 회전하게 되어 마치 달이 지구 주위를 도는 것처럼 움직임 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#scaling-rotation-translation",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#scaling-rotation-translation"
  },"528": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "DirectX Math 주요 함수 및 연산",
    "content": "DirectX Math에서 자주 사용되는 주요 함수 및 연산을 기능별로 정리한 표 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#directx-math-%EC%A3%BC%EC%9A%94-%ED%95%A8%EC%88%98-%EB%B0%8F-%EC%97%B0%EC%82%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#directx-math-주요-함수-및-연산"
  },"529": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "Vector",
    "content": "벡터는 크기와 방향을 가지는 수학적 객체로, 3D 공간에서의 위치, 방향, 속도 등을 표현하는 데 사용 . | 생성 및 초기화 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMVectorSet | 4개의 실수 (x, y, z, w) | XMVECTOR | 4개의 실수 값으로 벡터를 생성 | XMVECTOR v = XMVectorSet(1.0f, 2.0f, 3.0f, 0.0f); | . | XMLoadFloat3 | XMFLOAT3 구조체 포인터 | XMVECTOR | XMFLOAT3 구조체로부터 벡터를 로드 | XMFLOAT3 p = {1.0f, 2.0f, 3.0f}; XMVECTOR v = XMLoadFloat3(&amp;p); | . | 연산 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMVectorAdd | XMVECTOR, XMVECTOR | XMVECTOR | 두 벡터의 각 성분을 더함 | XMVECTOR result = XMVectorAdd(v1, v2); | . | XMVectorSubtract | XMVECTOR, XMVECTOR | XMVECTOR | 첫 번째 벡터에서 두 번째 벡터의 각 성분을 뺌 | XMVECTOR result = XMVectorSubtract(v1, v2); | . | XMVectorScale | XMVECTOR, float | XMVECTOR | 벡터의 각 성분에 스칼라 값을 곱함 | XMVECTOR result = XMVectorScale(v, 2.0f); | . | XMVector3Dot | XMVECTOR, XMVECTOR | XMVECTOR | 두 3D 벡터의 내적을 계산. 결과는 벡터의 모든 성분에 복제 | XMVECTOR dotProduct = XMVector3Dot(v1, v2); | . | XMVector3Cross | XMVECTOR, XMVECTOR | XMVECTOR | 두 3D 벡터의 외적을 계산하여 두 벡터에 수직인 벡터를 구함 | XMVECTOR crossProduct = XMVector3Cross(v1, v2); | . | 길이 및 정규화 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMVector3Length | XMVECTOR | XMVECTOR | 3D 벡터의 길이를 계산. 결과는 벡터의 모든 성분에 복제. | XMVECTOR length = XMVector3Length(v); | . | XMVector3Normalize | XMVECTOR | XMVECTOR | 3D 벡터를 정규화하여 길이가 1인 단위 벡터로 만듦 | XMVECTOR normalizedV = XMVector3Normalize(v); | . | 변환 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMVector3Transform | XMVECTOR, XMMATRIX | XMVECTOR | 3D 벡터를 주어진 행렬로 변환. (위치 벡터 변환에 사용) | XMVECTOR transformedV = XMVector3Transform(v, m); | . | XMVector3TransformNormal | XMVECTOR, XMMATRIX | XMVECTOR | 3D 법선 벡터를 주어진 행렬로 변환 (법선 벡터 변환에 사용) | XMVECTOR transformedNormal = XMVector3TransformNormal(normal, m); | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#vector",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#vector"
  },"530": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "Matrix",
    "content": "행렬은 3D 객체의 변환(이동, 회전, 크기 조절)을 표현하고 계산하는 데 사용되는 핵심적인 도구 . | 생성 및 초기화 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMMatrixIdentity | 없음 | XMMATRIX | 단위 행렬을 생성합니다. (모든 변환의 기본값) | XMMATRIX I = XMMatrixIdentity(); | . | XMMatrixTranslation | float x, float y, float z | XMMATRIX | 주어진 x, y, z 값으로 이동 행렬을 생성 | XMMATRIX T = XMMatrixTranslation(1.0f, 2.0f, 3.0f); | . | XMMatrixRotationX | float Angle (라디안) | XMMATRIX | X축을 기준으로 주어진 각도만큼 회전하는 행렬을 생성 | XMMATRIX R = XMMatrixRotationX(XM_PIDIV2); | . | XMMatrixScaling | float x, float y, float z | XMMATRIX | 주어진 x, y, z 비율로 크기를 조절하는 행렬을 생성 | XMMATRIX S = XMMatrixScaling(2.0f, 2.0f, 2.0f); | . | 연산 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMMatrixMultiply | XMMATRIX, XMMATRIX | XMMATRIX | 두 행렬을 곱함. 변환을 결합하는 데 사용 | XMMATRIX M = XMMatrixMultiply(S, R); XMMATRIX world = XMMatrixMultiply(M, T); | . | XMMatrixTranspose | XMMATRIX | XMMATRIX | 행렬의 전치 행렬을 구함. | XMMATRIX T = XMMatrixTranspose(M); | . | XMMatrixInverse | XMVECTOR* (determinant), XMMATRIX | XMMATRIX | 행렬의 역행렬을 구함. 변환을 되돌리는 데 사용 | XMVECTOR det; XMMATRIX invM = XMMatrixInverse(&amp;det, M); | . | 뷰 및 투영 행렬 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMMatrixLookAtLH | XMVECTOR (Eye), XMVECTOR (At), XMVECTOR (Up) | XMMATRIX | 카메라의 위치, 바라보는 지점, 상향 벡터를 기반으로 뷰 행렬을 생성 (왼손 좌표계) | XMMATRIX V = XMMatrixLookAtLH(eye, at, up); | . | XMMatrixPerspectiveFovLH | float FovAngleY (라디안), float AspectRatio, float NearZ, float FarZ | XMMATRIX | 원근 투영 행렬을 생성. 3D 장면을 2D 화면에 투영하는 데 사용 (왼손 좌표계) | XMMATRIX P = XMMatrixPerspectiveFovLH(XM_PIDIV4, aspectRatio, 1.0f, 1000.0f); | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#matrix",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#matrix"
  },"531": {
    "doc": "6. 3D Model Scaling, Rotation, Translation",
    "title": "Quaternion",
    "content": "쿼터니언은 3D 회전을 표현하는 데 사용되는 4차원 복소수이다. 짐벌락(Gimbal Lock) 현상을 피할 수 있어 부드러운 회전 표현에 유리하다 . | 생성 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMQuaternionRotationAxis | XMVECTOR (Axis), float Angle (라디안) | XMVECTOR | 주어진 축을 기준으로 특정 각도만큼 회전하는 쿼터니언을 생성 | XMVECTOR q = XMQuaternionRotationAxis(axis, angle); | . | 연산 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMQuaternionMultiply | XMVECTOR, XMVECTOR | XMVECTOR | 두 쿼터니언을 곱하여 회전을 결합 | XMVECTOR q_combined = XMQuaternionMultiply(q1, q2); | . | 보간 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMQuaternionSlerp | XMVECTOR (Q0), XMVECTOR (Q1), float t | XMVECTOR | 두 쿼터니언 사이를 구면 선형 보간하여 부드러운 회전 애니메이션을 만듦 | XMVECTOR q_interp = XMQuaternionSlerp(q_start, q_end, 0.5f); | . | 변환 | . | 함수/연산 | 입력 | 출력 | 정의와 목적 | 예제 코드 (DirectX Math) | . | XMMatrixRotationQuaternion | XMVECTOR | XMMATRIX | 쿼터니언을 회전 행렬로 변환 | XMMATRIX R = XMMatrixRotationQuaternion(q); | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#quaternion",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/6.%203D%20Model%20Rendering.html#quaternion"
  },"532": {
    "doc": "6. Drawing a Triangle",
    "title": "6. Drawing a Triangle",
    "content": "삼각형 그리기 과정 . | GPU에게 기하학을 렌더링하는 방법을 알려주기 | 삼각형의 세 꼭짓점을 생성하기 | 이 꼭짓점을 비디오 메모리에 저장하기 | GPU에게 이 꼭짓점을 읽는 방법을 알려주기 | 삼각형 렌더링하기 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html"
  },"533": {
    "doc": "6. Drawing a Triangle",
    "title": "Using Shaders",
    "content": "렌더링 과정은 렌더링 파이프라인에 의해 제어된다 . | 하지만 파이프라인은 무엇을 해야할지 자동으로 알지 못한다 | 셰이더 프로그래밍을 통해 파이프라인을 제어할 수 있다 | . 셰이더에는 여러 유형이 있고, 렌더링 중 여러 번 실행된다 . | 정점 셰이더 : 렌더링 되는 각 정점에 대해 한번씩 실행되는 프로그램 | 픽셀 셰이더 : 그려지는 각 픽셀에 대해 실행되는 프로그램 | . 셰이더 로딩하기 . | .shader 파일에서 두 개의 셰이더를 로드하고 컴파일 | 두 개의 셰이더를 셰이더 객체로 캡슐화 | 두 개의 셰이더를 모두 활성 셰이더로 설정하기 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#using-shaders",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#using-shaders"
  },"534": {
    "doc": "6. Drawing a Triangle",
    "title": ".shader 파일에서 셰이더 로드",
    "content": "D3DX11CompileFromFile() 함수를 통해 셰이더를 로드하고 컴파일 한다 . HRESULT D3DX11CompileFromFile( LPCTSTR pSrcFile, // 코드가 포함된 파일 D3D10_SHADER_MACRO *pDefines, // 고급 설정 LPD3D10INCLUDE pInclude, // 고급 설정 LPCSTR pFunctionName, // 셰이더의 시작 함수 이름 LPCSTR pProfile, // 셰이더 프로파일 UINT Flags1, // 고급 설정 UINT Flags2, // 고급 설정 ID3DX11ThreadPump *pPump, // 고급 설정 ID3D10Blob **ppShader, // 컴파일된 셰이더를 포함하는 블롭 ID3D10Blob **ppErrorMsgs, // 고급 설정 HRESULT *pHResult); // 고급 설정 . | blob : Binary Large Object의 약자로, 텍스트 또는 이진 데이터를 포함하는 큰 객체를 의미함 . | 주로 DB나 파일 시스템에서 사용함 | . | LPCSTSTR pSrcFile . | 컴파일 되지 않은 셰이더 코드가 포함된 파일의 이름 | . | LPCSTR pFunctionName . | 셰이더의 이름 | 셰이더는 특정 함수로 시작하며 이 함수가 셰이더의 이름으로 간주됨 | . | LPCSTR pProfile . | 컴파일러에게 컴파일할 셰이더의 유형과 셰이더 버전을 알려주는 코드 | 예 : vs_4_0 . | v : 정점 (p : 픽셸) | s : 셰이더 | _4_4 : HLSL 버전 4.0 | . | . | ID3D10Blob **ppShader . | 블롭 객체에 대한 포인터 | 해당 객체에는 셰이더의 컴파일된 코드가 저장됨 | 데이터 버퍼를 저장하는 COM 객체이다 | GetBufferPointer()와 GetBufferSize() 함수를 사용하여 내용에 접근할 수 있다 | . | . void InitPipeline() { // 셰이더를 로드하고 컴파일 ID3DBlob* VS = nullptr, * PS = nullptr; ID3DBlob* errorBlob = nullptr; // 버텍스 쉐이더 컴파일 HRESULT hr = D3DCompileFromFile( L\"shaders.shader\", nullptr, nullptr, \"VShader\", // 버텍스 쉐이더 \"vs_4_0\", D3DCOMPILE_ENABLE_STRICTNESS, 0, &amp;VS, &amp;errorBlob ); // 픽셀 쉐이더 컴파일 hr = D3DCompileFromFile( L\"shaders.shader\", nullptr, nullptr, \"PShader\", // 픽셀 셰이더 \"ps_4_0\", D3DCOMPILE_ENABLE_STRICTNESS, 0, &amp;PS, &amp;errorBlob ); if (errorBlob) { OutputDebugStringA((char*)errorBlob-&gt;GetBufferPointer()); errorBlob-&gt;Release(); } } . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#shader-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%A1%9C%EB%93%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#shader-파일에서-셰이더-로드"
  },"535": {
    "doc": "6. Drawing a Triangle",
    "title": "셰이더를 셰이더 객체로 캡슐화",
    "content": ". | 각 셰이더는 자체 COM 객체에 저장된다 . | ID3D11_____Shader | . | . // 쉐이더 전역 선언 ID3D11VertexShader* pVS; // 버텍스 셰이더 ID3D11PixelShader* pPS; // 픽셀 셰이더 . void InitPipeline() { // 셰이더를 로드하고 컴파일 // 버텍스 쉐이더 컴파일 // 픽셀 쉐이더 컴파일 // ... // 셰이더 객체로 캡슐화 dev-&gt;CreateVertexShader(VS-&gt;GetBufferPointer(), VS-&gt;GetBufferSize(), NULL, &amp;pVS); dev-&gt;CreatePixelShader(PS-&gt;GetBufferPointer(), PS-&gt;GetBufferSize(), NULL, &amp;pPS); } . | 셰이더를 객체로 캡슐화 하기 | dev-&gt;Create_____Shader() 함수 사용 . | 첫 번째 매개변수 : 컴파일된 데이터의 주소 | 두 번째 매개변수 : 파일 데이터의 크기 | 세 번째 매개변수 : 고급 설정이므로 나중에 다루기 | 네 번째 매개변수 : 셰이더 객체의 주소 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#%EC%85%B0%EC%9D%B4%EB%8D%94%EB%A5%BC-%EC%85%B0%EC%9D%B4%EB%8D%94-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EC%BA%A1%EC%8A%90%ED%99%94",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#셰이더를-셰이더-객체로-캡슐화"
  },"536": {
    "doc": "6. Drawing a Triangle",
    "title": "셰이더를 활성 셰이더로 설정하기",
    "content": "void InitPipeline() { // 셰이더를 로드하고 컴파일 // 버텍스 쉐이더 컴파일 // 픽셀 쉐이더 컴파일 //... // 셰이더 객체로 캡슐화 devcon-&gt;VSSetShader(pVS, 0, 0); devcon-&gt;PSSetShader(pPS, 0, 0); } . | devcon-&gt;___SetShader() 함수 사용 . | 첫 번째 매개변수 : 설정할 셰이더 객체의 주소 | 두, 세번째 매개변수 : 고급 설정이므로 나중에 다루기 | . | . 위 과정을 통해 GPU가 렌더링을 준비하도록 한다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#%EC%85%B0%EC%9D%B4%EB%8D%94%EB%A5%BC-%ED%99%9C%EC%84%B1-%EC%85%B0%EC%9D%B4%EB%8D%94%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#셰이더를-활성-셰이더로-설정하기"
  },"537": {
    "doc": "6. Drawing a Triangle",
    "title": "Vertex Buffers",
    "content": "Direct3D에서는 입력 레이아웃 (input layout) 이라는 개념을 사용한다 . | 입력 레이아웃 : 버텍스가 어떤 식으로 메모리에 저장돼 있는지를 기술하는 데이터 형식 정의서 | . 버텍스 하나는 일반적으로 구조체로 정의되며, 구조체 안에는 모델을 렌더링하는 데 필요한 모든 정보가 들어 있다 . | 입력 레이아웃을 이용하면 사용할 필드만 추려서 데이터를 작게 만들어 GPU로 보내도록 최적화할 수 있다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#vertex-buffers",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#vertex-buffers"
  },"538": {
    "doc": "6. Drawing a Triangle",
    "title": "Creating Vertices",
    "content": "정점 구조체를 사용하여 원하는 데이터를 저장하기 . struct VERTEX { FLOAT X, Y, Z; // 위치 D3DXCOLOR Color; // 색상 }; VERTEX OurVertex = {0.0f, 0.5f, 0.0f, D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f)}; . | 정점 배열 만들기 | . VERTEX OurVertices[] = { {0.0f, 0.5f, 0.0f, D3DXCOLOR(1.0f, 0.0f, 0.0f, 1.0f)}, {0.45f, -0.5, 0.0f, D3DXCOLOR(0.0f, 1.0f, 0.0f, 1.0f)}, {-0.45f, -0.5f, 0.0f, D3DXCOLOR(0.0f, 0.0f, 1.0f, 1.0f)} }; . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#creating-vertices",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#creating-vertices"
  },"539": {
    "doc": "6. Drawing a Triangle",
    "title": "Creating a Vertex Buffer",
    "content": "비디오 메모리에 접근할 수 있도록 direct3D는 시스템 메모리와 비디오 메모리 모두에 버퍼를 유지할 수 있는 COM 객체를 제공한다 . | 처음엔 버퍼의 데이터가 시스템 메모리에 저장된다 | 렌더링 시 해당 버퍼가 필요하면 direct3D가 자동으로 비디오 메모리에 데이터를 복샇나다 | 비디오 카드의 메모리가 부족해지면 direct3D는 우선순위가 낮은 버퍼를 삭제하여 리소스를 확보한다 | . ❓ direct3D가 비디오 메모리 관리를 대신 해주는 이유? . | 비디오 카드와 운영 체제 버전에 따라 비디오 메모리 접근 방식이 다르기 때문 . | GPU : GPU 마다 VRAM을 보는 방식이 제각각 | Windows : OS 버전이 달라질 때마다 메모리 관리 규칙이 달라짐 | → Direct3D가 표준화된 가상 VRAM을 제공하여 애플리케이션은 CreateBuffer/Draw 같은 고수준 호출만 신경 쓰면 됨 | . | . | CreateBuffer() 함수로 ID3D11Buffer COM 객체 생성하기 | . ID3D11Buffer* pVBuffer; D3D11_BUFFER_DESC bd; ZeroMemory(&amp;bd, sizeof(bd)); bd.Usage = D3D11_USAGE_DYNAMIC; // CPU와 GPU가 쓰기 액세스 가능 bd.ByteWidth = sizeof(VERTEX) * 3; // 크기는 VERTEX 구조체의 3배 bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; // 버텍스 버퍼로 사용 bd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; // CPU가 버퍼에 쓰기 허용 dev-&gt;CreateBuffer(&amp;bd, NULL, &amp;pVBuffer); // 버퍼 생성 . | D3D11_BUFFER_DESC bd . | 버퍼의 속성을 담고 있는 구조체 | . | bd.Usage = D3D11_USAGE_DYNAMIC . | 버퍼에 어떻게 액세스할 것인지 설정 | . | . | flag | CPU Access | GPU Access | . | D3D11_USAGE_DEFAULT | None | Read / Write | . | DXD11_USAGE_IMMUTABLE | None | Read Only | . | DXD11_USAGE_DYNAMIC | Write Only | Read Only | . | DXD11_USAGE_STAGING | Read / Write | Read / Write | . | bd.ByteWidth . | 생성될 버퍼의 크기 | 우리가 버퍼에 넣을 정점 배열의 크기와 같음 | . | bd.BindFlags . | direct3D에 어떤 종류의 버퍼를 만들것인지 알림 | . | bd.CPUAccessFlags . | direct3D에 CPU 접근 방식 알림 | 시스템 메모리에서 버퍼로 데이터를 복사하려고 하므로 D3D11_CPU_ACCESS_WRITE 사용함 | . | dev-&gt;CreateBuffer(&amp;bd, NULL, &amp;pVBuffer) . | 버퍼 생성 함수 | 첫 번째 매개변수 : 버퍼 속성 구조체의 주소 | 두 번째 매개변수 : 버퍼 생성 시 특정 데이터로 초기화하는데 사용 | 세 번째 매배견수 : 버퍼 객체의 주소 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#creating-a-vertex-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#creating-a-vertex-buffer"
  },"540": {
    "doc": "6. Drawing a Triangle",
    "title": "Filling the Vertex Buffer",
    "content": "direct3D는 버퍼에 대한 직접적인 CPU 액세스를 허용하지 않는다 . | CPU가 데이터를 쓸 때 GPU가 사용 중인 메모리를 건드리지 않도록 데이터 경쟁을 방지하기 위함 | 따라서 direct3D는 Map/Unmap을 통해 메모리 접근을 중재한다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#filling-the-vertex-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#filling-the-vertex-buffer"
  },"541": {
    "doc": "6. Drawing a Triangle",
    "title": "Map/Unmap 작동 과정",
    "content": ". | Map (매핑) . | CPU가 GPU의 리소스(예: 버퍼)에 접근할 수 있도록 임시 권한을 얻는 과정 . | ID3D11DeviceContext::Map() 함수 호출 | . | GPU가 해당 리소스를 사용 중인 경우, 명령 큐가 비워질 때까지 대기 | 명령 큐가 비워지면 CPU가 접근할 수 있는 포인터를 반환 (이 포인터로 버퍼 읽기/쓰기 가능) . | 이때, GPU는 해당 리소스에 대한 접근을 잠시 중지함 | . | . | 데이터 수정 . | 반환된 포인터로 CPU가 직접 데이터를 수정합니다 (예: 정점 데이터 업데이트, 상수 버퍼 값 변경) | . | Unmap (언매핑) . | ID3D11DeviceContext::Unmap() 함수 호출 | CPU의 수정 사항이 리소스에 반영되고, GPU가 다시 해당 리소스를 사용할 수 있게됨 | 필요에 따라 DMA(Direct Memory Access)를 통해 데이터가 GPU 메모리로 복사됨 | . | . 해당 과정을 통해 CPU와 GPU 간의 안전한 데이터 교환이 가능하다 . 핵심 . | Map : CPU가 수정 가능한 메모리 블록(원본 또는 임시)을 확보하고, GPU가 그 블록을 잠시 건드리지 못하도록 예약함 | Unmap : CPU 수정이 끝났음을 알리고, 필요 시 DMA 복사 후 GPU 접근을 재개 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#mapunmap-%EC%9E%91%EB%8F%99-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#mapunmap-작동-과정"
  },"542": {
    "doc": "6. Drawing a Triangle",
    "title": "버퍼의 메모리 위치",
    "content": "버퍼의 실제 물리적 위치는 생성 시 지정한 D3D11_USAGE 플래그에 의해 결정됨 . | DEFAULT 버퍼 (GPU 전용 메모리) . | 위치 : 오직 비디오 메모리(VRAM)에만 존재 | CPU 접근 : 불가능 (D3D11_CPU_ACCESS_FLAG 없음) | Map/Unmap : 불가능 . | 대신 CopyResource() 또는 UpdateSubresource()로 데이터를 복사해야 함 | . | 용도 : 자주 변경되지 않는 정적 데이터 (예: 월드 지오메트리) | . | DYNAMIC 버퍼 (CPU ↔ GPU 공유) . | 위치: 시스템 메모리(RAM) + 비디오 메모리(VRAM)의 사본 . | 내부적으로 쓰기 가능한 GPU 메모리 영역이 할당됨 | Map/Unmap 시 CPU가 시스템 메모리에 쓰고, 필요 시 GPU로 복사 | . | CPU 접근: 쓰기 전용 (D3D11_CPU_ACCESS_WRITE) | Map/Unmap: 가능 . | Map() 시 반환되는 포인터는 시스템 메모리를 가리킴 | Unmap() 후 드라이버/GPU가 필요 시 VRAM으로 복사 | . | 용도: 프레임마다 자주 업데이트되는 데이터 (예: 애니메이션 정점 데이터) | . | . 이 외에도 IMMUTABLE, STAGING 도 있음 . | IMMUTABLE : 생성 시 데이터 한 번 채우고 이후 불변, CPU 접근 불가 (텍스처 룩업 테이블 등) | STAGING : GPU ↔ CPU 복사 전용 창고. Map(READ/WRITE) 모두 허용, 바인드플래그 없음 | . D3D11_MAPPED_SUBRESOURCE ms; devcon-&gt;Map(pVBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &amp;ms); // 버퍼 매핑 memcpy(ms.pData, OurVertices, sizeof(OurVertices)); // 데이터 복사 devvcon-&gt;Unmap(pVBuffer, NULL); // 버퍼 매핑 해제 . | D3D11_MAPPED_SUBRESOURCE ms . | 버퍼 매핑 시 버퍼에 대한 정보로 채워지는 구조체 | 버퍼의 위치에 대한 포인터가 포함 | ms.pData를 통해 포인터에 접근 가능 | . | devcon-&gt;Map() . | 버퍼를 매핑하여 CPU의 접근을 허용함 | 첫 번째 매개변수 : 버퍼 객체의 주소 | 두 번째 매개변수 : 고급 설정. 나중에 살펴보기 | 세 번째 매개변수 : 매핑되는 동안 CPU의 버퍼 접근을 제어할 수 있는 플래그 집합 | . | . | 플래그 | 설명 | . | D3D11_MAP_READ | 버퍼는 CPU에서만 읽음 | . | DXD11_MAP_WRITE | 버퍼는 CPU에서만 쓸 수 있음 | . | DXD11_MAP_READ_WRITE | 버퍼는 CPU에 의해 읽혀지고 쓰여질 수 있음 | . | DXD11_MAP_WRITE_DISCARD | 버퍼의 이전 내용은 지워지고, 쓰기를 위해 새로운 버퍼가 열림 | . | DXD11_MAP_WRITE_NO_OVERWRITE | GPU가 파트를 사용 중일 때에도 버퍼에 더 많은 데이터를 추가할 수 있는 고급 플래그. 단, GPU가 사용 중인 파트를 사용해서는 안 됨 | . | 네 번째 매개변수 : GPU의 버퍼 작업을 어떻게 할지 결정하는 플래그 . | NULL 또는 D3D11_MAP_FLAG_DO_NOT_WAIT 선택 | D3D11_MAP_FLAG_DO_NOT_WAIT : GPU가 버퍼 작업을 계속 진행 중이더라도 프로그램을 계속 진행하도록 강제 | . | 다섯 번째 매개변수 : D3D11_MAPPED_SUBRESOURCE 구조체 주소 . | 해당 구조체를 채워 필요한 정보를 제공함 | . | memcpy() . | 버텍스(OurVertices)의 값을 목적지 (ms.pData)로 카피 | . | devcon-&gt;Unmap() . | 버퍼 매핑 해제 | GPU가 버퍼에 다시 접근 가능 | CPU 접근은 다시 차단됨 | . | . 정점 버퍼 생성 및 MAP/UNMAP . // 정점 버퍼 전역 선언 ID3D11Buffer* pVBuffer; // 버텍스 버퍼 struct VERTEX { float x, y, z; float Color[4]; // R, G, B, A }; void InitGraphics() { // VERTEX 구조체 사용하여 삼각형 생성 struct VERTEX OurVertices[] = { // x, y, z, Color 배열 [R, G, B, A] { 0.0f, 0.5f, 0.0f, {1.0f, 0.0f, 0.0f, 1.0f} }, { 0.45f, -0.5f, 0.0f, {0.0f, 1.0f, 0.0f, 1.0f} }, {-0.45f, -0.5f, 0.0f, {0.0f, 0.0f, 1.0f, 1.0f} } }; // 정점 버퍼 생성 D3D11_BUFFER_DESC bd; ZeroMemory(&amp;bd, sizeof(bd)); bd.Usage = D3D11_USAGE_DYNAMIC; // CPU와 GPU가 쓰기 액세스 가능 bd.ByteWidth = sizeof(VERTEX) * 3; // 크기는 VERTEX 구조체 * 3 bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; // 버텍스 버퍼로 사용 bd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; // CPU가 버퍼에 쓰기 허용 dev-&gt;CreateBuffer(&amp;bd, NULL, &amp;pVBuffer); // 버퍼 생성 // 정점을 버퍼에 복사 D3D11_MAPPED_SUBRESOURCE ms; devcon-&gt;Map(pVBuffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &amp;ms); // 버퍼 매핑 memcpy(ms.pData, OurVertices, sizeof(OurVertices)); // 데이터 복사 devcon-&gt;Unmap(pVBuffer, NULL); // 버퍼 매핑 해제 } . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#%EB%B2%84%ED%8D%BC%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9C%84%EC%B9%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#버퍼의-메모리-위치"
  },"543": {
    "doc": "6. Drawing a Triangle",
    "title": "Verifying the Input Layout",
    "content": "입력 레이아웃 확인하기 . | 입력 레이아웃 : 정점 버퍼에 저장된 데이터가 어떻게 해석되어 정점 셰이더로 전달될지 정의한다 | . 주의사항 . | 입력 레이아웃은 정점 셰이더의 입력 서명과 일치해야함 | 정점 버퍼의 구조체와 입력 레이아웃 정의가 일치해야 함 | 성능을 위해 가능한 한 적은 수의 입력 레이아웃을 사용하는 것이 좋음 | 정점 셰이더가 변경되면 해당하는 입력 레이아웃도 다시 생성해야 할 수 있음 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#verifying-the-input-layout",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#verifying-the-input-layout"
  },"544": {
    "doc": "6. Drawing a Triangle",
    "title": "Create the Input Elements",
    "content": "정점 레이아웃은 하나 이상의 입력 요소로 구성됨 . | 입력 요소 : 위치, 색상 같은 정점의 속성 중 하나 . | 입력 요소는 D3D11_INPUT_ELEMENT_DESC 구조체로 정의된다 . | . typedef struct D3D11_INPUT_ELEMENT_DESC { LPCSTR SemanticName; // 의미 이름 (예: \"POSITION\", \"NORMAL\", \"TEXCOORD\") UINT SemanticIndex; // 동일한 시맨틱이 여러 개일 때 인덱스 (예: TEXCOORD0, TEXCOORD1) DXGI_FORMAT Format; // 데이터 형식 (예: DXGI_FORMAT_R32G32B32_FLOAT) UINT InputSlot; // 정점 버퍼 슬롯 번호 (0~15) UINT AlignedByteOffset; // 정점 내에서의 바이트 오프셋 D3D11_INPUT_CLASSIFICATION InputSlotClass; // 일반적으로 D3D11_INPUT_PER_VERTEX_DATA UINT InstanceDataStepRate; // 인스턴싱 사용 시 인스턴스당 데이터 증가율 } D3D11_INPUT_ELEMENT_DESC; . | LPCSTR SemanticName . | GPU에 해당 값이 어떤 용도로 사용되는지 알려주는 문자열 | . | UINT SemanticIndex . | 같은 시맨틱을 여러개 사용할 때 혼란을 피하기 위해 다른 번호를 할당함 | 예를 들어, 두 가지 색상을 가진 정점이 있으면 두 색상 모두 COLOR 세미틱 사용 | 각각 COLOR 시맨틱 마다 다른 인덱스 부여 | . | DXGI_FORMAT Format . | 데이터 형식 | 버텍스에서 사용하는 형식과 일치해야 함 | . | UINT InputSlot . | 고급 설정이므로 나중에 다룰 예정 | . | UINT AlignedByteOffset . | 구조체 내에서 요소가 몇 번째 바이트 위치에 있는지 나타냄 | . | D3D11_INPUT_CLASSIFICATION InputSlotClass . | 요소가 어떤 용도로 사용되는지 나타냄 | . | UINT InstanceDataStepRate . | 위 InputSlotClass의 플래그에 따라 다름 | 현재 사용할 D3D11_INPUT_PER_VERTEX_DATA 플래그와 함께 사용되지 않아 0으로 설정 | . | . D3D11_INPUT_ELEMENT_DESC ied[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}, }; . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#create-the-input-elements",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#create-the-input-elements"
  },"545": {
    "doc": "6. Drawing a Triangle",
    "title": "Create the Input Layout Object",
    "content": "CreateInputLayout() 을 호출하여 정점 레이아웃 객체 생성하기 . HRESULT CreateInputLayout( D3D11_INPUT_ELEMENT_DESC *pInputElementDescs, UINT NumElements, void *pShaderBytecodeWithInputSignature, SIZE_T BytecodeLength, ID3D11InputLayout **pInputLayout); . | D3D11_INPUT_ELEMENT_DESC . | 요소 설명 배열에 대한 포인터 (예: &amp;ied) | . | UINT NumElements . | 배열에 포함된 요소 수 | . | void *pShaderBytecodeWithInputSignature . | 파이프라인의 셰이더 | 현재 버텍스 셰이더를 사용해야 하므로 VS-&gt;GetBufferPointer() 넣기 | . | SIZE_T BytecodeLength . | 셰이더 파일의 길이 VS-&gt;GetBufferSize() | . | ID3D11InputLayout **pInputLayout . | 입력 레이아웃 객체에 대한 포인터 | . | . ID3D11InputLayout *pLayout; // 입력 레이아웃 객체 전역 변수 선언 // 입력 레이아웃 구조체 설정 D3D11_INPUT_ELEMENT_DESC ied[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}, }; // 입력 레이아웃 객체 생성 dev-&gt;CreateInputLayout(ied, 2, VS-&gt;GetBufferPointer(), VS-&gt;GetBufferSize(), &amp;pLayout); // 입력 레이아웃 설정 devcon-&gt;IASetInputLayout(pLayout); . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#create-the-input-layout-object",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#create-the-input-layout-object"
  },"546": {
    "doc": "6. Drawing a Triangle",
    "title": "Drawing the Primitive",
    "content": "렌더링을 수행하기 위해 호출해야 하는 함수를 알아보자 . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#drawing-the-primitive",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#drawing-the-primitive"
  },"547": {
    "doc": "6. Drawing a Triangle",
    "title": "IASetVertexBuffers()",
    "content": "입력 조립 단계(Input Assembler Stage, IA)에 하나 이상의 정점 버퍼를 바인딩하는 함수 . void IASetVertexBuffers( UINT StartSlot, UINT NumBuffers, ID3D11Buffer **ppVertexBuffers, UINT *pStrides, UINT *pOffsets ); . | StartSlot . | 정점 버퍼를 바인딩하기 시작할 슬롯 인덱스 (0~15) | 일반적으로 0부터 시작 | . | NumBuffers . | 바인딩할 정점 버퍼의 수 (최대 16개) | . | ID3D11Buffer **ppVertexBuffers . | 바인딩할 정점 버퍼 객체의 포인터 배열 | . | UINT *pStrides . | 각 정점 버퍼의 한 정점당 크기(바이트) 배열 | UINT를 생성하고 sizeof(VERTEX)로 채운 후 해당 UINT의 주소를 여기에 입력 | . | UINT *pOffsets . | 각 정점 버퍼의 시작 오프셋(바이트) 배열 | 일반적으로 0으로 설정 | . | . UINT stride = sizeof(VERTEX); UINT offset = 0; devcon-&gt;IASetVertexBuffers(0, 1, &amp;pBuffer, &amp;stride, &amp;offset); . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#iasetvertexbuffers",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#iasetvertexbuffers"
  },"548": {
    "doc": "6. Drawing a Triangle",
    "title": "IASetPrimitiveTopology()",
    "content": "입력 조립 단계(Input Assembler Stage, IA)에 프리미티브 토폴로지(primitive topology)를 설정하는 함수 . | 정점 데이터가 어떻게 해석되어 어떤 종류의 기본 도형(프리미티브)으로 조립될지 결정 | . void IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY Topology); . | Flag | 설명 | . | D3D11_PRIMITIVE_TOPOLOGY_POINTLIST | 각 정점에 점 표시 | . | D3D11_PRIMITIVE_TOPOLOGY_LINELIST | 분리된 선 표시 | . | D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP | 연결된 선 표시 | . | D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST | 분리된 삼각형 표시 | . | D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP | 연결된 삼각형 표시 | . devcon-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#iasetprimitivetopology",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#iasetprimitivetopology"
  },"549": {
    "doc": "6. Drawing a Triangle",
    "title": "Draw()",
    "content": "바인딩된 정점 버퍼(Vertex Buffer)의 데이터를 사용하여 프리미티브(기본 도형)를 렌더링 . void Draw( UINT VertexCount, // 그려질 정점의 개수 UINT StartVertexLocation // 그려질 첫 번째 정점 ); . | UINT VertexCount . | 렌더링에 사용할 총 정점(vertex) 수 | 현재 설정된 프리미티브 토폴로지에 따라 실제 그려지는 도형 수가 결정 | . | UINT StartVertexLocation . | 정점 버퍼에서 읽기 시작할 위치의 인덱스 | . | . devcon-&gt;Draw(3, 0); // 정점 0부터 시작하여 3개의 정점 그리기 . | 위 함수들을 render_frame() 함수에 추가하기 | . // 단일 프레임을 렌더링하는 데 사용되는 함수입니다. void RenderFrame(void) { // 백 버퍼를 진한 파란색으로 채움 devcon-&gt;ClearRenderTargetView(backbuffer, D3DXCOLOR(0.0f, 0.2f, 0.4f, 1.0f)); // 표시할 정점 버퍼를 선택합니다. UINT stride = sizeof(VERTEX); UINT offset = 0; devcon-&gt;IASetVertexBuffers(0, 1, &amp;pVBuffer, &amp;stride, &amp;offset); // 사용할 기본 유형을 선택합니다. devcon-&gt;IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // 정점 버퍼를 백 버퍼에 그립니다. devcon-&gt;Draw(3, 0); // 백 버퍼와 프런트 버퍼를 전환합니다. swapchain-&gt;Present(0, 0); } . 드디어 삼각형 그리기 완성 . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#draw",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#draw"
  },"550": {
    "doc": "6. Drawing a Triangle",
    "title": "정리",
    "content": ". | 셰이더 사용 . | 두 개의 셰이더를 로드하고 컴파일 : D3DX11CompileFromFile() | 각 셰이더에 대한 객체 생성 : CreateVertexShader() | 셰이더 객체 설정 : SetShader() | . | 버퍼 만들기 . | 정점을 나타내는 구조체 생성 | 정점 버퍼 객체 생성 : D3D11_BUFFER_DESC, CreateBuffer() | 정점을 버퍼에 복사 : Map(), memcpy(), Unmap() | . | 입력 레이아웃 설정 . | 입력 레이아웃 구조체 설정 : D3D11_INPUT_ELEMENT_DESC | 입력 레이아웃 객체 생성 : CreateInputLayout() | 입력 레이아웃 설정 : IASetInputLayout() | . | 그리기 . | 사용할 정점 버퍼 설정 : IASetVertexBuffers() | 사용할 기본 유형 설정 : IASetPrimitiveTopology() | 백 버퍼에 그리기 : Draw() | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/6.%20Drawing%20a%20Triangle.html#정리"
  },"551": {
    "doc": "6. Matrix multiplication",
    "title": "6. Matrix multiplication",
    "content": "행렬 곱셈 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html"
  },"552": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 차원 (Dimension) 규칙",
    "content": ". | 행렬 곱셈이 가능하기 위해서는 . | 첫 번째 행렬의 열 개수 | 두 번째 행렬의 행 개수가 같아야 함 | . | . \\[A \\text{ is } m \\times n \\text{ and } B \\text{ is } n \\times p \\rightarrow AB \\text{ is } m \\times p\\] \\[(m \\times n) \\times (n \\times p) = (m \\times p)\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EC%B0%A8%EC%9B%90-dimension-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-차원-dimension-규칙"
  },"553": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 예시",
    "content": "\\[A = \\begin{pmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{pmatrix}, \\quad B = \\begin{pmatrix} b_{11} &amp; b_{12} \\\\ b_{21} &amp; b_{22} \\end{pmatrix}\\] . \\[A \\times B = \\begin{pmatrix} a_{11}b_{11} + a_{12}b_{21} &amp; a_{11}b_{12} + a_{12}b_{22} \\\\ a_{21}b_{11} + a_{22}b_{21} &amp; a_{21}b_{12} + a_{22}b_{22} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-예시"
  },"554": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 법칙",
    "content": ". | 결합 법칙 | . \\[(A \\times B) \\times C = A \\times (B \\times C)\\] . | 분배 법칙 | . \\[A \\times (B + C) = A \\times B + A \\times C\\] . \\[(A + B) \\times C = A \\times C + B \\times C\\] . | 교환 법칙은 성립하지 않음 | . \\[A \\times B \\neq B \\times A \\quad \\text{(일반적으로)}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-법칙"
  },"555": {
    "doc": "6. Packed Level Actor",
    "title": "6. Packed Level Actor",
    "content": "여러 액터들을 하나의 단위로 묶어서 관리할 수 있게 해주는 특수한 유형의 액터 . | 배경에 반복 배치되는 소규모 오브젝트를 집합으로 관리 (HLOD 최적화 용) | 동적인 오브젝트에는 부적합하다 | . ❓ Packed Level Actor를 어떻게 이해하면 돼? . | 100개의 나무 액터를 Packed Level Actor로 Pack → 통합된 “나무 군집 메시” | 여러 Static Mesh → 단일 Static Mesh로 병합 | 원본의 복잡한 콜리전 → 간략화된 볼륨(Box/Convex Hull)으로 대체 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html"
  },"556": {
    "doc": "6. Packed Level Actor",
    "title": "사용 목적",
    "content": ". | 복잡한 액터 계층 구조 단순화: 여러 하위 액터들을 하나의 논리적 단위로 묶어 관리 | 재사용성 향상: 패키지된 레벨 액터를 다른 레벨이나 프로젝트에서 재사용 가능 | 성능 최적화: 그룹화된 액터들을 더 효율적으로 로드/언로드 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#사용-목적"
  },"557": {
    "doc": "6. Packed Level Actor",
    "title": "특징",
    "content": ". | 계층 구조 유지: 하위 액터들의 상대적 위치와 관계 보존 | 블루프린트 통합: PLA를 블루프린트로 변환하여 로직 추가 가능 | 월드 파티션 호환: 대형 월드 지원 시스템과 잘 통합됨 | 동적 로딩: 필요 시점에만 로드되도록 설정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#특징"
  },"558": {
    "doc": "6. Packed Level Actor",
    "title": "생성 방법",
    "content": ". | 여러 액터를 선택 . | 예시: 10개의 Static Mesh Actor, 2개의 Light, 3개의 Decal 등 | . | 선택된 액터 우클릭 -&gt; “Packed Level Actor 생성” | 오브젝트 중심점 설정 | 저장될 폴더 위치 지정 후 저장 | 새로운 Packed Level Actor BPP 에셋 생성 . | 선택된 액터들의 Static Mesh, 머티리얼, 콜리전 등 리소스 머지 | 단일 Static Mesh와 머티리얼 세트 생성 (Bake) | . | . 참고하면 좋은 링크 . | Level Instancing | World Partition - Hierarchical Level of Detail | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#생성-방법"
  },"559": {
    "doc": "7. Ambient Lighting",
    "title": "7. Ambient Lighting",
    "content": "HLSL을 사용하여 DirectX 11에서 환경광을 사용해보자 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html"
  },"560": {
    "doc": "7. Ambient Lighting",
    "title": "Ambient Lighting (환경광)",
    "content": "3D 공간에 존재하는 ‘간접광’을 흉내 내는 가장 간단한 조명 모델 . | 태양(광원)이 직접 보이지는 않지만, 구름에 의해 빛이 사방으로 흩어져 세상 전체가 은은하게 밝혀지는 것과 같은 원리 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#ambient-lighting-%ED%99%98%EA%B2%BD%EA%B4%91",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#ambient-lighting-환경광"
  },"561": {
    "doc": "7. Ambient Lighting",
    "title": "특징",
    "content": ". | 특정한 광원이 없음 . | 빛이 어디서 오는지 방향성이 없음 | . | 모든 물체에 동일하게 적용 . | 모든 방향, 모든 표면에 균일한 강도와 색상으로 빛을 더해줌 | . | 그림자를 없애줌 . | 물체의 어두운 부분 (그림자)이 완전히 검은색 (RGB 0,0,0)으로 표현되지 않도록 | 기본 밝기를 제공한다. 이 덕분에 장면이 훨씬 자연스러워 보인다 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#특징"
  },"562": {
    "doc": "7. Ambient Lighting",
    "title": "Ambient Lighting 이 추가된 코드 예시",
    "content": "float4 LightPixelShader(PixelInputType input) : SV_TARGET { float4 textureColor; float3 lightDir; float lightIntensity; float4 color; // 이 텍스처 좌표 위치에서 샘플러를 사용하여 텍스처에서 픽셀 색상을 샘플링 textureColor = shaderTexture.Sample(SampleType, input.tex); // 기본 출력 색상을 모든 픽셀의 주변광 값으로 설정 color = ambientColor; // 계산 위해 빛 방향을 반전 lightDir = -lightDirection; // 이 픽셀에 대한 빛의 양을 계산 lightIntensity = saturate(dot(input.normal, lightDir)); if (lightIntensity &gt; 0.0f) { // 디퓨즈 컬러와 빛의 세기에 따라 최종 디퓨즈 컬러를 결정 color += (diffuseColor * lightIntensity); } // Saturate the final light color color = saturate(color); // 텍스처 픽셀과 최종 확산 색상을 곱하여 최종 픽셀 색상 결과를 얻음 color = color * textureColor; return color; } . diffuse color 만 있는 코드와의 차이점 . | diffuse color 코드 예시 | . // 조명 강도와 결합된 확산 색상을 기반으로 최종 확산 색상의 양을 결정 color = saturate(diffuseColor * lightIntensity); . | 빛의 세기(lightIntensity)가 0이면 color도 검은색(0, 0, 0)이 됨 | 오직 직접광의 영향만으로 색을 결정 | . | diffuse color + ambient color 코드 예시 | . // 기본 출력 색상을 모든 픽셀의 주변광 값으로 설정 color = ambientColor; ... if (lightIntensity &gt; 0.0f) { // 디퓨즈 컬러와 빛의 세기에 따라 최종 디퓨즈 컬러를 결정 color += (diffuseColor * lightIntensity); } . | 모든 픽셀에 ambientColor라는 기본 밝기를 부여 | 그 후, 빛이 닿는 부분에만 추가로 확산광을 더해 더 밝게 만듦 | . | 따라서 빛이 직접 닿지 않아도 물체는 최소한의 형태를 알아볼 수 있게 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#ambient-lighting-%EC%9D%B4-%EC%B6%94%EA%B0%80%EB%90%9C-%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#ambient-lighting-이-추가된-코드-예시"
  },"563": {
    "doc": "7. Ambient Lighting",
    "title": "KEYWORD NOTE",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#keyword-note",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#keyword-note"
  },"564": {
    "doc": "7. Ambient Lighting",
    "title": "saturate()",
    "content": "saturate 함수는 입력값을 0.0에서 1.0 사이로 클램핑(clamping) . float saturate(float x); float4 saturate(float4 x); float2x2 saturate(float2x2 x); . | 다양한 데이터 타입에 대해 오버로딩되어 있음 | 스칼라(scalar), 벡터(vector), 행렬(matrix) 등 float 기반의 모든 타입에 사용 | . // saturate(x)는 아래 코드와 같음 max(0.0, min(1.0, x)); . 리턴 값 . | x &lt; 0.0 : 0.0 반환 | x &gt; 1.0 : 1.0 반환 | 0.0 ≤ x ≤ 1.0 : x 그대로 반환 | . 사용 예시 . float3 lightDir = normalize(lightPosition - input.worldPos); float3 normal = normalize(input.worldNormal); // 내적 결과가 음수가 될 수 있으므로 saturate를 사용해 0~1 범위로 제한 float diffuse = saturate(dot(lightDir, normal)); // 최종 색상 계산 float4 finalColor = lightColor * diffuse; . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#saturate",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/7.%20Ambient%20Lighting.html#saturate"
  },"565": {
    "doc": "7. Level Instance",
    "title": "7. Level Instance",
    "content": "하나의 레벨(.umap)을 ‘오브젝트’처럼 메인 레벨에 인스턴스로 배치할 수 있는 시스템 . | Packed Level Actor가 오브젝트를 그룹으로 묶어 재사용화 했다면 | 레벨 인스턴스는 한 레벨 맵 (.umap)을 월드 안에 인스턴스로 재사용화 하는 개념 | . 즉, 레벨을 액터처럼 여러 번, 여러 위치에 복제/배치할 수 있음 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html"
  },"566": {
    "doc": "7. Level Instance",
    "title": "특징",
    "content": ". | 재사용성: 동일한 레벨 조각을 여러 위치에 반복적으로 배치 가능 | 동기화: 원본 레벨이 변경되면 모든 인스턴스에 자동 반영 | 계층 구조: 부모-자식 관계를 유지하며 복잡한 구조 생성 가능 | 에디터 지원: 인스턴스 편집 모드를 통해 인스턴스 내용 직접 수정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#특징"
  },"567": {
    "doc": "7. Level Instance",
    "title": "사용 방법",
    "content": ". | 서브 레벨(.umap) 준비 . | 인스턴스화할 방, 건물, 블록 등 서브 레벨을 미리 생성 및 저장 | (예시: Room_A.umap, Building_Block.umap) | . | 메인 레벨(예: MainLevel.umap)을 열기 . | Place Actors 패널에서 Level Instance 또는 LevelInstance를 검색 | → 드래그해서 씬에 배치 | . | .umap 지정 . | 배치한 Level Instance 액터 선택 | Details 패널에서 Level 또는 Level Asset 속성에 사용할 .umap 파일 지정 (예시: Room_A.umap 파일을 드래그&amp;드롭, 또는 경로 지정) | . | 트랜스폼/복제 . | 일반 액터와 동일하게 위치, 회전, 스케일 조정 가능 | 각 인스턴스는 개별 트랜스폼을 가짐 | . | 게임을 실행하면, Level Instance로 배치한 모든 서브 레벨이 해당 위치에서 독립적으로 동작 | . - Main World (World.umap) ├─ Level Instance: Ocean (Ocean.umap) ├─ Level Instance: Jungle (Jungle.umap) └─ Level Instance: Desert (Desert.umap) . 팀 협업 시 맵 섹션을 분할 제작 → 병렬 개발 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#사용-방법"
  },"568": {
    "doc": "7. Level Instance",
    "title": "주요 설정 옵션",
    "content": "| 설정 항목 | 설명 | . | Level Asset | 인스턴스할 .umap 파일 지정 | . | Transform | 위치, 회전, 스케일(씬에서 직접 수정 가능) | . | Actor Merge Policy | 충돌 시 동작 정책(기본값: Use Level, Merge, 또는 Override 등) | . | Override Loading Policy | 월드 파티션/스트리밍 환경에서 Level Instance의 로드 정책(Always Loaded, Blueprint 등) | . | Edit in Place | 인스턴스된 레벨을 ‘현장 편집’ 모드로 전환하여, 해당 인스턴스 내 액터 직접 편집 가능 | . | Lock Transform | 트랜스폼(위치/회전/스케일) 잠금 여부 | . | Blueprint Class | Level Instance를 Blueprint로 래핑하여 로직 확장 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%EC%A3%BC%EC%9A%94-%EC%84%A4%EC%A0%95-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#주요-설정-옵션"
  },"569": {
    "doc": "7. Level Instance",
    "title": "Packed Level Actor VS Level Instance",
    "content": "| 구분 | Packed Level Actor | Level Instance | . | 목적 | 렌더링 최적화(HLOD), 드로우콜 감소, LOD 관리 | 씬(맵) 구성 모듈화, 반복 배치, 유지보수/재사용성 강화 | . | 내부 구조 | 여러 액터 → 통합 메쉬/머티리얼 등으로 Bake된 단일 액터 | 레벨(.umap) 전체를 액터처럼 인스턴싱(복제) | . | 계층/정보 유지 | 원본 액터의 개별 정보 대부분 사라짐 (Bake 결과물만 남음) | 원본 레벨(액터, 컴포넌트, 논리 등) 구조 그대로 유지 | . | 동적 변경 | Packed Level Actor 자체는 런타임에 내용 수정 불가 | Level Instance는 에디터/런타임 모두 개별 인스턴스 수정 가능 | . | HLOD/LOD 연관 | HLOD 시스템과 직접 연결 | HLOD와 별개 필요 시 인스턴스화한 레벨에도 HLOD 적용 가능 | . | 스트리밍 연관 | HLOD/Level Streaming에서 효율화 목적 | Level Streaming, 월드 파티션에서 반복 구조 및 스트리밍에 용이 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#packed-level-actor-vs-level-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#packed-level-actor-vs-level-instance"
  },"570": {
    "doc": "7. identity matrix",
    "title": "7. identity matrix",
    "content": "항등 행렬 . 곱셈 결과를 바꾸지 않는 ‘1’에 해당하는 행렬 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html"
  },"571": {
    "doc": "7. identity matrix",
    "title": "항등 행렬의 개념",
    "content": ". | 항등행렬은 주로 I로 표시된다 | 반드시 정방( n×n ) 행렬이어야 한다 | 주 대각선은 1, 나머지는 0 이다 | . \\[I_n = \\begin{bmatrix} 1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix}_{n \\times n}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등-행렬의-개념"
  },"572": {
    "doc": "7. identity matrix",
    "title": "항등 행렬의 곱셈 성질",
    "content": "항등 행렬은 행렬 곱셈의 항등원 역할을 한다 . | 항등원 : 임의의 수에 어떤 수를 연산 했지만 연산 결과가 연산 전과 항상 같음 | . \\[IA = A \\\\ AI = A\\] . | 항등원과 행렬 곱셈 예시 | . \\[A = \\begin{bmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{bmatrix}, \\quad A I_3 = \\begin{bmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등-행렬의-곱셈-성질"
  },"573": {
    "doc": "7. identity matrix",
    "title": "항등행렬의 차원 규칙",
    "content": "| 곱셈 형태 | 필요한 I의 크기 | . | IA | A의 행 수만큼 \\(I_m\\) | . | AI | A의 열 수만큼 \\(I_n\\) | . 곱하는 순서에 따라 사용해야 할 항등행렬의 차원이 달라질 수 있다 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1%ED%96%89%EB%A0%AC%EC%9D%98-%EC%B0%A8%EC%9B%90-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등행렬의-차원-규칙"
  },"574": {
    "doc": "8. Elimination Matrix",
    "title": "8. Elimination Matrix",
    "content": "제거 행렬 . | 가우스 소거법(Gaussian Elimination)을 행렬 형태로 표현한 것 | 기본행연산(elementary row operations)을 수행한다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html"
  },"575": {
    "doc": "8. Elimination Matrix",
    "title": "소거 행렬의 핵심",
    "content": ". | 각 행 연산은 하나의 행연산 행렬로 표현할 수 있다 | . | 수행하는 모든 행 연산의 전체를 하나의 행렬로 모은 행렬을 소거 행렬이라고 부른다 | . | 예시 | . \\[A = \\begin{bmatrix} -1 &amp; -5 &amp; \\;\\;1 \\\\ -5 &amp; -5 &amp; \\;\\;5 \\\\ \\;\\;2 &amp; \\;\\;5 &amp; -3 \\end{bmatrix}\\] . | 소거 행렬 | . \\[-R_1 \\to R_1\\] \\[E_1 = \\begin{bmatrix} -1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[\\tfrac15 R_2 \\to R_2\\] \\[E_2 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\tfrac15 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[R_1 + R_2 \\to R_2\\] \\[E_3 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[R_3 - 2R_1 \\to R_3\\] \\[E_4 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ -2 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[\\tfrac14 R_2 \\to R_2\\] \\[E_5 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\tfrac14 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[-5R_2 + R_1 \\to R_1\\] \\[E_6 = \\begin{bmatrix} 1 &amp; -5 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[5R_2 + R_3 \\to R_3\\] \\[E_7 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 5 &amp; 1 \\end{bmatrix}\\] \\[-R_3 \\to R_3\\] \\[E_8 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; -1 \\end{bmatrix}\\] \\[R_1 + R_3 \\to R_1\\] \\[E_9 = \\begin{bmatrix} 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . 따라서 . \\[E = E_9E_8E_7E_6E_5E_4E_3E_2E_1 = \\begin{bmatrix} -\\tfrac12 &amp; -\\tfrac12 &amp; -1\\\\[4pt] -\\tfrac14 &amp; \\tfrac1{20} &amp; 0\\\\[4pt] -\\tfrac34 &amp; -\\tfrac14 &amp; -1 \\end{bmatrix}\\] . \\[EA = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%86%8C%EA%B1%B0-%ED%96%89%EB%A0%AC%EC%9D%98-%ED%95%B5%EC%8B%AC",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#소거-행렬의-핵심"
  },"576": {
    "doc": "8. Elimination Matrix",
    "title": "소거 행렬은 행렬의 역행렬과 같다",
    "content": "\\[A^{-1} = \\begin{bmatrix} -\\tfrac12 &amp; -\\tfrac12 &amp; -1\\\\[4pt] -\\tfrac14 &amp; \\tfrac1{20} &amp; 0\\\\[4pt] -\\tfrac34 &amp; -\\tfrac14 &amp; -1 \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%86%8C%EA%B1%B0-%ED%96%89%EB%A0%AC%EC%9D%80-%ED%96%89%EB%A0%AC%EC%9D%98-%EC%97%AD%ED%96%89%EB%A0%AC%EA%B3%BC-%EA%B0%99%EB%8B%A4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#소거-행렬은-행렬의-역행렬과-같다"
  },"577": {
    "doc": "8. Elimination Matrix",
    "title": "역행렬에 행렬을 곱하면 결과는 항등 행렬이다",
    "content": "\\[A^{-1}A = I\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%97%AD%ED%96%89%EB%A0%AC%EC%97%90-%ED%96%89%EB%A0%AC%EC%9D%84-%EA%B3%B1%ED%95%98%EB%A9%B4-%EA%B2%B0%EA%B3%BC%EB%8A%94-%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%B4%EB%8B%A4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#역행렬에-행렬을-곱하면-결과는-항등-행렬이다"
  },"578": {
    "doc": "8. Specular Lighting",
    "title": "8. Specular Lighting (정반사광)",
    "content": "매끄럽거나 광택이 나는 표면에서 빛이 특정 방향으로 강하게 반사되어 생기는 하이라이트를 모델링하는 조명 . | 정반사광은 빛이 거울처럼 특정 각도로 반사되어 우리 눈에 직접 들어올 때만 보이는 밝은 빛이다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#8-specular-lighting-%EC%A0%95%EB%B0%98%EC%82%AC%EA%B4%91",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#8-specular-lighting-정반사광"
  },"579": {
    "doc": "8. Specular Lighting",
    "title": "Specular Lighting을 계산하는 데 필요한 요소들",
    "content": "하이라이트를 계산하려면 셰이더(Shader) 코드에서 몇 가지 벡터와 값이 필요 . | 광원 벡터 (Light Vector, L) . | 표면의 한 점에서 광원(조명)을 향하는 방향 벡터 | . | 표면 노멀 벡터 (Normal Vector, N) . | 해당 지점의 표면이 바라보는 방향을 나타내는 벡터. 표면에 수직인 방향 | . | 시선 벡터 (View Vector, V) . | 표면의 한 점에서 카메라(눈)를 향하는 방향 벡터 | . | 반사 벡터 (Reflection Vector, R) . | 광원 벡터(L)가 표면의 법선(N)을 기준으로 반대편으로 반사된 방향 벡터 | . | 광택도 (Shininess 또는 Roughness) . | 표면이 얼마나 매끄러운지를 나타내는 값 . | 값이 높을수록: 하이라이트가 작고 날카로움 (예: 금속, 유리) | 값이 낮을수록: 하이라이트가 크고 뭉툭 (예: 플라스틱, 고무) | . | . | . 기본적인 퐁(Phong) 조명 모델에서는 다음과 같은 원리로 정반사광을 계산 . | “반사된 빛의 방향(R)과 우리 눈의 방향(V)이 얼마나 가까운가?” | 반사 벡터 (R) 과 눈 방향 (V) 의 방향이 일치할 수록 밝은 하이라이트를 갖게 됨 | 광택도 값을 조절하여 같은 물체라도 다양한 재질의 느낌을 표현 | . 따라서 . | 둘 사이의 각도를 계산하여 하이라이트의 강도를 결정함 | 광택도 값을 제곱 연산(power)의 지수로 사용하여 하이라이트의 집중도를 조절 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#specular-lighting%EC%9D%84-%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94-%EB%8D%B0-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9A%94%EC%86%8C%EB%93%A4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#specular-lighting을-계산하는-데-필요한-요소들"
  },"580": {
    "doc": "8. Specular Lighting",
    "title": "Phong Model",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#phong-model",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#phong-model"
  },"581": {
    "doc": "8. Specular Lighting",
    "title": "반사 벡터 R 구하는 과정",
    "content": ". | 우리는 입사 벡터 L과 노멀 벡터 N을 알고 있음 | L을 N에 투영(projection)하면 벡터 P를 얻을 수 있음 . | P의 길이(스칼라)는 dot(N, L) | P 벡터는 dot(N, L) * N | . | 그림에서 L + E = P 이므로, E = P - L | 반사 벡터 R은 P + E 와 같음 | 따라서 R = P + (P - L) 이 되고, 최종적으로 R = 2 * P - L | P를 원래 공식으로 되돌리면, R = 2 * dot(N, L) * N - L 이라는 최종 공식이 나옴 | . | 2.0f는 바로 이 2 * P 에서 나온 것 | 입사 벡터를 노멀 벡터 기준으로 “두 번 밀어내서” 반대편으로 보낸다고 생각하기 | . | The Phong Model . | RestaerTek 코드 예시 . | . float4 LightPixelShader(PixelInputType input) : SV_TARGET { float4 textureColor; float3 lightDir; float lightIntensity; float4 color; float3 reflection; float4 specular; // Sample the pixel color from the texture using the sampler at this texture coordinate location. textureColor = shaderTexture.Sample(SampleType, input.tex); // Set the default output color to the ambient light value for all pixels. color = ambientColor; // Initialize the specular color. specular = float4(0.0f, 0.0f, 0.0f, 0.0f); // Invert the light direction for calculations. lightDir = -lightDirection; // Calculate the amount of light on this pixel. lightIntensity = saturate(dot(input.normal, lightDir)); if(lightIntensity &gt; 0.0f) { // Determine the final diffuse color based on the diffuse color and the amount of light intensity. color += (diffuseColor * lightIntensity); // Saturate the ambient and diffuse color. color = saturate(color); // 이 부분이 위에서 말한 반사 벡터 R 구하는 곳 reflection = normalize(2.0f * lightIntensity * input.normal - lightDir); // Determine the amount of specular light based on the reflection vector, viewing direction, and specular power. specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower); } // Multiply the texture pixel and the final diffuse color to get the final pixel color result. color = color * textureColor; // Add the specular component last to the output color. color = saturate(color + specular); return color; } . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#%EB%B0%98%EC%82%AC-%EB%B2%A1%ED%84%B0-r-%EA%B5%AC%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#반사-벡터-r-구하는-과정"
  },"582": {
    "doc": "8. Specular Lighting",
    "title": "Blinn-Phong",
    "content": "블린-퐁은 반사 벡터(R)를 직접 계산하는 대신, 하프웨이 벡터(Halfway Vector, H) 라는 것을 사용 . | 하프웨이 벡터(H): 광원 벡터(L)와 시선 벡터(V)의 딱 중간 방향을 가리키는 벡터 | . 블린-퐁 모델은 이 하프웨이 벡터(H)와 법선 벡터(N)가 얼마나 가까운지를 계산한다 . | “표면의 방향(N)이 빛과 시선의 중간 방향(H)을 얼마나 정확히 바라보고 있는가?” | . 계산이 더 효율적이고, 특정 상황에서 더 자연스러운 결과를 보여주기 때문에 현대 그래픽스에서 더 널리 사용됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#blinn-phong",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#blinn-phong"
  },"583": {
    "doc": "8. Specular Lighting",
    "title": "Blinn-Phong 계산 원리",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#blinn-phong-%EA%B3%84%EC%82%B0-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#blinn-phong-계산-원리"
  },"584": {
    "doc": "8. Specular Lighting",
    "title": "1. 하프웨이 벡터 (Halfway Vector, H) 계산",
    "content": "정반사광을 계산하려는 표면의 한 점을 기준으로 두 개의 벡터를 구함 . | 광원 벡터 (L): 표면에서 광원을 향하는 단위 벡터 | 시선 벡터 (V): 표면에서 카메라(관찰자)를 향하는 단위 벡터 | . 하프웨이 벡터는 위 두 벡터의 정확히 중간 방향을 가리키는 단위 벡터 . 하프웨이 벡터 구하기 . | 광원 벡터(L)와 시선 벡터(V) 더하기 | . \\[H = L + V\\] . | 결과 벡터를 정규화(Normalize)하여 크기를 1로 만들기 | . \\[H = normalize(L + V)\\] float3 lightDir; float3 viewDir; float3 halfVector; halfVector = normalize(lightDir + viewDir); . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#1-%ED%95%98%ED%94%84%EC%9B%A8%EC%9D%B4-%EB%B2%A1%ED%84%B0-halfway-vector-h-%EA%B3%84%EC%82%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#1-하프웨이-벡터-halfway-vector-h-계산"
  },"585": {
    "doc": "8. Specular Lighting",
    "title": "2. 하이라이트 강도 계산",
    "content": "하이라이트의 밝기를 결정한다. | 법선 벡터 (N): 표면에 수직인 단위 벡터 | 하프웨이 벡터(H): 중간 방향을 가리키는 단위 벡터 | . 하프웨이 벡터(H)와 표면의 법선 벡터(N)가 얼마나 같은 방향을 바라보는지를 측정 . | 표면의 법선 벡터(N)와 하프웨이 벡터(H)가 얼마나 같은 방향을 향하는지 내적(Dot Product)을 통해 계산 | 이 값은 0과 1 사이의 스칼라 값으로, 하이라이트의 기본 밝기를 결정 | . \\[specular_{intensity} = max(0, dot(N, H))\\] float SpecularIntensity; float3 normal; float3 halfVector; SpecularIntensity = saturate(dot(normal, halfVector)) . | 값이 1에 가까울수록 (두 벡터의 방향이 거의 일치), 그 지점은 가장 밝은 하이라이트를 갖게 됨 | 값이 0에 가까울수록 (두 벡터가 수직에 가까울수록), 하이라이트는 거의 보이지 않게 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#2-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8A%B8-%EA%B0%95%EB%8F%84-%EA%B3%84%EC%82%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#2-하이라이트-강도-계산"
  },"586": {
    "doc": "8. Specular Lighting",
    "title": "3. 광택도 적용하기",
    "content": "위에서 구한 하이라이트 강도 값에 광택도(Shininess) 계수를 적용하여 하이라이트의 크기를 조절 . | L_s: 계산된 반사광의 최종 색상 및 강도 | k_s: 물체의 재질에 따라 반사광의 색상과 강도를 정의하는 RGB 값 | L_light: 광원의 색상 및 강도 | shininess: 광택도를 나타내는 지수 | . \\[L_s = k_s \\cdot L_{light} \\cdot (specular_{intensity})^{shininess}\\] . float4 specular; float specularPower; specular = pow(SpecularIntensity, specularPower); . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#3-%EA%B4%91%ED%83%9D%EB%8F%84-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#3-광택도-적용하기"
  },"587": {
    "doc": "8. Specular Lighting",
    "title": "shininess 계산 예시",
    "content": ". | 매우 낮은 값 (1 ~ 10) . | 직물, 무광택 페인트, 거친 나무 등 빛을 넓게 분산시키는 무광 재질을 표현 | 하이라이트가 매우 넓고 희미하게 나타남 | . | 중간 값 (50 ~ 200) . | 플라스틱, 에나멜 코팅된 표면, 약간 광택이 있는 금속 등 어느 정도의 광택을 가진 재질에 사용 | . | 높은 값 (200 이상) . | 크롬, 유리, 유광 금속 등 매우 매끄럽고 빛을 날카롭게 반사하는 광택 재질을 표현 | 하이라이트가 매우 작고 강하게 나타남 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess-%EA%B3%84%EC%82%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess-계산-예시"
  },"588": {
    "doc": "8. Specular Lighting",
    "title": "shininess가 낮은 경우",
    "content": "shininess 값이 2일 때, 하이라이트 강도의 변화 . | (H · N) = 1.0 (정확히 중앙) → \\(1.0^2 = 1.0\\) (최대 밝기) | (H · N) = 0.5 (중앙에서 약간 벗어남) → \\(0.5^2 = 0.25\\) | (H · N) = 0.2 (중앙에서 많이 벗어남) → \\(0.2^2 = 0.04\\) | (H · N) = 0.0 (하이라이트 영역 밖) → \\(0.0^2 = 0.0\\) | . 값이 제곱되면서 중앙에서 멀어질수록 강도가 서서히 낮아짐 . | 이로 인해 넓고 부드러운 하이라이트가 만들어짐 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess%EA%B0%80-%EB%82%AE%EC%9D%80-%EA%B2%BD%EC%9A%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess가-낮은-경우"
  },"589": {
    "doc": "8. Specular Lighting",
    "title": "shininess가 높은 경우",
    "content": "shininess 값이 200일 때, 하이라이트 강도의 변화 . | (H · N) = 1.0 (정확히 중앙) → \\(1.0^{200} = 1.0\\) (최대 밝기) | (H · N) = 0.9 (중앙에서 아주 살짝 벗어남) → \\(0.9^{200} ≈ 0.000000000012\\) (거의 0에 가까움) | (H · N) = 0.5 (중앙에서 벗어남) → \\(0.5^{200} ≈ 0.0\\) | . 값이 200이라는 큰 지수로 거듭제곱되면서, 내적 값이 1에서 아주 조금만 벗어나도 결과값이 급격하게 0으로 수렴 . | 하이라이트가 매우 작고 날카로운 점처럼 보이게 됨 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess%EA%B0%80-%EB%86%92%EC%9D%80-%EA%B2%BD%EC%9A%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#shininess가-높은-경우"
  },"590": {
    "doc": "8. Specular Lighting",
    "title": "phong VS Blinn-Phong",
    "content": ". | phong Model HLSL 소스코드 예시 | . // Pixel Shader float4 PhongPS(float3 worldPos : WORLDPOS, float3 normal : NORMAL) : SV_Target { // 조명 및 재질 속성 (상수로 선언) float3 lightPos = float3(10.0f, 10.0f, -10.0f); float3 lightColor = float3(1.0f, 1.0f, 1.0f); float3 objectColor = float3(0.0f, 0.5f, 1.0f); // 파란색 float3 cameraPos = float3(0.0f, 0.0f, -10.0f); float shininess = 32.0f; // 벡터 계산 float3 N = normalize(normal); // 법선 벡터 float3 L = normalize(lightPos - worldPos); // 광원 벡터 float3 V = normalize(cameraPos - worldPos); // 시선 벡터 float3 R = reflect(-L, N); // 반사 벡터 // 1. 주변광 (Ambient) float ambientStrength = 0.1f; float3 ambient = ambientStrength * lightColor; // 2. 난반사광 (Diffuse) float diff = max(dot(N, L), 0.0); float3 diffuse = diff * lightColor; // 3. 정반사광 (Specular) float spec = pow(max(dot(V, R), 0.0), shininess); float3 specular = spec * lightColor; // 최종 색상 계산 float3 result = (ambient + diffuse) * objectColor + specular; return float4(result, 1.0f); } . reflect 함수를 사용하여 반사 벡터 R을 구하고, 이를 시선 벡터 V와 내적(dot)하여 정반사광을 계산 . | Blinn-Phong HLSL 소스코드 예시 | . // Pixel Shader float4 BlinnPhongPS(float3 worldPos : WORLDPOS, float3 normal : NORMAL) : SV_Target { // 조명 및 재질 속성 (상수로 선언) float3 lightPos = float3(10.0f, 10.0f, -10.0f); float3 lightColor = float3(1.0f, 1.0f, 1.0f); float3 objectColor = float3(0.0f, 0.5f, 1.0f); // 파란색 float3 cameraPos = float3(0.0f, 0.0f, -10.0f); float shininess = 32.0f; // 벡터 계산 float3 N = normalize(normal); // 법선 벡터 float3 L = normalize(lightPos - worldPos); // 광원 벡터 float3 V = normalize(cameraPos - worldPos); // 시선 벡터 float3 H = normalize(L + V); // 하프 벡터 // 1. 주변광 (Ambient) float ambientStrength = 0.1f; float3 ambient = ambientStrength * lightColor; // 2. 난반사광 (Diffuse) float diff = max(dot(N, L), 0.0); float3 diffuse = diff * lightColor; // 3. 정반사광 (Specular) float spec = pow(max(dot(N, H), 0.0), shininess); float3 specular = spec * lightColor; // 최종 색상 계산 float3 result = (ambient + diffuse) * objectColor + specular; return float4(result, 1.0f); } . 광원 벡터 L과 시선 벡터 V를 더해 정규화한 하프 벡터 H를 구하고, 이를 법선 벡터 N과 내적하여 정반사광을 계산 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#phong-vs-blinn-phong",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#phong-vs-blinn-phong"
  },"591": {
    "doc": "8. Specular Lighting",
    "title": "Clarity Notes",
    "content": "공부하며 헷갈렸던 부분 명료화 하기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#clarity-notes",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#clarity-notes"
  },"592": {
    "doc": "8. Specular Lighting",
    "title": "bufferNumber",
    "content": "lightshaderclass.cpp 의 SetShaderParameters() 의 bufferNumber 사용 목적 . | 버텍스 셰이더 : 두 개의 상수 버퍼가 정의 | . cbuffer MatrixBuffer // : register(b0) by default { matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; }; cbuffer CameraBuffer // : register(b1) by default { float3 cameraPosition; float padding; }; . | HLSL에서 cbuffer를 선언할 때, 명시적으로 레지스터를 지정하지 않으면 | 컴파일러가 순서대로 register(b0), register(b1), register(b2)… 와 같이 자동으로 할당 | . | SetShaderParameters() | . // CameraBuffer 설정 // Set the position of the camera constant buffer in the vertex shader. bufferNumber = 1; // Now set the camera constant buffer in the vertex shader with the updated values. deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_cameraBuffer); . | bufferNumber를 1로 설정하고 VSSetConstantBuffers를 호출 . | m_cameraBuffer에 담긴 카메라 위치 데이터를 버텍스 셰이더(VS)의 1번 슬롯(register(b1))에 바인딩 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#buffernumber",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#buffernumber"
  },"593": {
    "doc": "8. Specular Lighting",
    "title": "결론",
    "content": ". | bufferNumber = 1;은 이제부터 버텍스 셰이더의 1번 상수 버퍼 슬롯에 데이터를 설정하겠다는 의미 | . 그리고 이어지는 VSSetConstantBuffers 함수 호출을 통해 m_cameraBuffer의 내용(카메라 위치)이 버텍스 셰이더의 CameraBuffer(register(b1))로 전달됨 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#결론"
  },"594": {
    "doc": "8. Specular Lighting",
    "title": "View Direction VS View Matrix",
    "content": ". | viewDirection : 빛 계산에 사용되는 방향 벡터 | viewMatrix : 공간을 변환하는 행렬 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-direction-vs-view-matrix",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-direction-vs-view-matrix"
  },"595": {
    "doc": "8. Specular Lighting",
    "title": "View Direction (시선 방향 벡터)",
    "content": ". | 목적 : 빛 계산 (Lighting Calculation) . | viewDirection은 주로 정반사광(Specular Lighting)을 계산하는 데 필수적 | . | . 정반사광은 광원에서 나온 빛이 물체 표면에 반사되어 우리 눈(카메라)으로 얼마나 강하게 들어오는지를 표현한다 . | 이 반사광을 계산하려면 표면의 한 지점에서 카메라를 향하는 방향을 알아야 하며 | 그 역할을 viewDirection이 맡는다 | . 결론 : 물체의 특정 부분이 얼마나 반짝거릴지를 결정하는 데 사용되는 값 . 계산 과정 . | GPU (버텍스 셰이더)에서 각 정점(vertex)마다 계산됨 . | 코드에서처럼 cameraPosition.xyz - worldPosition.xyz 로 계산 . | worldPosition: 현재 계산 중인 정점의 월드 공간 위치 | cameraPosition: CPU에서 보내준 카메라의 월드 공간 위치 | . | . | (정점의 위치)에서 (카메라의 위치)를 향하는 벡터를 구한 뒤, 이를 정규화(normalize)하여 길이가 1인 순수한 방향 벡터로 만들어 픽셀 셰이더로 넘김 . | 오브젝트의 모든 정점은 월드에서 위치가 다르므로, 각 정점에서 카메라를 바라보는 viewDirection 벡터도 모두 미세하게 다름 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-direction-%EC%8B%9C%EC%84%A0-%EB%B0%A9%ED%96%A5-%EB%B2%A1%ED%84%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-direction-시선-방향-벡터"
  },"596": {
    "doc": "8. Specular Lighting",
    "title": "View Matrix (뷰 행렬)",
    "content": ". | 목적 : 공간 변환 (Coordinate Transformation) . | viewMatrix의 주된 목적은 3D 월드에 존재하는 모든 물체(정점)들을 카메라의 시점으로 가져오는 것 | . | . 3D 공간의 원점에 카메라가 있고 -Z축 방향을 바라보는 것처럼, 월드 전체를 카메라의 좌표계로 변환 . | 이 변환된 공간을 뷰 공간(View Space) 또는 카메라 공간(Camera Space)이라고 부름 | 이 과정이 있어야 우리가 보는 화면에 물체들이 올바른 위치와 방향으로 그려질 수 있습니다. | . 계산 과정 . | CPU (C++ 애플리케이션)에서 계산 . | 일반적으로 카메라의 위치(eye), 카메라가 바라보는 지점(at), 그리고 카메라의 상단 방향(up) 벡터, 이 세 가지 정보를 이용해 4x4 행렬을 만듦 | . | 이렇게 만들어진 행렬은 매 프레임(또는 카메라가 움직일 때마다) cbuffer를 통해 GPU 셰이더로 전송 . | 셰이더 코드에서는 output.position = mul(output.position, viewMatrix); 와 같이 모든 정점의 위치를 변환하는 데 사용 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-matrix-%EB%B7%B0-%ED%96%89%EB%A0%AC",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html#view-matrix-뷰-행렬"
  },"597": {
    "doc": "8. Specular Lighting",
    "title": "8. Specular Lighting",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/8.%20Specular%20Lighting.html"
  },"598": {
    "doc": "9. Multiple Point Lights",
    "title": "9. Multiple Point Lights",
    "content": "포인트 라이트는 3D 공간의 특정 한 지점(위치)에서 모든 방향으로 빛을 방출하는 광원 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html"
  },"599": {
    "doc": "9. Multiple Point Lights",
    "title": "특징",
    "content": ". | 위치 기반: 포인트 라이트는 3D 월드 좌표계에 고유한 위치를 가짐 | 전방향 방출: 특정 방향 없이 자신의 위치에서 360도 모든 방향으로 빛을 내뿜는다 | 감쇠 (Attenuation): 포인트 라이트의 가장 큰 특징 중 하나 . | 빛은 광원으로부터 멀어질수록 세기가 약해짐. 즉, 물체가 광원에서 멀리 떨어져 있을수록 더 어둡게 보임 | . | . 포인트 라이트는 “특정 위치에서 모든 방향으로 빛을 내뿜는 광원” . | 실내의 램프, 촛불 등을 표현하는 데 아주 유용하게 사용된다 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#특징"
  },"600": {
    "doc": "9. Multiple Point Lights",
    "title": "Point Light VS Directional Light",
    "content": ". | 위치 vs 방향: 포인트 라이트는 ‘위치’가 중요하지만, 방향 조명은 ‘방향’만 중요합니다. 방향 조명은 태양광처럼 아주 멀리서 오는 빛으로 간주하여, 씬의 모든 물체에 동일한 각도로 빛이 내리쬔다고 가정합니다. 따라서 위치 정보가 없습니다. | 빛의 방향 벡터: . | 포인트 라이트: 표면의 각 픽셀마다 ‘픽셀의 위치’에서 ‘광원의 위치’를 향하는 벡터를 계산해야 하므로, 빛의 방향이 픽셀마다 다릅니다. | 방향 조명: 모든 픽셀에 대해 빛의 방향 벡터가 동일합니다. | . | 감쇠 (Attenuation): 방향 조명은 감쇠가 없습니다. 씬의 모든 곳에 동일한 세기의 빛이 도달합니다. 하지만 포인트 라이트는 거리에 따라 빛의 세기가 약해집니다. | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-vs-directional-light",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-vs-directional-light"
  },"601": {
    "doc": "9. Multiple Point Lights",
    "title": "Point Light Attenuation (점광원의 감쇠)",
    "content": "빛은 광원으로부터 멀어질수록 세기가 약해지는데, 이를 감쇠(Attenuation)라고 한다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-attenuation-%EC%A0%90%EA%B4%91%EC%9B%90%EC%9D%98-%EA%B0%90%EC%87%A0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-attenuation-점광원의-감쇠"
  },"602": {
    "doc": "9. Multiple Point Lights",
    "title": "Inverse Square Law (역제곱 법칙)",
    "content": "물리적으로 정확한 빛의 감쇠는 역제곱 법칙을 따른다 . ❓ 역제곱 법칙이란? . | 광원으로부터의 거리가 2배가 되면 빛의 세기는 4배(2의 제곱) 약해지고, | 거리가 3배가 되면 9배(3의 제곱) 약해진다는 원리 | . 즉, 빛의 세기는 거리의 제곱에 반비례 . 역제곱 법칙의 수식 . \\[\\text{Intensity} = \\frac{I_0}{d^2}\\] . | Intensity: 특정 거리에서의 빛의 세기 | I_0: 광원의 초기 강도 (또는 기준 거리 1에서의 강도) | d: 광원으로부터의 거리 | . 이 공식을 컴퓨터 그래픽스에 그대로 적용하면 문제가 발생함 . | 거리가 0에 가까워질수록 빛의 세기가 무한대로 치솟아 비현실적인 밝은 점이 생기기 때문 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#inverse-square-law-%EC%97%AD%EC%A0%9C%EA%B3%B1-%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#inverse-square-law-역제곱-법칙"
  },"603": {
    "doc": "9. Multiple Point Lights",
    "title": "Attenuation in Computer Graphics",
    "content": "위 문제를 해결하기 위해 컴퓨터 그래픽스에서는 역제곱 법칙을 변형한 다음과 같은 일반적인 감쇠 공식을 사용 . \\[\\text{Attenuation} = \\frac{1}{K_c + K_l \\cdot d + K_q \\cdot d^2}\\] . | Attenuation: 감쇠율 (0과 1 사이의 값). 이 값을 최종 빛의 색상에 곱하여 감쇠 효과를 적용 | d: 광원과 물체 표면의 픽셀(또는 정점) 사이의 거리 | K_c (Constant Attenuation) . | 상수 감쇠 계수. 거리에 상관없이 일정한 감쇠를 적용 | 이 값을 1 이상으로 설정하면 거리가 0일 때 빛의 세기가 무한대가 되는 것을 방지하고, 전체적인 빛의 밝기를 조절하는 역할을 함 | . | K_l (Linear Attenuation) . | 선형 감쇠 계수. 거리에 비례하여 빛을 선형적으로 감쇠시킴 | 이 값이 클수록 거리에 따라 빛이 더 빨리 어두워짐 | . | K_q (Quadratic Attenuation) . | 이차 감쇠 계수. 거리에 제곱에 비례하여 빛을 감쇠 | 물리적으로 가장 현실적인 감쇠 효과를 내며, 이 값이 클수록 빛이 매우 빠르게 어두워져 광원의 영향 범위가 좁아짐 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#attenuation-in-computer-graphics",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#attenuation-in-computer-graphics"
  },"604": {
    "doc": "9. Multiple Point Lights",
    "title": "Point Light 구하기",
    "content": "점광원의 최종 색상은 주변광(Ambient), 난반사광(Diffuse), 정반사광(Specular)을 모두 계산한 뒤 . | 위에서 구한 감쇠율(Attenuation)을 곱하여 결정 | . \\[\\text{Final Color} = (\\text{Ambient} + \\text{Diffuse} + \\text{Specular}) \\cdot \\text{Attenuation}\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-%EA%B5%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#point-light-구하기"
  },"605": {
    "doc": "9. Multiple Point Lights",
    "title": "Multiple point lights",
    "content": "여러 개의 포인트 라이트를 처리하는 과정 . | 각각의 포인트 라이트에 대해 순회하는 반복문을 실행하고 그 결과들을 모두 더하기 | . 1. 초기 색상 설정 . 최종 색상을 저장할 변수를 선언하고, 주변광(Ambient Light)으로 초기화 . | finalColor = ambientColor; | . 2. 반복문 (Loop) . 모든 포인트 라이트를 순회하는 반복문을 실행 . | 픽셀 셰이더에서는 보통 배열(Array) 형태로 여러 개의 광원 정보(위치, 색상)를 전달받음 | . 3. 개별 광원 계산 및 누적: . 반복문 내에서 현재 순서의 포인트 라이트 하나에 대해 위의 공식(난반사, 정반사, 감쇠 계산)을 그대로 적용하여 해당 광원이 기여하는 색상(lightContribution)을 계산 . | 계산된 색상을 최종 색상 변수에 더해줌 | finalColor += lightContribution; | . 4. 최종 처리: . 모든 포인트 라이트에 대한 반복이 끝나면 finalColor 변수에는 모든 광원의 영향이 합산된 최종 색상 값이 담김 . | finalColor = saturate(finalColor) | 마지막으로, 최종 색상 값이 1.0을 초과하지 않도록 saturate 함수를 이용해 값을 [0, 1] 범위로 클램핑(clamping) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#multiple-point-lights",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#multiple-point-lights"
  },"606": {
    "doc": "9. Multiple Point Lights",
    "title": "HLSL code sample (감쇠 X)",
    "content": "Vertex Shader . // DEFINES // // 처리할 포인트 라이트의 개수를 4개로 정의 #define NUM_LIGHTS 4 // GLOBALS // C++ 애플리케이션에서 전달받는 행렬 버퍼 cbuffer MatrixBuffer { matrix worldMatrix; // 모델의 로컬 좌표를 월드 좌표로 변환하는 행렬 matrix viewMatrix; // 월드 좌표를 카메라(뷰) 좌표로 변환하는 행렬 matrix projectionMatrix; // 뷰 좌표를 2D 화면에 투영하기 위한 투영 행렬 }; // C++ 애플리케이션에서 전달받는 포인트 라이트의 위치 버퍼 cbuffer LightPositionBuffer { float4 lightPosition[NUM_LIGHTS]; // NUM_LIGHTS 개수만큼의 광원 위치 }; // TYPEDEFS // 정점 셰이더의 입력 구조체. 3D 모델의 정점 데이터에 해당 struct VertexInputType { float4 position : POSITION; // 정점의 위치 float2 tex : TEXCOORD0; // 텍스처 UV 좌표 float3 normal : NORMAL; // 정점의 법선 벡터 (빛의 반사를 계산하는 데 사용) }; // 정점 셰이더의 출력 구조체이자, 픽셀 셰이더의 입력 구조체 struct PixelInputType { float4 position : SV_POSITION; // 최종 변환된 정점의 화면 위치 float2 tex : TEXCOORD0; // 픽셀 셰이더로 전달될 텍스처 UV 좌표 float3 normal : NORMAL; // 월드 공간으로 변환된 법선 벡터 float3 lightPos[NUM_LIGHTS] : TEXCOORD1; // 각 정점에서 광원까지의 방향 벡터 }; PixelInputType LightVertexShader(VertexInputType input) { PixelInputType output; // 픽셀 셰이더로 보낼 출력 객체 float4 worldPosition; // 월드 공간에서의 정점 위치를 저장할 변수 int i; // 행렬 계산을 위해 정점 위치를 4차원 벡터(w=1.0)로 만듦 input.position.w = 1.0f; // 1. 정점 위치 변환 // 로컬 -&gt; 월드 -&gt; 뷰 -&gt; 투영 공간으로 정점의 위치를 변환 output.position = mul(input.position, worldMatrix); output.position = mul(output.position, viewMatrix); output.position = mul(output.position, projectionMatrix); // 2. 텍스처 좌표 전달 // 텍스처 좌표는 변환 없이 그대로 픽셀 셰이더로 전달 output.tex = input.tex; // 3. 법선 벡터 변환 // 법선 벡터를 월드 행렬과 곱하여 월드 공간 기준으로 변환 output.normal = mul(input.normal, (float3x3)worldMatrix); // 조명 계산의 정확도를 위해 법선 벡터를 정규화합니다. (길이를 1로 만듦) output.normal = normalize(output.normal); // 4. 월드 공간에서의 정점 위치 계산 worldPosition = mul(input.position, worldMatrix); // 5. 빛 벡터 계산 (반복문) // 각 포인트 라이트에 대해 빛 벡터를 계산합니다. for(i=0; i&lt;NUM_LIGHTS; i++) { // 정점의 위치에서 광원의 위치를 향하는 벡터(빛 벡터)를 계산 output.lightPos[i] = lightPosition[i].xyz - worldPosition.xyz; // 빛의 방향만이 중요하므로 벡터를 정규화 output.lightPos[i] = normalize(output.lightPos[i]); } // 계산된 모든 데이터를 담은 output 객체를 픽셀 셰이더로 반환 // 이 값들은 래스터라이저에 의해 각 픽셀에 맞게 보간(interpolated) return output; } . 정점 셰이더는 각 정점에 대해 다음의 작업을 수행 . | 정점의 위치를 월드, 뷰, 투영 행렬을 이용해 2D 화면 좌표로 변환 | 정점의 법선 벡터(Normal)를 월드 공간으로 변환 | 각 정점에서 여러 개의 포인트 라이트를 향하는 빛 벡터를 계산하고 정규화 | 위에서 계산된 값들을 픽셀 셰이더로 넘김 | . Pixel Shader . // 처리할 포인트 라이트의 개수를 4개로 정의 (정점 셰이더와 일치해야 함) #define NUM_LIGHTS 4 // GLOBALS // C++ 애플리케이션에서 전달받는 텍스처와 샘플러 Texture2D shaderTexture : register(t0); // 모델의 표면에 입힐 텍스처 SamplerState SampleType : register(s0); // 텍스처를 샘플링(색상 추출)하는 방법을 정의 // C++ 애플리케이션에서 전달받는 포인트 라이트의 색상 버퍼 cbuffer LightColorBuffer { float4 diffuseColor[NUM_LIGHTS]; // NUM_LIGHTS 개수만큼의 난반사 색상 }; // TYPEDEFS // 픽셀 셰이더의 입력 구조체. 정점 셰이더의 출력과 동일 // 각 값들은 픽셀 위치에 맞게 보간된 값 struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 lightPos[NUM_LIGHTS] : TEXCOORD1; // 보간된 빛의 방향 벡터 }; float4 LightPixelShader(PixelInputType input) : SV_TARGET { float4 textureColor; // 텍스처에서 읽어온 픽셀의 기본 색상 float lightIntensity[NUM_LIGHTS]; // 각 광원에 대한 빛의 세기 float4 colorArray[NUM_LIGHTS]; // 각 광원이 만드는 색상 float4 colorSum; // 모든 광원의 색상을 합산한 결과 float4 color; // 최종 픽셀 색상 int i; // 1. 텍스처 샘플링 // 보간된 텍스처 좌표(input.tex)를 사용하여 텍스처의 색상을 가져옴 textureColor = shaderTexture.Sample(SampleType, input.tex); // 2. 각 광원에 대한 조명 계산 (반복문) for(i=0; i&lt;NUM_LIGHTS; i++) { // 3. 난반사(Diffuse) 강도 계산 // 보간된 법선 벡터(input.normal)와 보간된 빛 방향 벡터(input.lightPos)를 내적(dot) // 내적 결과는 두 벡터가 이루는 각도의 코사인 값으로, 빛을 얼마나 정면으로 받는지를 나타냄 // saturate() 함수는 결과를 0과 1 사이로 제한하여 음수 값이 나오는 것을 방지 lightIntensity[i] = saturate(dot(input.normal, input.lightPos[i])); // 4. 각 광원의 색상 결정 // 해당 광원의 난반사 색상(diffuseColor)에 빛의 세기를 곱함 colorArray[i] = diffuseColor[i] * lightIntensity[i]; } // 5. 조명 색상 합산 준비 // 색상을 더하기 위한 초기값으로 검은색을 설정 colorSum = float4(0.0f, 0.0f, 0.0f, 1.0f); // 6. 모든 광원의 색상 합산 for(i=0; i&lt;NUM_LIGHTS; i++) { colorSum.r += colorArray[i].r; colorSum.g += colorArray[i].g; colorSum.b += colorArray[i].b; } // 7. 최종 픽셀 색상 계산 // 합산된 조명 색상(colorSum)과 텍스처의 기본 색상(textureColor)을 곱함 // saturate()를 통해 최종 결과가 [0, 1] 범위를 벗어나지 않도록 함 color = saturate(colorSum) * textureColor; // 최종 계산된 픽셀의 색상을 반환 return color; } . | 텍스처에서 현재 픽셀에 해당하는 색상(기본 색상)을 샘플링 | 보간된 법선 벡터와 보간된 빛 벡터를 사용하여 각 포인트 라이트에 대한 난반사(Diffuse) 조명 강도를 계산 | 모든 포인트 라이트의 조명 효과를 합산 | 합산된 조명 색상과 텍스처의 기본 색상을 곱하여 최종 픽셀 색상을 결정 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#hlsl-code-sample-%EA%B0%90%EC%87%A0-x",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#hlsl-code-sample-감쇠-x"
  },"607": {
    "doc": "9. Multiple Point Lights",
    "title": "Clarity Notes",
    "content": "공부하며 헷갈렸던 부분 명료화 하기 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#clarity-notes",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#clarity-notes"
  },"608": {
    "doc": "9. Multiple Point Lights",
    "title": "Call shader",
    "content": "쉐이더가 불리는 횟수가 궁금함 . 오브젝트 하나가 있다고 할 때, 오브젝트의 버텍스가 300개라면 . | 버텍스 셰이더는 300번 호출 | 픽셀 셰이더는 300번보다 훨씬 많이 호출 | . 버텍스 셰이더 (Vertex Shader) . 버텍스 셰이더는 오브젝트를 구성하는 모든 정점(Vertex)의 개수만큼 정확하게 호출 . | 오브젝트의 버텍스가 300개라면, GPU는 300개의 버텍스 데이터 각각에 대해 버텍스 셰이더를 한 번씩 실행 | 버텍스 셰이더의 역할은 이 300개의 정점 위치를 3D 공간에서 2D 화면으로 옮기는 것이 주된 목적 | . 픽셀 셰이더 (Pixel Shader) . 픽셀 셰이더는 버텍스 개수와는 직접적인 관련이 없음 . | 픽셀 셰이더는 최종적으로 렌더링될 화면에 그려질 픽셀(Pixel)의 개수만큼 호출 | . | 정점 처리: 버텍스 셰이더가 300개의 버텍스를 처리하여 2D 화면상의 위치를 결정 . | 예를 들어, 300개의 버텍스가 모여 100개의 삼각형(Triangle)을 이룬다고 가정 | . | 래스터화 (Rasterization): GPU는 이 100개의 삼각형이 화면에서 차지하는 영역을 계산 . | 그리고 그 영역을 픽셀 단위로 채웁니다. 이 과정을 ‘래스터화’라고 함 | . | 픽셀 처리: 픽셀 셰이더는 바로 이 래스터화된 모든 픽셀 각각에 대해 한 번씩 호출 | . | 오브젝트 | 300개의 버텍스 | 오브젝트가 최종 화면에서 가로 200픽셀, 세로 300픽셀 크기의 영역을 차지한다고 가정 | . 이 경우, 래스터화 단계에서 이 영역은 약 200 * 300 = 60,000개의 픽셀로 채워짐 . | 따라서 픽셀 셰이더는 약 60,000번 호출되어 각 픽셀의 색상을 계산 | . 결론 . | 버텍스 셰이더 호출 횟수 = 모델의 총 버텍스 개수 | 픽셀 셰이더 호출 횟수 = 모델이 화면에 그려지는 최종 픽셀의 개수 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#call-shader",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/9.%20Multiple%20Point%20Lights.html#call-shader"
  },"609": {
    "doc": "APlayerController",
    "title": "APlayerController",
    "content": "플레이어의 입력(Input)을 받아 액터(주로 Pawn/Character)를 조작하는 역할을 담당하는 클래스 . | doc - APlayerController | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/APlayerController.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/APlayerController.html"
  },"610": {
    "doc": "Actor Component",
    "title": "Actor Component",
    "content": "Actor는 레벨에 출력되는 기본 단위이다. 이 Actor에 Component를 붙여 세부 기능을 추가할 수 있다 . | 컴포넌트란 액터의 부품으로 작동하며, 기능을 추가하는 모듈이다 (예: 메시, 충돌체, AI 로직 등) | Actor는 컴포넌트 시스템을 통해 기능을 확장할 수 있다 | . 참고하면 좋은 링크 . | Components | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html"
  },"611": {
    "doc": "Actor Component",
    "title": "컴포넌트 클래스 상속 구조",
    "content": "UObject (최상위 베이스 클래스) ├── UActorComponent (모든 컴포넌트의 기본 클래스) │ └── USceneComponent (변환(위치/회전/스케일)을 가진 컴포넌트) │ ├── UPrimitiveComponent (시각적 표현과 물리적 상호작용 가능) │ │ ├── UMeshComponent (메시 기반 컴포넌트) │ │ │ ├── UStaticMeshComponent (정적 메시 렌더링) │ │ │ └── USkeletalMeshComponent (스켈레탈 메시 렌더링) │ │ └── ULightComponent (광원 컴포넌트) │ └── UCameraComponent (카메라 기능 제공) └── AActor (월드에 배치 가능한 객체) └── APawn (플레이어 또는 AI가 제어할 수 있는 액터) └── ACharacter (캐릭터 특화 액터) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#컴포넌트-클래스-상속-구조"
  },"612": {
    "doc": "Actor Component",
    "title": "UActorComponent",
    "content": "가장 기본적인 컴포넌트로, 논리적 기능만 제공 . 액터 컴포넌트는 액터에 추가하여 동작을 확장할 수 있다 . 사용 사례 . | 데이터 관리 | 타이머 기반 로직 | 네트워크 동기화가 필요한 기능 | . 특징 . | 변환(Transform) 정보 없음 | 렌더링 기능 없음 | . // UHealthComponent.h UCLASS() class UHealthComponent : public UActorComponent { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) float MaxHealth = 100.0f; UFUNCTION() void TakeDamage(float Damage); }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uactorcomponent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uactorcomponent"
  },"613": {
    "doc": "Actor Component",
    "title": "USceneComponent",
    "content": "위치, 회전, 스케일 정보를 가짐 . | 위치(location): Fvector | 회전(rotation): FRotator | 크기(scale): FVector | . GetActorLocation() : Root Compoent인 SceneComponent에서 위치 가져옴 . 사용 사례 . | 계층 구조 형성 (부모-자식 관계) | 다른 컴포넌트의 부모 역할 | 다른 컴포넌트에 Attachment 기능을 지원 | . 특징 . | 컴포넌트 간의 상대적 위치 지정 가능 | 액터의 RootComponent로 사용됨 | . Attachment . | 루트 구성요소가 이동하면 하위 SceneComponent도 같이 이동한다 | 루트와 하위 구성요소의 상대적인 거리는 항상 유지된다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uscenecomponent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uscenecomponent"
  },"614": {
    "doc": "Actor Component",
    "title": "Static Mesh Component",
    "content": "스태틱 매시 컴포넌트를 Root Component로 만들 수도 있다 . | UStaticMeshComponent는 USceneComponent를 상속받으므로 가능 | . StaticMesh 컴포넌트를 Root로 만들기 . | 블루프린트 에디터 열기 | 좌측 컴포넌트 패널의 Add 버튼 누르기 | StaticMesh 컴포넌트 선택 -&gt; Details 패널에서 Static Mesh로 쓸 모델링 선택 | StaticMesh 컴포넌트를 드래그 하여 SceneRoot에 드롭 | StaticMesh 컴포넌트가 Root 컴포넌트가 됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#static-mesh-component",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#static-mesh-component"
  },"615": {
    "doc": "Add Custom Delegate",
    "title": "목표: 콘텐트 브라우저 모듈을 로드하고 해당 모듈의 델리게이트 배열에 Custom 메뉴 델리게이트 추가하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%A1%9C%EB%93%9C%ED%95%98%EA%B3%A0-%ED%95%B4%EB%8B%B9-%EB%AA%A8%EB%93%88%EC%9D%98-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%B0%EC%97%B4%EC%97%90-custom-%EB%A9%94%EB%89%B4-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#목표-콘텐트-브라우저-모듈을-로드하고-해당-모듈의-델리게이트-배열에-custom-메뉴-델리게이트-추가하기"
  },"616": {
    "doc": "Add Custom Delegate",
    "title": "Pragma region",
    "content": ". | IDE에서 확장하거나 축소할 수 있는 코드 블록 지정 | 버튼을 통해 소스 코드 블록을 접었다 펼 수 있다 | . #pragma region 리전이름 void Test(){ // ... } #pragma endregion 리전이름 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region"
  },"617": {
    "doc": "Add Custom Delegate",
    "title": "InitCBMenuExtention() 함수 구현에 사용한 메서드",
    "content": "1. Module.GetAllPathViewContextMenuExtenders() . Content Browser의 폴더 뷰(경로 뷰)에서 우클릭 시 메뉴를 추가할 수 있도록 델리게이트(Extender) 리스트를 리턴해줌 . TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; GetAllPathViewContextMenuExtenders(); . | 반환값: . | TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; | 폴더 뷰 컨텍스트 메뉴 확장자(델리게이트) 리스트의 레퍼런스 | 이 리스트에 새로운 확장 델리게이트를 추가(Add) 하면, 폴더(경로) 우클릭 시 커스텀 메뉴가 동적으로 삽입됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-함수-구현에-사용한-메서드"
  },"618": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 리스트",
    "content": "언리얼에서는 기존 시스템을 건드리지 않고 사용자만의 기능을 쉽게 추가할 수 있도록 모듈 내부에 델리게이트 배열을 가지고 있다 . | 모듈별로 델리게이트 리스트가 있음 | 여기에 커스텀 델리게이트를 추가하면 이벤트 발생 시 엔진이 모든 델리게이트를 순회하여 호출함 | . | 모듈 | 확장 대상 | 델리게이트 리스트 함수 | . | FContentBrowserModule | 폴더(경로) 컨텍스트 메뉴 | GetAllPathViewContextMenuExtenders() | . | FContentBrowserModule | 에셋(파일) 컨텍스트 메뉴 | GetAllAssetViewContextMenuExtenders() | . | FContentBrowserModule | 컬렉션 컨텍스트 메뉴 | GetAllCollectionViewContextMenuExtenders() | . | FLevelEditorModule | 툴바 메뉴 | GetAllLevelEditorToolbarMenuExtenders() | . | FLevelEditorModule | 뷰포트 컨텍스트 메뉴 | GetAllLevelViewportContextMenuExtenders() | . | FLevelEditorModule | 레벨 에디터 컨텍스트 메뉴 | GetAllLevelEditorContextMenuExtenders() | . | FSequencerModule | 시퀀서 메뉴 | GetAddMenuExtensibilityManager() | . | FMainFrameModule | 메인 프레임 메뉴/툴바 | GetMainFrameMenuExtensibilityManager() | . | FBlueprintEditorModule | 블루프린트 툴바/메뉴 | GetMenuExtensibilityManager()GetToolbarExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 메뉴 | GetMenuExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 툴바 | GetToolbarExtensibilityManager() | . | FComponentAssetBrokerModule | 에디터 에셋 관련 메뉴 | GetAssetBrokerMenuExtensibilityManager() | . 폴더(경로) 메뉴 확장 델리게이트 등록 예시 . void RegisterContentBrowserFolderMenuExtender() { // 1. ContentBrowser 모듈 인스턴스 획득 FContentBrowserModule&amp; ContentBrowserModule = FModuleManager::LoadModuleChecked&lt;FContentBrowserModule&gt;(TEXT(\"ContentBrowser\")); // 2. 폴더 뷰 컨텍스트 메뉴 델리게이트 리스트 획득 TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; Extenders = ContentBrowserModule.GetAllPathViewContextMenuExtenders(); // 3. 사용자 델리게이트 생성 (람다 예시) FContentBrowserMenuExtender_SelectedPaths MyFolderMenuExtender = FContentBrowserMenuExtender_SelectedPaths::CreateLambda( [](const TArray&lt;FString&gt;&amp; SelectedPaths) -&gt; TSharedRef&lt;FExtender&gt; { TSharedRef&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); // 여기서 Extender-&gt;AddMenuExtension 등으로 커스텀 메뉴 항목을 추가 return Extender; } ); // 4. 델리게이트 리스트에 등록 (Add) Extenders.Add(MyFolderMenuExtender); } . 2. FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate . 콘텐츠 브라우저(Content Browser)의 컨텍스트 메뉴를 확장하기 위해 사용되는 델리게이트 타입 . | GetAllPathViewContextMenuExtenders()가 리턴하는 타입으로 델리게이트 타입 추론 가능 | 해당 타입의 정의를 가보면 반환값, 파라미터를 설명한 델리게이트 매크로를 볼 수 있음 | . 3. CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender) . 델리게이트에서 제공하는 여러 바인딩 메서드를 사용해 바인딩 할 수 있다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-리스트"
  },"619": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 바인딩 케이스",
    "content": "Case 1 : 명시적 변수 선언 + 바인딩 + 델리게이트 배열에 추가 . // 델리게이트 객체 선언 FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate; // 델리게이트를 통해 내가 쓸 커스텀 함수에 바인딩 CustomCBMenuDelegate.BindRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender); // 모듈의 델리게이트 배열에 내 함수를 바인딩한 델리게이트 추가 ContentBroswerModuleMenuExtenders.Add(CustomCBMenuDelegate); . | 가독성: delegate 선언 → 바인딩 → 추가, 각각의 단계가 명확하게 분리됨 | 디버깅 용이: 바인딩된 delegate를 변수로 직접 디버깅/추적/조작할 수 있음 | . Case 2 : CreateRaw()로 delegate 생성과 배열 추가 한번에 하기 . ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); . | 델리게이트 시스템에서 제공하는 정적 메서드 CreateRaw()로 생성과 배열 추가 한번에 가능 | 임시 변수가 없음: delegate 객체가 따로 이름을 가지지 않음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%BC%80%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-바인딩-케이스"
  },"620": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 static 생성 메서드",
    "content": "언리얼 델리게이트 타입이 아래 메서드들을 일관되게 제공 . 1. Raw 포인터 바인딩 . CreateRaw( RawObjectPtr, &amp;Class::Method ) FMyDelegate::CreateRaw(this, &amp;MyClass::Handler) . | 비-UObject C++ 클래스용 | . 2. UObject 바인딩 (자동 수명 관리) . CreateUObject( UObject*, &amp;UClass::Method ) FMyDelegate::CreateUObject(this, &amp;AMyActor::EventHandler) . | 가비지 컬렉션 대상 객체용 | . 3. 스마트 포인터 바인딩 . CreateSP( SharedPtr, &amp;Class::Method ) FMyDelegate::CreateSP(MySharedPtr.ToSharedRef(), &amp;FMyClass::Callback) . | TSharedPtr/TSharedRef와 함께 사용 | . 4. 스레드-안전 약한 포인터 . CreateThreadSafeSP( WeakPtr, &amp;Class::Method ) FMyDelegate::CreateThreadSafeSP(MyWeakPtr.Pin(), &amp;FMyClass::ThreadCallback) . | 멀티스레드 환경용 | . 5. 람다 함수 바인딩 . CreateLambda( []{ ... } ) FMyDelegate::CreateLambda([this](){ UE_LOG(LogTemp, Warning, TEXT(\"Lambda called!\")); . | 인라인 콜백 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-static-%EC%83%9D%EC%84%B1-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-static-생성-메서드"
  },"621": {
    "doc": "Add Custom Delegate",
    "title": "Add Custom Delegate",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html"
  },"622": {
    "doc": "Add Prifixes To Assets",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 클래스에 맞는 접두사(예: BP_) 붙이기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%A0%91%EB%91%90%EC%82%AC%EC%98%88-bp_-%EB%B6%99%EC%9D%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#목표-콘텐트-폴더에서-선택한-에셋-클래스에-맞는-접두사예-bp_-붙이기"
  },"623": {
    "doc": "Add Prifixes To Assets",
    "title": "Add Prifixes To Assets",
    "content": ". | TMap&lt;UClass*, FString&gt; PrefixMap 에 Prifixes 목록 작성 . | 예: {UBlueprint::StaticClass(),TEXT(\"BP_\")} | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html"
  },"624": {
    "doc": "Add Prifixes To Assets",
    "title": "add Prifixes 함수 구현에 사용한 메서드",
    "content": "1. UObject* S-&gt;GetClass()-&gt;GetName() . | 클래스 이름을 반환 . | (예: “AActor”, “UMyComponent”) | . | 해당 오브젝트가 어떤 클래스로 생성되었는지 알 수 있음 | . 2. UObject* S-&gt;GetName() . | 오브젝트 인스턴스의 이름을 반환 . | (예: “Player_123”, “Weapon_Sword”) | . | 에디터에서 부여한 이름이나 동적으로 생성된 이름이 반환 | . AActor* MyActor = GetWorld()-&gt;SpawnActor&lt;AActor&gt;(...); FString ClassName = MyActor-&gt;GetClass()-&gt;GetName(); // \"AActor\" FString InstanceName = MyActor-&gt;GetName(); // \"MyActor_42\" . 3. FString::StartsWith() . | 문자열이 특정 문자열로 시작하는지 여부를 bool로 반환 | 대소문자 구분 여부 선택 옵션 존재 | 주의 : InPrefix가 빈 문자열이면 항상 true를 반환 | . 함수 시그니처 . bool StartsWith( const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . 사용 예시 . FString FilePath = \"Content/Textures/PlayerTexture.png\"; // 대소문자 무시 (기본값) bool bIsContent = FilePath.StartsWith(\"Content\"); // true // 대소문자 구분 bool bIsExact = FilePath.StartsWith(\"content\", ESearchCase::CaseSensitive); // false // 실제 활용 예시 if (FilePath.StartsWith(\"Content/Textures/\")) { UE_LOG(LogTemp, Warning, TEXT(\"텍스처 경로가 유효합니다.\")); } . 4. FString::RemoveFromStart . | 대상 문자열의 앞부분이 특정 문자열로 시작할 경우, 해당 부분을 제거 | . bool RemoveFromStart(const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase); . | 매개변수 . | InPrefix: 앞에서 제거하고자 하는 문자열(접두사, Prefix) | SearchCase: 대소문자 구분 여부 (ESearchCase::IgnoreCase 또는 ESearchCase::CaseSensitive) | . | 반환값 . | 제거 성공 true / 실패 false | . | . 5. FString::RemoveFromEnd . | 대상 문자열의 끝이 특정 문자열로 끝날 경우, 해당 부분을 제거 | 위 메서드와 동일하게 뒤에서 제거하고자 하는 문자열과 대소문자 구분 여부를 받는다. | . FString Str = TEXT(\"HelloWorld\"); bool bRemoved = Str.RemoveFromEnd(TEXT(\"World\")); // Str은 \"Hello\"가 되고, bRemoved는 true FString Str2 = TEXT(\"HelloWorld\"); bool bRemoved2 = Str2.RemoveFromEnd(TEXT(\"Hi\")); // Str2는 그대로 \"HelloWorld\", bRemoved2는 false . 6. UObject::IsA() . | 해당 오브젝트가 특정 클래스 타입이거나 그 클래스의 자식 클래스인지를 확인하는 메서드 | 비슷한 경우로 IsA(UClass*) 가 있다 | . 예시 . // IsA&lt;T&gt;() template&lt;typename T&gt; FORCEINLINE bool IsA() const { return IsA(T::StaticClass()); } if (SelectedObject-&gt;IsA&lt;UMaterialInstanceConstant&gt;()) { // UMaterialInstanceConstant 타입일 때 실행 } // IsA() bool IsA(const UClass* TargetClass) const; if (SelectedObject-&gt;IsA(AActor::StaticClass())) { UE_LOG(LogTemp, Warning, TEXT(\"이 오브젝트는 Actor입니다!\")); } . ❓ 왜 머티리얼 인스턴스 클래스를 찾으려면 UMaterialInstanceConstant를 사용해야 할까? . | 계층구조 UMaterialInterface (베이스) ├─ UMaterial (실제 마테리얼 에셋) └─ UMaterialInstance (인스턴스 베이스) ├─ UMaterialInstanceDynamic (런타임 생성 인스턴스) └─ UMaterialInstanceConstant (에디터에서 생성된 인스턴스) . | . | UMaterialInstance . | 추상 베이스 클래스. 직접 인스턴스화되지 않음 | . | UMaterialInstanceConstant . | 에디터에서 미리 생성해 놓은 정적 마테리얼 인스턴스 | 런타임 중 파라미터 변경이 불가능 | . | UMaterialInstanceDynamic (MID) . | 런타임에 동적으로 생성되며, 파라미터를 실시간으로 변경할 수 있음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-함수-구현에-사용한-메서드"
  },"625": {
    "doc": "Asset Batch Duplication",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 복사하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#목표-콘텐트-폴더에서-선택한-에셋-복사하기"
  },"626": {
    "doc": "Asset Batch Duplication",
    "title": "Scripting Libraries",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries"
  },"627": {
    "doc": "Asset Batch Duplication",
    "title": "1. UEditorUtilityLibrary::",
    "content": "에디터에서 에셋(Asset) 관련 작업을 자동화하기 위한 기능 제공 . | 에셋의 로드, 저장, 복사, 이동, 삭제 등 파일 시스템 수준의 작업 | 에셋 메타데이터(metadata) 접근 및 수정 | 에셋 의존성(dependencies) 분석 | 에셋 브라우저(Content Browser)와 연동된 작업 | . 메소드 . | GetSelectedAssetData() : TArray&lt;FAssetData&gt;를 반환 | GetSelectedAssets() : TArray&lt;UObject*&gt;를 반환 . | FAssetData는 UObject* 보다 더 많은 정보를 포함 | . | 모두 static 함수임 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary"
  },"628": {
    "doc": "Asset Batch Duplication",
    "title": "2. UEditorAssetLibrary:: 클래스",
    "content": "에디터 UI 및 일반 유틸리티 작업을 지원 . | 선택된 객체(Selected Actors/Assets)에 접근 | 에디터 UI(알림, 다이얼로그) 제어 | 월드/레벨 편집과 관련된 작업 | 블루프린트/파이썬 스크립트와의 연동 용이 | . 정리 . | 에디터 상호작용 (선택된 객체 제어, 알림 표시, 다이얼로그 생성) → UEditorUtilityLibrary | 에셋 작업 (일괄 임포트, 이름 변경, 메타데이터 편집) → UEditorAssetLibrary | . | UEditorUtilityLibrary로 선택한 에셋을 가져온 후 UEditorAssetLibrary로 해당 에셋을 수정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-클래스"
  },"629": {
    "doc": "Asset Batch Duplication",
    "title": ".uasset",
    "content": "Unreal Engine이 에디터에서 사용하는 에셋(데이터) 저장 파일 포맷 (파일 확장자) . | 모든 에셋은 UObject를 상속한 특정 클래스(예: UMaterial, UStaticMesh 등)로 만들어진다 | 에디터에서 만드는 에셋은 각기 다른 UObject 파생 클래스의 인스턴스가 디스크에 .uasset으로 저장된 것 . | BP_NewBlueprint.uasset | MyMaterial.uasset | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset"
  },"630": {
    "doc": "Asset Batch Duplication",
    "title": "객체 식별",
    "content": ". | Asset Name: 에셋(객체) 이름. 에디터에서 보이는 에셋의 이름 . | (예: BP_NewBluePrint) | . | Package Path: 에셋이 저장된 폴더 경로 + 에셋 이름 . | (예:/Game/MyFolder/BP_NewBluePrint) | ‘패키지’란 언리얼에서 하나의 저장 단위 | 하나의 .uasset 파일 = 하나의 패키지 . | 패키지 파일(.uasset) 안에는 여러 객체(에셋)가 저장 될 수 있음 | . | 패키지 경로는 항상 /로 시작 | 패키지 경로에는 .uasset 확장자가 포함되지 않음 | . | Object Path: 패키지 경로 + .에셋(객체) 이름 . | (예: /Game/MyFolder/BP_NewBluePrint.BP_NewBlueprint) | 패키지 내부에는 여러 객체가 있을 수 있으므로, 반드시 객체 이름까지 명시해야 객체를 특정할 수 있다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EA%B0%9D%EC%B2%B4-%EC%8B%9D%EB%B3%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#객체-식별"
  },"631": {
    "doc": "Asset Batch Duplication",
    "title": "duplicate 함수 구현에 사용한 메서드",
    "content": "1..ToString() . | FString, FName, FText, FVector, FGuid 등 일부 엔진 주요 클래스에서 각 타입에 맞는 방식으로 문자열 변환 | . 2.FString::FromInt() . | 정수형 값을 FString 객체로 변환하는 정적(static) 메서드 . | 매개변수 . | int32 Value: 변환할 정수 값 | . | 반환값 . | FString: 정수를 문자열로 변환한 결과 | . | . int32 Number = 42; FString Str = FString::FromInt(Number); // \"42\" . 3.FPaths::Combine() . | 여러 개의 경로 문자열을 OS별로 올바른 구분자로 결합해 하나의 경로 문자열로 만듦. | 내부적으로 /, \\ 자동 정리 | . | 매개변수 . | 오버로드가 많으나, 대표적으로 다음과 같은 버전 | const FString&amp; PathA, const FString&amp; PathB | . | 반환값 . | FString: 결합된 경로 문자열 | . | . FString FullPath = FPaths::Combine(TEXT(\"C:/Project\"), TEXT(\"Content\"), TEXT(\"Textures\")); // \"C:/Project/Content/Textures\" . 4.UEditorAssetLibrary::DuplicateAsset() . | 에디터 전용 라이브러리 함수. Content Browser에서 특정 자산(에셋)을 지정 경로로 복제(복사)함 . | 매개변수 . | const FString&amp; SourceAssetPath: 원본 자산의 경로 . | (예: “/Game/StarterContent/Textures/T_Wood”) | . | const FString&amp; DestinationAssetPath: 복제될 위치의 경로 . | (예: “/Game/MyFolder/T_Wood_Copy”) | . | . | 반환값 . | UObject*: 복제된 자산의 포인터 . | (복제 실패 시 nullptr 반환) | . | . | . UObject* Duplicated = UEditorAssetLibrary::DuplicateAsset(TEXT(\"/Game/AssetA\"), TEXT(\"/Game/Folder/AssetB\")); if (Duplicated) { /* 성공 */ } . 5.UEditorAssetLibrary::SaveAsset() . | 에디터에서 지정한 자산(에셋)을 디스크에 저장 . | 매개변수 . | const FString&amp; AssetPath: 저장할 자산의 경로 (예: “/Game/MyFolder/AssetB”) | . | 반환값 . | bool (true: 저장 성공 / false: 저장 실패) | . | . bool bSaved = UEditorAssetLibrary::SaveAsset(TEXT(\"/Game/MyFolder/AssetB\")); . 6.TEXT() . | C++의 문자열 리터럴을 엔진 내부 문자 타입(TCHAR)로 변환하는 매크로 . | TEXT() 매크로는 C++의 매크로 전처리 기능을 사용 | . | . FString MyString = TEXT(\"Hello\"); // ↓ 매크로 확장 후 FString MyString = L\"Hello\"; // C++ 컴파일러가 처리할 코드 생성 . | L”Hello” : UTF-16/유니코드 문자열 리터럴로 컴파일 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-함수-구현에-사용한-메서드"
  },"632": {
    "doc": "Asset Batch Duplication",
    "title": "Custom Editor Message",
    "content": ". | FMessageDialog를 사용해 메시지 대화 상자 출력하기 (모달) | FNotificationInfo를 사용해 알림 정보 출력하기 (오른쪽 하단에 나타나는 비동기 알림) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message"
  },"633": {
    "doc": "Asset Batch Duplication",
    "title": "FMessageDialog",
    "content": ". | 에디터 환경에서 사용자에게 메시지 박스(모달 대화상자)를 띄울 때 사용하는 유틸리티 클래스 | core 소속 | 블로킹(Blocking) 방식으로, 다이얼로그가 닫히기 전까지 다음 코드가 실행되지 않음 | 정적(static) 메서드로만 구성 | . 1. FMessageDialog::Open(EAppMsgType::Type MsgType, const FText&amp; Message) . | 지정한 메시지 유형과 메시지 텍스트로 다이얼로그 표시 | . 2. EAppReturnType::Type . EAppReturnType::Type ShowMsgDialog( EAppMsgType::Type MsgType, const FString&amp; Message, bool bShowMsgAsWarning = true ) . | MsgType: 메시지 박스 버튼 조합(Ok, YesNo 등) 지정 | Message: 출력할 메시지 문자열 | bShowMsgAsWarning: 경고(Warning) 스타일로 메시지를 띄울지 여부, 기본값 true . | true면 경고 스타일(노란색 경고 아이콘, “Warning” 타이틀 등)로 표시 | false면 일반 정보 스타일(파란색 info 아이콘, “Message” 또는 “Info” 타이틀 등)로 표시 | . | . EAppMsgType::Type 정리 . | 타입 | 다이얼로그 버튼 조합 | 대표적 사용 상황 | . | Ok | OK | 단순 확인, 정보 알림 | . | YesNo | Yes / No | 선택(이행/거부) | . | YesNoCancel | Yes / No / Cancel | 저장 여부 등 3분기 선택 | . | OkCancel | OK / Cancel | 진행/중단 | . | CancelRetryContinue | Cancel / Retry / Continue | 재시도 여부(예: 파일 저장 실패) | . | YesNoYesAllNoAll | Yes / No / Yes to All / No to All | 여러 작업에 대해 일괄 처리 | . | YesNoYesAllNoAllCancel | Yes / No / Yes to All / No to All / Cancel | 여러 파일 작업에서 개별/일괄/취소 | . | YesNoCancelContinue | Yes / No / Cancel / Continue | 드문 복합적 분기 | . | YesNoYesAllNoAllCancelContinue | Yes / No / Yes to All / No to All / Cancel / Continue | 매우 복잡한 결정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog"
  },"634": {
    "doc": "Asset Batch Duplication",
    "title": "FNotificationInfo",
    "content": ". | 에디터 하단 (주로 오른쪽 아래)에 잠시 나타나는 비동기 알림(Notification Toast) 정보를 정의하는 구조체 | FSlateNotificationManager를 통해 실제 알림을 생성/표시 | slate 소속 | . FNotificationInfo Info(FText::FromString(TEXT(\"작업이 완료되었습니다.\"))); Info.bFireAndForget = true; Info.ExpireDuration = 2.0f; // 2초 후 자동 닫힘 Info.bUseThrobber = false; // 스피너 비표시 FSlateNotificationManager::Get().AddNotification(Info); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo"
  },"635": {
    "doc": "Asset Batch Duplication",
    "title": "Asset Batch Duplication",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html"
  },"636": {
    "doc": "Binding Funcionts",
    "title": "목표: hook을 사용해 메뉴 엔트리, 메뉴 항목, 사용할 함수 바인딩 하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EB%AA%A9%ED%91%9C-hook%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%A9%94%EB%89%B4-%EC%97%94%ED%8A%B8%EB%A6%AC-%EB%A9%94%EB%89%B4-%ED%95%AD%EB%AA%A9-%EC%82%AC%EC%9A%A9%ED%95%A0-%ED%95%A8%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#목표-hook을-사용해-메뉴-엔트리-메뉴-항목-사용할-함수-바인딩-하기"
  },"637": {
    "doc": "Binding Funcionts",
    "title": "에디터에서 Extension hook 보기",
    "content": ". | 언리얼 에디터 툴바에서 편집 클릭 | 하단 환경설정의 에디터 환경설정 클릭 | 에디터 환경설정 창의 검색에 ui extension 입력 | Developer Tools의 Display UI Extension Points 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-extension-hook-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#에디터에서-extension-hook-보기"
  },"638": {
    "doc": "Binding Funcionts",
    "title": "FExtender와 FExtensionBase의 동작 원리 이해하기",
    "content": ". | FExtender = 각각의 FExtensionBase 정보를 통합 | FExtensionBase = 메뉴, 툴바 등 실제 확장 정보 데이터 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender%EC%99%80-fextensionbase%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender와-fextensionbase의-동작-원리-이해하기"
  },"639": {
    "doc": "Binding Funcionts",
    "title": "FExtensionBase",
    "content": "언리얼 엔진 Slate UI에서 메뉴/툴바 확장 시스템에서 사용하는 기본 추상 베이스 클래스 . | 실질적인 메뉴/툴바 확장 정보를 가지고 있음 | . class FExtensionBase { public: /** 멤버가 제대로 정리되도록 가상 소멸자가 필요함 */ virtual ~FExtensionBase() { } /** @return 확장 객체의 유형을 반환합니다. 파생 클래스에서 구현하세요 */ virtual EExtensionType::Type GetType() const = 0; /** 확장 포인트의 ID */ FName Hook; /** 확장 지점과 관련하여 후크할 위치 */ EExtensionHook::Position HookPosition; /** UI에 추가되는 액션에 사용할 커맨드 목록 */ TSharedPtr&lt; FUICommandList &gt; CommandList; }; . 주요 파생 클래스들 . 주요 파생 클래스들에는 델리게이트까지 추가됨 . | FMenuExtension : 메뉴 확장 구현 | FToolBarExtension : 툴바 확장 구현 | FMenuBarExtension : 메뉴 바 확장 구현 | . | 인자 | 역할 | 설명 | . | FName Hook | 확장 위치 지정 | 어떤 Hook(지점) 근처에 엔트리를 추가할지(예: “Delete”) | . | EExtensionHook::Position HookPosition | 상대 위치 | Hook 기준 Before/After/First 중 어디에 넣을지 | . | const TSharedPtr&lt;FUICommandList&gt;&amp; CommandList | 커맨드 집합 | 메뉴 엔트리의 활성/실행/단축키/상태 관리용, 없으면 nullptr | . | const FMenuExtensionDelegate&amp; MenuExtensionDelegate | 생성 콜백 | 실제로 메뉴 엔트리 Slate 위젯을 추가하는 함수/람다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase"
  },"640": {
    "doc": "Binding Funcionts",
    "title": "FExtender",
    "content": "여러 소스에서 메뉴/툴바에 엔트리를 동적으로 삽입할 때, 각각의 확장 요청을 병합하는 기능을 담당 . | 여러 소스에서 반환한 확장 요청을 실제 Slate UI에 적용하기 전 단일 리스트로 통합 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender"
  },"641": {
    "doc": "Binding Funcionts",
    "title": "FExtender 동작 과정",
    "content": "1. 확장자 생성 . TSharedPtr&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); . | 빈 FExtender 컨테이너 생성 | . 2. 확장 항목 생성 및 등록 . MenuExtender-&gt;AddMenuExtension( FName(\"Delete\"), // 확장 지점 (예: 컨텐트 폴더 우클릭 창의 삭제) EExtensionHook::After, // 위치 (예: 삭제 항목 다음에 추가) TSharedPtr&lt;FUICommandList&gt;(), // 명령 처리기 (단축키 설정) FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry) // 메뉴 엔트리 생성 함수 ); . | AddMenuExtension 호출 시 새로운 FMenuExtension 인스턴스 생성 | FMenuExtension 인스턴스는 아래 정보 저장 . | 확장 지점 이름(FName(“Delete”)) | 위치 정보(After) | 연결된 명령 리스트 | 메뉴 생성 델리게이트 | . | 생성된 객체는 FExtender의 내부 배열에 저장 . | TArray&lt; TSharedPtr&lt; const FExtensionBase &gt; &gt; Extensions | . | . FExtender 다이어그램 . 3. 실제 메뉴 생성 . 사용자가 콘텐트 폴더를 우클릭하면 Slate가 FExtender::Apply()를 호출 . | FExtender의 Extensions를 순회하면서 조건에 맞는 확장 지점 찾음 | 해당 지점에 등록된 모든 FExtensionBase 파생 객체 순회 | 각 확장의 HookPosition에 따라 적절한 위치에 메뉴 항목 삽입 | 파생 객체의 delegate를 실행해 메뉴/툴바에 실제 메뉴 항목 생성 | 확장 해제(RemoveExtension) 가능 . | 사용자가 직접 반환받은 FExtensionBase 핸들을 이용해 해당 확장 객체를 Extensions에서 제거 | . | . 확장 제거 . // 확장 제거 예시 TSharedRef&lt;const FExtensionBase&gt; MyExtension = Extender-&gt;AddMenuExtension(...); // ... Extender-&gt;RemoveExtension(MyExtension); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-동작-과정"
  },"642": {
    "doc": "Binding Funcionts",
    "title": "정리",
    "content": ". | 등록과 실행이 분리된다 . | 확장은 미리 등록만 해두고 실제로 필요할 때만 생성 (예: 메뉴가 열릴 때만 메뉴 항목 생성) | . | 확장 지점 기반으로 작동한다 . | 예: 같은 확장 지점 Delete에서 Before, After 생성 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#정리"
  },"643": {
    "doc": "Binding Funcionts",
    "title": "FMenuBuilder",
    "content": "FExtender와 함께 사용되어 컨텍스트 메뉴, 툴바 메뉴, 메인 메뉴 등을 구성 . | FExtender : “어디에 메뉴를 추가할지” 결정 | FMenuBuilder : “메뉴에 무엇을 추가할지” 정의 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder"
  },"644": {
    "doc": "Binding Funcionts",
    "title": "자유 사용되는 메서드",
    "content": "1. AddMenuEntry() . 기본 메뉴 항목 추가 . AddMenuEntry( FText::FromString(\"메뉴 항목\"), // 표시 이름 FText::FromString(\"툴팁 설명\"), // 툴팁 FSlateIcon(FAppStyle::GetStyleSetName(), \"Icons.Play\"), // 아이콘 FUIAction(FExecuteAction::CreateLambda([](){ /* 액션 로직 */ })) // 델리게이트 ); . FUIAction . Slate의 액션(메뉴 엔트리, 버튼 등)을 나타내는 컨테이너 구조체 -&gt; 통합적 관리 가능 . | 실행(FExecuteAction) : (void() 시그니처 콜백) . | 실행할 함수 | . | 활성화 가능 여부(FCanExecuteAction) : (bool() 시그니처 콜백, 선택적) . | 메뉴가 활성화되는지/비활성화되는지 | . | 체크 상태(FIsActionChecked) : (bool() 시그니처 콜백, 토글 메뉴/버튼용, 선택적) . | 체크(토글) 상태를 반영할지 말지 | . | . FExecuteAction만 단독 사용 . FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) . | 내부적으로 활성/체크 상태 등은 기본값으로 취급 | . 2. AddMenuSeparator() . 메뉴 항목 사이에 구분선을 추가 . AddMenuEntry(...); // 첫 번째 항목 AddMenuSeparator(); // ----- 구분선 ----- AddMenuEntry(...); // 두 번째 항목 . 3. AddWidget() . 커스텀 위젯 추가 / 체크박스, 슬라이더, 버튼 등 복잡한 UI를 메뉴에 삽입할 때 사용 . AddWidget( SNew(SCheckBox) .IsChecked(false) .OnCheckStateChanged_Lambda([](ECheckBoxState State){ /* 체크 상태 변경 */ }) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%9E%90%EC%9C%A0-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#자유-사용되는-메서드"
  },"645": {
    "doc": "Binding Funcionts",
    "title": "총 세번의 바인딩",
    "content": ". | 메뉴 엔트리 생성 위치(1차 바인딩) | . InitCBMenuExtention() { ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); } // CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); TSharedRef&lt;FExtender&gt; FBacgroundToolsModule::CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelectedPaths) { TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); if (SelectedPaths.Num() &gt; 0) { MenuExtender-&gt;AddMenuExtension(FName(\"Delete\"), EExtensionHook::After, TSharedPtr&lt;FUICommandList&gt;(), FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); } return MenuExtender; } . | 메뉴 항목의 모양 및 동작(2차 바인딩) | . // FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); void FBacgroundToolsModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder) { MenuBuilder.AddMenuEntry ( FText::FromString(TEXT(\"Delete Unused Assets\")), FText::FromString(TEXT(\"Safely delete all unused assets under folder\")), FSlateIcon(), FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) ); } . | 실제 실행할 함수(3차 바인딩) | . // FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) void FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked() { } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%B4%9D-%EC%84%B8%EB%B2%88%EC%9D%98-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#총-세번의-바인딩"
  },"646": {
    "doc": "Binding Funcionts",
    "title": "Binding Funcionts",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html"
  },"647": {
    "doc": "Component in C++",
    "title": "Component in C++",
    "content": "컴포넌트 등록을 c++로 해보자 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html"
  },"648": {
    "doc": "Component in C++",
    "title": "CDO (Class Default Object)",
    "content": "클래스의 기본 설정값을 가지는 싱글톤 객체 . 해당 클래스의 모든 인스턴스가 참조하는 템플릿 . ❓ CDO는 언제 생성돼? . | 게임/에디터 시작 시 UClass가 로드될 때 한 번만 생성 | 그 후 인스턴스를 생성할 때 마다 CDO를 참조해 프로퍼티를 복사 | 즉 UClass의 CDO는 기본값 정의이다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#cdo-class-default-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#cdo-class-default-object"
  },"649": {
    "doc": "Component in C++",
    "title": "특징",
    "content": ". | UClass별 유일 객체: 각 UClass당 하나만 존재 | 템플릿 역할: 새 객체 생성 시 CDO의 프로퍼티 값들이 기본값으로 복사됨 . | 인스턴스가 직접 CDO를 참조하는 구조 X, 복사 원본 역할 | . | 에디터 통합: 블루프린트/프로퍼티 윈도우에서 편집하는 값들이 CDO에 저장 | 메모리 효율: 모든 인스턴스가 공유하는 기본값을 중앙에서 관리 | . | CDO Constructor : 모든 인스턴스에 공통적으로 적용되는 설정 초기화 . | 월드 의존 로직 X (월드 내 위치 값 등), 인풋 바인딩 X (컨트롤러 미확정) | . | BeginPlay : 런타임에서 실제 게임이 시작될 때 호출 . | 게임 중 변하는 값은 BeginPlay에서 로드 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#특징"
  },"650": {
    "doc": "Component in C++",
    "title": "Default Sub Object",
    "content": "컴포넌트의 기본 서브 오브젝트 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#default-sub-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#default-sub-object"
  },"651": {
    "doc": "Component in C++",
    "title": "특징",
    "content": ". | 액터 클래스에 기본적으로 포함되는 서브 컴포넌트 | CDO에 귀속되어 저장되고 생성/관리됨 | CreateDefaultSubobject&lt;T&gt;() 로 생성 . | Type* 반환 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#특징-1"
  },"652": {
    "doc": "Component in C++",
    "title": "사용 예시",
    "content": "// 헤더 파일에서 선언 UPROPERTY(VisibleAnyWhere, Category=\"Components\") UStaticMeshComponent* MeshComp; // CPP 파일에서 생성 AMyActor::AMyActor() { MeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"MeshComp\")); MeshComp-&gt;SetupAttachment(RootComponent); // 컴포넌트 간 부모-자식 관계 설정 } // 혹은 바로 루트 컴포넌트로 설정 가능 AItem::AItem() { PrimaryActorTick.bCanEverTick = true; ItemMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"ItemMeshComponent\")); RootComponent = ItemMesh; } // 혹은 바로 루트 컴포넌트로 설정 가능 2 AItem::AItem() { PrimaryActorTick.bCanEverTick = true; ItemMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"ItemMeshComponent\")); SetRootComponent(ItemMesh); } . | MyActor()의 생성자는 CDO 생성 때 한 번만 실행됨 | 인스턴스 생성 시에는 CDO의 Default Subobject들이 복사되어 개별 인스턴스의 컴포넌트 트리로 초기화됨 . | 해당 클래스의 모든 인스턴스가 동일한 컴포넌트 트리를 갖도록 하는 기본 역할 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#사용-예시"
  },"653": {
    "doc": "Construct SButton",
    "title": "목표 : SListView 에 delete 버튼 생성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%AA%A9%ED%91%9C--slistview-%EC%97%90-delete-%EB%B2%84%ED%8A%BC-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#목표--slistview-에-delete-버튼-생성"
  },"654": {
    "doc": "Construct SButton",
    "title": "SButton",
    "content": "사용자 상호작용 (클릭, 호버 등)을 처리하는 클릭 가능한 버튼을 구현한 위젯 . | SPrimitiveButton을 상속 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton"
  },"655": {
    "doc": "Construct SButton",
    "title": "특징",
    "content": ". | 다양한 상호작용 상태 . | Normal 기본 | Hovered 호버 | Pressed 클릭 | Disabled 비활성 | . | 커스텀 콘텐츠 지원 : 텍스트, 아이콘, 복합 위젯 수용 가능 | 접근성 기능 : 키보드 포커스, 게임패드 네비게이션 지원 | 시각적 피드백 : 클릭 애니메이션, 상태별 스타일 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#특징"
  },"656": {
    "doc": "Construct SButton",
    "title": "생성 예시",
    "content": "TSharedRef&lt;SButton&gt; MyButton = SNew(SButton) .Text(LOCTEXT(\"Submit\", \"제출\")) .OnClicked(FOnClicked::CreateLambda([](){ UE_LOG(LogTemp, Warning, TEXT(\"Button Clicked!\")); return FReply::Handled(); })); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%83%9D%EC%84%B1-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#생성-예시"
  },"657": {
    "doc": "Construct SButton",
    "title": "동작 원리",
    "content": ". | SButton이 클릭/호버/누름 상태를 감지해 스타일을 변경 | 클릭 등 입력 이벤트 발생 시, Delegate(예: OnClicked)에 바인딩된 함수가 호출 | 버튼 내부에 포함된 Slate 위젯은 Slot에 넣는 방식으로 조합 가능 | 비활성(Disable) 상태는 입력 차단 및 스타일 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#동작-원리"
  },"658": {
    "doc": "Construct SButton",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-속성"
  },"659": {
    "doc": "Construct SButton",
    "title": ".OnClicked",
    "content": "버튼 클릭 시 호출될 델리게이트. 반드시 FReply를 반환 . SNew(SButton) .OnClicked(this, &amp;SMyWidget::OnButtonClicked) FReply SMyWidget::OnButtonClicked() { // 버튼 클릭 시 동작 구현 return FReply::Handled(); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onclicked",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onclicked"
  },"660": {
    "doc": "Construct SButton",
    "title": ".OnPressed",
    "content": "버튼이 눌리는 순간(마우스 다운 등)에 호출되는 델리게이트 . SNew(SButton) .OnPressed(this, &amp;SMyWidget::OnButtonPressed) void SMyWidget::OnButtonPressed() { // 버튼을 누르는 순간의 처리 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onpressed",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onpressed"
  },"661": {
    "doc": "Construct SButton",
    "title": ".OnReleased",
    "content": "버튼을 눌렸다가 뗄 때(마우스 업)에 호출되는 델리게이트 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onreleased",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onreleased"
  },"662": {
    "doc": "Construct SButton",
    "title": ".IsEnabled()",
    "content": "버튼의 활성/비활성(Enable/Disable) 상태를 지정 . SNew(SButton) .IsEnabled(true) // 항상 활성 // 동적 제어 예시 .IsEnabled(this, &amp;SMyWidget::IsButtonEnabled) bool SMyWidget::IsButtonEnabled() const { return bCanClickButton; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#isenabled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#isenabled"
  },"663": {
    "doc": "Construct SButton",
    "title": "SButton 속성 정리",
    "content": "| 속성명 | 설명 | 코드 예시 | . | .OnClicked | 버튼 클릭 시 호출될 델리게이트 (반환: FReply) | .OnClicked(this, &amp;SMyWidget::OnButtonClicked) | . | .OnPressed | 마우스 버튼 눌렀을 때 호출 | .OnPressed(this, &amp;SMyWidget::OnButtonPressed) | . | .OnReleased | 마우스 버튼 뗐을 때 호출 | .OnReleased(this, &amp;SMyWidget::OnButtonReleased) | . | .IsEnabled | 버튼 활성/비활성 바인딩 | .IsEnabled(bEnableButton) | . | .ContentPadding | 버튼 내부 패딩 | .ContentPadding(FMargin(10,5)) | . | .ButtonColorAndOpacity | 버튼 배경 색 및 투명도 | .ButtonColorAndOpacity(FLinearColor::Blue) | . | .ForegroundColor | 버튼 내부 컨텐츠(주로 텍스트) 색상 | .ForegroundColor(FLinearColor::White) | . | .HAlign | 내부 컨텐츠 수평 정렬 | .HAlign(HAlign_Center) | . | .VAlign | 내부 컨텐츠 수직 정렬 | .VAlign(VAlign_Center) | . | .Style | 버튼 스타일(FButtonStyle) 지정 | .Style(&amp;MyCustomStyle) | . | [ ... ] | 버튼 내부 컨텐츠 (STextBlock, SImage 등) | [SNew(STextBlock).Text(...)] | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton-속성-정리"
  },"664": {
    "doc": "Construct SButton",
    "title": "FReply",
    "content": "UI 입력 이벤트에 대한 처리 결과와 후속 동작을 Slate에 전달하는 응답 객체 . | SlateCore 모듈에 정의된 불변(Immutable) 객체 . | 불변 객체 : 생성 후 값이 변하지 않는 객체 | 체이닝 방식 (setter 메서드)은 내부적으로 새로운 객체를 복사, 반환 | 멀티스레드 환경에서 안전, 예측 가능한 동작 보장 | . | 대부분의 Slate 입력 이벤트 델리게이트(특히 OnClicked, OnMouseButtonDown 등)의 반환 타입 | 이벤트 버블링(Bubbling) 및 전파(Propagation) 제어 . | 이벤트 전파 방향: 하위 -&gt; 상위 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply"
  },"665": {
    "doc": "Construct SButton",
    "title": "특징",
    "content": ". | 체이닝 디자인: 메서드 체인으로 복합 동작 구성 가능 | 스레드 안전성: 모든 메서드가 const로 선언되어 재사용 가능 | 이벤트 라우팅: 입력 이벤트의 계층적 전파 제어 | 다양한 응답 타입: 핸들링 여부, 포커스 변경, 커서 모드 등 지원 | 고성능: 힙 할당 없이 스택에서 작동 (약 16바이트 크기) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#특징-1"
  },"666": {
    "doc": "Construct SButton",
    "title": "사용 예시",
    "content": "FReply MyWidget::OnMouseButtonDown(const FGeometry&amp; Geometry, const FPointerEvent&amp; Event) { if (Event.GetEffectingButton() == EKeys::LeftMouseButton) { // 이벤트 처리 완료 return FReply::Handled().ReleaseMouseCapture(); } return FReply::Unhandled(); // 이벤트 계속 전파 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#사용-예시"
  },"667": {
    "doc": "Construct SButton",
    "title": "FReply 생성과 라이프사이클",
    "content": ". | FReply는 함수 내에서 “임시로” 생성되는, 단순한 값 객체(value type, struct) | 이벤트 핸들러(예: OnClicked, OnMouseButtonDown)가 호출될 때마다 매번 새로운 FReply 인스턴스가 반환됨 | 반환 이후에는 Slate가 해당 객체를 해석해서 입력 전파/포커스 등 후속 처리 . | 그 후 FReply 인스턴스는 더 이상 사용되지 않음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply-생성과-라이프사이클"
  },"668": {
    "doc": "Construct SButton",
    "title": "동작 원리",
    "content": ". | 이벤트 수신 . | 슬레이트 입력 시스템이 이벤트 분배 | . | 응답 생성 . | 위젯이 Handled() 또는 Unhandled() 반환 | . | 전파 결정 . | Unhandled 시 부모 위젯으로 이벤트 버블링 | . | 부가 작업 (이벤트 체이닝) . | 핸들링 후 추가 명령 실행(포커스 변경 등) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#동작-원리-1"
  },"669": {
    "doc": "Construct SButton",
    "title": "주요 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-메서드"
  },"670": {
    "doc": "Construct SButton",
    "title": "FReply::Handled()",
    "content": "입력 처리 . FReply SMyWidget::OnButtonClicked() { // 버튼 클릭에 대한 동작 수행 return FReply::Handled(); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyhandled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyhandled"
  },"671": {
    "doc": "Construct SButton",
    "title": "FReply::Unhandled()",
    "content": "입력 무시 -&gt; 부모나 다른 위젯에게 이벤트 위임 . FReply SMyWidget::OnButtonClicked() { // 클릭을 무시(부모나 다른 위젯에게 이벤트 위임) return FReply::Unhandled(); } . Handled() vs Unhandled() 동작 비교 . | 구분 | Handled() | Unhandled() | . | 의미 | “이 이벤트는 처리 완료됨” | “이 이벤트를 더 처리해야 함” | . | 전파 | 즉시 중단 | 부모 위젯으로 계속 전달 | . | 사용 사례 | 버튼 클릭 처리 후 | 이벤트를 추가로 처리해야 할 때 | . | 체이닝 | 추가 액션 연결 가능 | 추가 액션 연결 불가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyunhandled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyunhandled"
  },"672": {
    "doc": "Construct SButton",
    "title": "포커스 제어 (체이닝)",
    "content": "입력 후 추가 행동 설정 . // 체이닝 예시 FReply Reply = FReply::Handled().SetUserFocus(...).CaptureMouse(...); FReply SMyWidget::OnButtonClicked() { return FReply::Handled().SetUserFocus(MyWidgetSharedRef, EFocusCause::SetDirectly); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8F%AC%EC%BB%A4%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EC%B2%B4%EC%9D%B4%EB%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#포커스-제어-체이닝"
  },"673": {
    "doc": "Construct SButton",
    "title": "주요 메서드 정리",
    "content": "| 메서드 | 설명 | . | Handled() | 이벤트를 처리함(기본 FReply 생성) | . | Unhandled() | 이벤트를 무시함 | . | SetUserFocus(TSharedRef&lt;SWidget&gt;) | 특정 위젯에 키보드 포커스 부여 | . | ClearUserFocus(bool bInAllUsers) | 포커스 제거 | . | CaptureMouse(TSharedPtr&lt;SWidget&gt;) | 위젯에 마우스 캡처(드래그 등) | . | ReleaseMouseCapture() | 마우스 캡처 해제 | . | SetMousePos(FVector2D) | 마우스 커서 위치 강제 이동 | . | SetCursor(EMouseCursor::Type) | 커서 모양 변경 | . | .SetKeyboardFocus(TSharedPtr&lt;SWidget&gt;) | 키보드 포커스 설정 | . | .SetUserFocus(EFocusCause::SetDirectly) | 사용자 포커스 설정 | . | .ClearUserFocus(EFocusCause::Cleared) | 포커스 해제 | . | PreventThrottling() | Slate Tick 최적화 예외(강제 업데이트) | . | DetectDrag(TSharedPtr&lt;SWidget&gt;, EKeys) | 드래그 시작 이벤트 감지 | . | BeginDragDrop(TSharedRef&lt;FDragDropOperation&gt;) | 커스텀 드래그 앤 드롭 시작 | . | EndDragDrop() | 드래그 앤 드롭 종료 | . | RouteReplyThrough(TSharedPtr&lt;SWidget&gt;) | 이벤트를 다른 위젯을 통해 라우팅 | . | ScrollToWidget(TSharedPtr&lt;SWidget&gt;) | 특정 위젯 위치로 스크롤 이동 | . 응답 객체 상태 검사 관련 메서드 . | 메서드 | 설명 | . | IsEventHandled() | 이벤트 처리 여부 | . | GetMouseCaptor() | 마우스 캡처한 위젯 반환 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-메서드-정리"
  },"674": {
    "doc": "Construct SButton",
    "title": "Construct SButton",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html"
  },"675": {
    "doc": "Construct SCheckBox",
    "title": "목표 : 체크 박스를 통해 SListView 의 에셋 선택",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EB%AA%A9%ED%91%9C--%EC%B2%B4%ED%81%AC-%EB%B0%95%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%B4-slistview-%EC%9D%98-%EC%97%90%EC%85%8B-%EC%84%A0%ED%83%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#목표--체크-박스를-통해-slistview-의-에셋-선택"
  },"676": {
    "doc": "Construct SCheckBox",
    "title": "SCheckBox",
    "content": "슬레이트(UI 프레임워크)에서 제공하는 체크박스 위젯. 사용자가 선택/해제할 수 있는 상호작용 요소 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#scheckbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#scheckbox"
  },"677": {
    "doc": "Construct SCheckBox",
    "title": "특징",
    "content": ". | 기본 기능 . | 켜짐/꺼짐 상태를 나타내는 박스와 레이블로 구성 | 마우스 클릭이나 키보드로 상태 전환 가능 | 일반 체크박스, 라디오 버튼, 토글 버튼 등 다양한 형태로 사용 가능 | . | 상태 종류 . | ECheckBoxState::Unchecked : 선택된 상태 | ECheckBoxState::Unchecked : 선택되지 않은 상태 | ECheckBoxState::Undetermined : 부분 선택 또는 결정되지 않은 상태(3-state 체크박스) . | 스위치 케이스 문을 통해 각 상태 별로 동작 다르게 설정 가능 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#특징"
  },"678": {
    "doc": "Construct SCheckBox",
    "title": "기본 사용법",
    "content": "TSharedRef&lt;SCheckBox&gt; MyCheckBox = SNew(SCheckBox) .IsChecked(ECheckBoxState::Unchecked) // 초기 상태 설정 .OnCheckStateChanged(this, &amp;MyClass::HandleCheckStateChanged) // 상태 변경 핸들러 [ SNew(STextBlock) .Text(LOCTEXT(\"CheckBoxLabel\", \"옵션 활성화\")) ]; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#기본-사용법"
  },"679": {
    "doc": "Construct SCheckBox",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#주요-속성"
  },"680": {
    "doc": "Construct SCheckBox",
    "title": ".Type",
    "content": "SCheckBox의 시각적/기능적 동작 모드를 결정하는 속성 . | ESlateCheckBoxType::을 통해 타입 지정 가능 | . enum ESlateCheckBoxType . enum class ESlateCheckBoxType : uint8 { /** 표준 체크박스 (사각형, 체크 표시) */ CheckBox, /** 라디오 버튼 (원형, 동그라미가 채워지는 형태, 그룹 내 단일 선택) */ RadioButton, /** Toggle 버튼 (스위치 느낌의 토글형 UI, UE5에서 추가됨) */ ToggleButton }; .Type 속성 사용예시 . SNew(SCheckBox) .Type(ESlateCheckBoxType::CheckBox) .IsChecked(...) .OnCheckStateChanged(...) [ SNew(STextBlock).Text(FText::FromString(TEXT(\"옵션 1\"))) ] . | 값 | 설명 및 사용 예시 | . | CheckBox | - 일반적인 체크박스 UI- 여러 항목을 중복 선택 가능- ✔ 표시 또는 3-state(불확정) 표시 지원 | . | RadioButton | - 원형 라디오 버튼 UI- 한 그룹에서 한 항목만 선택 가능- 중복 선택 불가 | . | ToggleButton | - 스위치 UI처럼 On/Off 시각적 효과- 단일 토글용 (스마트폰의 토글 스위치와 유사) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#type",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#type"
  },"681": {
    "doc": "Construct SCheckBox",
    "title": ".IsChecked",
    "content": "체크박스의 현재 체크 상태를 반환하는 델리게이트 지정 . | Slate Tick 주기마다 IsChecked에 지정된 함수를 호출하여 UI에 표시할 상태를 동적으로 갱신 | 내부 데이터(bOptionEnabled)가 바뀌면, Slate가 자동으로 체크 상태를 갱신해서 보여줌 | .IsChecked 속성 사용예시 .IsChecked(this, &amp;SMyWidget::GetCheckBoxState) ECheckBoxState SMyWidget::GetCheckBoxState() const { return bOptionEnabled ? ECheckBoxState::Checked : ECheckBoxState::Unchecked; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#ischecked",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#ischecked"
  },"682": {
    "doc": "Construct SCheckBox",
    "title": ".OnCheckStateChanged",
    "content": "사용자가 체크박스를 클릭하여 체크 상태가 변경될 때마다 호출되는 델리게이트 . | 이벤트의 파라미터로 새 상태(ECheckBoxState)가 전달 | 이 핸들러에서 보통 내부 상태를 갱신하거나, 추가 로직(예: 설정값 저장 등)을 처리 | 보통 .IsChecked와 연결된 멤버 변수(bOptionEnabled)를 여기서 변경 | .OnCheckStateChanged 속성 사용예시 .OnCheckStateChanged(this, &amp;SMyWidget::OnCheckBoxStateChanged) void SMyWidget::OnCheckBoxStateChanged(ECheckBoxState NewState) { bOptionEnabled = (NewState == ECheckBoxState::Checked); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#oncheckstatechanged",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#oncheckstatechanged"
  },"683": {
    "doc": "Construct SCheckBox",
    "title": ".Visibility",
    "content": "SWidget에서 사용 가능한 표시/숨김 상태를 제어하는 속성 . | EVisibility::Visible : 위젯이 보이고 상호작용 가능 | EVisibility::Collapsed : 위젯이 보이지 않고, 공간도 차지하지 않음 | EVisibility::Hidden : 위젯이 보이지 않지만, 공간은 차지함 | .Visibility 속성 사용예시 . SNew(SCheckBox) .Visibility(EVisibility::Visible) // 항상 보임 . // 동적 컨트롤 SNew(SCheckBox) .Visibility(this, &amp;SMyWidget::GetCheckBoxVisibility) EVisibility SMyWidget::GetCheckBoxVisibility() const { return bShouldShow ? EVisibility::Visible : EVisibility::Collapsed; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#visibility",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#visibility"
  },"684": {
    "doc": "Construct SCheckBox",
    "title": "Construct SCheckBox",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html"
  },"685": {
    "doc": "Construct SListView",
    "title": "목표 : 에셋 이름, 클래스, 선택, 삭제 버튼이 들어간 리스트 생성하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%AA%A9%ED%91%9C--%EC%97%90%EC%85%8B-%EC%9D%B4%EB%A6%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%ED%83%9D-%EC%82%AD%EC%A0%9C-%EB%B2%84%ED%8A%BC%EC%9D%B4-%EB%93%A4%EC%96%B4%EA%B0%84-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#목표--에셋-이름-클래스-선택-삭제-버튼이-들어간-리스트-생성하기"
  },"686": {
    "doc": "Construct SListView",
    "title": "위젯 창 전체 레이아웃 구조",
    "content": ". | 첫 번째 슬롯: 타이틀 텍스트 | 두 번째 슬롯: 리스트 조건 선택 드롭다운 | 세 번째 슬롯: 실제 에셋 리스트 -&gt; SListView 사용 | 네 번째 슬롯: 3개의 버튼(예: Delete All 등) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%9C%84%EC%A0%AF-%EC%B0%BD-%EC%A0%84%EC%B2%B4-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#위젯-창-전체-레이아웃-구조"
  },"687": {
    "doc": "Construct SListView",
    "title": "SListView",
    "content": "Slate UI 프레임워크에서 제공하는 리스트 위젯. 데이터 항목들을 스크롤 가능한 리스트 형태로 표시하는 데 사용 . 메모리 안전성 및 레퍼런스 관리를 위해 거의 항상 TSharedPtr&lt;T&gt; 형태로 운용 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview"
  },"688": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 템플릿 기반 디자인 : SListView&lt;T&gt; 형태로 사용. T는 표시할 데이터 항목의 타입 | 가상화 지원 : 많은 수의 항목을 효율적으로 처리하기 위해 가상화를 지원 (화면에 보이는 항목만 렌더링) | 커스터마이징 : 항목 표현 방식, 선택 동작, 스크롤 동작 등을 자유롭게 커스터마이즈 | 다양한 상호작용 : 선택, 더블 클릭, 컨텍스트 메뉴 등 다양한 사용자 상호작용을 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징"
  },"689": {
    "doc": "Construct SListView",
    "title": "기본 사용법",
    "content": "// 데이터 소스 준비 TArray&lt;FString&gt; Items = {\"Item 1\", \"Item 2\", \"Item 3\"}; // 리스트 뷰 생성 SNew(SListView&lt;FString&gt;) .ItemHeight(24) // 항목 높이 .ListItemsSource(&amp;Items) // 데이터 소스 설정 .OnGenerateRow(this, &amp;SMyWidget::HandleGenerateRow) // 항목 생성 핸들러 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#기본-사용법"
  },"690": {
    "doc": "Construct SListView",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#주요-속성"
  },"691": {
    "doc": "Construct SListView",
    "title": ".ListItemsSource()",
    "content": "리스트에 표시할 데이터(배열)의 포인터를 지정. 필수 속성임 . | 형식 : TArray&lt;T&gt;* 또는 TArray&lt;TSharedPtr&lt;T&gt;&gt;* | . TArray&lt;TSharedPtr&lt;FMyItem&gt;&gt; MyItems; ChildSlot [ SNew(SListView&lt;TSharedPtr&lt;FMyItem&gt;&gt;) .ListItemsSource(&amp;MyItems) // &lt;- 리스트에 표시할 아이템 배열의 포인터 // ... 생략 ... ]; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#listitemssource",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#listitemssource"
  },"692": {
    "doc": "Construct SListView",
    "title": ".OnGenerateRow()",
    "content": "리스트 뷰가 스크롤 시 화면에 보이는 행(Row)을 어떻게 생성할지 정의하는 핵심 함수. 가장 중요 . 필수 구현 사항 : 반드시 ITableRow 인터페이스를 반환 . FOnGenerateRow&lt;T&gt;::FDelegate OnGenerateRow TSharedRef&lt;ITableRow&gt; YourClass::OnGenerateRowFunc( TSharedPtr&lt;T&gt; InItem, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable ); . | T: 리스트에 표시하는 데이터 타입 | OwnerTable : SListView가 내부적으로 자동 생성하여 전달하는 인자 . | STableRow&lt;T&gt;의 부모가 되는 리스트 뷰 | . | 반환: TSharedRef&lt;ITableRow&gt; . | SNew(STableRow&lt;T&gt;, OwnerTable)로 생성 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#ongeneraterow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#ongeneraterow"
  },"693": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 동적 생성 : 실제로 화면에 보여질 때만 행을 생성 | 메모리 효율 : 스크롤 시 보이지 않는 항목은 즉시 해제되며, 생성된 행은 풀(Pool)에서 재사용 | 가상화 : 10,000개 항목이 있어도 실제로는 10~20개의 행 위젯만 존재 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징-1"
  },"694": {
    "doc": "Construct SListView",
    "title": "동작 원리",
    "content": ". | 스크롤 발생 . | 사용자가 리스트를 스크롤하면 엔진은 화면에 새로 들어올 항목의 인덱스를 계산 | . | 행 생성 요청 . | 새로 보여야 할 항목에 대해 OnGenerateRow를 호출 | 기존에 생성된 행이 풀에 있으면 재사용, 없으면 새로 생성 | . | 데이터 바인딩 . | 인자로 전달된 Item 데이터로 위젯을 구성 (TSharedRef&lt;ITableRow&gt;) | . | 화면에 배치 . | 생성된 행을 적절한 위치에 배치하고 스크롤 영역에 추가함 | . | 스크롤 밖으로 나간 행 처리 . | 화면에서 벗어난 행은 풀로 반환되며, 메모리에서 삭제되지 않음 | . | . 항목 재사용 (Pooling) . | 생성된 행은 STableRow로 래핑되어 풀에서 관리된다 | 같은 타입의 행은 재사용되므로 상태 유지에 주의가 필요하다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작-원리"
  },"695": {
    "doc": "Construct SListView",
    "title": "ITableRow",
    "content": "테이블/리스트의 개별 행(row)을 나타내는 인터페이스 . | SListView, STreeView, STableViewBase 등에서 각 행을 추상화 함 | STableRow&lt;T&gt;가 ITableRow를 상속(구현) . | 사용자는 STableRow만 직접 생성하면 되고, Slate 내부에서는 ITableRow*로 Row를 관리 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#itablerow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#itablerow"
  },"696": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 행의 기본 동작 정의 . | 선택(Selection), 호버(Hover), 드래그(Drag) 등의 상호작용 처리 | . | 행의 레이아웃 및 가시성 관리 | 부모 테이블 뷰와의 통신 | 가상화 지원 | . // 화면 밖의 행은 자동으로 해제 virtual void ExitRow() = 0; . | 폴링 시스템 : 행 인스턴스 재사용 | . TSharedRef&lt;ITableRow&gt; ReuseRow(TSharedPtr&lt;ItemType&gt; NewItem) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징-2"
  },"697": {
    "doc": "Construct SListView",
    "title": "정리",
    "content": ". | 위젯에서 스크롤 리스트 이벤트를 부름 . | 사용자가 스크롤하거나, 데이터가 바뀌거나, 리스트가 처음 표시될 때 이벤트 발생 | . | SListView에서 해당 스크롤에 들어갈 Row 함수 호출 (OnGenerateRow) . | SListView는 지금 화면에 보여져야 하는 Row에 대해서만 .OnGenerateRow() 콜백(델리게이트)을 호출함 | . | STableRow에서 실제 Row 객체 생성 . | OnGenerateRow에서 STableRow&lt;T&gt; 인스턴스를 생성해서 반환 | . | 스크롤에 따라 Row 객체 관리 . | 화면 밖으로 나간 행은 메모리에서 삭제되지 않고 풀에 보관 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#정리"
  },"698": {
    "doc": "Construct SListView",
    "title": "SListView 에서 자주 쓰이는 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview-%EC%97%90%EC%84%9C-%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview-에서-자주-쓰이는-메서드"
  },"699": {
    "doc": "Construct SListView",
    "title": "리스트 갱신",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B0%B1%EC%8B%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#리스트-갱신"
  },"700": {
    "doc": "Construct SListView",
    "title": "RequestListRefresh()",
    "content": "다음 프레임에 리스트를 안전하게 갱신 . void SListView::RequestListRefresh() { // Invalidate만 호출하고 즉시 작업 수행 X Invalidate(EInvalidateWidgetReason::Layout); } . | RebuildList()보다 성능 부하가 적음 | 빈번한 업데이트에 적합 (예: 실시간 필터링) | . ConstructedAssetListView-&gt;RequestListRefresh(); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#requestlistrefresh",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#requestlistrefresh"
  },"701": {
    "doc": "Construct SListView",
    "title": "동작",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작"
  },"702": {
    "doc": "Construct SListView",
    "title": "RebuildList()",
    "content": "즉시 전체 리스트 재구성 . | 주의점: 대량 데이터에서 성능 저하 가능 | . void SListView::RebuildList() { Private::TableViewBase::RebuildList(); // 전체 재생성 로직 // 모든 행을 새로 만들고 레이아웃 재계산 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#rebuildlist",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#rebuildlist"
  },"703": {
    "doc": "Construct SListView",
    "title": "동작",
    "content": ". RebuildList() vs RequestListRefresh() 선택 가이드 . | 특징 | RebuildList() | RequestListRefresh() | . | 실행 시점 | 즉시 | 다음 프레임 | . | 갱신 범위 | 전체 리스트 | 변경된 부분만 | . | 행 재사용 | 모든 행 새로 생성(pool 초기화) | 기존 행 유지(pool 재활용) | . | 성능 영향 | 항목 수에 선형적 부하 | 변경량에 비례한 부하 | . | 사용 시나리오 | 리스트 구조 변경 시 | 데이터 내용 변경 시 | . | 여러 항목을 연속 삭제할 때 RebuildList()는 매 삭제마다 전체 재구성하므로 성능 저하 발생 가능 | RequestListRefresh()는 변경 사항을 모아 한 번에 처리, 렌더링 프레임과 동기화되어 깜빡임 현상 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작-1"
  },"704": {
    "doc": "Construct SListView",
    "title": "네비게이션 &amp; 스크롤 제어",
    "content": "ScrollToTop() / ScrollToBottom() . // 리스트의 시작/끝으로 스크롤 ListView-&gt;ScrollToTop(); ListView-&gt;ScrollToBottom(); . ScrollToItem() . // 특정 아이템으로 스크롤 (가시 영역 보장) ListView-&gt;ScrollToItem(SelectedItem); . SetScrollOffset() . // 픽셀 단위 정밀 스크롤 제어 ListView-&gt;SetScrollOffset(200.f); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98--%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%A0%9C%EC%96%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#네비게이션--스크롤-제어"
  },"705": {
    "doc": "Construct SListView",
    "title": "선택 관리 메서드",
    "content": "SetSelection() . // 단일 아이템 선택 ListView-&gt;SetSelection(SelectedItem); // 다중 선택 모드 ListView-&gt;SetSelection(SelectedItems, ESelectInfo::OnMouseClick); . ClearSelection() . // 모든 선택 해제 ListView-&gt;ClearSelection(); . GetSelectedItems() . // 현재 선택된 아이템들 가져오기 TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; SelectedItems; ListView-&gt;GetSelectedItems(SelectedItems); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%84%A0%ED%83%9D-%EA%B4%80%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#선택-관리-메서드"
  },"706": {
    "doc": "Construct SListView",
    "title": "데이터 소스 제어",
    "content": "SetItemsSource() . // 데이터 소스 변경 (자동 갱신 X) ListView-&gt;SetItemsSource(&amp;NewDataArray); // 변경 후 수동 갱신 필요 ListView-&gt;RequestListRefresh(); . GetNumItems() . // 아이템 총 개수 확인 int32 ItemCount = ListView-&gt;GetNumItems(); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%8C%EC%8A%A4-%EC%A0%9C%EC%96%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#데이터-소스-제어"
  },"707": {
    "doc": "Construct SListView",
    "title": "Construct SListView",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html"
  },"708": {
    "doc": "Container",
    "title": "Container",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html"
  },"709": {
    "doc": "Container",
    "title": "TArray",
    "content": "동일한 타입의 데이터를 순차적으로 저장, 관리, 반복, 조작하기 위한 동적 배열 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray"
  },"710": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 하나의 TArray에는 반드시 동일 타입만 저장 가능 | 동적 크기 조절: 요소 추가/삭제에 따라 자동으로 메모리 할당/해제 및 재조정 | 슬랙(slack) 최적화: 추가/삭제에 따른 빈번한 할당/해제를 방지하기 위해 여유 메모리 유지 . | 실제 할당된 메모리는 Num(요소 개수) 이상일 수 있음(성능 최적화 목적) | . | 깊은 복사(Deep copy): 배열 자체의 복사는 내부 요소 모두 복사 | 메모리 및 성능 측면에서 튜닝 가능(Allocator, Reserve/Empty/Reset 등) | 블루프린트에서도 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징"
  },"711": {
    "doc": "Container",
    "title": "생성자 속성",
    "content": "TArray를 생성할 때 element Type, Allocator 두 가지 속성을 사용할 수 있다. TArray&lt;int32&gt; IntArray; // 요소 타입 지정 TArray&lt;int32, TInlineAllocator&lt;4&gt;&gt; IntArray; // 요소, 할당자 속성 지정, 할당자는 선택 옵션 . 요소 타입 (Element Type) . TArray는 동일한 타입의 요소들을 저장하는 동질적(homogeneous) 컨테이너 . | 즉, 배열에 저장되는 모든 요소는 동일한 타입이어야 한다 | 이는 TArray, TArray, TArray&lt;UMyObject*&gt; 등으로 선언 | . 요소 타입은 다음과 같은 조건을 만족해야 함 . | 복사 가능(Copyable): 요소는 복사 생성자를 통해 복사될 수 있어야 함 | 소멸 가능(Destructible): 요소는 소멸자를 통해 적절히 정리될 수 있어야 함 | . 할당자 (Allocator) . TArray는 메모리 할당 방식을 결정하는 할당자(Allocator)를 선택적으로 지정할 수 있음 . | 할당자 | 설명 | . | FDefaultAllocator | 기본 힙 기반 할당자 | . | TInlineAllocator&lt;N&gt; | 처음 N개의 요소는 스택에 할당하고, 그 이후는 힙에 할당. 작은 배열에 유리하며, 스택 할당으로 인해 성능이 향상될 수 있음 | . | TFixedAllocator&lt;N&gt; | 고정 크기의 할당자로, 최대 N개의 요소만 저장할 수 있다. 초과할 경우 런타임 에러가 발생 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#생성자-속성"
  },"712": {
    "doc": "Container",
    "title": "ADD vs Emplace",
    "content": "ADD . 함수에 넘긴 인자를 임시 객체(temporary)로 만든 후, 그 임시 객체를 배열 끝에 복사하거나 이동해서 저장함 . TArray&lt;FString&gt; Arr; Arr.Add(TEXT(\"Hello\")); . | TEXT(\"Hello\")는 우선 임시로 FString이 만들어지고, 그 임시 객체가 TArray 내부에 복사/이동됨 | . Emplace . 배열 내부에 직접 인자를 전달해 객체를 생성함 . TArray&lt;FString&gt; Arr; Arr.Emplace(TEXT(\"Hello\")); . | TEXT(\"Hello\")를 인자로 받아서, 배열 메모리 공간에 바로 FString 생성자 호출 | . 결론 . | Add: 임시 객체 → TArray 내부 복사(힙) (임시 객체는 함수 끝나면 사라짐) . | 이미 만들어진 객체를 추가할 때 사용 | “이 객체를 배열에 더한다”는 의도가 명확함 | . | Emplace: 임시 객체 없이, 바로 TArray 내부(힙)에 생성 . | 임시 객체 생성/복사를 피함 → 성능 최적화 | 복잡한 객체 (복사/이동 비용이 큰 구조체 등)에서 효율적 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace"
  },"713": {
    "doc": "Container",
    "title": "TMap",
    "content": "키-값 쌍(key-value pair)을 저장하는 해시 맵(hash map) 구조 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap"
  },"714": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 키-값 쌍 저장: 키(Key)와 값(Value)을 쌍으로 저장하는 자료 구조 | 빠른 검색: 해시 테이블 기반으로 구현되어 있어 평균 O(1) 시간 복잡도로 검색 가능 | 템플릿 기반: TMap&lt;KeyType, ValueType&gt; 형태로 사용 | UPROPERTY로 선언 시, 세이브/로드, 네트워크 레플리케이션, 블루프린트에서 접근 가능 . | Key, Value 모두 리플렉션 및 직렬화 지원 타입이어야 함 | 예: TMap&lt;FString, float&gt; → O , TMap&lt;int32, UObject*&gt; → X | . | TMap은 삽입 순서나 정렬 순서를 보장하지 않음 | . 기본 사용법 . // TMap 선언 TMap&lt;FString, int32&gt; FruitPrices; // 요소 추가 FruitPrices.Add(TEXT(\"Apple\"), 1000); FruitPrices.Add(TEXT(\"Banana\"), 800); // 요소 접근 int32 ApplePrice = FruitPrices[\"Apple\"]; // 값 찾기 int32* Score = FruitPrices.Find(TEXT(\"Apple\")); int32 SafePrice = FruitPrices.FindRef(TEXT(\"Apple\")); // 존재하지 않으면 ValueType의 기본값 반환( int32면 0) // 값 변경 FruitPrices[TEXT(\"Apple\")] = 90; // 키 존재 확인 if (FruitPrices.Contains(TEXT(\"Banana\"))) { // 처리 코드 } // 키-쌍 제거 FruitPrices.Remove(TEXT(\"Apple\")); // 맵 비우기 FruitPrices.Empty(); // 반복문 순회 for (const TPair&lt;FString, int32&gt;&amp; Elem : FruitPrices) { UE_LOG(LogTemp, Log, TEXT(\"%s: %d\"), *Elem.Key, Elem.Value); } // 포인터 값 저장 시 안전한 삭제 예시 TMap&lt;FString, MyClass*&gt; ObjectMap; ObjectMap.Add(TEXT(\"Obj1\"), new MyClass()); TMap&lt;FString, TSharedPtr&lt;MyClass&gt;&gt; SafeMap; SafeMap.Add(TEXT(\"Obj1\"), MakeShared&lt;MyClass&gt;()); SafeMap.Empty(); // 자동 해제됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징-1"
  },"715": {
    "doc": "Container",
    "title": "주요 메서드 정리",
    "content": "| 메서드 | 설명 | . | Add(Key, Value) | 키-값 쌍 추가, 이미 키가 있으면 값 갱신 | . | Find(Key) | 키에 해당하는 값 포인터 반환, 없으면 nullptr | . | FindRef(Key) | 키에 해당하는 값의 복사본 반환 (키 없으면 기본값) | . | Contains(Key) | 해당 키 존재 여부 반환 (bool) | . | Remove(Key) | 키-값 쌍 제거, 성공 여부 반환 | . | RemoveAndCopyValue(Key, OutValue) | 키 삭제 + 값 복사 (성공 여부 반환) | . | Num() | 저장된 쌍의 개수 반환 | . | Empty() | 모든 데이터 삭제 | . | Reset() | 메모리 해제 및 초기화 | . | operator[] | [] 연산자로 값 접근/생성 | . | GenerateKeyArray() | 모든 키를 TArray로 반환 | . | GenerateValueArray() | 모든 값을 TArray로 반환 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주요-메서드-정리"
  },"716": {
    "doc": "Container",
    "title": "주의사항",
    "content": ". | 포인터를 저장할 때는 메모리 관리에 유의 → 스마트 포인터(TSharedPtr) 사용 추천 . | Remove()나 Empty()는 맵에서의 연결만 끊을 뿐, 메모리 해제는 하지 않음 | 만약 new로 할당한 객체를 저장했다면, 별도로 delete 하기 | . | operator[]는 키가 없으면 기본값(0, nullptr 등) 생성 후 반환하므로, 의도치 않은 값 생성 가능성 있음 . | 검색 전 Contains()로 확인하거나 Find()를 권장 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주의사항"
  },"717": {
    "doc": "Container",
    "title": "TSet",
    "content": "참고 링크 . | TArray | TMap | TSet | TArray vs std::vector | Optimizing TArray Usage for Performance | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset"
  },"718": {
    "doc": "Delete unused Assets From Selelction",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 중 미사용 에셋 삭제하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EC%A4%91-%EB%AF%B8%EC%82%AC%EC%9A%A9-%EC%97%90%EC%85%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#목표-콘텐트-폴더에서-선택한-에셋-중-미사용-에셋-삭제하기"
  },"719": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Asset Referencers",
    "content": ". | 레벨에서 사용된 에셋의 경우 Asset References(에셋 참조)가 존재함 | 즉 미사용 상태의 에셋의 경우 참조 개수 = 0 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers"
  },"720": {
    "doc": "Delete unused Assets From Selelction",
    "title": "AssetRegistry",
    "content": "모든 프로젝트 에셋의 메타 데이터를 인덱싱/검색/관리하는 중앙 관리 모듈 . | 에디터 구동 시 모든 프로젝트 에셋(.uasset, .umap 등)을 빠르게 탐색/관리할 수 있도록 내부적으로 모든 에셋의 메타데이터를 스캔 | 에셋 인덱싱: 실제 에셋 객체(UObject 등)는 메모리에 로드하지 않고, 각 에셋의 메타 데이터를 메모리에 인덱싱 (FAssetData 생성) | 빠른 검색: 이름, 클래스, 태그 등 다양한 조건으로 에셋을 빠르게 조회 | 런타임/에디터 지원: 런타임 자동화, 에디터 UI, 플러그인 등에서 활용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry"
  },"721": {
    "doc": "Delete unused Assets From Selelction",
    "title": "FAssetData",
    "content": "에셋 레지스트리에서 찾은 에셋에 대한 중요한 정보를 저장하는 구조체 . | Asset Registry는 FAssetData의 집합 | 실제 에셋의 전체 데이터나 객체는 아님 (일시적) | AssetRegistry를 통해 조회 시 TArray&lt;FAssetData&gt;로 반환됨 | . AssetRegistry 다이어그램 . | FARFilter : AssetRegistry 에서 검색에 사용되는 필터 | FAssetData → UObject: 필요에 따라 일시적으로 참조(사용)한다 (예: GetAsset() 호출) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata"
  },"722": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Remove Unused Assets 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::FindPackageReferencersForAsset . | 특정 에셋(Asset)을 참조하는 모든 패키지(Package)의 목록을 찾아 반환 | 에셋 의존성 분석에 사용. 특히 에셋을 삭제하거나 수정할 때 어떤 다른 에셋들이 영향을 받을지 확인 | 에디터 전용 기능 | . static TArray&lt;FString&gt; UEditorAssetLibrary::FindPackageReferencersForAsset( const FString&amp; AssetPath, bool bLoadAssetsToConfirm = false ); . | 매개변수 . | AssetPath (필수): 분석할 대상 에셋의 경로 (Object path) | bLoadAssetsToConfirm (옵션, 기본값 false) . | true: 참조하는 패키지를 메모리에 로드하여 정확성을 확인 (느리지만 정확하다) | false: 에셋 레지스트리(Asset Registry)의 메타데이터만 사용하여 빠르게 검색 (빠르지만 간접 참조 누락 가능) | . | . | 반환 값 . | 참조하는 패키지의 경로 문자열(FString) 배열 (TArray) | 에셋이 사용되지 않으면 빈 배열 반환 | . | . 2. Num() . | 컨테이너에 저장된 요소의 개수(길이)를 반환 | c++의 .Size()와 같음 | . 3. ObjectTools::DeleteAssets(UnusedAssetsData); . Asset들을 안전하게 일괄 삭제하는 유틸리티 . // UnrealEd 모듈 내 ObjectTools.h 선언부 static bool DeleteAssets(const TArray&lt;FAssetData&gt;&amp; AssetDataList, bool bShowConfirmation = true, bool bForceDelete = false); . | 대표적으로 FAssetData 배열을 인자로 받음 (다른 타입 매개변수 사용 가능) | . 동작과정 . | 입력 받은 FAssetData 리스트에서 실제 에셋 객체(UObject)를 찾아옴 | 에셋이 참조되는지 (Reference Graph) 검사 . | 다른 에셋이나 오브젝트에서 참조하고 있는 경우, 경고 대화창을 띄워 사용자에게 확인 받음 | 옵션에 따라, 강제 삭제(bForceDelete) 가능 | . | 사용자에게 삭제 확인(Confirmation) 요청 . | bShowConfirmation 인자가 true일 경우, 실제 삭제 전에 “정말 삭제할까요?”와 같은 확인창 표시 | . | 트랜잭션 생성 및 삭제 실행 . | 삭제 과정 전체를 에디터 트랜잭션(Undo/Redo)에 등록 → 실수 시 실행 취소 가능 | 내부적으로 FScopedTransaction을 사용하여 트랜잭션 단위로 관리 | . | 실제 삭제 . | 에셋을 Content Browser 및 파일 시스템(디스크)에서 제거 | 참조된 경우, 일부 삭제가 제한되거나, 사용자가 강제 삭제시 후처리(레퍼런스 클린업 등) 발생 | . | 결과 반환 . | 성공적으로 삭제된 경우 true, 실패 또는 취소시 false 반환 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-함수-구현에-사용한-메서드"
  },"723": {
    "doc": "Delete unused Assets From Selelction",
    "title": "ObjectTools.h",
    "content": "에디터 환경에서 UObject 관련 유틸리티 함수 집합을 정의한 헤더 파일 . | 삭제/이동/복사 동작과 관련해, 사용자에게 경고 및 결과 알림 대화창을 띄워줌 | UnrealEd 모듈에 소속 . | 런타임 환경(게임 실행)에서는 사용 불가. 에디터에서만 사용하는 기능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh"
  },"724": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Delete unused Assets From Selelction",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html"
  },"725": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug",
    "content": "디버그 메서드를 블루프린트와 C++로 어떻게 구현하는지 알아보자 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html"
  },"726": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Spheres",
    "content": "디버그용 구 그리기 . DrawDebugSphere() 함수 원형 . void DrawDebugSphere( const UWorld* InWorld, const FVector&amp; Center, float Radius, int32 Segments, FColor Color, bool bPersistentLines = false, float LifeTime = -1.f, uint8 DepthPriority = 0, float Thickness = 0.f ); . | 매개변수 . | InWorld: 월드 객체 포인터 | Center: 구의 중심 좌표 | Radius: 반지름 | Segments: 구 세그먼트 수 | Color: 색상 | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속) | DepthPriority: 렌더링 우선순위 | Thickness: 선 두께 | . | bPersistentLines . | true: 엔진 내부에서 해당 디버그 요소를 지속성 목록(Persistent List)에 등록하여 관리 . | FlushPersistentDebugLines()로 수동 제거 가능 | 지속적인 메모리 사용이 발생하지만 매 프레임 재생성 비용 절감 | . | false: 프레임 임시 배열에만 저장 . | 매 프레임 생성/삭제 반복 | . | . | LifeTime | . | 값 | 예시 | . | LifeTime = -1 | 무한 지속 | . | LifeTime = 0 | 1 프레임만 출력되고 사라짐 | . | LifeTime &gt; 0 | 지정된 시간(초) 동안 지속 후 사라짐 | . BP . | Draw Debug Sphere . | Get Actor Location : 디버그용 구의 Center 지정에 사용 | . | . C++ . #include \"DrawDebugHelpers.h\" // 디버그 헤더 인클루드 void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { DrawDebugSphere(World, Location, 25.f, 24, FColor::Red, false, 30.f); } } . | define 사용하기 | . #define DRAW_SPHERE(Location) if (GetWorld()) DrawDebugSphere(GetWorld(), Location, 25.f, 12, FColor::Red, true); AItem::AItem() { FVector Location = GetActorLocation(); DRAW_SPHERE(Location) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-spheres",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-spheres"
  },"727": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Lines",
    "content": "디버그용 벡터 라인 시각화하기 . Drawing Debug Lines() 함수 원형 . void DrawDebugLine( const UWorld* InWorld, const FVector&amp; LineStart, const FVector&amp; LineEnd, FColor Color, bool bPersistentLines = false, float LifeTime = -1.f, uint8 DepthPriority = 0, float Thickness = 0.f ); . | 매개변수 . | InWorld: 월드 객체 포인터 | LineStart: 시작 좌표 | LineEnd: 끝 좌표 | Color: 색상 | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속) | DepthPriority: 렌더링 우선순위 | Thickness: 선 두께 | . | . BP . | Draw Debug Line . | Get Actor Location : 디버그용 라인의 Start 지정에 사용 | Get Actor Foward Vector : 전방 벡터 불러오기 . | 위 두개를 ADD 해 Line End에 잇는다 | 벡터 단위는 cm . | 따라서 Foward Vector 크기 곱셈 필요 | . | . | . | . C++ . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { FVector Forward = ForwardVector(); DrawDebugLine(World, Location, Location + Forward * 100.f, FColor::Red, true); } } . | define 사용하기 | . #define DRAW_LINE(StartLocation, EndLocation) if (GetWorld()) DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f); AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_LINE(Location, Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-lines",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-lines"
  },"728": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Point",
    "content": "디버그용 포인트 찍기 . | 벡터의 처음과 끝을 표시하기에 좋음 | 포인트 크기는 거리에 따라 변하지 않음 (고정) | . DrawingDebugPoint() 함수 원형 . void DrawDebugPoint( const UWorld* InWorld, FVector const&amp; Position, float Size, FColor const&amp; Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority ); . | 매개변수 . | InWorld: 디버그 포인트를 그릴 월드 컨텍스트 | Position: 포인트의 위치 (FVector) | Size: 포인트의 크기 (float) | Color: 포인트의 색상 (FColor) | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 포인트가 화면에 유지될 시간(초) | DepthPriority: 렌더링 우선순위 | . | . BP . | Draw Debug Point . | Get Actor Location : 디버그용 포인트 찍을 Position | . | . C++ . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { FVector Forward = ForwardVector(); DrawDebugPoint(World, Location + Forward * 100.f, 15.f, FColor::Red, true); // 벡터 끝에 점찍기 } } . | define 사용하기 | . #define DRAW_POINT(Location) if (GetWorld()) DrawDebugPoint(GetWorld(), Location, 15.f, FColor::Red, true); AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_POINT(Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-point",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-point"
  },"729": {
    "doc": "Drawing Debug",
    "title": "Line + Point 로 벡터 그리기",
    "content": ". | \\ 사용해 매크로 계속 이어갈 수 있음 | . #define DRAW_VECTOR(StartLocation, EndLocation) if (GetWorld()) \\ { \\ DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f); \\ DrawDebugPoint(GetWorld(), EndLocation, 15.f, FColor::Red, true); \\ }; AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#line--point-%EB%A1%9C-%EB%B2%A1%ED%84%B0-%EA%B7%B8%EB%A6%AC%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#line--point-로-벡터-그리기"
  },"730": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input (UE 5.1)",
    "content": "기존 시스템보다 더 강력하고 유지보수가 용이한 입력 처리를 제공 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-ue-51",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-ue-51"
  },"731": {
    "doc": "Enhanced Input",
    "title": "특징",
    "content": ". | 데이터 기반 입력 시스템 . | 입력 액션과 매핑을 에디터에서 설정 가능 | 코드 재컴파일 없이 입력 설정 변경 가능 | . | 고급 입력 트리거 . | Started (눌림 시작), Triggered (지속), Completed (놓임), Canceled (중단) 등 다양한 트리거 이벤트 | 탭, 홀드, 더블탭 등 복잡한 입력 패턴 지원 | . | 입력 컨텍스트 시스템 . | 상황에 따라 다른 입력 매핑을 활성화/비활성화 가능 | . | 예: 걷기 상태와 운전 상태에서 다른 입력 매핑 사용 | . | 입력 모디파이어 . | 입력 값을 변환하는 모디파이어 적용 가능 (예: 감도 조정, 데드존 설정) . | 게임패드 스틱의 민감도 곡선 조정 등 | . | . | 크로스 플랫폼 입력 지원 . | 여러 입력 장치를 통합 관리 | 장치 유형에 따라 다른 입력 처리 가능 | . | 블루프린트 통합 . | C++뿐만 아니라 블루프린트에서도 완전히 지원 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#특징"
  },"732": {
    "doc": "Enhanced Input",
    "title": "이전 입력 처리 방식 (Legacy Input System)",
    "content": "1. 프로젝트 세팅에서 입력 매핑 정의 . | 상단의 Edit -&gt; Project Settings 클릭 | 목록의 Engine 섹션에서 input 클릭 | Binding에서 Axis Mappings(연속적인 입력, 예: WASD 이동) 추가 | Binding에서 Action Mappings(단발적인 입력, 예: 점프)를 추가 | . 단순히 “어떤 키가 어떤 입력 이름에 매핑되는지”를 정의할 뿐, 실제 게임 로직과 연결되지 않음 . 2. C++/블루프린트에서 입력 바인딩 . | SetupPlayerInputComponent() 함수에서 명시적으로 입력 이벤트와 함수를 연결 | 프로젝트 세팅에서 정의한 입력 이름(MoveForward, Jump 등)을 코드에서 하드코딩으로 참조 | . void AMyPawn::MoveForward(float Value) { UE_LOG(LogTemp, warning, TEXT(\"Value: %f\"), Value); } void AMyPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); // 프로젝트 세팅에서 정의한 이름과 동일하게 작성해야 함! PlayerInputComponent-&gt;BindAxis(\"MoveForward\", this, &amp;AMyPawn::MoveForward); PlayerInputComponent-&gt;BindAction(\"Jump\", IE_Pressed, this, &amp;AMyPawn::Jump); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#%EC%9D%B4%EC%A0%84-%EC%9E%85%EB%A0%A5-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EC%8B%9D-legacy-input-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#이전-입력-처리-방식-legacy-input-system"
  },"733": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input 시스템",
    "content": "Blueprint 로 설정하기 . | Input Action 생성 . | Content Browser에서 우클릭 → Input → Input Action | . | ‘IA_Move’로 이름 지정 | Value Type 설정 | . | Input Mapping Context 생성 . | Content Browser에서 우클릭 → Input → Input Mapping Context | . | ‘IMC_Context’로 이름 지정 | IMC_Context BP 더블클릭 후 Mappings + 아이콘 클릭 . | ‘IA_Move’와 같은 Input Action 블루프린트 설정 | 맵핑하고 싶은 키 선택하여 연결 가능 | . | . | Pawn 블루프린트에 매핑 컨텍스트 연결 . | BP_Pawn 블루프린트 열기 | Event Graph에서 BeginPlay에 다음 노드 연결 | . | Get Controller 함수 노드 → Cast To PlayerController 노드 - Cast To PlayerController 노드의 As player Comtroller 핀에 | Enhanced Input Local Player Subsystem 노드 연결 - Enhanced Input Local Player Subsystem → Add Mapping Context 함수 노드의 타겟 핀 연결 - Cast To PlayerController → Add Mapping Context 연결 | . | IA_Move Input Actoin 노드 가져오기 . | Action Value를 Print String 노드에 연결하여 True/False 출력 | . | 디버그로 작동 확인 . | 게임 플레이 상태에서 ` 키로 콘솔창 띄우기 | 콘솔 명령어 show debug enhancedinput 입력 | . | . C++ 로 설정하기 . | Input Mapping Context 멤버 변수 선언 UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"input\") UInputMappingContext* BirdMappingContext; . | BeginPlay에서 Enhanced Input Subsystem에 매핑 컨텍스트 등록 . | build.cs에 EnhancedInput 모듈 추가 // build.cs PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"EnhancedInput\" }); . | 헤더에 \"EnhancedInputSubsystems.h\" 인클루드 | PlayerController 캐스팅 / Subsystem에 MappingContext 추가 if (APlayerController* PlayerController = Cast&lt;APlayerController&gt;(GetController())) { if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem &lt; UEnhancedInputLocalPlayerSubsystem &gt;(PlayerController-&gt;GetLocalPlayer())) { Subsystem-&gt;AddMappingContext(BirdMappingContext, 0); } } . | . | Input Action 멤버 변수 선언 UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = input) UInputAction* MoveAction; . | 입력 콜백 함수 구현 //hpp void Move(const FInputActionValue&amp; Value); //cpp void ABird::Move(const FInputActionValue&amp; value) { const bool CurrentValue = value.Get&lt;bool&gt;(); if (CurrentValue) { UE_LOG(LogTemp, Warning, TEXT(\"IA_Move triggered\")); } } . | SetupPlayerInputComponent에서 InputAction에 바인딩 void ABird::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); if (UEnhancedInputComponent* EnhancedInputComponent = CastChecked&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) { // UInputAciont* MoveAction에 콜백 함수 (ABird::Move) 바인딩 EnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;ABird::Move); } } . | . 참고하면 좋은 링크 . | doc - enhanced-input | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-시스템"
  },"734": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html"
  },"735": {
    "doc": "Episode 1 - 10",
    "title": "material",
    "content": "머테리얼 에디터 아래의 통계 읽는법 추가하기 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#material"
  },"736": {
    "doc": "Episode 1 - 10",
    "title": "Metallic",
    "content": ". | base color | specular | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#metallic",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#metallic"
  },"737": {
    "doc": "Episode 1 - 10",
    "title": "Node function",
    "content": "floats . | constant : 하나의 값 (메탈릭, 러프니스, 베이스 컬러, 스페큘라같은 곳에 쓰임) | constant 2Vector : U,V 와 같은 곳에 쓰임 | constant 3Vector : RGB or vector | constant 4Vector : alpha | . 개수가 다른 float끼리 더하고 곱셈하기 . | floats : 0.2 | floats[2] : R 0.5, G 0.3 | add 노드 사용 -&gt; floats의 값이 floats[2]의 [0],[1]에 모두 더해짐 | . Vector2와 Vector3를 합하면 error . | 이럴 때 마스크로 활용 | . Masks . r,g,b,a 체크로 가져올 input 체크하기 . | R에 체크 : R 값만 가져옴 | . Append / Append Many . vector2에 floats push -&gt; vector3 . swizzle . 벡터의 구성 요소(component) 순서를 재배열하거나 특정 요소만 선택하여 새로운 벡터를 만든다 . | 선택 (Selection): 여러 채널 중 특정 채널 하나만 가져오기 | 재배열 (Reordering): 채널들의 순서 바꾸기 | 복제 (Duplication): 하나의 채널을 여러 번 사용하여 새로운 벡터 만들기 | 조합 (Combination): 위 기능들을 모두 활용하여 원하는 대로 새로운 벡터를 생성 | . RGBA에서 (A, R, G) 라는 새로운 Vector3 만들기 . split Component . Vector2, Vector3와 같은 벡터 타입을 입력으로 받아, 그 안에 포함된 각 채널(R, G, B, A)을 별개의 float 출력 핀으로 나눔 . debug float value . 디버깅용. base color에 넣고 값 확인 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#node-function",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#node-function"
  },"738": {
    "doc": "Episode 1 - 10",
    "title": "UV control",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#uv-control",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#uv-control"
  },"739": {
    "doc": "Episode 1 - 10",
    "title": "파이프라인 연결 예",
    "content": "[TextureCoordinate] → [Texture Sample] → [Base Color] . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%97%B0%EA%B2%B0-%EC%98%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#파이프라인-연결-예"
  },"740": {
    "doc": "Episode 1 - 10",
    "title": "hlsl 예시",
    "content": "float2 uv = input.TexCoord0.xy; // TextureCoordinate float4 color = MyTexture.Sample(MySampler, uv); // Texture Sample return color; // Base Color 출력 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#hlsl-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#hlsl-예시"
  },"741": {
    "doc": "Episode 1 - 10",
    "title": "TextureCoordinate",
    "content": "TextureCoordinate = “좌표 공급자” (데이터만 제공) . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texturecoordinate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texturecoordinate"
  },"742": {
    "doc": "Episode 1 - 10",
    "title": "TextureCoordinate 노드가 input이 없는 것처럼 보이는 이유",
    "content": ". | 메시 데이터에 포함된 UV . | 모델링 툴에서 내보낸 메시에는 버텍스 속성(attribute)들이 들어 있음. | 위치 (Position) / 법선 (Normal) / UV 좌표 (TexCoord0, TexCoord1, …) / 색상(Vertex Color) 등 | GPU는 이 속성을 버텍스 버퍼(vertex buffer)에 저장하고, 버텍스 셰이더에 전달 | . | 셰이더 파이프라인에서의 UV 전달 . | 버텍스 셰이더 입력: 메시 버텍스 버퍼에서 TEXCOORD0, TEXCOORD1 같은 UV 세트가 들어옴. 보통 여기서는 UV에 대한 연산 없이 그대로 출력 구조체에 담음. | 래스터라이저: 삼각형 내부 픽셀마다 바리센트릭 좌표를 사용해 전달된 UV를 보간. 일반적으로 투영 보정(perspective-correct interpolation) 포함. | 픽셀 셰이더 입력: 보간된 UV가 input.TexCoord0 형태로 들어옴. 여기서 샘플러에 전달 가능. | . | Unreal의 TextureCoordinate 노드 . | 머티리얼 그래프의 TextureCoordinate 노드는 추가 연산 없이 이 UV 입력을 그대로 참조하는 래퍼. | 단순히 메시에서 이미 넘어오는 TexCoord[n]을 가져와서 옵션(타일링/오프셋)을 곱해주는 것. | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texturecoordinate-%EB%85%B8%EB%93%9C%EA%B0%80-input%EC%9D%B4-%EC%97%86%EB%8A%94-%EA%B2%83%EC%B2%98%EB%9F%BC-%EB%B3%B4%EC%9D%B4%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texturecoordinate-노드가-input이-없는-것처럼-보이는-이유"
  },"743": {
    "doc": "Episode 1 - 10",
    "title": "Texture Sample",
    "content": "Texture Sample 노드 = GPU의 Texture2D.Sample 호출을 래핑한 것 . | Texture Sample = “샘플러” (실제 텍스처 메모리에서 읽음) | . float4 color = Texture2D.Sample(SamplerState, uv); . | Texture2D: GPU 메모리에 올라간 텍스처 객체. | SamplerState: 필터링(Nearest, Bilinear, Trilinear, Anisotropic)과 주소 모드(Wrap, Clamp 등)를 정의. | uv: 픽셀 셰이더 입력에서 넘어온 보간된 UV. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texture-sample",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#texture-sample"
  },"744": {
    "doc": "Episode 1 - 10",
    "title": "정리",
    "content": ". | 버텍스 → “내가 UV 공간의 어디에 붙어야 하는지” 정보 가짐 | TextureCoordinate → 그 UV 좌표를 가져와서 머티리얼 그래프의 다른 노드들이 쓸 수 있게 출력 | Texture Sample → UV 좌표를 사용해 텍스처 버퍼에서 색을 읽음 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#정리"
  },"745": {
    "doc": "Episode 1 - 10",
    "title": "time",
    "content": "머티리얼이 렌더링되는 동안의 경과 시간을 제공 . | CPU가 마련해 둔 시간 값을 셰이더(GPU)에서 손쉽게 꺼내 쓸 수 있도록 함 | . float t = MaterialParameters.Time; // 엔진에서 넘겨주는 시간 값 . | 출력: float (단일 값) | 단위: 초(second) | 값: 게임 실행 시점(또는 머티리얼이 처음 활성화된 시점)부터 누적된 시간 | GPU 셰이더로 전달될 때는 보통 GameTime 같은 전역 유니폼 값으로 들어감 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#time",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#time"
  },"746": {
    "doc": "Episode 1 - 10",
    "title": "활용",
    "content": ". | 스크롤링 텍스쳐 | . UV = TexCoord + float2(Time * Speed, 0); . | 펄싱/사인 웨이브 효과 | . Glow = abs(sin(Time * Frequency)); . | 노이즈 애니메이션 : 노이즈 텍스쳐 uv에 time을 곱해 움직히는 패턴 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#활용"
  },"747": {
    "doc": "Episode 1 - 10",
    "title": "Flipbook Animation",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook-animation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook-animation"
  },"748": {
    "doc": "Episode 1 - 10",
    "title": "Animation FPS",
    "content": "머티리얼에서 FPS라고 쓰는 건 사실 애니메이션 재생 속도를 의미하는 가상의 프레임레이트. 실제 렌더링 FPS와는 독립적 . Frame = floor(Time * FPS) % N // n = 스프라이트 시트의 전체 프레임 개수 . | 여기서 FPS는 1초 동안 몇 개의 스프라이트 칸을 넘길지를 의미 | 렌더링 FPS에 상관없이 애니메이션을 1초에 12장(12 FPS)의 속도로 재생하라고 명령한 것 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#animation-fps",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#animation-fps"
  },"749": {
    "doc": "Episode 1 - 10",
    "title": "Flipbook",
    "content": "내장 함수. time과 행, 열 값을 받음 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook"
  },"750": {
    "doc": "Episode 1 - 10",
    "title": "Flipbook 효과 직접 만들기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook-%ED%9A%A8%EA%B3%BC-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#flipbook-효과-직접-만들기"
  },"751": {
    "doc": "Episode 1 - 10",
    "title": "frac",
    "content": "숫자의 소수점 부분만 반환 . | 0~1 사이의 주기적 패턴에 매우 유용 | UV 스크롤이나 간단한 펄스 생성에 사용 | . Frac(3.7) = 0.7 Frac(-2.3) = 0.7 // 주의: 음수일 때 결과가 양수 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#frac",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#frac"
  },"752": {
    "doc": "Episode 1 - 10",
    "title": "floor",
    "content": "소수점 이하를 버리고 정수만 남김 (항상 내림) . Floor(3.0) = 3.0 Floor(3.2) = 3.0 Floor(3.7) = 3.0 Floor(3.999) = 3.0 Floor(-2.3) = -3.0 // 주의: 음수일 때 더 작은 수로 내림 . Floor vs 다른 정수화 노드 비교 . | 입력값 | Floor (내림) | Ceil (올림) | Round (반올림) | . | 2.1 | 2.0 | 3.0 | 2.0 | . | 2.5 | 2.0 | 3.0 | 3.0 | . | 2.9 | 2.0 | 3.0 | 3.0 | . | -1.2 | -2.0 | -1.0 | -1.0 | . 플립북에는 왜 Floor를 사용하나? . | 시간이 흐르면서 프레임이 순차적으로 증가해야 함 | Ceil을 사용하면 프레임이 도약하는 문제 발생 | Round를 사용하면 2.5초 때 3번 프레임으로 점프하는 불연속 발생 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#floor",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#floor"
  },"753": {
    "doc": "Episode 1 - 10",
    "title": "Modulo",
    "content": "언리얼의 실수 modulo는 C의 fmod 계열이라 피제수(첫 인자)의 부호를 따름 . // 주의: y == 0이면 정의되지 않음 float r = FMath::Fmod(x, y); if (r &lt; 0) r += FMath::Abs(y); . Modulo vs Clamp 비교 . | 연산 | 결과 | 용도 | . | Modulo | 0,1,2,3,0,1,2,3,… | 무한 반복 애니메이션 | . | Clamp | 0,1,2,3,3,3,3,3,… | 한 번 재생하고 정지하는 애니메이션 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#modulo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#modulo"
  },"754": {
    "doc": "Episode 1 - 10",
    "title": "fmod",
    "content": "부동소수점 숫자를 위한 나머지 연산 . fmod( 7.5, -3.0) = 1.5 // 피제수가 양수면 결과 양수 fmod(-7.5, 3.0) = -1.5 // 피제수가 음수면 결과 음수 . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#fmod",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#fmod"
  },"755": {
    "doc": "Episode 1 - 10",
    "title": "param",
    "content": ". | Scalar Parameter : float | Vector Parameter : Vec3 → A 무시 / Vec2 → ComponentMask RG로 사용 | Material Parameter Collection(MPC) : 전역 공유 값 | Named Reroute (Declaration/Usage) : Vec2/Vec3/Vec4 모두 가능. 인스턴스에서 값 조절은 불가 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#param",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html#param"
  },"756": {
    "doc": "Episode 1 - 10",
    "title": "Episode 1 - 10",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/Episode%201%20-%2010.html"
  },"757": {
    "doc": "Exposing Function to Blueprint",
    "title": "Exposing Function to Blueprint",
    "content": "클래스 함수 블루 프린트에 노출 시키기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html"
  },"758": {
    "doc": "Exposing Function to Blueprint",
    "title": "사용 예시",
    "content": ". | UFUNCTION 매크로 사용 . | C++ 함수에 UFUNCTION 매크로 + 특정 Specifier를 붙이면 블루프린트에서 호출하거나, 이벤트/오버라이드/멀티캐스트 등 다양한 방식으로 사용할 수 있음 | . | . UCLASS() class MYPROJECT_API AMyActor : public AActor { GENERATED_BODY() public: // 블루프린트에서 호출 가능(이벤트 그래프에서 노드로 생성 가능) UFUNCTION(BlueprintCallable, Category=\"MyCategory\") void MyFunction(); // 블루프린트에서 오버라이드 가능한 이벤트로 노출 UFUNCTION(BlueprintImplementableEvent, Category=\"MyCategory\") void MyEvent(); // 블루프린트에서 직접 구현 및 호출 가능한 함수로 노출 UFUNCTION(BlueprintNativeEvent, Category=\"MyCategory\") void MyNativeEvent(); }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#사용-예시"
  },"759": {
    "doc": "Exposing Function to Blueprint",
    "title": "UFUNCIONT()",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#ufunciont",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#ufunciont"
  },"760": {
    "doc": "Exposing Function to Blueprint",
    "title": "Specifiers 정리",
    "content": "| 속성 | 설명 | 예시 | . | BlueprintCallable | 블루프린트에서 노드로 호출 가능 | UFUNCTION(BlueprintCallable) | . | BlueprintPure | 순수 함수. 값만 반환함 | UFUNCTION(BlueprintPure) | . | BlueprintImplementableEvent | 함수의 구현을 블루프린트에서 작성 (C++ 구현 없음) | UFUNCTION(BlueprintImplementableEvent) | . | BlueprintNativeEvent | C++ 기본 구현 + 블루프린트에서 오버라이드 가능 | UFUNCTION(BlueprintNativeEvent) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#specifiers-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#specifiers-정리"
  },"761": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintCallable",
    "content": ". | 블루프린트의 함수 노드로 직접 호출 가능 | 입력/출력 인자를 모두 지원. 함수의 실행 흐름에 실행 핀(Exec Pin)이 생김 | C++에서 구현하며, 블루프린트 그래프 내에서 다양한 조건문, 이벤트와 연결할 수 있음 . | 실행 흐름 제어가 필요한 곳에 적합 | . | . // 헤더 UFUNCTION(BlueprintCallable, Category=\"Gameplay\") void DealDamage(float DamageAmount); // CPP void AMyCharacter::DealDamage(float DamageAmount) { Health -= DamageAmount; } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintcallable",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintcallable"
  },"762": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintPure",
    "content": ". | 순수 함수로 값만 반환함 (반드시 반환값이 있어야함) | 실행 핀이 없이 입력값이 바뀌면 즉시 계산 결과 반환 . | 수식처럼 사용 | . | . // 헤더 UFUNCTION(BlueprintPure, Category=\"Stats\") float GetHealthPercentage() const; // CPP float AMyCharacter::GetHealthPercentage() const { return Health / MaxHealth; } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintpure",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintpure"
  },"763": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintImplementableEvent",
    "content": ". | C++에서는 함수 선언만 하고 구현은 블루프린트에서 작성 | C++에서 이벤트를 발동(Trigger) 시키기 가능 | . // 헤더 UFUNCTION(BlueprintImplementableEvent, Category=\"AI\") void OnEnemySpotted(AActor* SpottedEnemy); // CPP (구현부 없음!) -&gt; 블루프린트에서: \"On Enemy Spotted\" 이벤트 구현 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintimplementableevent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintimplementableevent"
  },"764": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintNativeEvent",
    "content": ". | C++ 기본 구현 + 블루프린트 오버라이드를 모두 지원 | _Implementation 접미사 규칙을 사용한다 | . // 헤더 UFUNCTION(BlueprintNativeEvent, Category=\"Inventory\") bool TryUseItem(UItem* Item); // CPP (기본 구현) bool AMyCharacter::TryUseItem_Implementation(UItem* Item) { return Item-&gt;bIsUsable; } // 블루프린트에서: \"Try Use Item\" 노드로 오버라이드 가능 . | C++ 호출은 TryUseItem(Item)로 호출 (자동으로 _Implementation 연결) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintnativeevent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintnativeevent"
  },"765": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Exposing Variables to Blueprint",
    "content": "클래스 변수 블루프린트에 노출시키기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html"
  },"766": {
    "doc": "Exposing Variables to Blueprint",
    "title": "사용 예시",
    "content": ". | UPROPERTY 매크로 사용 . | 변수에 메타데이터 및 속성을 부여해 언리얼의 리플렉션 시스템과 에디터, 블루프린트 등에서 활용할 수 있게 함 | . | . UCLASS() class YOURPROJECT_API UMyClass : public UObject { GENERATED_BODY() public: // 블루프린트에서 읽기/쓰기 가능한 변수 UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\") float MyFloatVariable; // 블루프린트에서 읽기만 가능한 변수 UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"MyCategory\") int32 MyReadOnlyInt; }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#사용-예시"
  },"767": {
    "doc": "Exposing Variables to Blueprint",
    "title": "UPROPERTY()",
    "content": "UPROPERTY([specifier1, specifier2, ...], [meta=(key1=value1, key2=value2, ...]) . | Specifiers : 변수의 기본 동작을 정의하는 필수 속성들 . | 쉼표로 구분하여 여러 개 지정 가능 | . | Meta Data : 선택적 추가 설정 (meta=로 시작) . | key=value 형태로 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#uproperty",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#uproperty"
  },"768": {
    "doc": "Exposing Variables to Blueprint",
    "title": "특징",
    "content": ". | 블루프린트 노출 . | 변수를 블루프린트에서 사용하려면 반드시 BlueprintReadOnly 또는 BlueprintReadWrite를 지정 | . | 카테고리 지정 . | Category 속성을 사용하면 에디터에서 속성이 그룹화되어 표시 | . | 네트워크 복제 . | 멀티플레이어 게임에서는 Replicated 속성을 사용하여 변수를 복제 | . | 에디터 표시 . | meta 속성들을 사용하여 에디터에서 변수가 어떻게 표시되고 동작할지 세부 조정 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#특징"
  },"769": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Specifiers 정리",
    "content": ". | EditDefaultsOnly : 블루프린트 기본 설정 (이벤트 그래프) 디테일 패널에 노출 | EditInstanceOnly : 블루프린트 인스턴스 (레벨 뷰) 디테일 패널에 노출 | EditAnywhere : 둘 다 보임. 인스턴스에서 설정 건드리면 기본 설정 바꿔도 인스턴스 설정 그대로 따라감 | . | BlueprintReadWrite : 블루 프린트 노드로 클래스 변수 사용 가능하게 해줌 . | private 안에서 사용 불가 | . | . | 속성 | 설명 | 사용 예시 | . | EditAnywhere | 에디터의 모든 인스턴스에서 편집 가능 | UPROPERTY(EditAnywhere) | . | VisibleAnywhere | 에디터에서 볼 수 있지만 편집 불가 | UPROPERTY(VisibleAnywhere) | . | EditDefaultsOnly | 클래스 기본값에서만 편집 가능 | UPROPERTY(EditDefaultsOnly) | . | VisibleDefaultsOnly | 클래스 기본값에서만 보임 | UPROPERTY(VisibleDefaultsOnly) | . | EditInstanceOnly | 인스턴스에서만 편집 가능 | UPROPERTY(EditInstanceOnly) | . | BlueprintReadWrite | 블루프린트에서 읽기/쓰기 가능 | UPROPERTY(BlueprintReadWrite) | . | BlueprintReadOnly | 블루프린트에서 읽기만 가능 | UPROPERTY(BlueprintReadOnly) | . | Category | 에디터에서 표시될 카테고리 | UPROPERTY(Category=”Gameplay”) | . | Replicated | 네트워크 복제 활성화 | UPROPERTY(Replicated) | . | ReplicatedUsing | 복제 시 호출할 함수 지정 | UPROPERTY(ReplicatedUsing=OnRep_MyVar) | . | SaveGame | 세이브 게임에 포함 | UPROPERTY(SaveGame) | . | Transient | 저장되지 않는 임시 변수 | UPROPERTY(Transient) | . | Config | config 파일에서 값 로드 | UPROPERTY(Config) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#specifiers-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#specifiers-정리"
  },"770": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Meta Data 정리",
    "content": "| 속성 | 기능 | 사용 예시 | . | AllowPrivateAccess | private C++ 변수를 블루프린트에서 접근 가능하게 함 | meta = (AllowPrivateAccess = “true”) | . 참고하면 좋은 링크 . | gameplay classes Properties | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#meta-data-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#meta-data-정리"
  },"771": {
    "doc": "Fix Up Redirectors From Code",
    "title": "목표: 리다이렉터 정리하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%AA%A9%ED%91%9C-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#목표-리다이렉터-정리하기"
  },"772": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Redirector",
    "content": "에셋이 이동하거나 이름이 변경되었을 때 기존 참조를 유지하기 위해 사용 . | 에디터의 콘텐트 브라우저에서 이동하거나 변경하면 자동으로 생성함 | 탐색기나 터미널을 사용하여 에셋 이동 시 리다이렉터가 생성되지 않음 . | 에디터 API 를 사용하는 경우는 리다이렉터 정상 생성 | . | 리다이렉터가 많아지면 빌드/로딩 속도가 느려짐 -&gt; 정리 필요 | 콘텐츠 브라우저에서 우클릭 → ‘레퍼런스 뷰어’로 참조 관계 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector"
  },"773": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터가 필요한 이유",
    "content": ". | 언리얼 엔진 프로젝트는 에셋 간의 참조(Reference) 관계가 복잡하게 얽혀 있음 | 만약 어떤 블루프린트, 머티리얼, 레벨 등이 특정 에셋을 참조하고 있는데, 그 에셋의 위치나 이름이 바뀌면 기존 참조가 모두 깨짐 | 이 문제를 방지하기 위해, 기존 위치(예전 경로)에 ‘리다이렉터’ 에셋을 생성함 | 이 리다이렉터 에셋은 “이 에셋은 이제 새로운 위치에 있습니다”라고 알려줌으로써, 예전 참조들이 새 위치의 에셋을 계속 사용할 수 있게 해줌 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터가-필요한-이유"
  },"774": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터 작동 방식",
    "content": "1. 디스크(파일) 저장 . 리다이렉터는 ObjectRedirector 타입의 .uasset 파일로 저장 . | 자신이 원래 위치했던 경로(Original Path) | 참조해야 하는 대상 오브젝트(DestinationObject, 새 경로의 에셋에 대한 소프트 참조) 가 저장됨 | 이 상태의 리다이렉터는 그냥 하나의 “Proxy” 에셋(패키지)일 뿐이며, 실제 오브젝트 인스턴스(UObject 인스턴스)는 생성되어 있지 않음 | . 리다이렉터 에셋 개념적 구조 . // ObjectRedirector.uasset (실제 파일은 바이너리이지만, 개념적으로 다음과 같은 정보를 저장) { \"OriginalObjectPath\": \"/Game/Characters/OldCharacter\", // 원본 경로 \"DestinationObjectPath\": \"/Game/Heroes/NewCharacter\", // 새 경로 (SoftObjectPath) \"Flags\": RF_Public | RF_Standalone, // 객체 플래그 \"DestinationObject\": \"Soft Reference\" // 실제로는 포인터가 아니라 소프트 참조(경로 정보) 형태 } . 2. 메모리 로드(에디터/엔진에서 참조할 때) . | 리다이렉터가 메모리로 로드됨 . | 어떤 에셋이 리다이렉터 경로를 참조하고 있을 때, 언리얼은 먼저 리다이렉터(.uasset) 파일을 로드해서 UObjectRedirector 인스턴스로 메모리에 올림 | . | DestinationObject로 즉시 변환 . | 엔진은 리다이렉터를 참조하는 순간, DestinationObject(실제 에셋)를 메모리로 로드하고 참조를 자동으로 대체함 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터-작동-방식"
  },"775": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Redirectors 함수 구현에 사용한 메서드",
    "content": "Fix 과정의 핵심 . | 모든 리다이렉터를 탐색 | 각 리다이렉터의 DestinationObject를 메모리에 로드 | 예전 참조(리다이렉터 경로)를 새 참조(DestinationObject 경로)로 교체 | 리다이렉터 파일 삭제 | . 1. IAssetRegistry&amp; AssetRegistry . 에셋 레지스트리 가져오기 . ❓ 왜 인터페이스 레퍼런스 타입으로 가져오는거야? . | AssetRegistry는 엔진 내부적으로 이미 생성되어 관리되는 객체 | new로 직접 인스턴스를 만들면, 엔진의 전역 에셋 DB와 분리된 “쓸모 없는 객체”가 만들어짐 | 즉, 반드시 엔진이 소유/관리하는 인스턴스를 사용해야 하며, 이를 제공받는 공식 경로는 아래와 같다. | . FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get() . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-함수-구현에-사용한-메서드"
  },"776": {
    "doc": "Fix Up Redirectors From Code",
    "title": "함수명에 붙은 Checked란?",
    "content": "함수명에 “Checked”가 붙었을 때는 무조건 성공해야 하며, 실패 시 프로그램을 즉시 중단(Assert/Crash)한다는 의미 . | CastChecked (타입 불일치 → 크래시) | LoadModuleChecked (모듈 없음/실패 → 크래시) | . 비교 예시 . | 함수 | 동작 | 실패 시 | . | LoadModule() | 모듈 로드, 실패 시 nullptr 반환 | 안전 | . | LoadModuleChecked() | 모듈 로드, 실패 시 Assertion Failure(크래시) | 위험 (강제 중단) | . | GetModule() | 이미 로드된 모듈만 반환, 없으면 nullptr | 안전 | . 2. FModuleManager::LoadModuleChecked&lt;T&gt; . 엔진/에디터 모듈을 런타임에 안전하게 로드 . | FModuleManager:: . | 모듈 동적 로딩 시스템을 관리하는 핵심 클래스 | . | LoadModuleChecked() . | 템플릿 함수로, 지정된 모듈 타입(T)을 강제로 로드하고 검증 후 반환 | 모듈이 존재하지 않으면 크래시 | . | . template&lt;class T&gt; static T&amp; LoadModuleChecked(FName ModuleName); . 동작 . | ModuleName에 해당하는 모듈이 이미 로드되어 있으면 . | → 바로 그 모듈의 레퍼런스(포인터/레퍼런스)를 반환 | . | 아직 로드되지 않았다면 . | 모듈을 로드(동적 DLL 또는 엔진 플러그인 로딩) 시도 | 성공하면 인스턴스 반환 | 실패시 크래시 | . | 반환 타입은 T&amp; (예: FAssetRegistryModule&amp;) | . 3. CastChecked&lt;T&gt;() . 주어진 포인터가 실제 런타임에 T 타입(혹은 그 하위 타입)인지 체크한 뒤, 맞으면 T로 변환해서 반환 . | 틀리면 에디터 빌드(Development/Debug)에서는 강제로 크래시(Assertion 실패)를 일으킴 | . CastChecked&lt;T&gt;와 Cast&lt;T&gt;의 차이 . | 함수 | 타입 체크 실패 시 동작 | 주로 사용하는 상황 | . | Cast&lt;T&gt;() | 실패 시 nullptr 반환 | 타입이 확실하지 않을 때, if문으로 분기 필요할 때 | . | CastChecked&lt;T&gt;() | 실패 시 크래시/Assertion Failure | 타입이 반드시 T여야 할 때 (논리 오류 방지) | . 3. FARFilter . AssetRegistry 모듈에서 사용하는 에셋 검색 조건을 표현하는 구조체 . | AssetRegistry API (GetAssets 등) 호출 시, 이 구조체를 넘겨주면 조건에 맞는 에셋만 결과로 반환 | . FARFilter 주요 멤버 . | 필드 | 역할 | . | TArray&lt;FName&gt; PackagePaths | 검색할 폴더 경로(예:/Game, /Game/MyFolder) | . | TArray&lt;FName&gt; ClassPaths | 검색할 클래스 유형(예: Blueprint, ObjectRedirector) | . | bool bRecursivePaths | 하위 폴더까지 검색할지 여부 | . | TArray&lt;FName&gt; ObjectPaths | 특정 오브젝트 경로 지정(옵션) | . | … | 이 외에도 Tag, Metadata 등 다양한 조건 가능 | . FARFilter 사용 예시 . // AssetRegistry 모듈 참조 얻기 IAssetRegistry&amp; AssetRegistry = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get(); // FARFilter 구조체 생성 FARFilter Filter; // 검색할 폴더 지정 (여러 개 가능) Filter.PackagePaths.Add(FName(\"/Game/MyFolder\")); // 예시: /Game/MyFolder 폴더만 검색 // 하위 폴더까지 재귀적으로 검색할지 여부 Filter.bRecursivePaths = true; // 검색할 클래스 지정 (여러 개 가능) Filter.ClassPaths.Add(UStaticMesh::StaticClass()-&gt;GetClassPathName()); // 스태틱 메시만 대상 // Filter.ClassPaths.Add(UMaterial::StaticClass()-&gt;GetClassPathName()); // 필요하면 다른 클래스도 추가 // 특정 태그 기반 검색 예시 (선택 사항) // Filter.TagsAndValues.Add(FName(\"MyTag\"), TEXT(\"MyValue\")); // 결과 저장할 배열 TArray&lt;FAssetData&gt; AssetList; // 실제 검색 수행 AssetRegistry.GetAssets(Filter, AssetList); // 결과 사용 예시 for (const FAssetData&amp; Asset : AssetList) { UE_LOG(LogTemp, Log, TEXT(\"Asset found: %s\"), *Asset.AssetName.ToString()); } . 4. AssetRegistry.GetAssets(Filter, AssetList) . Filter에 지정된 조건(폴더, 클래스, 태그 등)에 맞는 에셋의 메타데이터 목록을 OutAssetData(배열)에 추가 . virtual bool GetAssets( const FARFilter&amp; InFilter, TArray&lt;FAssetData&gt;&amp; OutAssetData, bool bSkipARFilteredAssets ) const = 0; . | 매개변수 . | const FARFilter&amp; Filter . | 에셋 검색 조건 | . | TArray&amp; OutAssetData . | 검색 결과가 담길 배열 (에셋 메타데이터(FAssetData) 객체) | . | bool bSkipARFilteredAssets . | AssetRegistry에 이미 “숨김(Filtered Out)” 처리된 에셋을 결과에서 제외 | 기본값 true (숨김 에셋 제외) | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%ED%95%A8%EC%88%98%EB%AA%85%EC%97%90-%EB%B6%99%EC%9D%80-checked%EB%9E%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#함수명에-붙은-checked란"
  },"777": {
    "doc": "Fix Up Redirectors From Code",
    "title": "AssetViewUtils",
    "content": "콘텐츠 브라우저(에셋 뷰)에서 에셋의 표시, 로딩, 정렬, 필터링 등과 관련된 작업 유틸리티 . | ContentBrowser 모듈에 포함 . | 에셋을 실제로 메모리로 로드(Load) | 에셋 목록을 정렬(Sort), 필터(Filter) | 콘텐츠 브라우저에서 사용할 다양한 유틸리티 제공 | . 5. AssetViewUtils::FLoadAssetsSettings . 에셋 로딩 동작을 세부적으로 제어하는 옵션 구조체 . | 위에서 설명한 Filter와 마찬가지로 설정 옵션을 정의하는 용도로 쓰임 | . FLoadAssetsSettings 주요 맴버 . | 필드 | 역할 | . | bFollowRedirectors | 에셋 경로가 리다이렉터인 경우, 자동으로 실제 에셋을 따라갈지 여부 - true면 리다이렉터를 따라가 실제 에셋을 로딩 - false면 리다이렉터 그 자체만 로드 | . | bAllowCancel | 로딩 도중 사용자가 취소(Interrupt/Cancel)할 수 있는 UI가 노출될지 여부 - 에디터에서 대량 에셋 로딩시 “취소” 가능 | . 6. AssetViewUtils::LoadAssetsIfNeeded . 에셋의 오브젝트 경로(ObjectPath) 리스트를 받아, 실제로 필요한 에셋만 메모리로 로드하는 에디터 유틸리티 함수 . | 이미 메모리에 로드된 에셋은 재로드하지 않음 | 콘텐츠 브라우저 및 에디터 툴에서 대량 에셋 로딩에 특화 | . // 매개변수 설명 ELoadAssetsResult LoadAssetsIfNeeded( const TArray&lt;FString&gt;&amp; AssetObjectPaths, // 오브젝트 경로 문자열 리스트 TArray&lt;UObject*&gt;&amp; LoadedAssets, // 실제 로딩된 에셋 객체가 저장될 배열 const FLoadAssetsSettings&amp; Settings // 로딩 옵션(구조체) ); AssetViewUtils::LoadAssetsIfNeeded(AssetObjectPaths, LoadedAssets, Settings); . 반환값 . | 값 | 의미 | . | ELoadAssetsResult::Succeeded | 모든 에셋 정상 로드 | . | ELoadAssetsResult::Cancelled | 로딩 중 사용자 취소 | . | ELoadAssetsResult::Failed | 로딩 자체 실패 | . 7. AssetToolsModule.Get().FixupReferencers() . FixupReferencers()는 깨진 참조를 수정하는 핵심 함수이다 . | 깨진 참조 자동 복구 . | 에셋 경로 변경으로 인해 깨진 참조를 검색하고 자동으로 수정 | 리다이렉터가 존재할 경우 대상 경로로 참조를 업데이트 | . | 대상 범위 . | 선택한 에셋(들)을 참조하는 모든 다른 에셋을 검사 | 블루프린트, 머티리얼, 레벨 등 모든 에셋 타입의 참조 처리 가능 | . | 리다이렉터 처리 . | 기존 리다이렉터를 제거하고 직접 참조로 변환할 수 있음 | . | . virtual void FixupReferencers( const TArray&lt;UObjectRedirector*&gt;&amp; Redirectors, bool bCheckoutDialogPrompt = false, ERedirectFixupMode FixupMode = ERedirectFixupMode::DeleteFixedUpRedirectors ) = 0; . | 매개변수 . | Redirectors: UObjectRedirector*의 배열로, 참조를 갱신할 리다이렉터 목록 | bCheckoutDialogPrompt: true로 설정하면, 소스 컨트롤 사용 시 체크아웃 다이얼로그를 표시 | FixupMode: 리다이렉터 처리 방식을 지정 . | ERedirectFixupMode::DeleteFixedUpRedirectors: 참조가 갱신된 리다이렉터를 삭제 | ERedirectFixupMode::LeaveFixedUpRedirectors: 참조가 갱신되더라도 리다이렉터를 유지 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils"
  },"778": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Up Redirectors From Code",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html"
  },"779": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration (전방 선언)",
    "content": "클래스나 구조체의 완전한 정의 없이 컴파일러에게 해당 타입의 존재만을 알리는 선언 . | 포인터(또는 참조) 변수만 쓸 때는 클래스 전체 정의가 필요 없음 | 포인터는 타입의 실제 크기를 몰라도 주소값만 저장하므로 forward declaration만으로 충분 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%A0%84%EB%B0%A9-%EC%84%A0%EC%96%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-전방-선언"
  },"780": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration 사용 이유",
    "content": ". | 컴파일 시간 감소 . | 헤더 파일을 포함하면 해당 헤더와 모든 종속성이 재컴파일되지만, 전방 선언은 이를 방지함 | . | 순환 참조 해결 . | 두 클래스가 서로를 참조할 때 발생하는 순환 종속성을 해결 | . | 코드 팽창 방지 . | 불필요한 헤더 포함으로 인한 코드 크기 증가를 막음 | . | 빌드 시스템 간소화 . | 종속성 감소로 빌드 시스템이 단순화 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-사용-이유"
  },"781": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration 예시",
    "content": "hpp . // MyClass.h 헤더 파일 #pragma once class ADependencyClass; // 전방 선언 UCLASS() class UMyClass : public UObject { GENERATED_BODY() private: ADependencyClass* DependencyPtr; // 포인터로 사용 가능 }; . cpp . // MyClass.cpp 소스 코드 #include \"ADependencyClass.h\" // 실제 객체를 생성하거나 멤버 함수, 변수 접근 시 필요 UMyClass::UMyClass() { DependencyPtr = CreateDefaultSubobject&lt;ADependencyClass&gt;(TEXT(\"MyComp\")); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-예시"
  },"782": {
    "doc": "Forward Declaration",
    "title": "언제 헤더 파일을 include 해야 하나",
    "content": ". | 클래스를 상속할 때 . | 부모 클래스의 완전한 정의가 필요 | . | 실제 객체(인스턴스)를 생성할 때 . | new 또는 CreateDefaultSubobject 등 메모리 할당이 필요한 경우 | 타입의 크기를 알아야 할 때 (sizeof 등) | . | 멤버 변수 또는 함수에 접근할 때 . | 클래스의 실제 멤버 정보가 필요 | . | 템플릿 인스턴스화가 필요할 때 . | 템플릿 타입을 특정 타입으로 인스턴스화할 때 완전한 정의 필요 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#%EC%96%B8%EC%A0%9C-%ED%97%A4%EB%8D%94-%ED%8C%8C%EC%9D%BC%EC%9D%84-include-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#언제-헤더-파일을-include-해야-하나"
  },"783": {
    "doc": "Forward Declaration",
    "title": "권장 인클루드 순서",
    "content": ". | 현재 클래스의 헤더 . | \"MyClass.h\" | 자기 완결성 검증: 자신의 헤더가 다른 헤더에 의존하지 않고 독립적인지 확인 | 컴파일 오류 조기 발견: 헤더 파일의 누락된 종속성을 즉시 확인 가능 | . | 엔진/프레임워크 헤더 . | &lt;CoreMinimal.h&gt; 등 | 시스템 종속성 분리: 플랫폼별 정의나 엔진 매크로가 먼저 로드되도록 보장 | . | 다른 모듈의 헤더 . | \"MyGame/Public/ModuleX.h\" | 모듈 경계 명확화: 프로젝트 내부 모듈 간의 종속성을 가시화 | . | 로컬, 프라이빗 헤더 . | Private/Subsystem.h | 구현 세부사항 은닉: 내부 구현용 헤더를 마지막에 위치시켜 public 헤더와 분리 | . | UCLASS, USTRUCT와 같은 매크로 사용시 #include \"MyClass.generated.h\" 맨 마지막에 선언 . | 강제 규칙: 반드시 마지막에 위치 (UHT 처리 요구사항) | . | . 예시 . // 1. 현재 모듈 헤더 (생략) // 2. 엔진 헤더 #include \"CoreMinimal.h\" #include \"GameFramework/Character.h\" // 3. 다른 모듈 헤더 #include \"MyGame/Public/Components/HealthComponent.h\" #include \"MyGame/Public/Weapons/WeaponManager.h\" // 4. 로컬 헤더 #include \"MyCharacterCustomAnimInstance.h\" // 5. 생성 헤더 #include \"MyCharacter.generated.h\" . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#%EA%B6%8C%EC%9E%A5-%EC%9D%B8%ED%81%B4%EB%A3%A8%EB%93%9C-%EC%88%9C%EC%84%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#권장-인클루드-순서"
  },"784": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html"
  },"785": {
    "doc": "Forward vs Deferred",
    "title": "Forward Rendering",
    "content": "직관적이고 전통적인 렌더링 방식으로 오브젝트(Object) 단위로 렌더링을 처리한다 . | 화면에 그려야 할 물체 하나를 가져옴 | 그 물체에 영향을 미치는 모든 광원(Light)을 계산하여 최종 색상을 결정 | 그다음 물체를 가져와 이 과정을 반복 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering"
  },"786": {
    "doc": "Forward vs Deferred",
    "title": "Forward Rendering 장점 vs 단점",
    "content": "장점 . | 구현이 직관적이고 간단하다 | 투명(Transparent) 객체나 반투명(Translucent) 객체를 처리하기 용이하다 . | 이미 그려진 배경 위에 알파 블렌딩(Alpha Blending)을 적용하면 되기 때문 | . | 다양한 재질(Material)을 표현하는 데 유연하다 . | 각 오브젝트마다 완전히 다른 쉐이더(Shader)를 적용하기 쉽기 때문 | . | . 단점 . | 광원의 수가 많아지면 성능이 급격히 저하됨 . | 예를 들어, 오브젝트 100개, 광원 100개가 있다면 100 * 100 = 10000번의 조명 계산이 필요할 수 있음 | . | 오버드로우(Overdraw) 문제가 심각할 수 있음 . | 깊이 테스트(Depth Test)에 의해 최종적으로 화면에 보이지 않을 픽셀(Fragment)에 대해서도 복잡한 조명 계산을 수행하는 낭비가 발생 | . | . | N : 오브젝트 수 | M : 광원의 수 | . \\[O(N \\times M)\\] . 오브젝트의 수(N)와 광원의 수(M)에 비례하여 쉐이딩 계산량이 증가 . | Forward Rendering 과정 코드 예시 | . // 이 코드는 개념을 설명하기 위한 의사 코드(Pseudo-code) // 메인 렌더링 루프 void ForwardRender(Scene&amp; scene) { // 화면을 특정 색으로 초기화 ClearRenderTarget(); ClearDepthBuffer(); // 씬에 있는 모든 렌더링할 오브젝트에 대해 반복 for (const auto&amp; object : scene.GetObjects()) { // 이 오브젝트에 적용할 쉐이더를 활성화 object.GetMaterial()-&gt;GetShader()-&gt;Bind(); // 쉐이더에 필요한 데이터를 버텍스 쉐이더로 전달. (예: 월드, 뷰, 투영 행렬) SetShaderConstants(object.GetWorldMatrix(), viewMatrix, projectionMatrix); // 씬에 있는 모든 광원 정보를 픽셀 쉐이더로 전달 // 이것이 순방향 렌더링의 핵심이며, 성능 저하의 주된 원인이 될 수 있다. SetShaderLights(scene.GetLights()); // 오브젝트의 메쉬(정점 데이터)를 GPU에 그리도록 명령. object.GetMesh()-&gt;Draw(); } } . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering-%EC%9E%A5%EC%A0%90-vs-%EB%8B%A8%EC%A0%90",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering-장점-vs-단점"
  },"787": {
    "doc": "Forward vs Deferred",
    "title": "Deferred Rendering",
    "content": "복잡하고 비용이 큰 조명 계산을 나중으로 미루는 방식. | 순방향 렌더링이 다수의 광원 환경에서 겪는 성능 문제를 해결하기 위해 고안되었다 | . 링크 . | openGL - Deferred Shading | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering"
  },"788": {
    "doc": "Forward vs Deferred",
    "title": "Deferred Rendering 과정",
    "content": "화면(Screen) 공간을 기준으로 렌더링을 처리하며, 크게 두 단계로 나뉨 . Geometry Pass (지오메트리 패스) . | 씬의 모든 오브젝트를 렌더링하지만, 조명 계산은 전혀 하지 않음 | 대신, 조명 계산에 필요한 정보들을 여러 장의 텍스처에 저장 . | 예: 픽셀의 깊이(Depth), 표면 법선(Normal), 색상(Albedo), 반사율(Specular) 등 | . | 이 텍스처 세트를 G-Buffer(Geometric Buffer)라고 부름 | . Lighting Pass (라이팅 패스) . | G-Buffer가 완성되면, 화면을 덮는 거대한 사각형 하나만 그림 | 이 사각형의 각 픽셀을 처리할 때, G-Buffer에서 해당 픽셀의 위치, 노멀, 색상 등의 정보를 읽어옴 | 그리고 이 정보를 사용하여 모든 광원과의 조명 계산을 수행하여 최종 픽셀 색상을 결정 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-과정"
  },"789": {
    "doc": "Forward vs Deferred",
    "title": "Deferred Rendering 장점 vs 단점",
    "content": "장점 . | 수많은 광원을 효율적으로 처리할 수 있다 . | 조명 계산량이 오브젝트 수와 무관하며, 화면 픽셀 수와 광원 수에만 비례함 | . | 조명 계산에 필요한 모든 데이터를 G-Buffer에서 한 번에 가져올 수 있다 . | 데이터 지역성(Data Locality)이 좋아짐 | . | SSAO(Screen Space Ambient Occlusion)와 같은 화면 공간 기반의 후처리(Post-processing) 효과를 적용하기 용이 | . 단점 . | 투명 객체 처리가 매우 까다롭다 (블렌딩 불가) . | G-버퍼의 모든 값이 단일 프래그먼트에서 생성되기 때문 | 블렌딩은 여러 프래그먼트의 조합으로 작동하기 때문에 블렌딩이 불가 | . | 다양한 재질을 표현하기 어렵다 . | 모든 오브젝트가 표준화된 데이터를 제공하고, 표준화된 조명 계산을 거쳐야 한다는 제약이 따름 | 독특한 재질을 표현하려면, 지연 렌더링 파이프라인을 우회하여 해당 객체만 따로 순방향 렌더링으로 그리는 등의 추가 작업이 필요해짐 | . | 메모리 대역폭(Memory Bandwidth) 사용량이 높다 . | G-Buffer를 저장하기 위해 여러 장의 큰 텍스처를 사용하기 때문 | . | MSAA(Multisample Anti-aliasing)와 같은 하드웨어 기반 안티앨리어싱을 직접 적용하기 어렵다 . | G-Buffer를 생성할 때, 각 픽셀은 단 하나의 정보(하나의 노멀, 하나의 색상 등)만을 저장 | 이 과정에서 픽셀 내부의 서브샘플들이 어디에 있었는지, 경계선이 정확히 어디를 지나갔는지에 대한 ‘지오메트리 정보’가 손실 | 라이팅 패스에서는 G-Buffer의 값만 읽을 뿐 원래 어떤 삼각형의 일부였는지, 픽셀 내의 경계선 정보가 어떠했는지 전혀 알지 못함 | 따라서 최종 이미지에 후처리(Post-processing) 방식으로 적용하는 FXAA나 TAA 같은 이미지 기반 안티앨리어싱 기법에 의존 | . | . | P : 화면의 총 픽셀 수 (p = screen width * screen height) | M : 장면에 있는 총 광원의 수 | . \\[O(P \\times M)\\] . 조명 계산은 최종 화면에 그려질 픽셀(P)에 대해서만 한 번씩 수행 . | 오브젝트가 수백, 수천 개가 있더라도 지연 렌더링의 조명 계산 비용은 변하지 않음 | 최종적으로 눈에 보이는 픽셀에 대해서만 계산하기 때문 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-%EC%9E%A5%EC%A0%90-vs-%EB%8B%A8%EC%A0%90",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-장점-vs-단점"
  },"790": {
    "doc": "Forward vs Deferred",
    "title": "Deferred Rendering shader",
    "content": "디퍼드 렌더링은 지오메트리 패스와 라이팅 패스 모두 각각의 목적에 맞는 버텍스 셰이더와 픽셀 셰이더를 사용 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-shader",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#deferred-rendering-shader"
  },"791": {
    "doc": "Forward vs Deferred",
    "title": "Geometry Pass",
    "content": "목표: 3D 모델의 정보를 G-Buffer 텍스처에 기록 . | Vertex Shader | . // GeometryPass_VS cbuffer MatrixBuffer : register(b0) { matrix worldMatrix; matrix viewMatrix; matrix projectionMatrix; }; struct VertexInputType { float3 position : POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; }; // 픽셀 셰이더로 넘겨줄 데이터 구조 struct PixelInputType { float4 position : SV_POSITION; // 클립 공간 위치 (필수) float2 tex : TEXCOORD0; // 텍스처 좌표 float3 normal : NORMAL; // 월드 공간 법선 float3 worldPos : WORLDPOS; // 월드 공간 위치 }; PixelInputType main(VertexInputType input) { PixelInputType output; // 1. 정점 위치를 월드, 뷰, 프로젝션 순으로 변환 float4 worldPos = mul(float4(input.position, 1.0f), worldMatrix); float4 viewPos = mul(worldPos, viewMatrix); output.position = mul(viewPos, projectionMatrix); // 2. 픽셀 셰이더에서 사용할 월드 공간 위치와 법선을 계산 output.worldPos = worldPos.xyz; output.normal = normalize(mul(input.normal, (float3x3)worldMatrix)); // 3. 텍스처 좌표 전달 output.tex = input.tex; return output; } . | Pixel Shader | . //GeometryPass_PS Texture2D shaderTexture : register(t0); SamplerState SampleType : register(s0); struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; float3 normal : NORMAL; float3 worldPos : WORLDPOS; }; // G-Buffer 출력을 위한 구조체 (MRT: Multiple Render Targets) struct GBufferOutputType { float4 worldPos : SV_Target0; // 타겟 0: 월드 위치 텍스처 float4 albedo : SV_Target1; // 타겟 1: Albedo 색상 텍스처 float4 normal : SV_Target2; // 타겟 2: 월드 법선 텍스처 }; GBufferOutputType main(PixelInputType input) { GBufferOutputType output; // 입력 데이터를 각 G-Buffer 타겟에 맞게 채워넣기 output.worldPos = float4(input.worldPos, 1.0f); output.albedo = shaderTexture.Sample(SampleType, input.tex); output.normal = float4(normalize(input.normal), 1.0f); return output; } . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#geometry-pass",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#geometry-pass"
  },"792": {
    "doc": "Forward vs Deferred",
    "title": "Lighting Pass",
    "content": "목표: G-Buffer의 정보를 읽어와 최종 조명 계산을 수행 . | Vertex Shader | . //LightingPass_VS struct VertexInputType { float3 position : POSITION; float2 tex : TEXCOORD0; }; struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; }; PixelInputType main(VertexInputType input) { PixelInputType output; // 이미 화면 좌표계로 정점이 들어온다고 가정하고 그대로 출력 output.position = float4(input.position, 1.0f); output.tex = input.tex; return output; } . | Pixel Shader | . // LightingPass_PS // 지오메트리 패스에서 만든 G-Buffer 텍스처들을 입력으로 받음 Texture2D worldPosTexture : register(t0); Texture2D albedoTexture : register(t1); Texture2D normalTexture : register(t2); SamplerState SampleType : register(s0); cbuffer LightBuffer : register(b0) { float3 lightDirection; float4 diffuseColor; }; struct PixelInputType { float4 position : SV_POSITION; float2 tex : TEXCOORD0; }; // 최종 출력은 색상 하나 float4 main(PixelInputType input) : SV_TARGET { // 1. 현재 픽셀의 UV 좌표를 이용해 G-Buffer에서 데이터 샘플링 float3 worldPos = worldPosTexture.Sample(SampleType, input.tex).xyz; float4 albedo = albedoTexture.Sample(SampleType, input.tex); float3 normal = normalize(normalTexture.Sample(SampleType, input.tex).xyz); // 2. 간단한 방향성 광원(Directional Light) 계산 float lightIntensity = saturate(dot(normal, -lightDirection)); float4 finalColor = lightIntensity diffuseColor albedo; // 3. 최종 계산된 색상 출력 return finalColor; } . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#lighting-pass",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#lighting-pass"
  },"793": {
    "doc": "Forward vs Deferred",
    "title": "차이점 요약",
    "content": "| 특징 | 순방향 렌더링 (Forward Rendering) | 지연 렌더링 (Deferred Rendering) | . | 처리 단위 | 오브젝트(Object) 단위 | 화면(Screen) 공간, 픽셀 단위 | . | 조명 계산 | 오브젝트를 그릴 때마다 모든 광원 계산 | 모든 오브젝트를 그린 후(G-Buffer), 픽셀별로 한 번에 계산 | . | 성능 (광원 수) | 광원 수에 매우 민감 | 광원 수에 덜 민감 | . | 메모리 | 상대적으로 적은 메모리 사용 | G-Buffer 때문에 많은 메모리 및 대역폭 사용 | . | 투명 객체 | 처리하기 용이함 | 처리하기 매우 복잡함 (보통 순방향 렌더링 혼용) | . | 재질 다양성 | 각 오브젝트마다 다른 쉐이더 사용 가능 (높은 유연성) | 모든 재질이 G-Buffer 포맷을 따라야 함 (낮은 유연성) | . | 안티앨리어싱 | MSAA 등 하드웨어 AA 적용 용이 | 하드웨어 AA 적용이 어려워 FXAA, TAA 등 후처리 방식 사용 | . | 주요 사용처 | 광원이 적은 게임, 모바일 게임 | 수백, 수천 개의 동적 광원이 필요한 현대 AAA 게임 | . 참고하면 좋은 링크 . | forward-and-deferred-rendering | Interactive Graphics 21 - Deferred, Variable-Rate, &amp; Adaptive Shading | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#차이점-요약"
  },"794": {
    "doc": "Forward vs Deferred",
    "title": "Forward vs Deferred",
    "content": " ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html"
  },"795": {
    "doc": "Function",
    "title": "나중에 리플렉션, 가비지 컬렉션, 직렬화, 네트워크 동기화, 에디터 통합으로 마크다운 파일 나누기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%82%98%EC%A4%91%EC%97%90-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9%EC%9C%BC%EB%A1%9C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%9D%BC-%EB%82%98%EB%88%84%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#나중에-리플렉션-가비지-컬렉션-직렬화-네트워크-동기화-에디터-통합으로-마크다운-파일-나누기"
  },"796": {
    "doc": "Function",
    "title": "UObject 특징",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-특징"
  },"797": {
    "doc": "Function",
    "title": "1. 리플렉션(Reflection)",
    "content": "런타임에 객체의 타입, 필드, 메서드 정보를 조회하고 동적으로 접근/수정할 수 있는 기능 . | 리플렉션 데이터는 컴파일 시점에 UHT(Unreal Header Tool)이 자동 생성 . | GENERATED_BODY() 매크로가 이를 활성화 | . | 런타임 타입 정보(RTTI): UCLASS, UPROPERTY, UFUNCTION 등 매크로를 통해 리플렉션 데이터 생성 | 동적 캐스팅: Cast&lt;UMyClass&gt;(SomeObject) 형태로 안전한 타입 변환 가능 | 프로퍼티 검사: 런타임에 객체의 프로퍼티를 검사하고 수정할 수 있음 . | C++ 표준에는 런타임 리플렉션 기능이 없음 . | 예를 들어, 클래스에 어떤 필드가 있는지, 메서드가 무엇인지 런타임에 알 수 없음 | RTTI로 typeid, dynamic_cast 정도만 제공 | . | 언리얼의 리플렉션 . | 자체적인 리플렉션 시스템을 만들어 UObject 계열 클래스에 한해 런타임 타입 정보, 속성, 함수 목록 등을 관리 | C++ 매크로(UCLASS, UPROPERTY, UFUNCTION)와 Unreal Header Tool(UHT)이 자동으로 메타데이터를 생성해 코드에 삽입 | . | . 내부 매커니즘 . | 각 UObject 인스턴스는 UClass 타입 메타데이터(속성, 함수, 부모 정보 등)를 보유. | 런타임에 GetClass(), FindField, GetDefaultObject, ProcessEvent 등의 API로 동적 접근. | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98reflection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-리플렉션reflection"
  },"798": {
    "doc": "Function",
    "title": "2. 가비지 컬렉션(Garbage Collection)",
    "content": "더 이상 필요하지 않은 객체(메모리)를 자동으로 탐지하여 해제하는 메커니즘 . | 자동 메모리 관리: UObject는 UE의 가비지 컬렉션 시스템과 통합되어 있어 참조가 없어지면 자동으로 제거 | UPROPERTY() 매크로로 표시된 멤버 변수는 가비지 컬렉터가 추적 . | C++은 명시적 메모리 관리(new/delete, 스마트 포인터)를 요구 . | 실수로 delete를 빼먹거나, 중복해서 delete하면 메모리 누수/오류가 발생할 수 있음. | . | 언리얼의 가비지 컬렉션 . | UObject 파생 객체만 엔진의 GC 대상이 됨 (일반 C++ 객체는 해당 없음) | 엔진은 참조 그래프(Reference Graph)를 따라 “루트 오브젝트에서부터 도달할 수 없는 UObject”를 자동 삭제 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98garbage-collection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-가비지-컬렉션garbage-collection"
  },"799": {
    "doc": "Function",
    "title": "레퍼런스 그래프(Reference Graph)",
    "content": "GC가 객체 간 참조 관계를 추적하는 핵심 메커니즘 . | 주기적으로 또는 명시적으로(엔진 Tick, 레벨 변경 등) GC가 수행됨 | UObject만 추적. 일반 C++ 객체/스마트 포인터는 GC 영향 없음 | 순환 참조 문제 자동 해결 | . // A가 B를 참조, B가 A를 참조해도 루트 연결이 없으면 모두 삭제됨 class A { UPROPERTY() B* RefB; }; class B { UPROPERTY() A* RefA; }; . 1. 루트 객체(Root Objects) 식별 . | 가비지 컬렉션의 시작점으로 절대 삭제되지 않는 객체들 | . - 월드에 배치된 `AActor` - `AddToRoot()`로 등록된 객체 - 게임 인스턴스(`UGameInstance`) - 에디터에서 열린 에셋 (`UPackage`) . 2. 그래프 탐색 (Mark 단계) . | 루트 객체부터 UPROPERTY() 참조를 재귀적으로 따라가며 도달 가능한 객체 마킹 | . Mark 단계 순서 . | GC Root(예: 월드, 게임 인스턴스, 에디터 오브젝트 등)에서 탐색 시작 | RootObjectA를 방문(Mark) | RootObjectA의 UPROPERTY 필드 참조를 따라 ObjB, ObjC를 방문(Mark) | ObjB의 UPROPERTY 필드 참조를 따라 ObjD, ObjE 방문(Mark) | … 이하 반복 | 모든 방문이 끝나면, Mark되지 않은 나머지 객체들은 GC 대상으로 간주 | . 3. 미사용 객체 삭제 (Sweep 단계) . | 마킹되지 않은 객체를 안전하게 제거 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EA%B7%B8%EB%9E%98%ED%94%84reference-graph",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#레퍼런스-그래프reference-graph"
  },"800": {
    "doc": "Function",
    "title": "3. 직렬화(Serialization)",
    "content": "UObject 기반 클래스 객체는 파일이나 네트워크로 저장/불러오거나 복제할 수 있음. | 맵, 에셋, 게임 세이브 파일, 블루프린트 인스턴스 등은 모두 UObject 파생 클래스의 직렬화에 기반해 저장/복원 | FArchive 기반의 엔진 직렬화 시스템이 모든 UPROPERTY 데이터를 자동으로 기록 및 재구성 . | UPROPERTY()로 선언된 변수는 별도의 코드 없이도 자동 직렬화 대상 | 예: SaveGame, 네트워크 동기화, 복제 등 | . | Serialize(FArchive&amp; Ar) 메서드를 오버라이드하면, 특정 데이터를 커스텀하게 저장/복원할 수 있음 | . 자동 직렬화 예시 . UCLASS() class UMySaveGame : public USaveGame { GENERATED_BODY() public: UPROPERTY() int32 PlayerLevel; UPROPERTY() FString PlayerName; }; // 이렇게 선언된 변수는 SaveGame 파일에 자동 저장/복원 . 커스텀 직렬화 시 버전 호환성을 위한 패턴 . void Serialize(FArchive&amp; Ar) { Super::Serialize(Ar); int32 Version = 0; Ar &lt;&lt; Version; // 버전 기록 if (Version &gt;= 1) { Ar &lt;&lt; MyNewVariable; } } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-%EC%A7%81%EB%A0%AC%ED%99%94serialization",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-직렬화serialization"
  },"801": {
    "doc": "Function",
    "title": "데이터 저장 흐름",
    "content": ". | UObject 계열 클래스는 저장 대상이 되면 . | 엔진 내부의 FArchive 객체(파일/메모리/네트워크 스트림)를 통함 | 각 UPROPERTY 값을 자동으로 기록(Serialize)한다 | . | 불러오기(로드) 시 저장된 바이너리 데이터가 FArchive로 읽혀짐 . | UPROPERTY 정보를 기반으로 객체(=UObject)의 멤버 변수로 복원(Deserialize) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#데이터-저장-흐름"
  },"802": {
    "doc": "Function",
    "title": "SaveGame 동작 예시",
    "content": "// SaveGame 객체 선언 UMySaveGame* SaveGameObj = NewObject&lt;UMySaveGame&gt;(); SaveGameObj-&gt;PlayerLevel = 25; SaveGameObj-&gt;PlayerName = TEXT(\"홍길동\"); // 저장 UGameplayStatics::SaveGameToSlot(SaveGameObj, TEXT(\"MySlot\"), 0); // 불러오기 UMySaveGame* LoadedGame = Cast&lt;UMySaveGame&gt;( UGameplayStatics::LoadGameFromSlot(TEXT(\"MySlot\"), 0) ); int32 LoadedLevel = LoadedGame-&gt;PlayerLevel; // 직렬화된 값이 자동 복원 . | 저장(Serialize) 과정 . | SaveGame 클래스 객체를 생성 | UGameplayStatics::SaveGameToSlot() 같은 API 호출 | 내부적으로 SaveGame 객체 → FArchive → UPROPERTY 자동 순회 및 값 기록 결과적으로 바이너리 파일(.sav 등)로 저장 | . | 불러오기(Deserialize) 과정 . | UGameplayStatics::LoadGameFromSlot() 같은 API 호출 | FArchive가 파일을 읽고, SaveGame 객체를 새로 만듦 | FArchive 데이터 → UPROPERTY 기반으로 멤버 변수 값이 자동 복원 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-동작-예시"
  },"803": {
    "doc": "Function",
    "title": "네트워크 동기화 (Replicate) 동작 예시",
    "content": "나중에 멀티 플레이 공부할 때 채워넣겠음 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-replicate-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#네트워크-동기화-replicate-동작-예시"
  },"804": {
    "doc": "Function",
    "title": "4. 에디터 통합",
    "content": "메타데이터로 자동으로 디테일 패널 생성. | 디테일 패널 표시: UPROPERTY 지정자를 통해 에디터에서 편집 가능 | 블루프린트 노출: UFUNCTION에 BlueprintCallable 등의 지정자 추가로 블루프린트에서 사용 가능 | . 커스텀 프로퍼티 에디터 예시 . FPropertyEditorModule&amp; PropModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\"); . 정리 . // 1. 객체 생성 + 메타데이터 UCLASS(BlueprintType, meta=(DisplayName=\"My Cool Object\")) class UMyObject : public UObject { GENERATED_BODY() public: // 2. 라이프사이클 관리 virtual void BeginDestroy() override { CleanupResources(); Super::BeginDestroy(); } // 3. 메타데이터 활용 UPROPERTY(EditAnywhere, meta=(ClampMin=0)) int32 Value; }; // 결과: // - 블루프린트에서 \"My Cool Object\"로 노출 (리플렉션) // - Value는 에디터에서 0 이상 값만 입력 가능 (에디터 통합) // - 객체 파괴 시 CleanupResources() 자동 호출 (GC 연동) . 참고 링크 . | Memory Management &amp; Garbage Collection in Unreal Engine 5 | 04. Reflection and Garbage Collection | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-에디터-통합"
  },"805": {
    "doc": "Function",
    "title": "Function",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html"
  },"806": {
    "doc": "Instruction",
    "title": "Instruction (명령어)",
    "content": "CPU가 수행할 작업을 지시하는 기본 단위 . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-명령어"
  },"807": {
    "doc": "Instruction",
    "title": "명령어의 기본 구성",
    "content": ". | 연산 코드(Opcode) . | 수행할 연산을 지정 (예: ADD, SUB, LOAD, JUMP) | . | 피연산자(Operand) . | 연산에 사용될 데이터 또는 데이터의 주소 (레지스터, 메모리 주소, 상수 등) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#명령어의-기본-구성"
  },"808": {
    "doc": "Instruction",
    "title": "Instruction Format (명령어 형식)",
    "content": "CPU 설계에 따라 다양한 형식으로 나뉘지만 주요 형식은 아래와 같음 . | 0-주소 명령어 (Stack Machine) . | 피연산자를 명시하지 않음 / 스택(Stack) 의 최상위 값(TOS)을 암묵적으로 사용 | Op-code | . | . | 예: ADD (스택의 top 두 값을 꺼내 더한 후 결과를 push) | . | 1-주소 명령어 (Accumulator Machine) . | 하나의 피연산자만 명시 | 누산기(ACC)가 암묵적인 피연산자 . | 누산기(Accumulator) : CPU 내부에서 산술 및 논리 연산 결과를 임시로 저장하는 특별한 레지스터 | Op-code | Address | . | . | . | 예: LOAD X (메모리 주소 X의 값을 ACC에 적재) | . | 2-주소 명령어 (General Register Machine) . | 두 피연산자를 명시 | 결과는 첫 번째 피연산자에 저장 | Op-code | Address1 | Address2 | . | . | 예: ADD R1, R2 (R1 = R1 + R2) | . | 3-주소 명령어 (RISC 구조) . | 두 피연산자와 결과 저장 위치를 모두 명시 | Op-code | Address1 | Address2 | Address3 | . | . | 예: ADD R1, R2, R3 (R1 = R2 + R3) | . | . | 형식 | 0-주소 명령어 | 1-주소 명령어 | 2-주소 명령어 | 3-주소 명령어 | . | 장점 | 명령어 길이가 짧음 | 간단한 하드웨어 구현 | 유연성 높음 (대부분의 현대 CPU에서 사용) | 명확한 의미 전달 병렬 처리 용이 | . | 단점 | 스택 관리 복잡 | 연산마다 ACC 접근이 필요해 병목 현상 발생 가능 | 명령어 길이가 상대적으로 김 | 명령어 길이가 가장 김 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-format-%EB%AA%85%EB%A0%B9%EC%96%B4-%ED%98%95%EC%8B%9D",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-format-명령어-형식"
  },"809": {
    "doc": "Instruction",
    "title": "명령어의 피연산자 유형",
    "content": "주소 지정 방식 명령어를 이해하기 위해 피연산자 유형이 어떻게 지정되는지 설명 . | 즉시 (Immediate) . | 명령어 내에 상수 값 포함 | 예: ADD R1, #5 (R1 = R1 + 5) | . | 레지스터 (Register) . | CPU 내 레지스터 참조 | 예: MOV R1, R2 (R1 = R2) | . | 메모리 주소 (Memory Address) . | 직접 주소, 간접 주소, 인덱스 주소 등 | 예: LOAD R1, [0x1000] (메모리 주소 0x1000의 값을 R1에 적재) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%ED%94%BC%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#명령어의-피연산자-유형"
  },"810": {
    "doc": "Instruction",
    "title": "Addressing Mode (주소 지정 방식)",
    "content": "명령어가 지정한 피연산자(operand)를 메모리·레지스터·즉시값 등에서 어떤 방식으로 찾는가에 대한 규칙 . | 주소 지정 방식 | 설명 | 명령어 예시 | 의미 | . | 즉시(Immediate) | 주소 필드에 들어있는 값 자체를 operand로 사용 | ADD R1, #5 | (R1 = R1 + 5) | . | 직접(Direct) | 주소 필드에 적힌 주소를 operand의 메모리 주소로 사용 | LOAD R1, [1000] | 메모리 주소 0x1000의 값을 R1에 적재 | . | 간접(Indirect) | 주소 필드에 적힌 주소에 가서 그 안의 값을 operand 주소로 사용 | LOAD R1, [[0x1000]] | 1000번지에 저장된 값이 진짜 주소, 거기 있는 값을 R1에 로드 | . | 레지스터(Register) | 주소 필드가 레지스터 번호 해당 레지스터 값을 operand로 사용 | MOV R1, R2 | R1 = R2 | . | 레지스터 간접(Register Indirect) | 주소 필드가 가리키는 레지스터 안에 저장된 값(주소)을 실제 메모리 주소로 사용 | LOAD R1, [R2] | R2의 값이 500이면, 500번지의 데이터를 R1에 로드 | . | 상대(Relative/PC-relative) | 주소 필드 값과 현재 PC(program counter)의 값을 더해 실주소를 만듦 | JMP 20 | (JUMP PC + 20) 현재 PC가 100이라면 120번지로 점프 | . | 인덱스(Index) | 베이스 레지스터 + 인덱스 레지스터 | LOAD R1, [ADRS + R2] | R2가 10이고 ADRS가 1000이면 1010 주소 값 적재 | . | 기타(변형) | 자동 증가/감소, 변위(Displacement), 스택 등 |   |   | . 인덱스 레지스터 동작 과정 . 배열, 테이블, 벡터와 같이 메모리에 연속적으로 저장된 데이터에 반복적으로 접근할 때 사용 . | Base Address (기준 주소): 배열의 시작 주소 (예: 1000 = A[0]의 주소) | Offset (인덱스 레지스터): 시작 주소로부터의 거리 (예: R2는 i × 원소 크기) | 실제 주소: Base + Offset으로 계산 | . // LOAD R1, [ADRS + R2] LOAD R1, 1000(R2) . | 배열 원소의 크기는 4바이트로 가정 | 배열 A[0]의 시작주소 = 1000 | R2는 바이트 단위 Offset이 저장됨 . | R2 = 원하는 인덱스 × 원소 크기 | 예: A[3] 접근 시 R2 = 3 × 4 = 12 | . | 메모리 접근 . | 예: LOAD R1, 1000(20) → R1 = 메모리[1020] (즉, A[5]의 값) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#addressing-mode-%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#addressing-mode-주소-지정-방식"
  },"811": {
    "doc": "Instruction",
    "title": "Types of Instructions (명령어 종류)",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html#types-of-instructions-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#types-of-instructions-명령어-종류"
  },"812": {
    "doc": "Instruction",
    "title": "Data Transfer Instructions",
    "content": ". | 데이터 전송 명령어 | 입출력 명령어가 포함됨 | . | 전송명령어 | 니모닉 | 기 능 | . | Load | LD | 기억장치로부터 레지스터로 전송 | . | Store | ST | 레지스터로부터 기억장치로의 전송 | . | Move | MOVE | 레지스터로부터 다른 레지스터로의 전송 | . | Exchange | XCH | 두 레지스터 또는 한 레지스터와 기억장치 간의 데이터 교환 | . | Push | PUSH | 레지스터의 값을 스택에 저장 | . | Pop | POP | 스택에서 레지스터로 값 복원 | . | Input | IN | 입출력장치로부터 레지스터로 데이터 전송 | . | Output | OUT | 레지스터와 입출력장치 간의 데이터 전송 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#data-transfer-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#data-transfer-instructions"
  },"813": {
    "doc": "Instruction",
    "title": "Data Processing Instructions",
    "content": ". | 데이터 처리 명령어 | 데이터에 대한 연산을 실행하고 계산함 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#data-processing-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#data-processing-instructions"
  },"814": {
    "doc": "Instruction",
    "title": "Arithmetic Instructions",
    "content": ". | 산술 명령어 | . | 산술 명령어 | 니모닉 | 기 능 | . | Increment | INC | 1 증가 | . | Decrement | DEC | 1 감소 | . | Add | ADD | 덧셈 | . | Subtract | SUB | 뺄셈 | . | Multiply | MUL | 곱셈 | . | Divide | DIV | 나눗셈 | . | Add with carry | ADDC | 캐리 포함한 덧셈 | . | Subtract with borrow | SUBB | 빌림 포함한 뺄셈 | . | Negate | NEG | 2의 보수 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#arithmetic-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#arithmetic-instructions"
  },"815": {
    "doc": "Instruction",
    "title": "Logical Instructions",
    "content": ". | 논리비트 명령어 | 레지스터나 기억장치에 저장된 데이터에 2진 연산 | . | 논리 명령어 | 니모닉 | 기 능 | . | Clear | CLR | 모든 비트를 0으로 리셋 | . | Set | SET | 모든 비트를 1로 셋 | . | Complement | COM | 오퍼랜드에 저장된 모든 비트값 반전 | . | AND | AND | 비트별 AND 연산 | . | OR | OR | 비트별 OR 연산 | . | Exclusive-OR | XOR | 비트별 XOR 연산 | . | Clear carry | CLRC | 캐리 비트 리셋 | . | Set carry | SETC | 캐리 비트 셋 | . | Complement carry | COMC | 연산 결과에서 발생하는 캐리 비트만 반전 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#logical-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#logical-instructions"
  },"816": {
    "doc": "Instruction",
    "title": "Shift Instructions",
    "content": ". | 시프트 명령어 | logical : 비트열을 단순히 왼쪽 또는 오른쪽으로 밈 . | 비어지는 자리는 항상 0 으로 채움 | 부호 비트도 이동 | . | Arithmetic : 부호 비트(MSB)를 유지하면서 나머지 비트만 이동 . | 오른쪽 시프트의 경우 부호 비트는 원래 값 유지 | 왼쪽 시프트의 경우 부호 비트까지 움직임 (비는 자리는 0으로 채움) | . | Rotate : 비트열을 밀 때, 밀려나간 비트가 반대쪽 끝으로 다시 들어감 | Rotate with carry : 밀려나간 비트는 캐리 플래그로 이동 . | 캐리 플래그의 값은 오퍼랜드의 반대편 끝에 들어옴 | . | . | 시프트 명령어 | 니모닉 | 기 능 | . | Logical shift left | SHL | 논리적 왼쪽 시프트(빈 비트는 0으로 채움) | . | Logical shift right | SHR | 논리적 오른쪽 시프트(빈 비트는 0으로 채움) | . | Arithmetic shift left | SAL | 산술적 왼쪽 시프트 | . | Arithmetic shift right | SAR | 산술적 오른쪽 시프트 | . | Rotate left | ROL | 비트를 왼쪽으로 순환 | . | Rotate right | ROR | 비트를 오른쪽으로 순환 | . | Rotate left with carry | ROLC | 캐리 비트 포함 왼쪽 순환 | . | Rotate right with carry | RORC | 캐리 비트 포함 오른쪽 순환 | . 시프트 예시 . 로테이트 오른쪽 시프트의 경우 - 원래 값: 1 0 1 1 1 0 0 1 - 시프트 : 1 1 0 1 1 1 0 0 로데이트 캐리 왼쪽 시프트의 경우 - 캐리 플래그: C = 1 - 레지스터: 0 1 0 1 1 0 1 0 1.가장 왼쪽 비트(0)가 캐리로 이동 - 새 캐리 : 0 2.기존 캐리(1)가 오른쪽 끝(LSB)으로 들어감 - 레지스터 : 1 0 1 1 0 1 0 **1** &lt;- 캐리에서 온 1 추가 . ",
    "url": "/docs/Computer%20architecture/Instruction.html#shift-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#shift-instructions"
  },"817": {
    "doc": "Instruction",
    "title": "Control Flow Instructions",
    "content": ". | 프로그램 제어 명령어 | 다른 프로그램의 세그먼트로 분기 | . | 프로그램 제어 명령어 | 니모닉 | 기 능 | . | Branch | BR | 조건 혹은 무조건적으로 유효 주소로 분기 | . | Jump | JMP | 조건 혹은 무조건적으로 유효 주소로 분기 | . | Skip next instruction | SKP | 조건이 만족되면 다음 명령어를 수행하지 않고 넘어감 | . | Call | CALL | 서브루틴 호출 | . | Return | RET | 서브루틴에서 복귀 | . | Compare(by subtrction) | CMP | 두 오퍼랜드의 뺄셈을 통해 상태 레지스터의 값을 반환 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#control-flow-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#control-flow-instructions"
  },"818": {
    "doc": "Instruction",
    "title": "Instruction Set Architecture",
    "content": "CPU가 이해하는 명령어의 집합으로, 주요 유형은 아래와 같다 . | CISC (Complex Instruction Set Computer) . | 복잡한 명령어, 다양한 주소 지정 방식 | 예: x86 아키텍처 | . | RISC (Reduced Instruction Set Computer) . | 간단한 명령어, 고정된 길이, 레지스터 중심 | 예: ARM, MIPS | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-set-architecture",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-set-architecture"
  },"819": {
    "doc": "Instruction",
    "title": "아키텍처 요약",
    "content": "| 아키텍처 | 등장 시기/장소 | 설계 철학 | 주요 사용처 | 현재 | . | MIPS | 1981, 스탠포드 대학 | RISC | 임베디드, 라우터, PS1/2 | 쇠퇴, 일부 임베디드/네트워크에 잔존 | . | x86 | 1978, 인텔 | CISC | PC, 서버, 산업용 | PC/서버 시장 지배, 저전력은 약세 | . | ARM | 1985, 영국 Acorn | RISC | 모바일, IoT, 임베디드 | 모바일/임베디드 압도, PC/서버 확대 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#아키텍처-요약"
  },"820": {
    "doc": "Instruction",
    "title": "나중에 아키텍처 별 명령어 집합 유형 추가하기",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%82%98%EC%A4%91%EC%97%90-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B3%84-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A7%91%ED%95%A9-%EC%9C%A0%ED%98%95-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#나중에-아키텍처-별-명령어-집합-유형-추가하기"
  },"821": {
    "doc": "Instruction",
    "title": "Instruction",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html"
  },"822": {
    "doc": "Management",
    "title": "UObject 사용 방법",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-사용-방법"
  },"823": {
    "doc": "Management",
    "title": "1. 객체 생성 및 관리",
    "content": ". | UObject의 인스턴스화(Instantiation)와 기본 설정을 담당하는 단계 | “어떻게 객체가 만들어지고, 참조되고, 접근되는가?” | . (1) UObject 객체 생성 . | Outer와 Package: 객체의 계층 구조와 저장 위치 결정 // Outer: 객체의 소유자 (일반적으로 현재 객체를 생성하는 객체) // Package: 에셋으로 저장될 경우 대상 패키지 (예: /Game/MyAsset) UMyObject* Obj = NewObject&lt;UMyObject&gt;(Outer, Package, NAME_None, RF_Transactional); . | RF_Transactional: 에디터 실행 취소(Undo) 시스템에 등록할 때 사용하는 플래그 | RF_Standalone: 패키지와 무관한 독립적 존재 (에셋이 아닌경우) | RF_Transient : 임시 객체 (저장되지 않음) | RF_Public :에셋으로 저장 시 공개적으로 표시 | . // 1. 일반적인 생성 (Outer와 Name 지정 가능) UMyObject* Obj = NewObject&lt;UMyObject&gt;(GetTransientPackage(), TEXT(\"MyObj\")); // 2. 서브오브젝트 생성 (주로 Actor/Component에서 사용) UMyComponent* Comp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"Comp\")); . | NewObject&lt;T&gt;(): 새로운 UObject 인스턴스 생성 | CreateDefaultSubobject(): 생성자에서 서브오브젝트 생성 시 사용 | TWeakObjectPtr&lt;T&gt;: GC 영향을 받지 않는 참조 생성 | . (2) UObject 객체 접근 및 유효성 검사 . // 유효성 체크 (GC에 의해 파괴되지 않았는지 확인) if (IsValid(Obj)) { Obj-&gt;DoSomething(); } // 약한 참조 (WeakPtr)로 GC 방지 TWeakObjectPtr&lt;UMyObject&gt; WeakObj = Obj; . (3) UObject 객체 등록 관리 . // 객체를 특정 패키지에 등록 Obj-&gt;Rename(nullptr, MyPackage); // 에셋으로 저장 가능하게 함 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-객체-생성-및-관리"
  },"824": {
    "doc": "Management",
    "title": "2. 라이프 사이클 관리",
    "content": ". | UObject가 생성부터 파괴까지 거치는 전체 과정을 관리 | “객체가 어떤 단계를 거쳐 존재하고 소멸하는가?”를 정의 | 가비지 컬렉션과 연동 가능 | . (1) 라이프 사이클 - 생성 . // 예시: 초기화 흐름 UCLASS() class UMyAsset : public UObject { GENERATED_BODY() public: UMyAsset() { /* 생성자 */ } // 프로퍼티 초기화 후 호출 virtual void PostInitProperties() override { Super::PostInitProperties(); InitDefaultValues(); // 기본값 설정 } // 명시적 초기화 (필요한 경우) void Initialize() { LoadExternalData(); } // 에셋 로드 완료 시 호출 virtual void PostLoad() override { Super::PostLoad(); ApplyLoadedData(); // 로드된 데이터 적용 } }; . (2) 라이프 사이클 - 사용 . // 활성화/비활성화 제어 (AActor 파생클래스 예시) virtual void BeginPlay() override; // 게임 시작 시 호출 virtual void EndPlay() override; // 게임 종료 또는 제거 시 호출 . (3) 라이프 사이클 - 파괴 . virtual void BeginDestroy() override { // 리소스 해제 로직 Super::BeginDestroy(); } virtual void FinishDestroy() override { // 최종 정리 작업 Super::FinishDestroy(); } . UObject 라이프 사이클 3단계 요약 . 생성 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | 생성자 | NewObject() 호출 시 | 메모리 할당 + 기본값 설정 | UPROPERTY는 아직 초기화되지 않음 | . | PostInitProperties() | 생성자 직후 | 프로퍼티 초기화 완료 시점 | 에디터에서 설정한 기본값 적용됨 | . | PostLoad() | 에셋 로드 완료 시 | 디스크 데이터 처리 | 에셋 전용 (동적 생성 객체는 호출 X) | . 사용 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | AddToRoot() | 수동 호출 시 | GC 대상에서 제외 | 남용 시 메모리 누수 가능성 | . | BeginPlay() | 게임 시작 시(AActor 한정) | 게임플레이 로직 초기화 | UObject 직접 사용 불가 (Actor/Component 필요) | . | Tick() | 매 프레임 (AActor 한정) | 지속적인 업데이트 | 성성능 저하 가능성 → 꼭 필요할 때만 사용 | . 파괴 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | ConditionalBeginDestroy() | 수동 호출 또는 GC 시작 시 | 파괴 시작 신호 | 객체는 즉시 삭제되지 않음 | . | BeginDestroy() | GC 마킹 후 | 리소스 해제 (텍스처, 메모리 등) | 가상 함수 오버라이드 필수 | . | FinishDestroy() | 메모리 해제 직전 | 최종 정리 | 이후 모든 접근 불가능 | . (4) 가비지 컬렉션 연동 . // GC 대상에서 제외 (특수한 경우만 사용) Obj-&gt;AddToRoot(); // GC 대상으로 복귀 Obj-&gt;RemoveFromRoot(); . | BeginDestroy(): 객체가 파괴되기 전에 호출 | IsValidLowLevel(): 객체가 유효한지 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-%EB%9D%BC%EC%9D%B4%ED%94%84-%EC%82%AC%EC%9D%B4%ED%81%B4-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-라이프-사이클-관리"
  },"825": {
    "doc": "Management",
    "title": "3. 메타 데이터 시스템",
    "content": ". | UObject의 데이터(프로퍼티, 함수, 클래스 등)에 대해 추가 정보를 부여하는 키-값 쌍의 데이터 | “이 객체를 어떻게 표시하고, 직렬화하고, 에디터에서 다룰 것인가?”를 제어 . | “어떻게 에디터에서 표시할지”, “어떤 제약 조건을 둘지”, “블루프린트에 노출 여부” 등 | . | UCLASS, UPROPERTY 등에 메타데이터 추가 가능 | . UPROPERTY(EditAnywhere, meta=(DisplayName=\"My Custom Name\")) FString CustomizedName; . (1) 에디터 연동 및 UI 제어 . UPROPERTY(EditAnywhere, meta=(DisplayName=\"플레이어 이름\", Tooltip=\"캐릭터의 이름입니다.\")) FString CharacterName; . (2) 직렬화 동작 설정 . UPROPERTY(SaveGame, meta=(NoAutoLoad=true)) FString SaveSlotName; // 세이브 파일에 저장되지만 자동 로드 안 함 . (3) 리플렉션 시스템 연동 . UFUNCTION(meta=(WorldContext=\"WorldContextObject\")) static void MyFunction(UObject* WorldContextObject); //블루프린트에서 자동으로 World Context 연결 . (4) 제약 및 제어 커스텀 . UPROPERTY(meta=(ClampMin=0, ClampMax=100)) int32 Health; // 에디터에서 0~100 사이값만 입력 가능 . 메타데이터 시스템에서 자주 쓰는 키 목록 . | 메타 키 | 용도 | 예시 | . | BlueprintType | 블루프린트 변수로 사용 허용 | UCLASS(BlueprintType) | . | Category | 디테일 패널에서 그룹으로 묶임 | UPROPERTY(Category=\"Gameplay\") | . | AdvancedDisplay | 디테일 패널에서 접기 | meta=(AdvancedDisplay=true) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-%EB%A9%94%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-메타-데이터-시스템"
  },"826": {
    "doc": "Management",
    "title": "세 시스템 차이점 요약",
    "content": "| 시스템 | 핵심 질문 | 주요 도구 | 사용 예시 | . | 객체 생성 및 관리 | “객체를 어떻게 만들고 참조할까?” | NewObject CreateDefaultSubobject IsValid | 동적 객체 생성서브오브젝트 관리 | . | 라이프사이클 관리 | “객체가 생애주기 동안 무엇을 하는가?” | PostInitPropertiesBeginDestroyFinishDestroy | 리소스 할당/해제게임 로직 초기화 | . | 메타데이터 시스템 | “이 객체를 어떻게 표시/조작할까?” | meta=(…),UPROPERTY()/UFUNCTION() | 에디터 UI 커스터마이징직렬화 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#%EC%84%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#세-시스템-차이점-요약"
  },"827": {
    "doc": "Management",
    "title": "Management",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html"
  },"828": {
    "doc": "Modular",
    "title": "Modular",
    "content": "어떤 수를 다른 수로 나눴을 때 몫은 버리고, 나머지만 보는 것이 모듈러 연산 . | a mod b | a % b | 뜻 : a를 b로 나눈 나머지 | . ",
    "url": "/docs/Math/Modular.html",
    
    "relUrl": "/docs/Math/Modular.html"
  },"829": {
    "doc": "Modular",
    "title": "수학적 정의",
    "content": "정수 a,b에 대해 b &gt; 0 일 때 . \\[a \\ \\text{mod} \\ b = r\\] . 은 다음 조건을 만족하는 유일한 정수 r . | \\(a = qb + r\\)인 정수 q가 존재한다 (q는 몫, r은 나머지) | 0 ≤ r &lt; b (나머지 범위 조건) | . 두 조건으로 인해 나머지 r은 항상 0 이상 b-1 이하가 된다 . ",
    "url": "/docs/Math/Modular.html#%EC%88%98%ED%95%99%EC%A0%81-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/Modular.html#수학적-정의"
  },"830": {
    "doc": "Modular",
    "title": "모듈러 연산에서의 합동",
    "content": "모듈러 연산은 동치관계를 나타냄 . | ≡ mod 는 그 값이 같음을 나타내는 관계 | a - b가 n으로 나누어 떨어질 때에만 성립 | . 정수 n ≥ 1 고정. 정수 a,b에 대해 . a ≡ b (mod n) ⟺ n ∣ (a − b) . | a ≡ b (mod n) ? true : false | n ∣ (a - b) 에서 ∣ 기호는 “~는 ~로 나누어 떨어진다” 는 의미 | . 정리 . | a - b가 n의 배수이다 | 즉 a와 b를 n으로 나눈 나머지가 서로 같다 | . ",
    "url": "/docs/Math/Modular.html#%EB%AA%A8%EB%93%88%EB%9F%AC-%EC%97%B0%EC%82%B0%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A9%EB%8F%99",
    
    "relUrl": "/docs/Math/Modular.html#모듈러-연산에서의-합동"
  },"831": {
    "doc": "Modular",
    "title": "규칙",
    "content": "1. 결과는 항상 0 이상, 나누는 수(b)보다 작다 . 예: 14 mod 4 = 2 → 결과는 0,1,2,3 중 하나. 2. 반복되는 주기가 있다 . 예: 0 mod 3 = 0, 3 mod 3 = 0, 6 mod 3 = 0 → 3씩 커질 때마다 결과가 반복됨 . 3. 원래 수로 계산하든, 나머지로 바꿔서 계산하든 결과가 똑같다 . 덧셈, 뺄셈, 곱셈과 같은 연산을 할 때, 각 피연산자에 대해 모듈러 연산을 먼저 취한 후 계산해도 그 결과는 같음 . | 이를 합동 관계라고 한다 | . 덧셈: (a + b) mod n = ((a mod n) + (b mod n)) mod n 뺄셈: (a - b) mod n = ((a mod n) - (b mod n)) mod n 곱셈: (a * b) mod n = ((a mod n) * (b mod n)) mod n . | 지수에 대해서도 확장 가능 (RSA 같은 암호학 핵심) | . (a^k) mod n = ((a mod n)^k) mod n . 예시 : 7 + 5 mod 3 . | 원래 계산 : 12 mod 3 = 0 | 나머지로 바꿔서 계산 : 7 mod 3 = 1, 5 mod 3 = 2 | 합 : 1 + 2 = 3, 3 mod 3 = 0 | 결과가 동일함 | . 이 규칙 덕분에 큰 수를 직접 다루지 않고, 작은 나머지로 바꿔 계산해도 결과가 같음 암호학, 프로그래밍 등에서 큰 수를 작게 줄여서 계산하는 데 많이 쓰임 . ⚠️ 나눗셈은 일반적인 규칙이 적용되지 않음. 모듈러 역원(modular inverse) 개념 필요 . Modular Inverse (모듈러 역원) . a × x ≡ 1 (mod n)을 만족하는 x를 a의 모듈러 역원이라고 함 . | 예: 3 × x ≡ 1 (mod 11)을 만족하는 x는? | 3 × 4 = 12 ≡ 1 (mod 11) ∴ x = 4 | . 모든 수가 모듈러 역원을 가지는 것은 아님 . | a와 n이 서로소일 때만 역원이 존재함 | . ",
    "url": "/docs/Math/Modular.html#%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Math/Modular.html#규칙"
  },"832": {
    "doc": "Modular",
    "title": "생활 속 예시",
    "content": ". | 시계: 시계는 12시간마다 반복 . | 지금 9시에서 5시간 후는 몇 시? | 9 + 5 = 14 → 14 mod 12 = 2 → 2시 | . | 요일: 요일도 7일마다 반복 . | 오늘이 화요일(2번째 날)인데, 10일 뒤는? | 2 + 10 = 12 → 12 mod 7 = 5 → 금요일 | . | . ",
    "url": "/docs/Math/Modular.html#%EC%83%9D%ED%99%9C-%EC%86%8D-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/Modular.html#생활-속-예시"
  },"833": {
    "doc": "Modular",
    "title": "음수",
    "content": "나누는 수 (=mod 뒤에 오는 수, 보통 b) 는 양수만 쓰는 게 일반적 규칙 . | 음수가 들어가면 수학 책이나 프로그래밍 언어마다 정의가 다름 | . ",
    "url": "/docs/Math/Modular.html#%EC%9D%8C%EC%88%98",
    
    "relUrl": "/docs/Math/Modular.html#음수"
  },"834": {
    "doc": "Modular",
    "title": "1. (-a) mod b (음수 피제수)",
    "content": "예 : -7 mod 3 . | -7 ÷ 3 = -2 … -1 (몫 -2, 나머지 -1) | 나머지는 0 이상, b보다 작다는 규칙을 따르기 위해 나머지를 다시 조정 | -1 + 3 = 2 (나머지에 b 더하기) | . 피제수(앞 숫자)가 음수여도, 결과는 0 이상 b-1 사이 값으로 조정 . ",
    "url": "/docs/Math/Modular.html#1--a-mod-b-%EC%9D%8C%EC%88%98-%ED%94%BC%EC%A0%9C%EC%88%98",
    
    "relUrl": "/docs/Math/Modular.html#1--a-mod-b-음수-피제수"
  },"835": {
    "doc": "Modular",
    "title": "2. a mod (-b) (음수 나누는 수)",
    "content": "실제 수학에서는 음수 modulus를 정의하지 않는다 . | 수학적 정의에서 modulus는 양수여야 함 (0 &lt; b) | 0 ≤ r &lt; b라는 조건이 음수 b에서는 의미가 없어짐 | 프로그래밍에서도 거의 사용되지 않으며, 언어별로 일관성 없는 결과를 보임 | . ",
    "url": "/docs/Math/Modular.html#2-a-mod--b-%EC%9D%8C%EC%88%98-%EB%82%98%EB%88%84%EB%8A%94-%EC%88%98",
    
    "relUrl": "/docs/Math/Modular.html#2-a-mod--b-음수-나누는-수"
  },"836": {
    "doc": "Modular",
    "title": "3. 프로그래밍 언어 차이",
    "content": "정수 나눗셈을 어떻게 정의하느냐에 따라 차이가 난다 . C/C++ . Truncate toward 0. 소수 부분을 제거하여 정수로 반올림하는 방법 . | 양수 : 소수부분 그냥 버리기 → 2.7은 2, 4.95는 4 | 음수 : -3.2는 -3, -9.5는 -9 | . 나눗셈 연산 예: -7 / 3 . | 실제 나눗셈 : -2.333… | trunc toward 0 → q(몫) = -2 | r (나머지) = -7 - (-2) × 3 = -1 | . Python . Floor division 기반. 두 수를 나눈 후, 그 결과값에 대해 가장 작은 정수로 내림(round down)하여 결과를 반환하는 연산 . | 양수 : 7 / 3은 2.333... → 내림하기 → 2 | 음수 : -11 / 2는 -5.5 → 내림 (더 작은 정수) → -6 | . 나눗셈 연산 예: -7 / 3 . | 실제 나눗셈 : -2.333… | floor (내림) → q(몫) = -3 | r (나머지) = -7 - (-3) × 3 = 2 | . 따라서 r은 항상 나누는 수 n과 같은 부호임 . | 0 ≤ r &lt; n 범위에 들어감 | . ",
    "url": "/docs/Math/Modular.html#3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%EC%B0%A8%EC%9D%B4",
    
    "relUrl": "/docs/Math/Modular.html#3-프로그래밍-언어-차이"
  },"837": {
    "doc": "Modular",
    "title": "정리",
    "content": ". | C/C++: “0 기준으로 잘라라.” → 그래서 음수 나머지 허용 | Python: “항상 아래쪽 정수로 내려라.” → 그래서 몫이 더 작아지고, 그 결과 나머지는 항상 0 ≤ r &lt; n 범위 | . 링크 . | 모듈러 연산이란? | . ",
    "url": "/docs/Math/Modular.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Math/Modular.html#정리"
  },"838": {
    "doc": "Module",
    "title": "Module",
    "content": "특정 에디터 도구, 런타임 기능, 라이브러리 또는 기타 기능들을 독립적인 코드 단위로 캡슐화한 것 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html"
  },"839": {
    "doc": "Module",
    "title": "특징",
    "content": ". | 코드 분리 : 모듈은 코드 분리를 강제하여, 기능을 캡슐화하고 내부 구현을 숨길 수 있음 | 독립적 빌드 : 모듈은 독립적인 컴파일 단위로 빌드됨 . | 변경된 모듈만 다시 빌드되므로, 대규모 프로젝트의 빌드 속도가 크게 향상 | . | 의존성 그래프 및 헤더 관리 : 모듈 간 의존성 그래프가 생성되고, 실제 사용되는 코드에만 헤더 포함이 허용 . | 사용하지 않는 모듈은 컴파일에서 안전하게 제외 | . | 런타임 로드/언로드 제어 : 특정 모듈을 언제 로드/언로드할지 제어 가능 . | 이를 통해 프로젝트의 성능 최적화가 가능 | . | 플랫폼별 포함/제외 : 모듈을 플랫폼별로 포함하거나 제외할 수 있음 . | 예: 윈도우, 맥, 리눅스, 안드로이드 등에서 포함하거나 제외 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#특징"
  },"840": {
    "doc": "Module",
    "title": "모듈 디렉터리 구조",
    "content": "YourProject/ ├── Source/ # 모든 모듈은 반드시 프로젝트 또는 플러그인의 Source 디렉토리 하위에 위치 │ ├── YourModule/ # 모듈 루트 폴더명은 모듈명과 동일해야 함 │ │ ├── Public/ # 외부에 노출할 헤더 파일 │ │ ├── Private/ # 내부 구현 파일 (.cpp 및 내부 헤더) │ │ └── YourModule.Build.cs │ ├── YourPlugin.uplugin ├── YourProject.uproject . | Public/: 외부 모듈에서 사용할 수 있도록 공개된 헤더 파일 (.h) | Private/: 해당 모듈 내부에서만 사용하는 구현 파일 (.cpp) 과 헤더 파일 포함 . | .cpp 파일은 모두 private 폴더에 두는 것이 권장됨 | . | Build.cs: 모듈의 빌드 설정과 의존성을 정의하는 파일 . | Target.cs는 최종 빌드 옵션과 엔트리 포인트를 정의 | . | .uproject / .uplugin : “Modules” 리스트가 있어, 어떤 모듈이 어떻게 로드될지 정의 . | 이름, 타입, 지원 플랫폼, 로딩 단계 등을 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-디렉터리-구조"
  },"841": {
    "doc": "Module",
    "title": "모듈 타입 설정",
    "content": ".uproject 또는 .uplugin 파일의 Type 에서 정의 . | 모듈 타입에 따라 로드/언로드, 의존성, 포함 가능 플랫폼이 달라짐 | . { \"Modules\": [ { \"Name\": \"YourModule\", \"Type\": \"Runtime\", // 모듈 타입 지정 \"LoadingPhase\": \"Default\" // 로딩 단계 지정 } ] } . | Type (모듈 타입) . | \"Runtime\" : 게임 실행 시 필수적인 기능 제공 (예: Core, Engine) | \"Editor\" : 에디터 전용 기능 제공 (예: 플러그인) | \"Program\" : 독립 실행형 프로그램으로 사용 (예: UnrealHeaderTool) | \"Developer\" : 개발 전용 (예: Profiler, Visualizer) . | Shipping(릴리즈) 빌드에 포함되지 않는 특수 모듈 | . | \"ThirdParty\" : 외부 라이브러리 래핑용 . | 외부 바이너리/헤더 포함 및 관리 목적 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%ED%83%80%EC%9E%85-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-타입-설정"
  },"842": {
    "doc": "Module",
    "title": "로딩 단계 지정",
    "content": ".uproject 또는 .uplugin 파일의 LoadingPhase 에서 정의 . | LoadingPhase (주요 로딩 단계) . | \"PreDefault\" : 엔진 초기화 전 로드 (예: 코어 시스템) | \"Default\" : 대부분 모듈의 기본 단계 (기본값) | \"PostDefault\" : 기본 모듈 로드 후 (예: 게임플레이 코드) | \"PostConfigInit\" : 설정 파일 로드 후 (예: 설정 의존성 모듈) | \"PostSplashScreen\" : 스플래시 스크린 표시 후 (예: UI 모듈) | . | . 로딩 주의 사항 . A 모듈이 B 모듈에 의존할 때, B의 로딩 단계가 A보다 빠르거나 같아야 함 . | 예: B가 PreDefault, A가 Default여야 정상 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%A1%9C%EB%94%A9-%EB%8B%A8%EA%B3%84-%EC%A7%80%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#로딩-단계-지정"
  },"843": {
    "doc": "Module",
    "title": "Build.cs 파일에서 의존성 설정",
    "content": "언리얼 빌드 시스템은 프로젝트의 Target.cs와 각 모듈의 Build.cs 파일을 기준으로 프로젝트를 빌드함 . | 각 모듈에는 반드시 [ModuleName].Build.cs가 필요 | ModuleRules 클래스를 상속받아 자신의 모듈을 정의 | . Build.cs 파일 예시 . using UnrealBuildTool; public class ModuleTest : ModuleRules { public ModuleTest(ReadOnlyTargetRules Target) : base(Target) { PrivateDependencyModuleNames.AddRange(new string[] { \"Core\" }); } ... } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-파일에서-의존성-설정"
  },"844": {
    "doc": "Module",
    "title": "주요 의존성 설정",
    "content": "1. PublicDependencyModuleNames . // 사용할 모듈(폴더) 이름 적기 PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); . | 해당 리스트에 들어간 모듈은 내 모듈의 Public 코드(즉, Public 헤더 파일)와 Private 코드에서 모두 사용 가능 . | 예: #include “A/Public/A.h” | . | 해당 모듈에 의존하는 다른 모듈의 Public 코드에서도 이 의존성 모듈의 Public 헤더를 사용 | . 2. PrivateDependencyModuleNames . PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" }); . | Private 리스트에 들어간 모듈은 내 모듈의 Private 코드에서만 사용 가능 . | 내 모듈의 Public 헤더에서는 해당 모듈의 헤더를 include할 수 없음 | . | 이 모듈을 의존하는 다른 모듈에서는 이 의존성이 전파되지 않음 | . 3. PublicIncludePaths / PrivateIncludePaths . // Public 또는 Private 폴더 외부에 헤더 파일이 위치한 경우 PublicIncludePaths.Add(Path.Combine(ModuleDirectory, \"ThirdParty/SomeLibrary/include\")); // 서브디렉토리를 포함해야 하는 경우 PrivateIncludePaths.Add(Path.Combine(ModuleDirectory, \"Private/SubModule\")); // 외부 라이브러리 사용 PublicIncludePaths.Add(\"C:/ExternalLibs/SomeLibrary/include\"); . | 헤더 파일의 추가 경로를 지정함 . | 비표준 디렉토리 구조를 사용하는 경우 | 서브디렉토리를 포함해야 하는 경우 | 외부 라이브러리를 사용하는 경우 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주요-의존성-설정"
  },"845": {
    "doc": "Module",
    "title": "의존성 정리",
    "content": "| 구분 | PublicDependencyModuleNames | PrivateDependencyModuleNames | . | 내 모듈의 Public 코드 | O (사용 가능) | X (사용 불가) | . | 내 모듈의 Private 코드 | O (사용 가능) | O (사용 가능) | . | 의존 모듈의 Public 코드 | O (전파됨) | X (전파 안 됨) | . PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\" }); . | Core, Engine . | 내 모듈의 Public/Private 코드 모두에서 사용 가능 | 내 모듈을 사용하는 다른 모듈의 Public 코드에서도 사용 가능(전파) | . | Slate . | 내 모듈의 Private 코드에서만 사용 가능 | 내 모듈의 Public 코드, 내 모듈을 사용하는 다른 모듈에서는 Slate 의존성이 전파되지 않음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#의존성-정리"
  },"846": {
    "doc": "Module",
    "title": "주의사항",
    "content": ". | 프로젝트 파일 재생성: Build.cs 파일이나 소스 폴더를 이동/수정한 경우, 반드시 프로젝트 파일을 재생성해야 함 . | GenerateProjectFiles.bat 실행 | .uproject 파일 우클릭 후 “Generate Project Files” 선택 | Unreal Editor의 메뉴: File &gt; Refresh Visual Studio Project | . | UE 빌드 시스템은 모듈 간 순환 참조(의존성)를 허용하지 않음 | 반드시 실제로 사용하는 헤더만 명시적으로 추가함 . | 실제 사용하는 헤더만 #include하고 그 헤더의 위치가 Public/Private이라면 빌드 시스템이 알아서 처리 | . | . 참고 링크 . | Unreal Engine Modules | Module Properties | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주의사항"
  },"847": {
    "doc": "Ninate",
    "title": "Nanite",
    "content": ". | How does Unreal Engine 5’s Nanite work? | Nanite - Inside Unreal | . ",
    "url": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Nanite.html#nanite",
    
    "relUrl": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Nanite.html#nanite"
  },"848": {
    "doc": "Ninate",
    "title": "Ninate",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Nanite.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Nanite.html"
  },"849": {
    "doc": "Output Merger",
    "title": "Depth Buffer &amp; Stencil Buffer",
    "content": "두 버퍼는 일반적으로 하나의 버퍼에 있는 메모리를 공유 . | 별개의 두 버퍼를 따로따로 만드는 것이 아니라 깊이-스텐실 데이터를 함께 저장하는 특별한 포맷의 텍스처를 하나 생성하여 사용 . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-buffer--stencil-buffer",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-buffer--stencil-buffer"
  },"850": {
    "doc": "Output Merger",
    "title": "Depth-Stencil Buffer (깊이-스텐실 버퍼)",
    "content": "현대의 그래픽스에서는 깊이 정보와 스텐실 정보를 효율적으로 다루기 위해 이 둘을 합친 포맷을 사용하도록 최적화되어 있다 . // d3dclass.cpp - Initialize() 함수 내부 D3D11_TEXTURE2D_DESC depthBufferDesc; // ... depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // 바로 이 부분! // ... result = m_device-&gt;CreateTexture2D(&amp;depthBufferDesc, NULL, &amp;m_depthStencilBuffer); . | DXGI_FORMAT_D24_UNORM_S8_UINT : 깊이와 스텐실이 합쳐진 대표적인 포맷 . | D24 : 24비트를 깊이 버퍼로 사용 | S8 : 8비트를 스텐실 버퍼로 사용 | . | 픽셀당 총 32비트(24비트 깊이 + 8비트 스텐실)의 메모리 공간을 사용하는 하나의 텍스처 포맷 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-stencil-buffer-%EA%B9%8A%EC%9D%B4-%EC%8A%A4%ED%85%90%EC%8B%A4-%EB%B2%84%ED%8D%BC",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-stencil-buffer-깊이-스텐실-버퍼"
  },"851": {
    "doc": "Output Merger",
    "title": "Depth testing &amp; Stencil testing",
    "content": "깊이 테스트와 스텐실 테스트는 그래픽스 렌더링 파이프라인의 거의 마지막 단계인 출력 병합(Output Merger, OM) 단계에서 일어난다 . Direct3D 11의 렌더링 파이프라인은 다음과 같은 단계를 거쳐 3D 모델을 2D 이미지로 변환함 . | 입력 조립기 (Input Assembler): 정점 데이터를 읽어옴 | 정점 셰이더 (Vertex Shader): 정점의 위치를 변환 | 래스터라이저 (Rasterizer): 3D 모델을 2D 픽셀 (정확히는 프래그먼트)로 변환 | 픽셀 셰이더 (Pixel Shader): 각 픽셀의 최종 색상을 계산 | 출력 병합기 (Output Merger): 완성된 픽셀들을 최종 조립 라인(화면)에 배치하는 단계 . | 픽셀 셰이더의 결과를 최종 렌더링 타겟(화면 버퍼)에 기록 | . | . 깊이 테스팅, 스텐실 테스팅, 알파 블렌딩은 모두 마지막 단계인 출력 병합기(Output Merger)에서 일어남 . 읽어보면 좋은 링크 . | Depth testing | Stencil testing | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-testing--stencil-testing",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#depth-testing--stencil-testing"
  },"852": {
    "doc": "Output Merger",
    "title": "Output Merger",
    "content": "완성된 픽셀들을 최종 조립 라인(화면)에 배치하는 단계 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html"
  },"853": {
    "doc": "Output Merger",
    "title": "Output Merger 출력 병합기 처리 순서",
    "content": "출력 병합기 단계에 도달한 픽셀(프래그먼트)은 최종적으로 화면에 그려지기 전에 여러 테스트와 혼합 과정을 거침 . | 스텐실 테스팅 (Stencil Testing) . | 스텐실 버퍼라는 8비트 정수 버퍼(픽셀 당 0~255 값 저장)를 사용하여, 특정 조건을 만족하는 픽셀에만 그리거나, 그리는 대신 스텐실 버퍼의 값을 변경하는 등의 복잡한 작업을 수행 | . | 깊이 테스팅 (Depth Testing) . | 카메라에 더 가까운 물체만 그리고, 뒤에 있는 물체는 가려서 보이지 않게 만드는 것 | . | 알파 블렌딩 (Alpha Blending) . | 반투명한 색상을 어떻게 섞을지 결정 | 픽셀이 반투명할 경우 기존 컬러 버퍼의 색상과 새로 그릴 픽셀의 색상을 정해진 비율로 혼합 | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#output-merger-%EC%B6%9C%EB%A0%A5-%EB%B3%91%ED%95%A9%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EC%88%9C%EC%84%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#output-merger-출력-병합기-처리-순서"
  },"854": {
    "doc": "Output Merger",
    "title": "Output Merger 상세 처리 과정",
    "content": "픽셀 셰이더로부터 하나의 픽셀을 그리기 위한 정보 프래그먼트(Fragment)가 넘어왔다고 가정 . | 이 프래그먼트는 자신의 (x, y) 좌표, 색상(RGBA), 깊이(Z) 값을 가지고 있음 | . 1. Stencil Test . | 프래그먼트가 그려질 위치 (x, y)에 해당하는 스텐실 버퍼의 값을 읽어옴 | 미리 설정된 규칙에 따라 프래그먼트의 스텐실 값과 버퍼의 스텐실 값을 비교하여 테스트를 진행 . | 예를 들어 “버퍼의 값이 5일 때만 통과시켜라” 같은 규칙을 설정할 수 있음 | . | 결과: . | [통과] → 다음 단계인 2. 깊이 테스트로 진행 . | 설정에 따라 스텐실 버퍼의 값을 변경할 수도 있음 (예: 통과한 픽셀의 스텐실 값을 6으로 바꿔라) | . | [실패] → 프래그먼트는 즉시 버려잠 . | 이후의 모든 과정(깊이 테스트, 블렌딩)은 생략 | . | . | . | 스텐실 테스트 실패 = “이번에 그리려던 거, 그냥 없던 일로 할게” 라는 의미 해당 픽셀은 이전 상태를 그대로 유지 | . 2. Depth Test . | 프래그먼트가 그려질 위치 (x, y)에 해당하는 깊이 버퍼의 값을 읽어옴 . | 이 값은 현재 해당 픽셀에 그려진 물체 중 가장 가까운 것의 깊이 정보 | . | 미리 설정된 규칙 (보통 ‘보다 작을 때’를 사용) 에 따라 프래그먼트의 깊이 값과 깊이 버퍼의 값을 비교 | 결과: . | [통과] (프래그먼트가 더 앞에 있을 경우) → 이 프래그먼트는 보이는 것으로 간주 . | 다음 단계인 알파 블렌딩으로 진행 | . | [실패] (프래그먼트가 이미 그려진 것보다 뒤에 있을 경우) → 프래그먼트는 즉시 버림 . | 렌더링할 필요가 없는, 가려진 픽셀이기 때문 | . | . | . 3. Alpha Blending . | 프래그먼트가 그려질 위치 (x, y)에 해당하는 컬러 버퍼(렌더 타겟)의 현재 색상 값을 읽어옴 | 프래그먼트의 색상 및 알파 값과 컬러 버퍼에서 읽어온 색상 값을 미리 설정된 혼합 공식(Blend Formula)에 따라 계산하여 최종 픽셀 색상을 만들어냄 . | (예: 최종색 = (프래그먼트색 * Alpha) + (기존색 * (1-Alpha))) | 만약 불투명한 객체라면, 혼합 과정 없이 프래그먼트의 색상이 최종 색상이 됨 | . | 결과: 해당 픽셀에 그려질 최종 색상이 결정 | . 4. Buffer Update . | 1, 2, 3단계를 모두 통과한 프래그먼트의 최종 정보를 각 버퍼에 기록 | 결과 : . | 스텐실 버퍼: 스텐실 버퍼 설정에 따라 필요시 (x, y) 위치의 값을 업데이트 | 깊이 버퍼: 깊이 테스트를 통과한 프래그먼트의 깊이 값을 (x, y) 위치에 덮어씀 . | 이제 이 깊이가 새로운 ‘가장 가까운’ 값이 됨 | . | 컬러 버퍼: 3단계에서 계산된 최종 픽셀 색상을 (x, y) 위치에 덮어씀 | . | . 모든 테스트를 통과한 프래그먼트의 데이터 (최종 색상, 깊이 값, 새 스텐실 값)가 하나의 논리적인 묶음으로 각 버퍼의 해당 위치에 한 번에 기록된다 . | 이 모든 과정이 각 픽셀에 대해 독립적으로 일어나며, 렌더링할 모든 픽셀이 이 처리를 마치면 하나의 완전한 프레임이 완성된다 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#output-merger-%EC%83%81%EC%84%B8-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#output-merger-상세-처리-과정"
  },"855": {
    "doc": "Output Merger",
    "title": "Early-Z",
    "content": "픽셀 셰이더 이전의 깊이 테스팅 . | 현대 GPU는 성능 최적화를 위해 깊이 테스트를 픽셀 셰이더보다 먼저 수행하기도 한다 | 이를 Early-Z 또는 Early Depth Testing 이라고 부른다 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#early-z",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#early-z"
  },"856": {
    "doc": "Output Merger",
    "title": "왜 이런 최적화가 필요할까?",
    "content": "어떤 물체가 다른 물체에 완전히 가려져서 어차피 화면에 보이지 않을 것이라면, 그 보이지도 않을 픽셀의 색상을 계산하는 것은 엄청난 낭비 . Early-Z 동작 과정 . | 정점 셰이더에서 정점들의 위치와 깊이 값이 계산 | 래스터라이저는 이 정보를 바탕으로 픽셀들을 생성 | 이때, GPU는 본격적인 픽셀 셰이더를 실행하기 전에, 해당 픽셀의 깊이 값을 깊이 버퍼의 값과 미리 비교 | 만약 이 테스트에서 실패하면(즉, 더 뒤에 있는 픽셀이라 판단되면), 해당 픽셀에 대한 픽셀 셰이더를 아예 실행하지 않고 폐기 | . 단, Early-Z는 항상 사용할 수 있는 것은 아님 . | 픽셀 셰이더가 픽셀의 깊이 값을 변경하거나, 픽셀을 폐기(discard)하는 등의 특정 작업을 수행하면 | GPU는 깊이 값을 미리 알 수 없으므로 Early-Z 최적화를 비활성화하고 원래 순서대로(픽셀 셰이더 실행 후 깊이 테스트) 처리함 | . 읽어보면 좋은 링크 . | To Early-Z, or Not To Early-Z | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#%EC%99%9C-%EC%9D%B4%EB%9F%B0-%EC%B5%9C%EC%A0%81%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Output%20Merger.html#왜-이런-최적화가-필요할까"
  },"857": {
    "doc": "Profilers",
    "title": "Profilers",
    "content": "단축키 . | Contrl + Shift + , | . 링크 . | Performance and Profiling | Unreal Insights - Profile performance | Trace Control Tab | . ",
    "url": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Profilers.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Rendering%20pipeline/Profilers.html"
  },"858": {
    "doc": "Reference",
    "title": "주요 매크로 유형",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A3%BC%EC%9A%94-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#주요-매크로-유형"
  },"859": {
    "doc": "Reference",
    "title": "1. UCLASS",
    "content": ". | 클래스를 언리얼 리플렉션 시스템에 등록 (직렬화, GC, 에디터/블루프린트/네트워크 노출 가능) UCLASS(Blueprintable) class MYGAME_API AMyActor : public AActor { GENERATED_BODY() }; . | UCLASS()는 클래스 선언부 바로 위에 위치 | Blueprintable 등 옵션으로 블루프린트 생성 가능 여부 등 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass"
  },"860": {
    "doc": "Reference",
    "title": "2. USTRUCT",
    "content": ". | 구조체를 리플렉션 시스템에 등록 USTRUCT(BlueprintType) struct FMyStruct { GENERATED_BODY() UPROPERTY(EditAnywhere) int32 Value; }; . | BlueprintType : 블루프린트에서도 사용 가능하게 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct"
  },"861": {
    "doc": "Reference",
    "title": "3. UENUM",
    "content": "열거형(enum)을 리플렉션/에디터/블루프린트에 노출 . UENUM(BlueprintType) enum class EMyType : uint8 { TypeA UMETA(DisplayName = \"Type A\"), TypeB UMETA(DisplayName = \"Type B\") }; . | BlueprintType : 블루프린트에서 사용 가능 | UMETA(DisplayName = …) : 에디터에 표시될 이름 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum"
  },"862": {
    "doc": "Reference",
    "title": "4. UPROPERTY",
    "content": ". | 클래스 멤버 변수를 언리얼 리플렉션 시스템에 등록하기 위해 사용 | 에디터에서의 노출, 직렬화, 복제 등 다양한 기능 제어 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stats\") int32 Health; }; . | UPROPERTY로 연결된 객체만이 가비지 컬렉션에서 참조로 간주되어 소멸 방지 | 옵션(AccessSpecifier, Category 등): 노출 범위, 에디터 분류 등 지정 | 에디터, 블루프린트에서 실시간으로 값 변경 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty"
  },"863": {
    "doc": "Reference",
    "title": "5. UFUNCTION",
    "content": ". | 맴버 함수를 블루프린트에서 호출 가능하게 하거나 리플렉션 시스템에 등록 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UFUNCTION(BlueprintCallable, Category=\"Actions\") void TakeDamage(int32 Amount); }; . | BlueprintCallable : 블루프린트에서 호출 가능 | Server, Client 등 RPC 옵션 부여 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction"
  },"864": {
    "doc": "Reference",
    "title": "6. GENERATED_BODY",
    "content": ". | UHT(Unreal Header Tool)가 생성한 코드를 포함시키기 위해 사용 | 클래스 선언 끝에 반드시 포함되어야 함 UCLASS() class MYGAME_API AMyCharacter : public ACharacter { GENERATED_BODY() // ... }; . | GENERATED_BODY() 매크로가 없으면 UHT가 오류를 발생시킴 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body"
  },"865": {
    "doc": "Reference",
    "title": "7. UINTERFACE",
    "content": ". | 인터페이스 선언 . | 두 개의 타입을 동시에 정의함 . | UINTERFACE로 선언되는 UObject 기반 클래스 (메타데이터/리플렉션 목적) | 실제 인터페이스 본체 (관례적으로 I 접두어) | . | . | . UObject 기반 클래스 . // 헤더 파일: MyInterface.h // 1. UINTERFACE로 UObject 파생 클래스 선언 UINTERFACE(BlueprintType) class UMyInterface : public UInterface { GENERATED_BODY() }; // 2. 실제 인터페이스 본체(I 접두사 사용) class IMyInterface { GENERATED_BODY() public: // 인터페이스 함수 선언 (구현은 해당 인터페이스를 상속받는 클래스에서!) UFUNCTION(BlueprintCallable, Category=\"MyInterface\") void MyFunction(); }; . 상속 및 구현 예시 . UCLASS() class AMyActor : public AActor, public IMyInterface { GENERATED_BODY() public: virtual void MyFunction() override; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface"
  },"866": {
    "doc": "Reference",
    "title": "7. DECLARE_* 및 IMPLEMENT_* 매크로",
    "content": ". | 다양한 기능을 선언하고 구현하기 위한 매크로 쌍 . | DECLARE_*: 헤더 파일(.h)에 위치, 선언만 노출 (클래스/함수/변수의 존재를 시스템에 알림) | IMPLEMENT_*: 소스 파일(.cpp)에 위치, 실제 구현을 생성 (선언된 요소의 구체적인 동작 정의) | . | 모듈/플러그인 등록 (DECLARE_MODULE + IMPLEMENT_MODULE) | 로그 카테고리 생성 (DECLARE_LOG_CATEGORY_EXTERN + DEFINE_LOG_CATEGORY) | 인터페이스 구현 (DECLARE_INTERFACE + IMPLEMENT_INTERFACE) | . 기본 예시 . // MyModule.h class FMyModule : public IModuleInterface { public: DECLARE_MODULE(FMyModule) // 1. 모듈 선언 }; // MyModule.cpp IMPLEMENT_MODULE(FMyModule, MyModule) // 2. 모듈 구현 . | IMPLEMENT_MODULE이 자동으로 StartupModule(), ShutdownModule() 함수를 생성하고 모듈을 엔진에 등록 | . 내부 동작 . // 순수 C++ 방식 class MyClass {}; // 직접 구현 // 언리얼 방식 DECLARE_CLASS(MyClass) // UHT가 자동으로 다음 코드 생성: /* class MyClass { static StaticClass(); virtual UClass* GetClass() const; ... }; */ IMPLEMENT_CLASS(MyClass) // UHT가 자동으로 StaticClass() 구현체 생성 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-%EB%B0%8F-implement_-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-및-implement_-매크로"
  },"867": {
    "doc": "Reference",
    "title": "정리",
    "content": "| 매크로 | 적용 대상 | 리플렉션 | 직렬화 | GC | 네트워크 | 블루프린트 | 비고 | . | UCLASS() | 클래스 | O | O | O | O | O |   | . | USTRUCT() | 구조체 | O | O | X | X | O |   | . | UENUM() | enum | O | O | X | X | O |   | . | UPROPERTY() | 멤버 변수 | O | O | O | 옵션에 따라 | O | 옵션(Replicated 등) | . | UFUNCTION() | 멤버 함수 | O | X | X | 옵션에 따라 | O | 옵션(BlueprintCallable 등) | . | UINTERFACE() | 인터페이스 클래스 | O | X | X | X | O |   | . | GENERATED_BODY() | 클래스/구조체/인터페이스 | - | - | - | - | - | UHT 생성 코드 삽입 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#정리"
  },"868": {
    "doc": "Reference",
    "title": "매크로 사용 시 주의사항",
    "content": ". | 리플렉션 매크로는 템플릿 클래스와 호환되지 않음 | 가상 함수에 UFUNCTION 사용 시 반드시 override 키워드 추가 | Replicated 변수는 반드시 기본값 초기화 필요 UPROPERTY(Replicated) int32 Health = 100; // 초기화 필수 . | 에디터 전용 코드 . | WITH_EDITOR 매크로로 감싸지 않으면 런타임 크래시 가능성 #if WITH_EDITOR void EditorOnlyFunction() { ... } #endif . | . | 메모리 관리 : TObjectPtr 도입 (UE5.1+) . | UObject 파생 클래스는 절대 일반 C++ 포인터로 저장하지 말 것 | . | . // 잘못된 예 UPROPERTY() AActor* RawPtr; // 가비지 컬렉션 대상에서 누락될 수 있음 // 올바른 예 UPROPERTY() TObjectPtr&lt;AActor&gt; SafePtr; // UE5 권장 방식 . 참고 링크 . | UStruct | UFuncion | UInterface | 메타데이터 지정자 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#매크로-사용-시-주의사항"
  },"869": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html"
  },"870": {
    "doc": "Search And Delete Empty Folders",
    "title": "목표: 빈 폴더 찾아내서 삭제하기",
    "content": "강의에서는 UEditorAssetLibrary::ListAssets() 메서드를 통해 빈 폴더를 찾았지만, 내 버전 (UE 5.5)에서는 제대로 동작하지 않았다 . 그래서 AssetRegistry Module을 통해 해결했다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#%EB%AA%A9%ED%91%9C-%EB%B9%88-%ED%8F%B4%EB%8D%94-%EC%B0%BE%EC%95%84%EB%82%B4%EC%84%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#목표-빈-폴더-찾아내서-삭제하기"
  },"871": {
    "doc": "Search And Delete Empty Folders",
    "title": "OnDeleteEmptyFoldersButtonClicked() 함수 구현에 사용한 메서드",
    "content": "AssetRegistryModule.Get().GetSubPaths() . 특정 경로(폴더) 기준으로, 하위에 존재하는 모든 서브 폴더의 목록을 조회하는 기능 . void IAssetRegistry::GetSubPaths( const FString&amp; InBasePath, TArray&lt;FString&gt;&amp; OutPathList, bool bInRecurse ) const; . | 매개변수 . | const FString&amp; InBasePath : 서브 폴더를 검색할 기준이 되는 상위 폴더 경로 . | 예시: “/Game/MyFolder” | 반드시 패키지 경로 형식이어야 하며, 슬래시(/)로 시작함 | . | TArray&amp; OutPathList : 검색 결과로 반환될 서브 폴더 경로 문자열의 배열 . | 함수 호출 시 빈 배열을 넘기면 됨 | 함수가 반환되면, InBasePath의 하위에 존재하는 직속/모든(옵션) 폴더 경로가 여기 저장됨 | 패키지 경로 형식으로 배열에 담김김 | . | bool bInRecurse . | true : InBasePath의 모든 하위 폴더(재귀적으로 모든 Depth)를 탐색 | false : InBasePath 바로 직속 1 Depth의 폴더만 반환 (재귀 X) | . | . | 반환값 . | 반환값은 없으며, 결과는 OutPathList에 담김 | . | . UEditorAssetLibrary::DoesDirectoryExist() . 언리얼 에디터가 인식하는 특정 패키지 경로(폴더)가 실제로 존재하는지 확인하는 기능 . 이 함수는 “UE 에디터에서 인식”하는 패키지 경로 기준으로 폴더의 존재 유무만 판단한다 . 파일 시스템상의 디렉터리 유무와는 다를 수 있음 (에디터 DB에 등록된 경로만 인식) . static bool UEditorAssetLibrary::DoesDirectoryExist( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 존재 여부를 확인할 대상 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 에디터와 AssetRegistry에서 인식하는 경로임 | . | . | 반환값 . | true : 해당 경로의 폴더가 에디터 내에 실제로 존재함 . | 폴더가 비어있더라도, 존재하면 true를 반환 | . | false : 해당 경로의 폴더가 존재하지 않음 . | 완전히 삭제된 경우(에셋/폴더 모두 삭제 후 GC 반영 등), false를 반환 | . | . | . UEditorAssetLibrary::DoesDirectoryHaveAssets() . 지정한 패키지 경로(폴더)에 최소 1개 이상의 에셋(Asset)이 존재하는지를 확인하는 기능 . static bool UEditorAssetLibrary::DoesDirectoryHaveAssets( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 에셋 존재 유무를 확인할 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 언리얼 에디터가 인식하는 경로임 | . | . | 반환값 . | true : 해당 폴더 내에 최소 1개 이상의 에셋이 존재 | false : 폴더가 비어있거나(에셋 0개), 폴더 자체가 존재하지 않을 경우 | . | . FString::Append() . 문자열(또는 TCHAR 포인터, FString, FText 등) 값을 뒤에 이어붙이는 함수. 문자열 결합용 . FString S = TEXT(\"Hello\"); S.Append(TEXT(\" World\")); // S = \"Hello World\" . TArray::Append() . 다른 배열이나 범위의 모든 요소를 현재 배열 뒤에 “한꺼번에” 추가 . TArray&lt;Type&gt; Array; Array.Append(OtherArray); // OtherArray의 모든 원소를 뒤에 추가 Array.Append({ \"a\", \"b\", \"c\" }); // initializer list로 여러 개 추가 TArray&lt;FString&gt; Names = { \"Apple\" }; TArray&lt;FString&gt; NewFruits = { \"Banana\", \"Cherry\" }; Names.Append(NewFruits); // 배열: [\"Apple\", \"Banana\", \"Cherry\"] . | 결론 . | Add(): 배열에 “한 개”의 값을 추가 | Append(): 배열에 “여러 개(0개~N개)”의 값을 한 번에 추가 | . | . UEditorAssetLibrary::DeleteDirectory() . 지정한 패키지 경로(폴더) 및 그 하위의 모든 에셋과 폴더를 완전히 삭제하는 기능 . 삭제된 폴더/에셋은 휴지통(Trash) 등으로 이동되지 않고, 실제로 프로젝트에서 사라짐 . static bool UEditorAssetLibrary::DeleteDirectory( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 삭제할 대상 폴더의 패키지 경로 | . | 반환값 . | true : 폴더 및 하위 모든 에셋/폴더의 삭제에 성공 | false : 삭제 실패(예: 에디터가 폴더/에셋을 참조 중이거나, 파일 권한 문제 등) . | 일부 에셋/폴더만 삭제된 경우에도, 하나라도 실패 시 false | . | . | . 동작 설명 . DirectoryPath에 해당하는 폴더 및 모든 하위 폴더/에셋을 재귀적으로 완전 삭제 . | 해당 폴더 내 모든 에셋 및 폴더를 찾음 | 하위 폴더, 에셋 순으로 모두 삭제 | 삭제가 정상적으로 끝나면 true 반환 | 만약 삭제 불가(읽기 전용, 다른 곳에서 사용 중 등)한 경우 false | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-함수-구현에-사용한-메서드"
  },"872": {
    "doc": "Search And Delete Empty Folders",
    "title": "Search And Delete Empty Folders",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html"
  },"873": {
    "doc": "Search And Delete Unused Assets",
    "title": "목표 : 바인딩 된 함수 동작 구현하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EB%AA%A9%ED%91%9C--%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%90%9C-%ED%95%A8%EC%88%98-%EB%8F%99%EC%9E%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#목표--바인딩-된-함수-동작-구현하기"
  },"874": {
    "doc": "Search And Delete Unused Assets",
    "title": "글로벌 함수의 링크 에러 및 static/네임스페이스 처리",
    "content": "G 접두사가 붙은 변수나 함수에 static을 추가하기 . | 링크 에러 : 여러 cpp 파일에서 동일한 헤더를 include하고, 그 헤더에 글로벌 함수가 정의되어 있다면 컴파일 시 “중복 정의된 심볼” 에러 발생 | 전역 객체 : 전역 객체에 직접 접근하는 함수를 static으로 만들면 해당 함수를 사용하는 모듈이 전역 객체가 정의된 모듈에 대한 불필요한 종속성을 만들지 않음 | . -&gt; 디버그 헤더에 namespace 추가 (클래스가 아니라 namespace::로 사용하기 위해) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EA%B8%80%EB%A1%9C%EB%B2%8C-%ED%95%A8%EC%88%98%EC%9D%98-%EB%A7%81%ED%81%AC-%EC%97%90%EB%9F%AC-%EB%B0%8F-static%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#글로벌-함수의-링크-에러-및-static네임스페이스-처리"
  },"875": {
    "doc": "Search And Delete Unused Assets",
    "title": "OnDeleteUnsuedAssetButtonClicked() 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::ListAssets() . 특정 폴더 경로 내의 모든 에셋(assets) 목록을 가져오는 기능 . static TArray&lt;FString&gt; UEditorAssetLibrary::ListAssets( const FString&amp; Path, bool bRecursive = true, bool bIncludeFolder = false ); . | 매개변수 . | Path : 에셋을 검색할 디렉터리 경로 | bRecursive : 하위 폴더까지 탐색 여부 (기본값 true) | bIncludeFolder : 폴더 자체도 결과 배열에 포함할지 여부 (기본값 false) | . | 반환값 . | TArray : 폴더 내 모든 에셋/폴더의 \"Object Path\" 문자열 배열 . | 예 : /Game/Test/Sub/SM_Sphere.SM_Sphere | . | . | . 2. Contains() . 문자열 또는 컨테이너 내 특정 요소의 존재 여부를 검사 . bool FString::Contains( const TCHAR* SubStr, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . | 매개변수 . | const TCHAR* : 검색할 부분 문자열 (예: “Test”) | ESearchCase::Type : 대소문자 구분 여부 . | ESearchCase::IgnoreCase : 구분 안함 | ESearchCase::CaseSensitive : 구분함 | . | . | 반환값 . | 포함되면 true / 아니면 false | . | . 컨테이너 별 용도 . | 문자열 검색 → FString::Contains() | 빠른 요소 확인 → TSet::Contains() | 키 존재 여부 → TMap::Contains() | . 3. UEditorAssetLibrary::DoesAssetExist() . 에셋 경로(.uasset)가 실제로 존재하고 로드 가능한지 여부를 확인 . static bool UEditorAssetLibrary::DoesAssetExist( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검사할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환 값 . | 에셋이 존재하면 true, 아니면 false | . | . 4. UEditorAssetLibrary::FindAssetData() . 주어진 에셋 경로(.uasset)로부터 에셋의 메타데이터(FAssetData) 를 조회 . static FAssetData UEditorAssetLibrary::FindAssetData( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검색할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환값 . | FAssetData : 에셋 정보를 담은 객체 (없으면 빈 객체) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-함수-구현에-사용한-메서드"
  },"876": {
    "doc": "Search And Delete Unused Assets",
    "title": "Search And Delete Unused Assets",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html"
  },"877": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "목표: SCompoundWidget 상속받아 커스텀 위젯 클래스 만든 후 바인딩하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EB%AA%A9%ED%91%9C-scompoundwidget-%EC%83%81%EC%86%8D%EB%B0%9B%EC%95%84-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%A0-%ED%9B%84-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#목표-scompoundwidget-상속받아-커스텀-위젯-클래스-만든-후-바인딩하기"
  },"878": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "커스텀 위젯 등록과 바인딩",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%EB%93%B1%EB%A1%9D%EA%B3%BC-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#커스텀-위젯-등록과-바인딩"
  },"879": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule에서 이벤트 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%97%90%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule에서-이벤트-등록"
  },"880": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule의 역할",
    "content": "어떤 일이 생길 때, 무슨 코드를 실행할지를 엔진의 전역 관리자에게 등록 . 등록: 함수 포인터/Delegate, 생성자 콜백, 이름(ID) 등만 엔진 전역 자료구조에 저장 메모리상에는 해당 모듈이 필요해지면 이 콜백을 실행해서 만든다는 정보만 들어있음 . | 전역 테이블(맵, 배열, 리스트 등)에 ‘예약’만 해놓음 | . void FBacgroundToolsModule::StartupModule() { InitCBMenuExtention(); RegisterAdvanceDeletionTab(); } . | StartupModule()에서 RegisterAdvanceDeletionTab()을 호출 . | 탭(Advanced Deletion 패널)을 에디터에 “등록”하는 과정이 실행 | . | . void FBacgroundToolsModule::RegisterAdvanceDeletionTab() { FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;FBacgroundToolsModule::OnSpawnAdvanceDeletionTab)) .SetDisplayName(FText::FromString(TEXT(\"Advance Deletion\"))); } . FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner . | FGlobalTabmanager(언리얼 에디터의 전역 탭 관리자)에 “AdvanceDeletion” 이라는 ID로 탭 생성자를 등록 실제로 이 탭을 띄우기 전까지는 “정의만 되어있는 상태”이다 . 즉, “Advanced Deletion”이라는 이름의 탭을 만들 준비만 마친 것 . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule의-역할"
  },"881": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "탭을 실제로 여는 시점 (이벤트 발생)",
    "content": ". | OnAdvancedDeletionButtonClicked 함수 . | TryInvokeTab(\"AdvanceDeletion\")을 통해 등록된 스포너(생성 콜백)를 호출 | . | OnSpawnAdvanceDeletionTab() 함수를 통해 실제 인스턴스 생성 . | 이 순간부터 Advance Deletion 탭이 실제로 화면에 나타남 TSharedRef&lt;SDockTab&gt; FBacgroundToolsModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs) { return SNew(SDockTab).TabRole(ETabRole::NomadTab) [ SNew(SAdvanceDeletionTab) .TestString(TEXT(\"I am passing data\")) ]; } . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%ED%83%AD%EC%9D%84-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%EC%97%AC%EB%8A%94-%EC%8B%9C%EC%A0%90-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%9C%EC%83%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#탭을-실제로-여는-시점-이벤트-발생"
  },"882": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "정리",
    "content": ". | StartupModule()의 RegisterAdvanceDeletionTab()는 해당 이벤트 발생 전 준비만 바인딩 . | 이름만 등록, 실제 위젯 인스턴스 없음 | . | OnAdvancedDeletionButtonClicked()는 실제 사용자가 해당 이벤트를 발생시켰을 때 동작 바인딩 . | 실제 인스턴스 생성, SDockTab의 ChildSlot에 내가 생성한 위젯이 들어감 | . | . StartupModule() (에디터/플러그인 모듈 초기화) └→ RegisterAdvanceDeletionTab() └→ FGlobalTabmanager::RegisterNomadTabSpawner(\"AdvanceDeletion\", OnSpawnTab...) └→ \"AdvanceDeletion\" 탭 생성 콜백(준비만 해둠) └→ (사용자 요청이 있을 때까지 기다림) (사용자: 우클릭→Advanced deletion 메뉴 클릭) └→ OnAdvancedDeletionButtonClicked() → TryInvokeTab(\"AdvanceDeletion\") └→ FGlobalTabmanager에서 해당 탭 콜백 호출 └→ OnSpawnAdvanceDeletionTab() 실행 └→ SDockTab 생성, ChildSlot에 SAdvanceDeletionTab(Slate 위젯) 추가 └→ 트리 구조로 에디터 Slate 트리에 편입, 렌더링 시작 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#정리"
  },"883": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FGlobalTabmanager",
    "content": "언리얼 에디터 Slate 시스템의 탭(도킹 패널) 전체를 총괄하는 전역 관리자 . | 전역 객체 구조 . | FGlobalTabmanager::Get() : 항상 같은 전역 인스턴스 가져옴 | 실제로는 FSlateApplication 내부에 저장된 전역 포인터이다 | . | 역할 . | 탭의 등록/생성/소멸/상태관리 | 탭의 열림/닫힘/포커스/배치 등 관리 | ID(이름) ↔ 탭 생성자(Delegate) 맵 관리 | Slate 트리(SDockTab, SDockingArea, SWindow 등)와 연동 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager"
  },"884": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "주요 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#주요-메서드"
  },"885": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "RegisterNomadTabSpawner",
    "content": "RegisterNomadTabSpawner( FName TabId, FOnSpawnTab OnSpawnTabDelegate ) . | TabId : 이름의 도킹/플러그인 패널을 등록 | OnSpawnTabDelegate : 생성자 델리게이트 등록 | . 사용 예시 . // 탭 등록 FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner( FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;MyModule::OnSpawnAdvanceDeletionTab) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner"
  },"886": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "TryInvokeTab",
    "content": "TSharedPtr&lt;SDockTab&gt; TryInvokeTab(FName TabId); . | “TabId”의 탭이 열려있으면 포커스 | 없으면 등록된 Delegate로 탭 새로 생성/열기 | . 사용 예시 . // 탭 열기 (생성) FGlobalTabmanager::Get()-&gt;TryInvokeTab(FName(\"AdvanceDeletion\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab"
  },"887": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "UnregisterNomadTabSpawner",
    "content": "void UnregisterNomadTabSpawner(FName TabId); . | 등록해둔 탭 생성자(Delegate)와 ID 연결을 해제 . | 모듈이 종료될 때, ShutdownModule에서 주로 사용 | . | . 사용 예시 . // 탭 해제 FGlobalTabmanager::Get()-&gt;UnregisterNomadTabSpawner(FName(\"MyCustomTab\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner"
  },"888": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FindExistingLiveTab",
    "content": "TSharedPtr&lt;SDockTab&gt; FindExistingLiveTab(FName TabId); . | 이미 열려 있는 특정 TabId의 SDockTab Slate 객체를 반환 . | 없으면 nullptr | . | . 사용 예시 . // 이미 열린 탭 객체 얻기 TSharedPtr&lt;SDockTab&gt; LiveTab = FGlobalTabmanager::Get()-&gt;FindExistingLiveTab(FName(\"MyCustomTab\")); if (LiveTab.IsValid()) { // Tab이 이미 열려 있음 → 추가 동작 가능 } . ❓부모 모듈에서 에셋 데이터를 넘겨줘야 하는 이유? . | AdvanceDeletionTab은 “선택된 폴더 내의 에셋 데이터”를 리스트로 보여줘야 하므로, 그 데이터를 생성 시점에 한 번에 전달받아야 함 | 따라서 자식 위젯 클래스에서 설정한 SLATE_ARGUMENT에 부모가 에셋 리스트를 넘겨줘야 위젯의 생성자 초기화가 올바르게 세팅됨 | 부모에서 자식 탭을 생성할 때 반드시 값을 전달해야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab"
  },"889": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "Set Up A Class For Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html"
  },"890": {
    "doc": "Set Up Basic Layout",
    "title": "목표: 슬레이트 탭 레이아웃 작성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%AA%A9%ED%91%9C-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%ED%83%AD-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%9E%91%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#목표-슬레이트-탭-레이아웃-작성"
  },"891": {
    "doc": "Set Up Basic Layout",
    "title": "레이아웃 샘플 예시 보기",
    "content": ". | 에디터 플러그인 폴더 -&gt; 모듈 콘텐츠 폴더로 이동 | 우클릭 -&gt; 에디터 유틸리티 -&gt; 에디터 유틸리티 위젯 클릭 | 생성된 에디터 유틸리티 위젯 더블클릭 | 검색을 통해 슬롯에 추가 등 샘플 미리 볼 수 있음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%83%98%ED%94%8C-%EC%98%88%EC%8B%9C-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#레이아웃-샘플-예시-보기"
  },"892": {
    "doc": "Set Up Basic Layout",
    "title": "위젯 여러개 배치",
    "content": "SVerticalBox(세로 박스) 또는 SHorizontalBox(가로 박스)와 같은 패널 위젯을 사용 . | 해당 박스들은 여러개의 슬롯을 가질 수 있음 (보통 위젯은 하나의 슬롯만 가짐) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%9C%84%EC%A0%AF-%EC%97%AC%EB%9F%AC%EA%B0%9C-%EB%B0%B0%EC%B9%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#위젯-여러개-배치"
  },"893": {
    "doc": "Set Up Basic Layout",
    "title": "SNew",
    "content": "위젯을 생성하기 위한 핵심 매크로로, 타입 안전성과 메모리 관리를 자동화하는 데 사용 . | 생명주기를 동적으로 제어해야 할 때 SNew를 TSharedPtr 변수에 담아둔다 . | 메모리 관리와 수명 제어가 유연하게 필요하면 TSharedPtr | 절대 null이 될 수 없고, 항상 살아있어야 하면 TSharedRef | . | . // SNew()로 생성된 TSharedRef를 바로 반환하면: return SNew(SListView&lt;...&gt;); // 임시 객체가 즉시 파괴될 위험 // TSharedPtr에 보관하면 참조 카운트 유지 TSharedPtr &lt; SListView &lt; TSharedPtr &lt;FAssetData&gt; &gt; &gt; ConstructedAssetListView = SNew(SListView&lt;...&gt;); // 참조 +1 return ConstructedAssetListView.ToSharedRef(); // 참조 +1 (총 2) . | 방식 | 장점 | 단점 |   | . | TSharedRef | 직접 반환 | 간결함 | 이후 접근 불가능 | . | TSharedPtr | 저장 후 변환 | 생명주기 관리 용이 | 코드가 약간 길어짐 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#snew",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#snew"
  },"894": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 메모리 관리 자동화 . | 반환된 TSharedRef가 범위를 벗어나면 자동으로 메모리 해제 | 명시적인 delete 호출 불필요 | . | 빌더 패턴 지원 (.속성으로 속성 설정, [] 자식 위젯 추가) | 타입 안정성 . | 컴파일 타임에 위젯 타입 검증 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징"
  },"895": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": ". | 생성 방식: SNew(WidgetClass) 형태로 사용하며, 항상 TSharedRef&lt;WidgetClass&gt;를 반환 | . TSharedRef&lt;SCheckBox&gt; MyCheckBox = SNew(SCheckBox) .IsChecked(true) .OnCheckStateChanged(this, &amp;MyClass::Handler); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법"
  },"896": {
    "doc": "Set Up Basic Layout",
    "title": "SVerticalBox",
    "content": "자식 위젯들을 수직 방향(위에서 아래로)으로 배치하는 레이아웃 컨테이너 . | 각 자식 위젯은 새로운 행에 배치됨 | SVerticalBox에 슬롯을 추가 . | .AddSlot() | + SVerticalBox::Slot() | . | . // 메인 세로 박스 SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ // 첫 번째 슬롯: 타이틀 텍스트 SNew(STextBlock) .Text(FText::FromString(TEXT(\"Advanced Deletion\"))) // 아래에 속성 추가 ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox"
  },"897": {
    "doc": "Set Up Basic Layout",
    "title": "SHorizontalBox",
    "content": "자식 위젯들을 수평 방향으로 배치하는 레이아웃 컨테이너 (왼쪽-&gt; 오른쪽) . | 각 자식은 새로운 열에 배치됨 | +SHorizontalBox::Slot() | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox"
  },"898": {
    "doc": "Set Up Basic Layout",
    "title": "속성 지정자",
    "content": "각각의 컨테이너는 각자의 Slot 구조체를 가지고 있고, 이 Slot의 속성을 통해 레이아웃을 제어할 수 있다 . | SVerticalBox::Slot() | SHorizontalBox::Slot() | SGridPanel::Slot() 등등 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#속성-지정자"
  },"899": {
    "doc": "Set Up Basic Layout",
    "title": "주요 Slot 속성 지정자",
    "content": "| 속성 지정자 | 설명 | 적용 가능한 컨테이너 | . | AutoWidth() | 자식 위젯의 자연스러운 너비로 자동 조정 | SHorizontalBox | . | AutoHeight() | 자식 위젯의 자연스러운 높이로 자동 조정 | SVerticalBox | . | FillWidth(float) | 사용 가능한 수평 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SHorizontalBox | . | FillHeight(float) | 사용 가능한 수직 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SVerticalBox | . | Padding(FMargin) | 슬롯 내부의 여백 설정 (Left, Top, Right, Bottom) | 모두 | . | HAlign(HAlign) | 수평 정렬 방식 (Left, Center, Right, Fill) | 모두 | . | VAlign(VAlign) | 수직 정렬 방식 (Top, Center, Bottom, Fill) | 모두 | . | MaxWidth(float) | 최대 너비 제한 | SHorizontalBox | . | MaxHeight(float) | 최대 높이 제한 | SVerticalBox | . | Expose(ExposedSlot&amp;) | 슬롯을 외부에서 접근할 수 있도록 노출 | 모두 | . | AutoHeight/AutoWidth: 해당 자식 위젯의 DesiredSize에 맞춰 영역을 할 | FillHeight/FillWidth: 남은 공간을 지정된 가중치대로 자식들에게 분배 . | 예: FillHeight(1.0f), FillHeight(2.0f)로 지정하면 1:2 비율로 높이를 나눔 | . | HAlign/VAlign : 현재 위젯/슬롯의 자식에 대한 정렬 제어 . | 부모 레이아웃(SVerticalBox, SScrollBox 등)의 슬롯에서 설정 → 자식 위젯의 공간 배분을 결정 | 자식 위젯(예: STextBlock)에서 직접 설정 → 자신의 할당된 공간 내 정렬을 결정 | . | Padding: 각 자식 위젯의 Slot에 여백 부여 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%A3%BC%EC%9A%94-slot-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#주요-slot-속성-지정자"
  },"900": {
    "doc": "Set Up Basic Layout",
    "title": "STextBlock",
    "content": "순수한 텍스트 렌더링에 특화된 텍스트 표시를 위한 기본 위젯 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock"
  },"901": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 고성능 렌더링: DirectX/OpenGL 기반 하드웨어 가속 텍스트 렌더링 | 다국어 지원: FText와 통합된 LOC 시스템(로컬라이제이션) | 스타일 커스터마이징: 폰트, 색상, 정렬 등 완전한 제어 가능 | 동적 업데이트: 텍스트 내용 실시간 변경 가능 | 레이아웃 통합: 다른 슬레이트 위젯과 자유롭게 조합 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징-1"
  },"902": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": "TSharedRef&lt;STextBlock&gt; MyTextBlock = SNew(STextBlock) .Text(LOCTEXT(\"Greeting\", \"안녕하세요!\")) .Font(FSlateFontInfo(\"Roboto\", 16)) .ColorAndOpacity(FLinearColor::White); // 동적 바인딩 FText GetDynamicText() const; // 구현 SNew(STextBlock) .Text(this, &amp;MyClass::GetDynamicText) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법-1"
  },"903": {
    "doc": "Set Up Basic Layout",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#주요-속성"
  },"904": {
    "doc": "Set Up Basic Layout",
    "title": ".Text",
    "content": "표시할 텍스트. FText 사용 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#text",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#text"
  },"905": {
    "doc": "Set Up Basic Layout",
    "title": ".Font",
    "content": "폰트 정보. 스타일, 크기, 폰트 패밀리 등 지정 . | 아래의 FSlateFontInfo 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#font",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#font"
  },"906": {
    "doc": "Set Up Basic Layout",
    "title": ".ColorAndOpacity",
    "content": "텍스트 색상 및 투명도(FSlateColor) .ColorAndOpacity(FSlateColor(FLinearColor::Red)) // FLinearColor 바로 전달 .ColorAndOpacity(FLinearColor::Green) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#colorandopacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#colorandopacity"
  },"907": {
    "doc": "Set Up Basic Layout",
    "title": ".Justification",
    "content": "정렬 방식 (ETextJustify::Type) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#justification",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#justification"
  },"908": {
    "doc": "Set Up Basic Layout",
    "title": ".AutoWrapText",
    "content": "자동 줄바꿈 여부 .AutoWrapText(true) // 영역에 맞춰 자동 줄바꿈 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#autowraptext",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#autowraptext"
  },"909": {
    "doc": "Set Up Basic Layout",
    "title": ".MinDesiredWidth",
    "content": "최소 너비(줄바꿈용) .MinDesiredWidth(200.0f) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#mindesiredwidth",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#mindesiredwidth"
  },"910": {
    "doc": "Set Up Basic Layout",
    "title": ".WrappingPolicy",
    "content": "줄바꿈 정책 (UE5에서 도입, 텍스트 나누는 방식 선택) .WrappingPolicy(ETextWrappingPolicy::DefaultWrapping) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#wrappingpolicy",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#wrappingpolicy"
  },"911": {
    "doc": "Set Up Basic Layout",
    "title": "STextBlock 속성 지정 정리",
    "content": "// 텍스트 블록에 적용 SNew(STextBlock) .Font(FontInfo) // FSlateFontInfo 구조체 사용 .Text(FText::FromString(\"Hello Unreal\")) .ColorAndOpacity(FLinearColor::White) .Justification(ETextJustify::Center); . | 지정자 | 설명 | 예시 코드 | . | .Text(FText) | 표시할 텍스트 지정 | .Text(FText::FromString(TEXT(“Hello”))) | . | .Font(const FSlateFontInfo&amp;) | 폰트 패밀리/크기/스타일 지정 | .Font(FSlateFontInfo(“Roboto-Bold”, 24)) | . | .ColorAndOpacity(FSlateColor) | 텍스트 색상 및 불투명도(알파) 지정 | .ColorAndOpacity(FLinearColor::Red) | . | .ShadowOffset(FVector2D) | 텍스트 그림자 오프셋(거리) | .ShadowOffset(FVector2D(1, 1)) | . | .ShadowColorAndOpacity(FLinearColor) | 텍스트 그림자 색상 및 알파 | .ShadowColorAndOpacity(FLinearColor::Black) | . | .Justification(ETextJustify::Type) | 텍스트 정렬(좌/중앙/우) | .Justification(ETextJustify::Center) | . | .WrapTextAt(float) | 지정한 너비에서 텍스트 줄바꿈 | .WrapTextAt(200.0f) | . | .MinDesiredWidth(float) | 최소 표시 너비 | .MinDesiredWidth(50.0f) | . | .LineHeightPercentage(float) | 줄 간격 비율(1.0=기본) | .LineHeightPercentage(1.2f) | . | .AutoWrapText(bool) | 컨테이너 너비에 맞춰 자동 줄바꿈 | .AutoWrapText(true) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock-속성-지정-정리"
  },"912": {
    "doc": "Set Up Basic Layout",
    "title": "FSlateFontInfo",
    "content": "Slate 위젯에 텍스트 스타일 지정에 사용되는 구조체. 폰트 스타일, 크기 정보 . | STextBlock의 폰트 속성 지정자에 사용 | . struct FSlateFontInfo { UObject* FontObject; // 사용할 폰트 객체 (UFont 또는 FSlateFontInfo::GetFont) FName TypefaceFontName; // 폰트 페이스 이름(예: \"Bold\", \"Regular\") int32 Size; // 폰트 크기 FName FontMaterial; // 폰트 머티리얼 TEnumAsByte&lt;EFontHinting&gt; Hinting; // 폰트 힌팅 방식 bool bEnableOutline; // 아웃라인 사용 여부 float OutlineSize; // 아웃라인 크기 FLinearColor OutlineColor; // 아웃라인 색상 }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo"
  },"913": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": "// 에디터에서 제공하는 폰트 사용 FSlateFontInfo FontInfo = FCoreStyle::Get().GetFontStyle(\"Bold\", 18); // 직접 지정 FSlateFontInfo FontInfo(\"Roboto-Regular\", 24); // 폰트 패밀리, 크기 // 경로로 지정 FSlateFontInfo FontInfo( FPaths::EngineContentDir() / TEXT(\"Slate/Fonts/Roboto-Regular.ttf\"), 20 ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법-2"
  },"914": {
    "doc": "Set Up Basic Layout",
    "title": "FSlateColor",
    "content": "UI 요소의 색상 및 투명도(opacity)를 표현하고, 동적으로 바인딩하거나 테마 기반으로 자동 갱신할 수 있게 설계된 컬러 래퍼 구조체 . | .ColorAndOpacity 등 여러 스타일 속성에서 사용되는 색상 타입 | 내부적으로 FLinearColor 값을 갖음 | 직접 색상 지정 또는 Slate 색상 테마 (브러시/스타일) 참조 둘 다 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatecolor",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatecolor"
  },"915": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 정적 색상: 고정된 FLinearColor 값 | 동적 바인딩: Slate Attribute 시스템을 통한 동적 색상 변경 | Slate 브러시/스타일 연동: 테마/스타일에서 정의된 색상 참조 가능 | 투명도(Opacity) 포함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징-2"
  },"916": {
    "doc": "Set Up Basic Layout",
    "title": "생성 예시",
    "content": "// 정적 색상 지정 .ColorAndOpacity(FSlateColor(FLinearColor::Red)) .ColorAndOpacity(FSlateColor(FLinearColor(1, 0.5, 0, 1))) // 오렌지색, RGBA // FLinearColor 타입을 FSlateColor 생성자에 바로 전달해도 자동 변환 .ColorAndOpacity(FLinearColor::Green) // 동적 속성 바인딩 (예: 상태에 따른 색상 변경) .ColorAndOpacity(this, &amp;SMyWidget::GetTextColor) FSlateColor SMyWidget::GetTextColor() const { return bIsError ? FLinearColor::Red : FLinearColor::White; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-예시"
  },"917": {
    "doc": "Set Up Basic Layout",
    "title": "스타일 기반 참조",
    "content": ". | 스타일 시스템이 지정한 색상 사용 | 테마가 바뀌면 자동으로 색상이 바뀌도록 할 때 필수적 .ColorAndOpacity(FSlateColor::UseForeground()) .ColorAndOpacity(FSlateColor::UseSubduedForeground()) . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%8A%A4%ED%83%80%EC%9D%BC-%EA%B8%B0%EB%B0%98-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#스타일-기반-참조"
  },"918": {
    "doc": "Set Up Basic Layout",
    "title": "Set Up Basic Layout",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html"
  },"919": {
    "doc": "Slate",
    "title": "Slate",
    "content": "언리얼 엔진의 로우레벨 UI 프레임워크 . | SlateCore: UI 위젯, 레이아웃, 입력 처리 등 Slate의 핵심 로직을 담당 | Slate: 렌더링, 스타일링, 고수준 위젯 구현, Windows/OSX/Linux와의 통합 등 확장 기능 담당 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html"
  },"920": {
    "doc": "Slate",
    "title": "슬레이트 구조 특징",
    "content": ". | Slate의 UI는 SWidget이라는 추상 클래스를 루트로 하는 트리 구조 | 각 위젯(버튼, 텍스트, 리스트 등)은 SWidget을 상속한 C++ 클래스 . | 예: SButton, STextBlock, SListView 등 | . | 모든 위젯은 부모-자식 관계로 연결되어 트리 형태 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B5%AC%EC%A1%B0-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-구조-특징"
  },"921": {
    "doc": "Slate",
    "title": "슬레이트 동작 과정",
    "content": ". | Slate Application 구동 . | 엔진 초기화 시 FSlateApplication 싱글턴이 생성 | 이 객체가 Slate의 메인 루프, 입력 이벤트 분배, 렌더링 등을 총괄 | . | 위젯 트리 구성 . | 프로그래머가 C++로 SWidget 트리를 생성 (ex. SNew(SVerticalBox) + SNew(STextBlock) 형태) | 이 트리를 SlateApplication이 루트부터 관리 | . | 입력 이벤트 처리 . | OS 레벨의 입력(마우스, 키보드 등)이 SlateApplication에 전달됨 | Slate는 이를 루트 SWidget부터 트리 순회하며 적절한 위젯에 분배 | 각 위젯은 OnMouseDown, OnKeyDown 등 가상 메서드에서 처리 | . | Tick &amp; 업데이트 . | Slate 트리는 매 프레임마다 Tick(갱신)됨 | 애니메이션, 상태 변화, Focus 변경 등 UI 갱신이 여기서 처리 | . | 레이아웃 &amp; 측정 . | 각 SWidget은 ComputeDesiredSize, ArrangeChildren 등 메서드로 자기 크기와 자식 위치를 계산 | 위젯 트리를 재귀적으로 순회하며 레이아웃 패스를 수행 | . | 렌더링 . | 각 위젯의 OnPaint가 호출되어 FSlateDrawElement 명령을 발행 | Slate 렌더러가 DrawElement를 실제 GPU로 렌더링 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-동작-과정"
  },"922": {
    "doc": "Slate",
    "title": "슬레이트 다이어그램",
    "content": ". 클래스 관계 . | FSlateApplication → SWindow: 여러 윈도우(에디터 창 등)를 관리 | SWindow → SWidget: 각 윈도우는 하나의 루트 위젯 트리를 가짐 | SWidget → SPanel/SCompoundWidget: 각 위젯의 파생 구조를 통해 복잡한 UI 트리를 형성 | FSlateWindowElementList → FSlateDrawElement: 각 윈도우에서 발생하는 모든 드로우 명령을 버퍼링 | FSlateDrawElement ↔ FWidgetStyle: 드로우 요소마다 스타일 정보를 가짐 | FSlateApplication → FSlateRenderer: 실제 GPU 렌더링을 위해 렌더러로 명령을 위임 | . FSlateApplication . | Slate 전체의 엔트리 포인트이자 메인 루프 | 입력 이벤트(마우스, 키보드 등) 처리, UI 업데이트(Tick), 드로우 메시지 생성, 윈도우 관리, 렌더링 요청까지 Slate 관련 모든 핵심 흐름을 담당 | Tick, ProcessInput, GeneratePaintMessages, DrawWindows 등 메서드를 통해 매 프레임 UI 시스템의 상태를 갱신하고, 렌더링 파이프라인을 실행 | 여러 개의 SWindow 인스턴스를 직접적으로 관리 | . SWindow . | OS 창(Window)의 추상화 | 에디터 창, 툴팁, 팝업 등 각종 윈도우를 의미 | 각 SWindow는 자신의 루트 위젯(RootWidget, SWidget)을 하나 포함 . | 즉, 한 SWindow의 모든 Slate UI 요소는 하나의 SWidget 트리로 구성됨 | . | 창의 콘텐츠 설정, 네이티브 창 객체 반환, 뷰포트(창 영역) 크기 정보 제공 등의 역할을 담당 | . SWidget . | 모든 Slate 위젯(버튼, 텍스트, 패널 등)의 최상위 추상 베이스 클래스 | 모든 시각적 UI 요소는 SWidget을 상속하여 구현 | 주요 메서드: . | ComputeDesiredSize: 위젯이 필요로 하는 최소/최적 크기 계산 | ArrangeChildren: 자식 위젯 배치 | OnPaint: 실제로 드로우 요소를 생성(FSlateDrawElement)하는 렌더링 엔트리 포인트 | OnMouseButtonDown: 입력 이벤트 핸들링 | Tick: 프레임마다 상태 갱신 등 | . | . SWidget 컨테이너 상속 구조 (SCompoundWidget, SPanel) . | SCompoundWidget . | SWidget에서 파생되며, 단일 자식(Slot)만을 가질 수 있는 컨테이너 | 복잡한 단일 구조 위젯에 적합 | . | SPanel . | SWidget에서 파생되며, 여러 자식(Slot/배열)을 가질 수 있는 컨테이너 | 리스트, 박스, 그리드 등 여러 자식 위젯을 배치하는 레이아웃 위젯에서 사용 | . | . FSlateWindowElementList . | 실제 드로잉 명령(FSlateDrawElement)의 집합/버퍼 역할 | 각 SWindow의 OnPaint 과정에서 위젯 트리를 순회하며, SWidget들이 페인트 시 호출되는 OnPaint에서 DrawElement를 이 리스트에 기록 | Draw Call 최적화와 레이어 관리의 핵심 중간 계층 | . FSlateDrawElement . | 실제 GPU로 전달되는 드로우 명령을 표현하는 구조체 | 박스, 텍스트, 선, 이미지 등 다양한 유형의 그리기 명령을 포함 | SWidget이 OnPaint에서 시각적 요소를 그리고자 할 때, FSlateDrawElement를 만들어 FSlateWindowElementList에 추가함 | . FWidgetStyle . | 위젯의 시각적 스타일(컬러, 불투명도, 폰트 등)을 정의 | FSlateDrawElement와 연계되어, 각 드로우 요소에 스타일 속성을 부여 | 상위에서 하위로 스타일이 전파되어, 일관성 있는 UI 테마 구현이 가능 | . FSlateRenderer . | 실제 하드웨어(DirectX/OpenGL/Vulkan 등) 렌더러와의 인터페이스 | FSlateApplication이 그리기 명령을 넘기면, FSlateRenderer가 이를 플랫폼별로 변환/렌더링 | Slate의 플랫폼 독립성과 실제 렌더링 동작을 분리하는 핵심 계층 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-다이어그램"
  },"923": {
    "doc": "Slate",
    "title": "정리",
    "content": ". | FSlateApplication → SWindow → SWidget 트리 (OnPaint) → FSlateWindowElementList → FSlateDrawElement → FSlateRenderer (플랫폼별) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#정리"
  },"924": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "목표 : 커스텀 에디터 탭 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%AA%A9%ED%91%9C--%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%90%EB%94%94%ED%84%B0-%ED%83%AD-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#목표--커스텀-에디터-탭-등록"
  },"925": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 매크로",
    "content": ". | SLATE_BEGIN_ARGS , SLATE_END_ARGS 매크로는 필수적으로 클래스 안에 들어가야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-매크로"
  },"926": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_BEGIN_ARGS / SLATE_END_ARGS",
    "content": "위젯의 생성자 인자 구조체인 FArguments를 정의 . | SLATE_BEGIN_ARGS는 구조체의 시작 | SLATE_END_ARGS는 구조체의 끝 | 시작과 끝 매크로 안에서 위젯의 속성, 이벤트 등을 선언 | . SLATE_BEGIN_ARGS(SMyWidget) // 시작 선언 : _Title(FText::FromString(\"Default Title\")) // 기본값 설정 {} SLATE_ARGUMENT(FText, Title) SLATE_ATTRIBUTE(int32, Count) SLATE_EVENT(FOnClicked, OnButtonClicked) SLATE_END_ARGS() // 끝 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args"
  },"927": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ARGUMENT(Type, Name)",
    "content": "생성자 인자로 전달되는 불변 값을 선언 . | SLATE_ARGUMENT(FText, Title)은 FText 타입의 Title이라는 인자를 선언 | FArguments 구조체 내에서 _Title로 접근 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name"
  },"928": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ATTRIBUTE(Type, Name)",
    "content": "동적으로 변경 가능한 속성을 선언 . 외부 데이터와 바인딩하여 UI 요소가 실시간으로 업데이트되도록 할 수 있다 . | SLATE_ATTRIBUTE(int32, Count)은 Count라는 이름의 속성을 선언 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name"
  },"929": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_EVENT(DelegateType, Name)",
    "content": "위젯에서 발생하는 이벤트를 처리할 델리게이트를 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name"
  },"930": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_NAMED_SLOT(OwnerArgsType, SlotType, SlotName)",
    "content": "사용자 정의 슬롯을 선언할 때 사용. 슬롯은 위젯의 특정 위치에 다른 위젯을 삽입할 수 있는 영역을 의미 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname"
  },"931": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "매크로 정리",
    "content": "| 매크로 | 용도 | 사용 예시 | 설명 | . | SLATE_BEGIN_ARGS | 위젯 생성 인자 정의 시작 | SLATE_BEGIN_ARGS(SMyWidget) | 클래스의 생성 인자 정의 블록을 시작 | . | SLATE_END_ARGS | 위젯 생성 인자 정의 종료 | SLATE_END_ARGS() | 생성 인자 정의 블록을 종료 | . | SLATE_ARGUMENT | 단일 값 인자 정의 | SLATE_ARGUMENT(FText, InitialText) | 위젯 생성 시 전달되는 단일 값 인자 | . | SLATE_ATTRIBUTE | 바인딩 가능한 속성 정의 | SLATE_ATTRIBUTE(FText, DisplayText) | 동적으로 변경 가능한 속성(TAttribute로 래핑됨) | . | SLATE_EVENT | 이벤트 핸들러 정의 | SLATE_EVENT(FOnClicked, OnButtonClicked) | 위젯에서 발생하는 이벤트 핸들러 | . | SLATE_STYLE_ARGUMENT | 스타일 인자 정의 | SLATE_STYLE_ARGUMENT(FName, StyleName) | 스타일 세트에서 스타일을 지정하는 인자 | . | SLATE_DEFAULT_SLOT | 기본 슬롯 속성 정의 | SLATE_DEFAULT_SLOT(FArguments, Content) | 위젯의 기본 콘텐츠 슬롯을 정의 | . | SLATE_NAMED_SLOT | 명명된 슬롯 정의 | SLATE_NAMED_SLOT(FArguments, Header) | 특정 이름을 가진 슬롯을 정의 | . | SLATE_SUPPORTS_SLOT | 슬롯 타입 지원 선언 | SLATE_SUPPORTS_SLOT(SVerticalBox::FSlot) | 위젯이 지원하는 슬롯 타입 선언 | . | SLATE_USER_ARGS | 사용자 정의 인자 구조체 | SLATE_USER_ARGS() | 사용자 정의 인자 구조체 정의 시 사용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#매크로-정리"
  },"932": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 초기화 설정하기",
    "content": "Slate 위젯은 생성자(constructor) 대신 Construct() 함수를 통해 실질적인 초기화를 수행한다 . | 엔진에서 위젯 인스턴스를 만든 뒤 곧바로 Construct를 호출하여 속성(Arguments)과 함께 위젯의 동작을 설정함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-초기화-설정하기"
  },"933": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "코드 예시",
    "content": "void SYourWidget::Construct(const FArguments&amp; InArgs) { // 1. 포커스 관련 설정 bCanSupportFocus = true; // 또는 false (위젯 용도에 따라) // 2. 마우스 이벤트 처리 설정 SetCanTick(true); // 틱 활성화 (애니메이션 등 필요시) bAcceptsInput = true; // 마우스/터치 입력 허용 // 3. 시각적 상태 설정 SetVisibility(EVisibility::Visible); // 기본 가시성 설정 // 4. 콘텐츠 구성 (가장 중요한 부분) ChildSlot [ // 위젯 계층 구조 정의 SNew(SBorder) .Padding(FMargin(5)) [ SNew(STextBlock) .Text(LOCTEXT(\"DefaultText\", \"Hello Slate!\")) ] ]; // 5. 인자에서 전달받은 값 적용 if (InArgs._SomeArgument.IsSet()) { // 인자 처리 로직 } } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#코드-예시"
  },"934": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "초기화 설정 정리",
    "content": "| 설정 | 설명 | 기본값 | 사용 예시 | . | bCanSupportFocus | 위젯이 키보드 포커스를 받을 수 있는지 설정 | false | bCanSupportFocus = true; | . | bAcceptsInput | 마우스/터치 입력 허용 여부 | false | bAcceptsInput = true; | . | SetVisibility() | 위젯의 가시성 설정 (Visible, Collapsed, Hidden, HitTestInvisible, SelfHitTestInvisible) | EVisibility::Visible | SetVisibility(EVisibility::Visible); | . | SetCanTick() | 위젯이 Tick 이벤트를 받을지 설정 (애니메이션, 실시간 업데이트 시 필요) | false | SetCanTick(true); | . | SetClipping() | 콘텐츠 클리핑 방식 (OnDemand, ClipToBounds, ClipToBoundsWithoutIntersecting, ClipToBoundsAlways) | EWidgetClipping::Inherit | SetClipping(EWidgetClipping::ClipToBounds); | . | SetCursor() | 마우스 오버 시 커서 모양 (Default, Hand, TextEdit, Crosshairs 등) | EMouseCursor::Default | SetCursor(EMouseCursor::Hand); | . | SetEnabled() | 위젯의 활성화/비활성화 상태 | true | SetEnabled(TAttribute(this, &amp;SMyWidget::IsEnabled)); | . | SetToolTipText() | 툴팁 텍스트 설정 | FText::GetEmpty() | SetToolTipText(LOCTEXT(“Tooltip”, “Click me!”)); | . | SetHAlign() / SetVAlign() | 수평/수직 정렬 (HAlign_Fill, VAlign_Center 등) | HAlign_Fill, VAlign_Fill | SetHAlign(HAlign_Center); | . | SetPadding() | 안쪽 여백 설정 | FMargin(0) | SetPadding(FMargin(5.0f)); | . | SetRenderTransform() | 변환 행렬 적용 (위치, 회전, 스케일) | FSlateRenderTransform() | SetRenderTransform(FSlateRenderTransform(FVector2D(10, 10))); | . | SetRenderOpacity() | 투명도 설정 (0.0 ~ 1.0) | 1.0f | SetRenderOpacity(0.5f); | . | SetForegroundColor() | 전경색 (텍스트, 아이콘 등) | FSlateColor::UseForeground() | SetForegroundColor(FLinearColor::White); | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#초기화-설정-정리"
  },"935": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "커스텀 위젯 플로우 요약",
    "content": ". | 사용자 정의 Slate 위젯 클래스 구현 | 에디터 확장 코드에서 커스텀 Slate 위젯 인스턴스 생성 . | (예: 커스텀 패널, 탭, 도킹 윈도우 등에서 SNew(SMyWidget) 사용) | . | Slate 위젯 트리(Widget Tree)에 삽입 . | 에디터 패널/탭/도킹 윈도우 등의 컨테이너가 커스텀 Slate 위젯의 부모가 됨 | . | Slate Application이 매 프레임마다 Tick &amp; Render 호출 . | Slate 렌더링 파이프라인에 따라 모든 위젯을 탐색하며 그리기 | DirectX/OpenGL/Vulkan 등 RHI 기반 드로우콜로 변환 | . | 사용자 입력/이벤트 처리 및 갱신 . | Slate Application이 마우스/키보드/포커스 등 이벤트 분배 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#커스텀-위젯-플로우-요약"
  },"936": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "Spawn A Coustom Editor Tab",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html"
  },"937": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html"
  },"938": {
    "doc": "String",
    "title": "FString",
    "content": "FString은 일반적인 문자열 데이터로 문자열 검색, 수정, 비교를 할 수 있다. | 데이터 구조 . | 메모리 상에 각 인스턴스마다 고유 문자 배열을 직접 저장 | 내부적으로 TArray&lt;TCHAR&gt; (=동적 배열 기반 유니코드 문자열) | C++의 std::wstring(wide string)과 비슷하지만, 언리얼 엔진 특화 기능(TCHAR, UTF-16, 매크로 등)이 있다 | . | 대표적 사용 예 . | 파일 경로, 로그 메시지 | 유저 입력 (채팅, 이름 등) | 임시 데이터 처리, 문자열 연산 | . | 특징 . | 수정 가능 | 문자열 조작이 자유로움 | 각 인스턴스가 자체 메모리 공간 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring"
  },"939": {
    "doc": "String",
    "title": "FName",
    "content": "FString과 다르게 문자열 전체 저장 X. 글로벌 네임 테이블에 저장되어 데이터를 경량화 . | 데이터 구조 . | 엔진 시작 시부터 종료까지 고유 문자열을 전역적으로 관리하는 글로벌 네임 테이블 사용 . | 실제 문자열 데이터는 네임 테이블에 한번만 등록됨 | . | 어떤 FName이 새로 생성될 때, 문자열이 이미 테이블에 있으면 기존 인덱스를 사용하고, 없으면 새로 추가함 | . | 문자열의 중복 저장을 막고, 모든 FName이 같은 문자열이면 동일한 인덱스를 공유한다 | . | 대표적인 사용 예 . | 오브젝트 식별에 주로 사용 | 변수명, 파라미터 이름 | 리소스/에셋 이름 | GameplayTags | . | 특징 . | 수정 불가 | 비교 검색이 매우 빠름 . | 문자열끼리 직접 비교하는 대신, 인덱스만 비교하면 되기 때문에 성능이 우수하다 | . | 대소문자 구분이 없다 | 가비지 컬렉션 대상이 아니다 (엔진이 꺼질 때 까지 유지) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname"
  },"940": {
    "doc": "String",
    "title": "FText",
    "content": "사용자에게 보여지는 텍스트에 주로 사용된다. 다국어 번역이 필요한 경우 사용. FText는 외부 API에서 받은 플레이어 이름 등을 UI에 표시할 때처럼, 현지화 테이블 미등록 텍스트 문자열에도 쓰인다. | 데이터 구조 | . 최상위 . | ITextData(인터페이스)의 TSharedRef 스마트 포인터만을 소유 | 실질적 데이터는 FTextData에 들어있다. class FText { private: TSharedRef&lt;ITextData, ESPMode::ThreadSafe&gt; TextData; ... }; . | . FTextData 구조체 . struct FTextData : ITextData { FString SourceString; // 원본 문자열 FCulturePtr TextCulture; // 해당 텍스트의 문화권(언어) 정보 FTextHistory TextHistory; // 텍스트 생성/변환 이력 (핵심!) ... }; . 현지화 히스토리 . | 다양한 하위 클래스를 통해 데이터 관리 가능 . | FTextHistory_LocalizedString : 현지화 키, 원본 텍스트, 로컬라이제이션 리소스 정보 등 저장 | FTextHistory_FormattedNumber : 숫자 포맷, 소수점, 지역화 등 정보 | FTextHistory_FormatString : 포맷 패턴, 인자 배열 등 | . | . class FTextHistory_LocalizedString : public FTextHistory_Base { FString SourceString; // 원본 텍스트 FString Namespace; // 현지화 네임스페이스 FString Key; // 현지화 키 FString LocalizedString; // 번역된 문자열(캐싱) ... }; . FText 구조 정리 . FText └─ TextData (FTextData) ├─ SourceString (원본) ├─ TextCulture (문화권) └─ TextHistory (생성/포맷/현지화 이력) ├─ 현지화키 ├─ 네임스페이스 ├─ 포맷정보 └─ 캐시된 번역값 등... | 대표적인 사용 예 . | UI 버튼/ 메뉴 텍스트 (시작, Continue 등) | 게임 대사, 퀘스트 설명, 튜토리얼 메시지 | 점수, 날짜, 숫자 등 표시 | 모든 다국어 지원 필요한 표시용 텍스트 | . | 특징 . | 현지화, 포맷, 문화권별 번역 자동 처리 | 직접 수정 불가. 변환 후 새로 만들어야 함 | 직접 비교/조작은 제한됨 . | FText끼리 == 연산은 데이터 주소 또는 히스토리 비교이므로, 실제 표시 문자열이 같아도 false가 나올 수 있음 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext"
  },"941": {
    "doc": "String",
    "title": "정리",
    "content": "| 클래스 | 사용 목적 | 데이터 구조 | 특징 | . | FString | 임의 문자열, 수정/검색/연결 | TArray(인스턴스별 동적 배열) | 수정 가능, 조작 자유 | . | FText | 현지화/번역 표시 텍스트 | TSharedRef + FTextHistory | 현지화 지원, 수정 어려움, 포맷/언어 처리 | . | FName | 식별자/키/이름/빠른비교 | 글로벌 해시 테이블 인덱스+번호 | 비교 빠름, 대소문자 무시, 수정 불가 | . 참고 링크 . | String Handling | Why you should be using GameplayTags in Unreal Engine | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#정리"
  },"942": {
    "doc": "Subsystem",
    "title": "Subsystem",
    "content": "서브시스템은 코어 시스템 위에 추가되는 확장 레이어 (개발자가 선택적으로 구현) . 서브시스템 모듈을 통해 체계적인 게임 시스템을 커스텀하여 구축할 수 있음 (플러그인) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html"
  },"943": {
    "doc": "Subsystem",
    "title": "코어 시스템 vs 서브 시스템",
    "content": "| 특징 | 코어 시스템 (Core) | 서브시스템 (Subsystem) | . | 생성 주체 | 엔진 자동 생성 | 코어 시스템에 의해 생성 | . | 생명 주기 | 게임 실행부터 종료까지 유지 | 부모 시스템(게임/월드/플레이어)과 동기화 | . | 오버라이드 | 엔진 소스 수정 필요 (드문 경우) | 상속받아 자유롭게 확장 가능 | . | 예시 | UWorld, APlayerController | UMySaveSystem, UDialogueManager | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%BD%94%EC%96%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C-vs-%EC%84%9C%EB%B8%8C-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#코어-시스템-vs-서브-시스템"
  },"944": {
    "doc": "Subsystem",
    "title": "종류",
    "content": "| Subsystem 유형 | 주요 사용 예시 | . | UEngineSubsystem | 게임 메커니즘, 물리 시뮬레이션, 렌더링 프로세스 등 엔진의 수명 주기와 관련된 로직 및 시스템 | . | UGameInstanceSubsystem | 플레이어 진행 상황, 저장 데이터, 옵션 등 전체 게임 세션과 관련된 데이터를 저장하고 관리 | . | ULocalPlayerSubsystem | 로컬 플레이어의 입력, UI, 카메라, 사운드 등을 처리 | . | UWorldSubsystem | 환경 효과, 레벨 스트리밍, AI 생성 등 특정 레벨에 특화된 논리와 시스템을 구현 | . | UEditorSubsystem | 커스텀 에디터 툴, 에셋 관리 확장 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#종류"
  },"945": {
    "doc": "Subsystem",
    "title": "생명 주기",
    "content": "Subsystem이 속한 코어 모듈(Engine, GameInstance, World, LocalPlayer 등)의 생명주기에 종속됨 . Subsystem은 런타임 중 필요 시점에 자동으로 인스턴스화되며, 명시적으로 생성/삭제하지 않는다 . | Engine Subsystem (UEngineSubsystem) . | 시작: 엔진 초기화 시 생성 (UGameEngine/UEditorEngine 시작 시) | 종료: 엔진 종료 시 소멸 (에디터/게임 종료 시) | . | GameInstance Subsystem (UGameInstanceSubsystem) . | 시작: UGameInstance 생성 시 (게임 실행 시) | 종료: UGameInstance 소멸 시 (레벨 이동 없이 게임 종료 시) | . | World Subsystem (UWorldSubsystem) . | 시작: UWorld 생성 시 (레벨 로드 시) | 종료: UWorld 소멸 시 (레벨 언로드 시) | . | LocalPlayer Subsystem (ULocalPlayerSubsystem) . | 시작: ULocalPlayer 생성 시 (플레이어 로그인 시) | 종료: ULocalPlayer 소멸 시 (플레이어 로그아웃 시) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#생명-주기"
  },"946": {
    "doc": "Subsystem",
    "title": "나중에 쓰게되면 서브시스템 클래스 만드는 법 추가하기",
    "content": ". 참고 링크 . | doc - Programming Subsystems | What are subsystems? | subsystem-singleton | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EB%82%98%EC%A4%91%EC%97%90-%EC%93%B0%EA%B2%8C%EB%90%98%EB%A9%B4-%EC%84%9C%EB%B8%8C%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B2%95-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#나중에-쓰게되면-서브시스템-클래스-만드는-법-추가하기"
  },"947": {
    "doc": "Transform",
    "title": "Transform",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html"
  },"948": {
    "doc": "Transform",
    "title": "FVector",
    "content": "3차원 공간상의 위치, 방향, 속도, 크기 등 벡터 값을 표현할 때 사용 . | 오브젝트의 위치 (Location) : SetActorLocation(FVector(100.f, 200.f, 300.f)); | 이동 방향 및 속도 (Velocity, Direction) : FVector Direction = Target - Source; | 스케일(Scale) 값 (상대적 크기) | 힘(Force), 가속도(Acceleration) 등 물리 연산 | 충돌 처리에서 법선 벡터(Normal) 표현 | . | 데이터 구조 struct FVector { float X; float Y; float Z; }; . | 오른손 법칙 좌표계 : Z-위, X-앞, Y-오른쪽 | . | 특징 . | 기본적인 연산자 오버로딩 지원 (+, -, *, /, dot, cross 등) | 크기, 정규화, 내적(dot), 외적(cross) 등 벡터 연산 지원 | 단순 위치/방향뿐 아니라, 각종 수학적, 물리적 벡터 표현에 모두 사용 | 방향성과 크기를 함께 가짐 (예: 방향 벡터는 크기=1로 정규화) | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Size() | 없음 | float | 벡터의 크기를 반환합니다. | . | Normalize() | 없음 | 없음 | 벡터를 정규화합니다. | . | Dot() | const FVector&amp; Other | float | 두 벡터의 내적 | . | Cross() | const FVector&amp; Other | FVector | 두 벡터의 외적 | . | Rotation() | 없음 | FRotator | 벡터의 방향을 회전 값으로 반환 | . | Lerp() | const FVector&amp; A const FVector&amp; B float Alpha | FVector | 두 벡터 간의 선형 보간 | . | Size() / SizeSquared() |   | 벡터의 크기 또는 크기의 제곱을 반환 |   | . 배경 수학 . 벡터 연산(덧셈, 뺄셈, 스칼라 곱/나눗셈, 내적/외적 등)은 선형대수의 기본 연산. 내적(Dot Product): 두 벡터의 방향성이 얼마나 일치하는지 계산 → 코사인 법칙과 연관되어 각도 구하기, 투영, 정규화, 평면 법선 등 계산에 사용 . A·B = Ax * Bx + Ay * By + Az * Bz . 외적(Cross Product): 두 벡터에 수직인 벡터 산출 → 평면의 법선, 회전축 등 계산 . A×B = (Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx) . 정규화(Normalization) → 크기를 1로 맞춤 . V.Normalize() → V / |V| . 거리/길이 . V.Size() = sqrt(X^2 + Y^2 + Z^2) . 선형보간(LERP) . Lerp(A, B, Alpha) = (1-Alpha)*A + Alpha*B . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector"
  },"949": {
    "doc": "Transform",
    "title": "FRotator",
    "content": "오일러 각(Euler Angle)(Pitch, Yaw, Roll)로 3D 회전을 표현할 때 사용 . | 오브젝트 회전 : SetActorRotation(FRotator(0.f, 90.f, 0.f)); | 캐릭터, 카메라의 방향(회전) | Actor/Component의 회전값 저장 : GetActorRotation() | 블루프린트, 에디터의 회전값 입력 등 | . | 데이터 구조 struct FRotator { float Pitch; // X축 회전 (상하) float Yaw; // Z축 회전 (좌우) float Roll; // Y축 회전 (틸트) }; . | 세 개의 float값(Pitch, Yaw, Roll)로 오일러 각 표현 | . | 특징 . | 오일러 각 특성상 Gimbal Lock(짐벌락) 문제 발생 가능 | 사람에게 직관적으로 이해하기 쉬움 (디자이너, 에디터에서 많이 사용) | 내부적으로는 보통 Degree(각도) 단위 사용 (Radian 변환 필요시 지원) | FRotator는 내부적으로 회전 행렬 혹은 쿼터니언으로 변환 가능 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Quaternion() | 없음 | FQuat | 오일러 각을 쿼터니언으로 변환 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | UnrotateVector() | const FVector&amp; V | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | GetNormalized() | 없음 | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | Clamp() | 없음 | FRotator | 회전 값을 제한 | . 배경 수학 . | 오일러 각(Euler Angle) : 세 축(X, Y, Z)에 대한 회전 각도(θx, θy, θz)로 회전을 표현. | 언리얼 엔진은 Z(Yaw) → Y(Pitch) → X(Roll) 순서로 회전 (즉, “Yaw → Pitch → Roll” 오더) | . 행렬 변환: 오일러 각은 각각의 축 회전을 행렬로 변환 후 곱셈해서 최종 회전값을 만듦 . R = Rz(Yaw) * Ry(Pitch) * Rx(Roll) . Gimbal Lock: 두 축이 일치하여 3차원 회전 자유도가 2차원으로 줄어드는 현상 . | 예: Pitch가 ±90°에 가까워지면, Roll과 Yaw가 같은 평면이 됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator"
  },"950": {
    "doc": "Transform",
    "title": "FQuat",
    "content": "3D 공간에서 회전을 쿼터니언(Quaternion)으로 표현하여, 회전 연산의 정확성 및 안정성 확보 . | 모션 블렌딩, 본(스켈레톤) 등 애니메이션의 회전 보간 | 부드러운 연속 회전 (SLERP) | Gimbal Lock 방지가 중요한 복잡한 회전 연산 | . | 데이터 구조 struct FQuat { float X; // 허수 (벡터) float Y; // 허수 (벡터) float Z; // 허수 (벡터) float W; // 실수 (스칼라) 부분 }; . | 4개의 float형 멤버(X, Y, Z, W)로 구성 | 단위 쿼터니언(norm = 1) 으로 회전 표현 | . | 특징 . | 4차원 복소수로 회전 표현 | Gimbal Lock 문제 없음 | 회전 합성/보간에 최적화 (SLERP, NLERP 등 지원) | FRotator, FMatrix 등과 상호 변환 함수 제공 | 보통은 FRotator(에디터/코드) ↔ FQuat(엔진 내부)로 변환하며 사용 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | Inverse() | 없음 | FQuat | 쿼터니언의 역을 반환 | . | Slerp() | const FQuat&amp; A const FQuat&amp; B float Alpha | FQuat | 두 쿼터니언 간의 구면 선형 보간을 수행 | . | ToAxisAndAngle() | FVector&amp; Axis float&amp; Angle | 없음 (출력 매개변수 사용) | 회전 축과 각도로 변환 | . | MakeFromEuler() | const FVector&amp; Euler | FQuat | 오일러 각도로부터 쿼터니언을 생성 | . 배경 수학 . | 쿼터니언(Quaternion): 실수부(w)와 허수부(x, y, z)로 구성된 4차원 수학 구조 Q = w + xi + yj + zk (i, j, k는 허수 단위벡터) . | 회전 표현: 3D 공간에서 임의의 축(axis)과 각도(θ)에 대한 회전 Q = [cos(θ/2), (axis * sin(θ/2))] . | 복합 회전: 쿼터니언 곱셈으로 연속 회전 표현 Q' = Q2 * Q1 (Q1 후 Q2 수행) . | 회전 적용: 점 P를 Q로 회전시키려면 P' = Q * P * Q⁻¹ (여기서 P는 벡터를 허수부로 취급한 쿼터니언) . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat"
  },"951": {
    "doc": "Transform",
    "title": "FTransform",
    "content": "위치, 회전, 스케일을 함께 관리하여 오브젝트의 변환을 효율적으로 처리 . | 오브젝트의 전체 변환 설정: SetActorTransform(FTransform(Rotation, Translation, Scale)); | . | 데이터 구조 struct FTransform { FQuat Rotation; FVector Translation; FVector Scale3D; }; . | 특징 . | 위치, 회전, 스케일을 하나의 구조체로 관리 | 계층적 트랜스폼 계산에 유용 | 블루프린트에서 쉽게 사용할 수 있도록 지원 | . | 주요 메서드 | . 많아서 나중에 정리할랭 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform"
  },"952": {
    "doc": "Transform",
    "title": "정리",
    "content": "| 타입 | 목적/용도 | 데이터 구조 | 특징 요약 | . | FVector | 3D 위치, 방향, 벡터 | X, Y, Z (float) | 모든 위치/방향/벡터 연산에 사용 | . | FRotator | 오일러 각 기반 3D 회전 | Pitch, Yaw, Roll (float) | 직관적, Gimbal Lock 위험 | . | FQuat | 쿼터니언 기반 3D 회전 | X, Y, Z, W (float) | Gimbal Lock 없음, 고급 회전 | . | FTransform | 위치, 회전, 스케일 통합 변환 | 위치, 회전, 스케일 구조체 | Actor 변환, 부모-자식 변환 관리 | . 참고 링크 . | UE4 Transform Calculus | Vectors | Roll, Pitch, Yaw | Quaternion | Gimbal lock | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#정리"
  },"953": {
    "doc": "UPlayer",
    "title": "UPlayer",
    "content": "플레이어 표현의 최상위 추상 클래스로, 플레이어와 게임 세계 간의 상호작용을 관리하는 기본 프레임워크를 제공 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html"
  },"954": {
    "doc": "UPlayer",
    "title": "특징",
    "content": ". | UObject를 상속받는 언리얼 엔진의 코어 클래스 | 순수 가상 함수를 포함한 추상 클래스 | 플레이어로서의 식별 정보, 네트워크 연결, 컨트롤러 정보를 추상적으로 제공 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#특징"
  },"955": {
    "doc": "UPlayer",
    "title": "ULocalPlayer",
    "content": "UPlayer를 상속받아 실제 로컬 머신에서 실행되는 플레이어를 표현하는 클래스 . | 상속 : UObject → UPlayer → ULocalPlayer | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#ulocalplayer",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#ulocalplayer"
  },"956": {
    "doc": "UPlayer",
    "title": "특징",
    "content": ". | 스플릿 스크린 및 다중 뷰포트 지원 | 로컬 플레이어(키보드/마우스/게임패드 직접 입력을 받는 플레이어) 전용 구현 | 컨트롤러 입력과 뷰포트 렌더링 간의 연결 관리 (ViewPort 및 PlayerController와 연동) | 각 플레이어별로 LocalPlayerSubsystem 생성 및 입력, UI, HUD 등의 독립적 관리 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#특징-1"
  },"957": {
    "doc": "UPlayer",
    "title": "역할",
    "content": ". | 로컬 입력 장치와의 연결 관리 (PlayerController 연결) | 입력 관리 (키보드, 마우스, 게임패드 등 각 플레이어별로 입력 독립 처리) | UI, HUD 시스템과 상호작용 및 개별화 | Player Profile 설정 관리 | 로컬 세이브 데이터 관리 | . 참고하면 좋은 링크 . | doc - ULocalPlayer | Unreal Engine 4 Gameplay Framework Overview | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#역할"
  },"958": {
    "doc": "3. Slate Widget",
    "title": "목표 : 에디터 확장을 더 깊게 다루기 위해 슬레이트(Slate) 코드를 직접 작성해보자",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EB%AA%A9%ED%91%9C--%EC%97%90%EB%94%94%ED%84%B0-%ED%99%95%EC%9E%A5%EC%9D%84-%EB%8D%94-%EA%B9%8A%EA%B2%8C-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8slate-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%9E%91%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#목표--에디터-확장을-더-깊게-다루기-위해-슬레이트slate-코드를-직접-작성해보자"
  },"959": {
    "doc": "3. Slate Widget",
    "title": "슬레이트가 어렵게 느껴지는 이유",
    "content": ". | 슬레이트 코드는 고유의 문법을 가지고 있다 . | 일반적인 C++ 코드와 매우 다르다 | . | 시각화가 어렵다 . | 위젯 레이아웃을 전부 코드로만 해야 한다는 것이 문제 | 변경한 내용을 바로바로 미리보기로 확인할 수 없다 | . | 다른 모듈과의 연동 . | 다른 모듈과 데이터를 주고받고 상호작용하는 것이 바로 연동(communication)이다 | 이 부분이 슬레이트 위젯을 구현할 때 가장 어렵고 중요하다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8%EA%B0%80-%EC%96%B4%EB%A0%B5%EA%B2%8C-%EB%8A%90%EA%BB%B4%EC%A7%80%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#슬레이트가-어렵게-느껴지는-이유"
  },"960": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터",
    "content": "모듈 간의 데이터 전달 문제(communication issue)를 해결하기 위해서는 반드시 이해해야 할 중요한 개념 . 언리얼 엔진에서는 new 키워드를 직접 써서 객체를 만들도록 허용하지 않는다 . | new 키워드로 메모리를 할당할 일이 있다면, 반드시 스마트 포인터와 함께 쓴다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터"
  },"961": {
    "doc": "3. Slate Widget",
    "title": "UE에서 지원하는 스마트 포인터",
    "content": ". | Shared Pointer (TSharedPtr) | Shared Reference (TSharedRef) | Weak Pointer (TWeakPtr) | Unique Pointer (TUniquePtr) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#ue%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#ue에서-지원하는-스마트-포인터"
  },"962": {
    "doc": "3. Slate Widget",
    "title": "TSharedPtr (Shared Pointer, 공유 포인터)",
    "content": ". | 소유권(Owning) 보유: Shared Pointer는 해당 객체의 소유권을 갖는다 이 포인터가 존재하는 한 객체는 삭제되지 않음 . | 참조 카운팅(reference counting) 방식: 이 객체를 참조하는 Shared Pointer/Reference가 모두 사라지면 자동으로 삭제 . | null 할당 가능: 아직 가리키는 대상이 없어도 선언만 할 수 있다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Get() | 포인터가 가리키는 객체의 raw 포인터 반환 | T* | . | IsValid() | 포인터가 유효한 객체를 가리키는지 확인 | bool | . | Reset() | 포인터가 가리키는 객체 해제 | void | . | Pin() | TWeakPtr에서 TSharedPtr로 변환 (유효한 경우) | TSharedPtr&lt;T&gt; | . | ToSharedRef() | TSharedPtr을 TSharedRef로 변환 | TSharedRef&lt;T&gt; | . | GetSharedReferenceCount() | 참조 카운트 반환 | int32 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedptr-shared-pointer-%EA%B3%B5%EC%9C%A0-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedptr-shared-pointer-공유-포인터"
  },"963": {
    "doc": "3. Slate Widget",
    "title": "TSharedRef (Shared Reference, 공유 참조)",
    "content": "Shared Pointer와 거의 동일하지만 항상 유효한 객체만 가리킬 수 있다 . | null 할당 불가능: 항상 유효한 인스턴스가 존재해야 하므로, 슬레이트 함수 반환값 등에서 주로 사용 . | 따라서 Shared Reference는 언제나 Shared Pointer로 변환할 수 있다 . | 유효한 Shared Pointer는 언제나 Shared Reference로 변환이 가능하다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Get() | 포인터가 가리키는 객체의 raw 포인터 반환 | T* | . | IsValid() | 항상 true 반환 (TSharedRef는 null이 될 수 없음) | bool (항상 true) | . | ToSharedPtr() | TSharedRef를 TSharedPtr로 변환 | TSharedPtr&lt;T&gt; | . | GetSharedReferenceCount() | 참조 카운트 반환 | int32 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedref-shared-reference-%EA%B3%B5%EC%9C%A0-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedref-shared-reference-공유-참조"
  },"964": {
    "doc": "3. Slate Widget",
    "title": "TWeakPtr (Weak Pointer, 약한 참조)",
    "content": ". | 소유권을 갖지 않음: Weak Pointer는 객체의 소유권이 없음 객체가 삭제되는 것을 막지 않는다 . | “참조 순환(Reference Cycle)” 문제를 해결할 때 매우 유용하다 즉, 객체가 살아있을 때만 약하게 참조하고, 객체가 삭제되면 자동으로 무효(null)가 된다 . | 사용할 때마다 “이 객체가 아직 살아 있나요?”라고 먼저 체크해야 하며, 살아있으면 사용할 수 있다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Pin() | 유효한 경우 TSharedPtr로 변환, 아니면 null | TSharedPtr&lt;T&gt; | . | IsValid() | 가리키는 객체가 아직 유효한지 확인 | bool | . | Expired() | 가리키는 객체가 더 이상 유효하지 않은지 확인 | bool | . ❓게임 개발에서는 잘 안 보이는 이유? . | 스마트 포인터들은 UObject 기반 오브젝트에서는 쓸 수 없다 | UObject 시스템 자체가 고유한 메모리 관리(가비지 컬렉션)를 사용하기 때문 | Object 포인터를 직접 스마트 포인터로 관리하면 엔진의 GC 시스템과 충돌이 생김 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tweakptr-weak-pointer-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tweakptr-weak-pointer-약한-참조"
  },"965": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터 생성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터-생성"
  },"966": {
    "doc": "3. Slate Widget",
    "title": "MakeShareable",
    "content": ". | 작동 방식: 이미 힙에 할당된 객체(raw pointer)를 스마트 포인터로 감쌈 | 효율성: 객체 생성과 참조 카운트 관리를 분리해서 처리하므로 메모리 할당이 2번 발생 . | 이미 존재하는 객체를 감싸는 유일한 방법일 때 유용 | . | 제한 사항: 객체가 public 생성자를 가져야 함 (private/protected 생성자 불가) . | 객체가 이미 생성되어 있어야 함 | . | . // MakeShareable 예제 class MyClass { public: MyClass() {} }; // public 생성자 필요 TSharedPtr&lt;MyClass&gt; Ptr = MakeShareable(new MyClass()); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshareable",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshareable"
  },"967": {
    "doc": "3. Slate Widget",
    "title": "MakeShared",
    "content": ". | 작동 방식: 객체와 참조 카운트 컨트롤 블록을 한 번에 할당 | 효율성: 단일 메모리 할당으로 객체와 컨트롤 블록을 함께 할당하므로 일반적으로 더 나은 캐시 지역성 . | 하지만 UE 구현상의 이유로 실제로는 MakeShareable보다 약간 느릴 수 있음 | . | 장점: private/protected 생성자도 사용 가능 (Friend 선언으로 접근 가능) . | 더 현대적인 C++ 스타일 | . | . // MakeShared 예제 class MyClass { friend TSharedFromThis&lt;MyClass&gt;; MyClass() {} }; // private 생성자 가능 TSharedPtr&lt;MyClass&gt; Ptr = MakeShared&lt;MyClass&gt;(); . | 함수 | 설명 | 반환 타입 | . | MakeShared&lt;T&gt;(Args...) | 새로운 객체를 생성하고 TSharedRef 반환 | TSharedRef&lt;T&gt; | . | MakeShareable(new T) | 기존 객체를 스마트 포인터로 감싸기 | TSharedPtr&lt;T&gt; | . | StaticCastSharedPtr&lt;NewType&gt;() | 타입 안전한 static 캐스트 | TSharedPtr&lt;NewType&gt; | . | ConstCastSharedPtr&lt;NewType&gt;() | const 캐스트 | TSharedPtr&lt;NewType&gt; | . 슬레이트 위젯을 만들 때 자주 사용됨 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshared",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshared"
  },"968": {
    "doc": "3. Slate Widget",
    "title": "커스텀 Slate 레이아웃 구현 과정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%BB%A4%EC%8A%A4%ED%85%80-slate-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EA%B5%AC%ED%98%84-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#커스텀-slate-레이아웃-구현-과정"
  },"969": {
    "doc": "3. Slate Widget",
    "title": "1. Slate 위젯 클래스 정의",
    "content": ". | 대부분의 커스텀 슬레이트 위젯은 SCompoundWidget을 상속 | . #pragma once #include \"Widgets/SCompoundWidget.h\" class SMyCustomLayout : public SCompoundWidget {}; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-위젯-클래스-정의"
  },"970": {
    "doc": "3. Slate Widget",
    "title": "2. Slate 속성 매크로(Arguments) 활용",
    "content": "| 매크로 | 역할 | 예시 | . | SLATE_ARGUMENT | “불변 값” 1회성 복사(생성자 인자) | SLATE_ARGUMENT(FText, Title) | . | SLATE_ATTRIBUTE | “동적 값”(TAttribute 바인딩) | SLATE_ATTRIBUTE(int32, Count) | . | SLATE_EVENT | “이벤트/Delegate” (콜백 함수) | SLATE_EVENT(FOnClicked, OnButtonClicked) | . | SLATE_ARGUMENT: 위젯의 생성자(Construct)에 전달될 “불변 값” 인자 | SLATE_ATTRIBUTE: 바인딩 가능한 동적 값(속성) . | TAttribute로 선언되어 외부의 값을 실시간으로 바꿀 수 있음 | . | SLATE_EVENT: Slate Delegate/이벤트(함수, 람다 등 콜백) | . // CustomButtonPanel.h class SCustomButtonPanel : public SCompoundWidget { public: SLATE_BEGIN_ARGS(SCustomButtonPanel) {} // 슬레이트 속성 정의 SLATE_ARGUMENT(FText, Title) SLATE_ARGUMENT(TArray&lt;FText&gt;, ButtonLabels) SLATE_EVENT(FOnInt32Selected, OnButtonSelected) SLATE_END_ARGS() void Construct(const FArguments&amp; InArgs); private: // 위젯 상태 변수 TArray&lt;FText&gt; ButtonLabels; FOnInt32Selected OnButtonSelected; }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-%EC%86%8D%EC%84%B1-%EB%A7%A4%ED%81%AC%EB%A1%9Carguments-%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-속성-매크로arguments-활용"
  },"971": {
    "doc": "3. Slate Widget",
    "title": "3. Construct 함수 구현",
    "content": ". | ChildSlot을 이용해 Slate 레이아웃 선언 | ChildSlot(컨테이너의 루트)에 원하는 레이아웃 위젯(예: SVerticalBox, SHorizontalBox 등)으로 하위 위젯을 배치 | . void SMyCustomLayout::Construct(const FArguments&amp; InArgs) { Title = InArgs._Title; ChildSlot [ SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ SNew(STextBlock).Text(FText::FromString(Title)) ] + SVerticalBox::Slot() .FillHeight(1.0f) [ SNew(SButton) .Text(NSLOCTEXT(\"MyCustomLayout\", \"Button\", \"Click Me\")) // .OnClicked(....) ] ]; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-함수-구현"
  },"972": {
    "doc": "3. Slate Widget",
    "title": "4. Slate 스타일 및 Theme 적용",
    "content": ". | FSlateStyleSet을 사용해 스타일 정의 | FSlateBrush로 브러시 설정 | FSlateFontInfo로 폰트 설정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%8F-theme-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-스타일-및-theme-적용"
  },"973": {
    "doc": "3. Slate Widget",
    "title": "5. 이벤트 처리",
    "content": ". | 마우스/키보드 이벤트 바인딩 | 델리게이트를 사용한 커스텀 이벤트 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-이벤트-처리"
  },"974": {
    "doc": "3. Slate Widget",
    "title": "언리얼 에디터 슬레이트 계층 구조",
    "content": ". | 루트 레벨 (FSlateApplication) . | 모든 슬레이트 위젯의 최상위 관리자 . | 입력 이벤트, 렌더링 순서, 포커스 관리 | SMainFrame과 독립적인 팝업 창(SWindow_Standalone)을 자식으로 가짐 | . | . | 메인 프레임 (SMainFrame) . | 에디터 메인 창 (가장 바깥 윈도우) . | 상속 구조: SWindow → SMainFrame | . | . | 도킹 시스템 (SDockingArea) . | 탭/분할 레이아웃을 관리하는 컨테이너 | 여러 SDockTabStack(탭 묶음)을 포함하는 도킹 가능 영역 . | SSplitter : 수직/수평 영역 분할 | SDockTabStack : 탭 그룹 (ex. 왼쪽/가운데/오른쪽 스택) | SDockTab : 사용되는 실제 개별 패널 (ex. 콘텐츠 브라우저, 디테일 패널) | . | . | 탭 컨텐츠 (SDockTab → SCompoundWidget) . | 각 탭의 실제 UI 구현체 . | 커스텀 위젯은 반드시 SCompoundWidget을 상속받아 구현 | . | . | 기본 위젯 (Leaf Nodes) . | 최하위에 위치하는 실제 UI 요소 . | SextBlock, SButton, SImage 등 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%90%EB%94%94%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#언리얼-에디터-슬레이트-계층-구조"
  },"975": {
    "doc": "3. Slate Widget",
    "title": "3. Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/"
  },"976": {
    "doc": "Coding Standard",
    "title": "Coding Standard",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/"
  },"977": {
    "doc": "Coding Standard",
    "title": "저작권 고지",
    "content": "배포하는 모든 소스 파일(.h, .cpp, .xaml 등)에는 파일의 첫 줄에 반드시 다음과 같은 저작권 공지가 포함되어야 한다. // Copyright Epic Games, Inc. All Rights Reserved. 해당 줄이 없거나 형식이 다르면 오류 -&gt; 빌드 실패 처리됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A0%80%EC%9E%91%EA%B6%8C-%EA%B3%A0%EC%A7%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#저작권-고지"
  },"978": {
    "doc": "Coding Standard",
    "title": "클래스 구성",
    "content": "클래스는 읽는 사람을 우선으로 구성해야 한다. 대부분 클래스를 읽는 사람들은 public 인터페이스를 사용한다. 따라서 클래스는 . | public | protected | private | . 순으로 작성한다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-구성"
  },"979": {
    "doc": "Coding Standard",
    "title": "클래스 접두사",
    "content": "언리얼 엔진의 클래스에는 접두사가 있다. 해당 접두사를 알고있으면 어떤 클래스에서 파생됐는지 알 수 있다. | 접두사 | 클래스 | 예시 | . | A | AActor | AActor, APawn, AGameMode | . | U | UObject | UTexture, UBlueprintFunctionLibrary | . | S | SWidget | SButton, Swidget | . | F | 사용자 구조체 | FVector, FHitResult | . | I | 추상 인터페이스 | IInterface | . | T | 템플릿 클래스 | TArray&lt;T&gt;, TMap&lt;&lt;T&gt; | . | E | Enum 타입 | EGAmeState | . | G | globals 전역변수 | GEngine | . | b | Boolean 변수 | bHasFadedIn, bDied | . 사용예시 . typedef TArray&lt;FMytype&gt; FArrayOfMyTypes; . typedef에는 해당 타입에 적합한 문자가 접두사로 붙어야 한다. 위 예시는 사용자 구조체 타입을 받는 템플릿 클래스다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%91%EB%91%90%EC%82%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-접두사"
  },"980": {
    "doc": "Coding Standard",
    "title": "네이밍 규칙",
    "content": ". | 단어 사이에 언더스코어(_) 를 사용하지 않는다 | 단어의 첫 글자는 대문자로 표기한다 . | 예: MouseCoordinates (o), delta_x (x) | . | 타입명에는 추가로 대문자 접두사를 붙여 변수명과 구분한다 . | 예: FSkin (타입), Skin (FSkin 타입의 인스턴스) | . | 모든 변수는 한줄씩 선언한다 | 반환값이 있는 함수는 이름만으로 반환값을 명확히 한다 . | O: bool IsTeaFresh(FTea Tea) True 의미 명확 | X: bool CheckTea(FTea Tea) 어떤걸 반환할지 의미 불명확 | . | 반환값이 없는 절차 함수는 강한 동사+목적어 형식 . | 메서드의 목적어가 자기 자신이면 (맴버 함수) 생략 가능 | Handle, Process 등 모호한 동사 피하기 | . | bool 반환 함수는 항상 Yes/No 질문 형태를 취한다 . | IsVisible(), ShouldClearBuffer() | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#네이밍-규칙"
  },"981": {
    "doc": "Coding Standard",
    "title": "Const 정확성",
    "content": ". | 함수 인자가 함수 내에서 변경되지 않는다면, const pointer 또는 const reference로 전달 | 객체를 변경하지 않는 메서드는 const로 명시 | 컨테이너를 수정하지 않는 반복문은 const 반복자 사용 | . 사용예시 . void SomeMutatingOperation(FThing&amp; OutResult, const TArray&lt;Int32&gt;&amp; InArray) { // InArray는 수정되지 않음, OutResult는 아마 수정될것임 } void FThing::SomeNonMutatingOperation() const { // 이 코드는 FThing을 변경하지 않음 } TArray&lt;FString&gt; StringArray; for (const FString&amp; : StringArray) { // 반복문 내부에서 StringArray를 수정하지 않음 } . | 반환 타입에 const 사용 금지 (컴파일 경고 발생) . | 단 const 레퍼런스, 포인터 반환은 허용 | . | . // 좋은 예시 - const 참조 반환 const TArray&lt;FString&gt;&amp; GetSomeArray(); // 좋은 예시 - const 포인터 반환 const TArray&lt;FString&gt;* GetSomeArray(); // 나쁜 예시 - const 배열 반환 const TArray&lt;FString&gt; GetSomeArray(); // 나쁜 예시 - const 포인터를 const로 반환 const TArray&lt;FString&gt;* const GetSomeArray(); . | 포인터 자체를 const로 만들 때는 타입 뒤에 const . | 포인터가 가리키는 값이 아닌, 포인터 자체의 재할당을 막음 | . | . // 포인터는 재할당 불가, T는 변경 가능 T* const Ptr = ...; // 잘못된 사용: 불가(레퍼런스는 재할당 불가 특성상 의미 없음) T&amp; const Ref = ...; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-%EC%A0%95%ED%99%95%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-정확성"
  },"982": {
    "doc": "Coding Standard",
    "title": "주석",
    "content": ". | 클래스 주석 . | 이 클래스가 해결하는 문제 | 클래스 생성 이유 | . | 함수 (메서드) 주석 . | 함수 목적 기입 | . | 매개변수 주석 @param . | 측정 단위 | 예상 값 범위 | 불가능한 값 | 상태/오류 코드 의미 | . | 반환값 주석 @return . | 예상 반환 값 | . | 추가 정보 . | @warning 경고, @See보기 등을을 선택적으로 사용함 | . | . 사용예시 . /** The interface for drinkable objects. */ class IDrinkable { public: /** * Called when a player drinks this object. * @param OutFocusMultiplier - 반환 시, 마시는 사람의 집중력에 곱할 배수를 담는다. * @param OutThirstQuenchingFraction - 반환 시, 갈증 해소 정도(0~1)를 담는다. * @warning 반드시 음료가 제대로 준비된 후 호출해야 함. */ virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) = 0; }; /** 단일 찻잔 */ class FTea : public IDrinkable { public: /** * 주어진 물의 부피와 온도로 우려냈을 때, 차의 맛 변화량을 계산 * @param VolumeOfWater - 우릴 때 사용된 물의 양(mL) * @param TemperatureOfWater - 물의 온도(Kelvin) * @param OutNewPotency - 우려낸 후 차의 효능(0.97~1.04) * @return 차의 맛 강도 변화량(1분당 TTU) */ float Steep( const float VolumeOfWater, const float TemperatureOfWater, float&amp; OutNewPotency ); /** 설탕 당도 기준으로 감미를 추가 */ void Sweeten(const float EquivalentGramsOfSucrose); /** 일본 내 판매가(엔) */ float GetPrice() const { return Price; } virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) override; private: /** 가격(엔) */ float Price; /** 감미(설탕 환산 그램) */ float Sweetness; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#주석"
  },"983": {
    "doc": "Coding Standard",
    "title": "차후 더 추가 예정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%B0%A8%ED%9B%84-%EB%8D%94-%EC%B6%94%EA%B0%80-%EC%98%88%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#차후-더-추가-예정"
  },"984": {
    "doc": "Coding Standard",
    "title": "사용가능한 표준 라이브러리 목록",
    "content": ". | &lt;atomic&gt; : 신규 코드는 std::atomic 사용. 기존 TAtomic은 부분 구현만 되어 있음. | &lt;type_traits&gt; : 겹치는 부분은 표준 trait 사용. (표준 trait는 value/type 소문자, 기존 UE는 대문자 Value/Type 주의) | &lt;initializer_list&gt; : braced initializer 지원에 필수, 대체재 없음 | &lt;regex&gt; : 직접 사용 가능하나 에디터 전용 코드에 한정. 자체 구현 계획 없음. | &lt;limits&gt; : std::numeric_limits 전부 사용 가능 | &lt;cmath&gt; : 부동소수점 비교 함수만 사용 허용 | . 참고 링크 . | Coding Standard | Recommended Asset Naming Conventions | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%91%9C%EC%A4%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AA%A9%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#사용가능한-표준-라이브러리-목록"
  },"985": {
    "doc": "1. The Actor Class",
    "title": "1. The Actor Class",
    "content": "월드에 배치되는 독립적 객체 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/"
  },"986": {
    "doc": "1. The Actor Class",
    "title": "클래스 생성",
    "content": ". | 에디터 상단의 도구 (Tools) 클릭 | New C++ Class 클릭 | 엔진에서 제공하는 클래스 선택 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#클래스-생성"
  },"987": {
    "doc": "1. The Actor Class",
    "title": "언리얼 모듈 Public/Private 폴더",
    "content": "New C++ Class 를 통해 생성할 때 어디에 클래스를 생성할지 선택하게 된다 . | 폴더명 | 용도 및 특징 | . | Public | 다른 모듈(외부)에서 사용할 수 있게 공개하려는 헤더 파일 | . |   | 즉, ‘외부에 노출’되는 API/클래스/함수의 헤더(.h) 파일을 여기에 둠 | . | Private | 모듈 내부에서만 사용할 클래스/구현 파일 | . |   | 보통 소스(.cpp) 파일, 혹은 외부에 노출하지 않아도 되는 헤더(.h) 파일을 둠 | . | Public 폴더 : 다른 모듈에서 #include 가능 | Private 폴더 : 원칙적으로 해당 모듈 외부에서 #include 할 수 없음 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AA%A8%EB%93%88-publicprivate-%ED%8F%B4%EB%8D%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#언리얼-모듈-publicprivate-폴더"
  },"988": {
    "doc": "1. The Actor Class",
    "title": "Super::",
    "content": "상위 클래스의 함수를 호출할 때 사용되는 접두사 . | 부모(상위) 클래스의 함수, 생성자, 멤버 등에 접근할 때 사용 | . void AMyActor::BeginPlay() { Super::BeginPlay(); // 부모 클래스의 BeginPlay() 호출 // 이 아래에 자식에서의 추가 동작 구현 } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#super",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#super"
  },"989": {
    "doc": "1. The Actor Class",
    "title": "Blueprint Creation",
    "content": "생성한 C++ 기반 클래스를 블루 프린트로 가져오기 . | 에디터 우클릭 -&gt; 블루 프린트 클래스 클릭 | ALL Classes에 가져오고 싶은 클래스 검색 | 선택 후 BP_ 붙여 네이밍하기 | 클래스 기반 블루 프린트 생성 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#blueprint-creation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#blueprint-creation"
  },"990": {
    "doc": "1. The Actor Class",
    "title": "사용한 메서드 정리",
    "content": "GetWorld() . UWorld* UObject::GetWorld() const; . | 매개변수: 없음 | 리턴값: 현재 객체가 속한 월드의 포인터를 반환 . | 대부분의 Actor, Component 등에서 사용 가능 | . | . GetActorLocation() . FVector AActor::GetActorLocation() const; . | 매개변수: 없음 | 리턴값: FVector (액터의 월드 공간 위치) . | 액터가 현재 월드에서 어느 좌표에 있는지 반환 | . | . GetActorForwardVector() . FVector AActor::GetActorForwardVector() const; . | 매개변수: 없음 | 리턴값: FVector (액터의 앞 방향 벡터(Forward), 정규화됨) . | 로컬 Z축이 아닌, 로컬 X축 기준 (언리얼은 X가 Forward) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#사용한-메서드-정리"
  },"991": {
    "doc": "1. The Actor Class",
    "title": "Custom Header Files",
    "content": "매크로 전용 헤더 파일 만들기 . | Visual Studio 로 사용자 모듈 열기 | Games/사용자모듈/Source/사용자모듈이름 우클릭 | Add -&gt; New item 클릭 | 만들 종류로 헤더 파일 선택 -&gt; 헤더 이름 정하기 | 헤더가 들어갈 폴더 지정해주기 . | 예: 사용자 모듈\\Source\\사용자 모듈 이름 | . | . 참고하면 좋은 링크 . | Actor Lifecycle | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#custom-header-files",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#custom-header-files"
  },"992": {
    "doc": "UObject",
    "title": "UObject",
    "content": "언리얼 엔진의 모든 객체 지향 시스템의 기반이 되는 핵심 클래스. | 게임플레이 요소, 컴포넌트, 에셋 등 거의 모든 UE5 객체가 UObject에서 파생됨 | UObject 객체를 생성함으로써 리플렉션, 가비지 컬렉션(GC), 직렬화 등의 기능을 사용할 수 있다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/"
  },"993": {
    "doc": "UObject",
    "title": "개발자가 직접 사용하는 도구 (원인)",
    "content": ". | 객체 생성 및 관리 . | NewObject(), IsValid(), ConditionalBeginDestroy() | . | 라이프사이클 관리 . | PostInitProperties(), BeginDestroy(), AddToRoot() | . | 메타데이터 시스템 . | UPROPERTY(meta=(...)), UFUNCTION() 지정자 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-%EC%9B%90%EC%9D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#개발자가-직접-사용하는-도구-원인"
  },"994": {
    "doc": "UObject",
    "title": "UObject를 사용함으로써 자동으로 얻는 기능 (결과)",
    "content": ". | 리플렉션 . | UCLASS()로 등록한 클래스가 블루프린트/파이썬에서 자동 인식 | . | 가비지 컬렉션 . | UPROPERTY() 참조가 없어지면 GC가 자동으로 객체 제거 | . | 직렬화 . | SaveGame 지정 시 별도 코드 없이도 디스크에 저장 가능 | . | 에디터 통합 . | EditAnywhere 메타데이터로 자동으로 디테일 패널 생성 | . | . UObject 상속 계층 구조 . UObject (최상위 베이스 클래스) ├─ UActorComponent (액터 컴포넌트 베이스) │ ├─ USceneComponent (변환 기능 포함) │ │ ├─ UPrimitiveComponent (렌더링 가능) │ │ │ ├─ UMeshComponent (메시 기반) │ │ │ │ ├─ USkeletalMeshComponent (스켈레탈 메시) │ │ │ │ └─ UStaticMeshComponent (스태틱 메시) │ │ │ └─ ULightComponent (라이트 소스) │ │ └─ UCameraComponent (카메라) │ └─ UAudioComponent (사운드) ├─ AActor (월드 배치 객체) │ ├─ APawn (플레이어/AI 제어 가능) │ │ ├─ ACharacter (캐릭터 메시/이동 포함) │ │ └─ ADefaultPawn (기본 이동 기능) │ └─ AStaticMeshActor (스태틱 메시 배치) ├─ UDataAsset (데이터 전용 에셋) │ ├─ UPrimaryDataAsset (프라이머리 에셋 시스템) │ └─ UAnimSequence (애니메이션 데이터) ├─ UBlueprintFunctionLibrary (블루프린트 함수) │ ├─ UKismetSystemLibrary (시스템 유틸리티) │ └─ UKismetMathLibrary (수학 함수) └─ 기타 주요 클래스 ├─ UGameInstance (게임 인스턴스) ├─ UWorld (월드 컨텍스트) ├─ UUserWidget (UMG 위젯) └─ UMaterial (머티리얼) . 주의사항 . | 스택 할당 금지: 반드시 힙에 생성 (GC 관리 대상이어야 함) | 다중 상속 제한: UObject를 다중 상속할 때는 주의가 필요 (일반적으로 UInterface 사용) | 표준 C++ 타입과의 호환성: std::vector 등은 UPROPERTY()로 표시할 수 없으며, TArray를 사용함 | 아주 가벼운 데이터만 다룰 경우 USTRUCT를 권장 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%96%BB%EB%8A%94-%EA%B8%B0%EB%8A%A5-%EA%B2%B0%EA%B3%BC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject를-사용함으로써-자동으로-얻는-기능-결과"
  },"995": {
    "doc": "UObject",
    "title": "UObject의 내부 구조",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject의-내부-구조"
  },"996": {
    "doc": "UObject",
    "title": "UClass",
    "content": ". | UClass는 UObject 객체의 청사진 (UObject 타입에 대한 메타데이터와 구조 정보) | 프로퍼티의 이름/타입/위치(오프셋) . | (예: “고양이” 종류의 객체는 “고양이 클래스” DNA를 가짐) | . | 모든 UObject는 자신의 클래스 정보 (UClass)를 가리키는 ClassPrivate 포인터를 갖는다 | . class UClass : public UObject { TArray&lt;UProperty*&gt; Properties; // 프로퍼티 목록 (예: 체력, 공격력) TArray&lt;UFunction*&gt; Functions; // 함수 목록 (예: 점프(), 공격()) UClass* SuperClass; // 부모 클래스 (상속 관계) UObject* ClassDefaultObject; // CDO 포인터 // ... 기타 메타데이터 }; . 동작 예시 . UMyObject* Obj = NewObject&lt;UMyObject&gt;(); UClass* ObjClass = Obj-&gt;GetClass(); // 데이터 추출 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass"
  },"997": {
    "doc": "UObject",
    "title": "CDO (Class Default Object)",
    "content": ". | UClass가 관리하는 특별한 UObject 인스턴스 | 모든 UObject 인스턴스의 초기값을 제공하는 원본 . | (예: “고양이 클래스”의 기본 색상=검정, 기본 체력=100) | . | . | 클래스가 언리얼 모듈에 로드될 때 한 번만 생성됨 | . 내부 구조와 CDO의 관계 다이어그램 . | UClass : 모든 인스턴스가 공유하는 “청사진” | CDO : 인스턴스들이 참조하는 변하지 않는 원본 | UObject 인스턴스 : CDO의 기본값을 복사받아 생성된 개별 객체 | . CDO 접근 방법 . // CDO 얻기 UMyObject* Defaults = GetDefault&lt;UMyObject&gt;(); // 기본값 사용 예시 float DefaultHealth = Defaults-&gt;Health; // 에디터에서 설정한 Health 값 . CDO 실제 활용 . | 에디터 연동 (인스턴스 초기값 세팅) UPROPERTY(EditDefaultsOnly, Category=\"Settings\") float Health; // CDO에서만 편집 가능 . | 런타임 검사 if (MyObj-&gt;Health == GetDefault&lt;UMyObject&gt;()-&gt;Health) { UE_LOG(LogTemp, Warning, TEXT(\"체력이 기본값입니다!\")); } . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object"
  },"998": {
    "doc": "UObject",
    "title": "UObject 객체 생성 과정",
    "content": ". | UClass 로드 : 엔진 시작 시 UMyObject::StaticClass() 호출 → UClass 생성 | CDO 생성 : UClass 초기화 과정에서 GetDefaultObject()가 CDO 생성 | UObject 인스턴스 생성 : NewObject() 시 CDO의 프로퍼티 값을 복사 | . CDO vs 인스턴스 . | 비교 항목 | CDO | 일반 인스턴스 | . | 생성 시점 | 모듈 로드 시 1회 | NewObject() 호출 시 | . | 수정 가능성 | 에디터에서만 (런타임 X) | 런타임 자유롭게 변경 가능 | . | 메모리 위치 | 영구적 (게임 종료 시까지) | GC에 의해 삭제 가능 | . | 용도 | 기본값 템플릿 | 실제 게임 내 객체 | . | 에디터에서 Health=200 변경 → 모든 새 인스턴스는 Health=200으로 생성됨 | 기존 인스턴스는 영향 없음 (이미 생성된 객체는 독립적) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-객체-생성-과정"
  },"999": {
    "doc": "UObject",
    "title": "ObjectFlags",
    "content": "객체의 상태를 나타내는 비트 플래그 . enum EObjectFlags { RF_Public = 0x00000001, // 에디터에 노출 여부 RF_Transactional= 0x00002000, // Undo/Redo 지원 RF_Transient = 0x00004000, // 임시 객체 (저장 안 됨) // ... 30여 가지 플래그 }; . | UObject 인스턴스는 자신만의 ObjectFlags를 보유 | UClass는 UObject의 파생 클래스이므로, UClass도 자신만의 ObjectFlags를 가짐 | . ObjectFlags 내부 구조 다이어그램 . | UObject 인스턴스의 ObjectFlags: 개별 인스턴스의 런타임 상태 제어 . | 이 객체만의 상태 플래그 | . | UClass의 ObjectFlags: 클래스 전체의 정적 특성 정의, 추상 클래스 여부, 블루프린트 노출 . | 클래스 전체에 적용되는 플래그 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags"
  },"1000": {
    "doc": "UObject",
    "title": "서브오브젝트 시스템 (Subobject System)",
    "content": "다른 UObject (주로 AActor나 UActorComponent)에 종속된 자식 객체 . | “서브오브젝트”란 별도 클래스가 아니라, Outer 체계를 활용한 소유 관계/구조 | 모든 컴포넌트는 서브오브젝트임 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-subobject-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-시스템-subobject-system"
  },"1001": {
    "doc": "UObject",
    "title": "서브오브젝트의 특징",
    "content": ". | 생명주기 : 부모 종속 / 부모 객체가 파괴되면 함께 파괴됨 (GC 대상) | 생성 시점 제한 : 반드시 부모의 생성자에서 CreateDefaultSubobject&lt;T&gt;()로 생성해야 함 | 자동 직렬화 : 부모와 함께 저장/로드됨 (에디터에서 편집 가능) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트의-특징"
  },"1002": {
    "doc": "UObject",
    "title": "Suboject vs UObject",
    "content": "| 비교 항목 | 서브오브젝트 | 일반 UObject | . | 생성 방법 | CreateDefaultSubobject&lt;T&gt;() (생성자 내에서만 호출 가능) | NewObject&lt;T&gt;() (런타임 어디서나 가능) | . | 생명주기 | 부모 종속(부모 삭제 시 함께 삭제) | 독립적 | . | 에디터 노출 | 부모의 디테일 패널에 자동 표시 | 별도 에셋 또는 인스턴스로 관리 | . | 사용 사례 | 액터의 컴포넌트(Mesh, Camera 등) | 독립적인 데이터 에셋 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#suboject-vs-uobject",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#suboject-vs-uobject"
  },"1003": {
    "doc": "UObject",
    "title": "서브오브젝트 구조",
    "content": "class UObject { protected: UObject* Outer; // 상위 객체 (서브오브젝트인 경우 소유자) FName Name; // 고유 이름 (Outer + Name으로 식별) UClass* Class; // 타입 정보 // 기타... }; . | Outer : 서브 오브젝트의 소유자 (예: USceneComponent의 Outer는 일반적으로 소유자 AActor) | Name : 같은 소유자를 가진 그룹에서 고유하게 가져야함 (중복 시 경고 발생) | 블루프린트: 에디터에서 Add Component 버튼으로 추가 가능 | AActor: Actor의 경우 추가로 Components 배열 사용 | . UClass와의 관계 . | UClass는 서브오브젝트 목록을 직접 관리하지 않음 | UPROPERTY 메타데이터를 통해 리플렉션 및 자동 탐색이 이루어짐 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-구조"
  },"1004": {
    "doc": "UObject",
    "title": "서브오브젝트 탐색 방식",
    "content": "1. 리플렉션 기반 탐색 (UPROPERTY) . | UPROPERTY()로 표시된 멤버만 탐색 가능 UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* Comp; // 서브오브젝트는 UPROPERTY로 노출됨 }; . | . 2. Outer 체인 탐색 . | AActor가 아닌 일반 UObject 서브오브젝트를 찾을 때 사용 | . // 모든 서브오브젝트 순회 (예시 코드) TArray&lt;UObject*&gt; Subobjects; GetObjectsWithOuter(MyActor, Subobjects); // MyActor를 Outer로 가진 객체 찾기 // 결과 출력 for (UObject* Obj : Subobjects) { UE_LOG(LogTemp, Warning, TEXT(\"Subobject: %s\"), *Obj-&gt;GetName()); } . 3. AActor 특수 처리 . | AActor만 Components 배열을 명시적으로 별도 관리 | . class AActor : public UObject { TArray&lt;UActorComponent*&gt; Components; // 서브오브젝트 명시적 관리 }; // FindComponentByClass 활용 (최적화된 탐색) UMyComponent* MyComp = FindComponentByClass&lt;UMyComponent&gt;(); . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%83%90%EC%83%89-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-탐색-방식"
  },"1005": {
    "doc": "UObject",
    "title": "서브오브젝트 생성 및 과정",
    "content": "// MyActor.h UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* MyComp; // 서브오브젝트 포인터 AMyActor() { // 생성자에서 서브오브젝트 생성 MyComp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"MyComp\")); } }; . | 생성자 호출 . | 반드시 부모 객체의 생성자 내에서 호출 . | 예외: UActorComponent는 InitializeComponent()에서 추가 초기화 | . | . | 메모리 할당 . | 엔진은 UMyComponent 인스턴스를 생성하고, Outer를 AMyActor로 설정 | . | 이름 등록 . | TEXT(“MyComp”)를 이름으로 지정, 중복 검사 수행 | . | 리플렉션 연동 . | UPROPERTY가 없어도 서브오브젝트 생성 (에디터에서 수정 불가. 블루 프린트 노출 X) | UPROPERTY가 있으면 디테일 패널에 노출 | . | Actor에 등록 . | AActor 전용으로 Actor와 연관된 오브젝트가 아닐 경우 패스됨 | AActor의 경우 Components 배열에 자동 추가 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-생성-및-과정"
  },"1006": {
    "doc": "UObject",
    "title": "서브오브젝트 다이어그램",
    "content": ". | 실선: 명시적 참조 (AActor의 Components 배열) | 점선: 암시적 참조 (Outer 포인터) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-다이어그램"
  },"1007": {
    "doc": "1. Quick Asset Actions",
    "title": "1. Quick Asset Actions",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/"
  },"1008": {
    "doc": "1. Quick Asset Actions",
    "title": "에셋 액션",
    "content": "언리얼 에디터에서 에셋(Asset)에 대해 사용자가 직접 수행할 수 있는 특정 동작/명령 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%97%90%EC%85%8B-%EC%95%A1%EC%85%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#에셋-액션"
  },"1009": {
    "doc": "1. Quick Asset Actions",
    "title": "동작 방식 (5.3 이상)",
    "content": ". | C++에서 UAssetActionUtility 기반 커스텀 클래스 생성 . | UAssetActionUtility는 언리얼이 제공하는 에디터 확장용 베이스 클래스 | 이 클래스를 상속받아 C++ 또는 블루프린트에서 커스텀 명령(함수)을 구현 | . | 함수에 UFUNCTION(CallInEditor) 매크로 등록 . | 에디터에서 호출 가능한 함수로 등록 | 함수명은 명확하게 작성 | . | 에디터 유틸리티 블루프린트(Asset Action Utility BP) 생성 . | 플러그인 또는 프로젝트의 콘텐츠 브라우저에서 생성 | 부모 클래스로 1번에서 만든 커스텀 C++ 클래스를 선택 | (에디터가 이 BP 인스턴스를 통해 실제 액션을 인식) | . | 동작 실행 . | 에디터에서 에셋을 우클릭 → “스크립팅된 에셋 액션”에서 등록된 함수가 메뉴에 나타남 | 클릭 시 실제 동작 수행 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#동작-방식-53-이상"
  },"1010": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈",
    "content": "모듈은 언리얼 엔진의 구성 블록이다. 에디터를 만들려면 자신만의 모듈을 만들어야 한다. ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈"
  },"1011": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈에서 알아야 할 세가지 주요 포인트",
    "content": ". | 모듈은 코드 분리를 강제한다. | 여러 개의 무작위 코드들이 서로 소통해야 할 때 매우 유용하다 | . | 모든 모듈은 Build.cs 파일이 필요하다. | 새 프로젝트 자체도 하나의 모듈이다. | 모듈은 자신의 빌드 파일을 가진다. [ModuleName].Build.cs [ProjectName].Build.cs . | . | 모듈은 Build.cs 파일에 추가하여 포함할 수 있다. | 다른 모듈에 위치한 헤더 파일을 포함해야 할 때 해당 헤더의 모듈 이름을 Build.cs 파일에 추가한다. | 보통 PublicDependencyModuleNames에 모듈 이름을 추가하는 경우가 많다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88%EC%97%90%EC%84%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EC%84%B8%EA%B0%80%EC%A7%80-%EC%A3%BC%EC%9A%94-%ED%8F%AC%EC%9D%B8%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈에서-알아야-할-세가지-주요-포인트"
  },"1012": {
    "doc": "1. Quick Asset Actions",
    "title": "플러그인 생성하기",
    "content": ". | 언리얼 상단 메뉴 Edit &gt; Plugins 클릭 | 왼쪽 상단의 +ADD 버튼 클릭 | 여러가지 템플릿 목록에서 선택 (현재는 Blank 선택) . | 플러그인 이름이 곧 모듈 이름이다. | 한번 정하면 변경할 수 없다. | . | Create Plugin 버튼 클릭 | 비주얼 스튜디오로 돌아가 모두 로드 버튼 클릭 . | 프로젝트 소스 폴더 위에 플러그인 폴더 생성된 것 확인 | . | . // .uplugin \"Modules\": [ { \"Name\": \"BackgroundTool\", \"Type\": \"Editor\", // 만들 기능은 에디터 전용이므로 Runtime(게임 동작시 실행되는 타입) -&gt; Editor로 변경 \"LoadingPhase\": \"PreDefault\" // 플러그인이 언제 로드될지 결정함. PreDefault: 게임 모듈보다 먼저 로드됨 } ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#플러그인-생성하기"
  },"1013": {
    "doc": "1. Quick Asset Actions",
    "title": "액터와 에셋",
    "content": ". | 에셋 : 콘텐트 브라우저 안에 존재하는 것 (머티리얼, 스태틱 매시 등) . | 에셋은 AssetActionUtility라는 내장 클래스를 사용 | . | 액터 : 레벨(뷰) 안에 존재하며 클릭할 수 있는 것 . | 액터는 ActorActionUtility라는 클래스를 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%95%A1%ED%84%B0%EC%99%80-%EC%97%90%EC%85%8B",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#액터와-에셋"
  },"1014": {
    "doc": "1. Quick Asset Actions",
    "title": "Public/Private",
    "content": ". | 모듈을 하나 생성할 때 Pubilc, Private 폴더를 나눠서 생성할 수 있음 . | Pubilc : 헤더 | Private : cpp 소스 코드 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate"
  },"1015": {
    "doc": "1. Quick Asset Actions",
    "title": "build.cs",
    "content": ". | 인클루드 된 헤더에 빨간 밑줄 : 현재 모듈이 이 헤더 파일에 접근할 권한 없음 | . 접근권한 해결하기 . | 솔루션 탐색기에서 해당 헤더 검색 후 헤더가 들어있는 모듈 찾기 | 해당 모듈의 build.cs 소스 코드에 각각 private, pubilc 모듈 경로를 찾을수 있음 | 내가 쓸 build.cs에 private, pubilc에 해당하는 경로 붙여넣기 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs"
  },"1016": {
    "doc": "1. Quick Asset Actions",
    "title": "테스트용 에셋 함수 구동하기 (5.3 이상)",
    "content": "함수 준비하기 : 플러그인 콘텐트 . | 플러그인의 콘텐트 폴더로 이동 | 플러그인 콘텐트 브라우저에서 마우스 오른쪽 버튼 클릭 | 에디터 유틸리티 -&gt; 에디터 유틸리티 블루 프린트 -&gt; 에셋 액션 유틸리티 선택하여 생성 | 더블 클릭하여 해당 에셋을 열고 우측 상단의 파일 클릭 | 부모 블루프린트 -&gt; 내가 만든 c++ 클래스 입력 | 컴파일 및 저장 클릭 | . 이 과정이 없으면 에디터는 사용자가 만든 에셋 액션을 전혀 인식하지 못함 . | C++ 클래스 = 설계도 | 에셋 액션 유틸리티 BP 에셋 = 실제 완성품 (에디터가 사용할 수 있는 인스턴스) | . 함수 사용하기 . | 메인 콘텐트에서 Blueprint 폴더 생성 | Blueprint 클래스 생성 | 해당 클래스 우클릭 -&gt; Scripted Asset Actions | 플러그인 콘텐트에서 추가한 c++ 클래스가 보임 | 클릭하여 동작 확인 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9-%EC%97%90%EC%85%8B-%ED%95%A8%EC%88%98-%EA%B5%AC%EB%8F%99%ED%95%98%EA%B8%B0-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#테스트용-에셋-함수-구동하기-53-이상"
  },"1017": {
    "doc": "1. Quick Asset Actions",
    "title": "디버그 헤더 만들기",
    "content": ". | 플러그인 안의 폴더를 오른쪽 버튼으로 클릭 | 새 항목 추가 선택 | 추가 창이 뜨면 위치를 플러그인 -&gt; 모듈 -&gt; public 폴더로 선택 | 만들 유형 헤더로 선택하고 Debug.h 이름 지정 | Debug.h의 함수를 사용할 cpp 파일에 #include “Debug.h” 추가 | . void PrintMessage(const FString&amp; Message, const FColor&amp; Color) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage(-1, 8.f, Color, Message); // 화면 좌상단에 출력 } } void PrintLog(const FString&amp; Message) { UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *Message); // 콘솔 로그창에 출력 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%94%94%EB%B2%84%EA%B7%B8-%ED%97%A4%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#디버그-헤더-만들기"
  },"1018": {
    "doc": "1. Quick Asset Actions",
    "title": "단축키",
    "content": ". | UE 상단에서 툴 -&gt; visual studio 새로고침 선택 | Ctrl + B : vs studio 빌드 | Ctrl + F5 : 편집기 (엔진) 실행 | Ctrl + Alt + F11 : 라이브 코딩 실행 | Alt + F12(피킹 정의) : Quick Info 주석 보기 | Ctrl + ` : 터미널 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8B%A8%EC%B6%95%ED%82%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#단축키"
  },"1019": {
    "doc": "2. Moving Objects With Code",
    "title": "2. Moving Objects With Code",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/"
  },"1020": {
    "doc": "2. Moving Objects With Code",
    "title": "FRotator",
    "content": "FRotator::FRotator(float InPitch, float InYaw, float InRoll) . | 매개변수: . | InPitch: Up/Down (-90°~+90° 권장) . | - : 아래 | + : 위 | . | InYaw: Left/Right (-180°~+180°) . | -: 왼쪽 (반시계) | +: 오른쪽 (시계) | . | InRoll: 비틀기 (-180°~+180°) . | -: 왼쪽 (↙) | +: 오른쪽 (↘) | . | . | . | 회전 종류 | 기준 축 | 평면 변화 | 비유 | . | Pitch | Y축 | XZ 평면 | 캐릭터가 머리를 위아래로 끄덕임 | . | Yaw | Z축 | XY 평면 | 캐릭터가 좌우로 고개를 돌려 방향 전환 | . | Roll | X축 | YZ 평면 | 비행기의 날개가 좌우로 기울어지는 동작 | . | Pitch 제한 : Pitch는 일반적으로 -90°~+90°로 제한됨 . | Pitch가 ±90°일 때 Gimbal Lock 발생 가능 → FQuat 사용 권장 | . | Yaw/Roll 범위: 360° 회전 시 정규화 | . 사용예시 . FRotator NewRotation(0.0f, 0.0f, 0.0f); // 초기화 NewRotation.Pitch = -45.0f; // 아래 45도로 고개 숙임 NewRotation.Yaw = -90.0f; // 왼쪽 90도로 방향 전환 NewRotation.Roll = 30.0f; // 오른쪽 30도로 몸체 기울이기 FRotator Rot(370.0f, -190.0f, 0.0f); // 360도 이상 일 때 정규화 FRotator Normalized = Rot.GetNormalized(); // (10°, 170°, 0°) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#frotator",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#frotator"
  },"1021": {
    "doc": "2. Moving Objects With Code",
    "title": "SetActorLocation",
    "content": "벡터 통해 액터 위치 설정하기 . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); SetActorLocation(FVector(0.f, 0.f, 50.f)); // 액터 위치 설정 FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorlocation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorlocation"
  },"1022": {
    "doc": "2. Moving Objects With Code",
    "title": "SetActorRotation",
    "content": "void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); SetActorLocation(FVector(0.f, 0.f, 50.f)); SetActorRotation(FRotator(0.f, 45.f, 0.f)); // 액터 회전 설정 FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorrotation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorrotation"
  },"1023": {
    "doc": "2. Moving Objects With Code",
    "title": "Actor Wolrd Offset",
    "content": ". | BP . | Add Actor World Offset | Add Actor World Rotation | . | . 프레임 속도 조절 . | Edit -&gt; Project Settings | frame rate 검색 | Use Fixed Frame Rate 체크 | 원하는 프레임 수 설정 | . | 프레임 따라 움직이기 . | 프레임은 들쭉날쭉 하기때문에 비율로 조절해야 속도가 일정하게 찍힘 | . | . void AItem::Tick(float DeltaTime) { Super::Tick(DeltaTime); // movement rate in units of cm/s float MovementRate = 50.f; float RotationRate = 45.f; // MovementRate * DeltaTime (cm/s) * (s/frame) = (cm/frame) AddActorWorldOffset(FVector(MovementRate * DeltaTime, 0.f, 0.f)); AddActorWorldRotation(FRotator(0.f, RotationRate * DeltaTime, 0.f)); DRAW_SPHERE_SingleFrame(GetActorLocation()); DRAW_VECTOR_SingleFrame(GetActorLocation(), GetActorLocation() + GetActorForwardVector() * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#actor-wolrd-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#actor-wolrd-offset"
  },"1024": {
    "doc": "Macro",
    "title": "Macro",
    "content": ". | 언리얼 전용 메타데이터 매크로는 코드 재사용성과 생산성을 높이기 위한 강력한 기능을 제공한다 | 함수나 변수마다 위에 매크로를 붙이지 않으면 언리얼 엔진의 리플렉션 시스템에 등록되지 않는다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/"
  },"1025": {
    "doc": "Macro",
    "title": "매크로의 주요 기능",
    "content": ". | 리플렉션 시스템 통합 : 런타임에 클래스 정보 조회 가능 | 블루프린트 연동 : C++과 블루프린트 간의 상호 운용성 제공 | 직렬화 지원 : 객체 상태 저장 및 로드 가능 | 네트워크 복제 : 멀티플레이어 게임에서 변수 및 함수 복제 | 가비지 컬렉션 : UObject 파생 클래스의 자동 메모리 관리 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로의-주요-기능"
  },"1026": {
    "doc": "Macro",
    "title": "빌드 시스템과 매크로 연동",
    "content": "1. 빌드 시스템 기본 구조 . | UBT(Unreal Build Tool) . | 모든 빌드 명령을 관리/자동화. | 각종 .Build.cs, .Target.cs 파일을 해석하여 모듈, 의존성, 플랫폼, 설정에 따라 빌드를 분기 | . | UnrealHeaderTool(UHT) . | 언리얼 리플렉션을 위해 추가적으로 동작하는 툴 | 리플렉션 매크로(UCLASS, UPROPERTY, 등)가 붙은 소스코드를 파싱 | 메타데이터와 Glue 코드(C++에선 자동 생성된 코드)를 생성 | . | . 2. 매크로와 빌드 파이프라인 . | UCLASS 등을 통해 매크로를 사용한 코드 작성 | UBT : 빌드 시작 | UHT : 헤더 파싱 &amp; Glue 코드(메타데이터) 생성 . | *.generated.h 를 반드시 #include로 포함해야 함 | 이 파일이 누락될 경우 컴파일 에러 발생 | . | C++ 컴파일러가 코드 + 자동코드 컴파일 | 런타임: 리플렉션 시스템 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%97%B0%EB%8F%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#빌드-시스템과-매크로-연동"
  },"1027": {
    "doc": "Macro",
    "title": "UHT (UnrealHeaderTool) 의 작동 과정",
    "content": ". | 소스 코드 스캐닝 . | UHT는 .h 헤더 파일을 파싱하여 UCLASS, USTRUCT, UFUNCTION, UPROPERTY 등의 매크로가 포함된 특수 주석을 검색 | 일반 C++ 파서와 달리, 언리얼 특수 매크로를 이해하는 커스텀 파서를 사용 | . | 메타데이터 추출 . | 매크로에 지정된 속성들(예: BlueprintCallable, EditAnywhere 등)을 분석 | 클래스 계층 구조, 프로퍼티 타입, 함수 시그니처 등의 정보를 추출 | . | 리플렉션 코드 생성 . | GENERATED_BODY() 매크로 위치에 대체될 실제 코드를 생성 | 생성되는 파일들은 주로 Intermediate/Build 폴더에 저장 | 주요 생성 파일: . | [ModuleName].generated.h | [ClassName].generated.cpp | . | . | 직렬화/리플렉션 시스템 통합 . | UObject 시스템이 런타임에 클래스 정보를 조회할 수 있도록 함 | 블루프린트와의 상호 운용을 위한 바인딩 코드를 생성 | . | . 생성되는 코드 예시 . | 원본 UCLASS(Blueprintable) class AMyActor : public AActor { GENERATED_BODY() UPROPERTY(EditAnywhere) float Health; }; . | UHT가 생성하는 코드 (간소화 된 예) | . // AMyActor.generated.h #define AMyActor_Extra_Code \\ public: \\ static UClass* StaticClass(); \\ virtual UClass* GetClass() const override; \\ static void __StaticDependenciesAssets(TArray&lt;FAssetData&gt;&amp; OutAssets); \\ private: \\ static UClass* PrivateStaticClass; \\ public: \\ DECLARE_CLASS(AMyActor, AActor, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(\"/Script/MyGame\"), NO_API) \\ DECLARE_REPLICATION_FRAGMENT(AMyActor) \\ enum {IsIntrinsic=COMPILED_IN_INTRINSIC}; // 리플렉션 데이터 구조체 static const FClassFunctionLinkInfo Z_Construct_UClass_AMyActor_Functions[]; static const FPropertyParamsBase* const Z_Construct_UClass_AMyActor_Properties[]; . UHT가 생성하는 정보 . | 클래스 등록용 StaticRegisterNatives | UPROPERTY 메타정보 배열 | 블루프린트용 함수 등록 | C++에서 런타임에 사용할 수 있는 메타데이터 구조체 | 에디터/런타임용 데이터 구조 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-의-작동-과정"
  },"1028": {
    "doc": "Macro",
    "title": "UHT 처리의 특징",
    "content": ". | 템플릿 기반 코드 생성 . | 단순 복사-붙여넣기가 아닌, 템플릿을 기반으로 상황에 맞는 최적화된 코드 생성 | . | 의존성 분석 . | 클래스 간의 관계를 분석하여 올바른 초기화 순서 보장 | . | 크로스-레퍼런스 해결 . | 모듈 간 상호 참조 문제를 해결하기 위한 전방 선언(forward declaration) 생성 | . | 빌드 시스템 통합 . | 생성된 코드가 실제 컴파일 과정에 올바르게 포함되도록 Makefile/UBT 스크립트 조정 | . | 에러 체크 . | 잘못된 매크로 사용이나 충돌하는 설정을 빌드 전에 검출 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-%EC%B2%98%EB%A6%AC%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-처리의-특징"
  },"1029": {
    "doc": "Macro",
    "title": "매크로 카테고리",
    "content": "| 카테고리 | 주요 매크로 | 용도 | . | 코어 리플렉션 | UCLASS, USTRUCT, UENUM, UPROPERTY, UFUNCTION, GENERATED_BODY | 언리얼 리플렉션 시스템 등록 | . | 네트워크 복제 | Replicated, ReplicatedUsing, DOREPLIFETIME, RPC 관련 매크로 | 멀티플레이어 게임에서 변수/함수 동기화 | . | 메모리 관리 | UPROPERTY(), UObject 관련 매크로 | 가비지 컬렉션 및 메모리 안전성 보장 | . | 에디터 연동 | EditAnywhere, VisibleDefaultsOnly, BlueprintReadOnly, Category | 에디터 노출 및 편집 제어 | . | 플랫폼 특화 | PLATFORM_WINDOWS, PLATFORM_ANDROID, WITH_EDITOR, WITH_SERVER_CODE | 플랫폼/빌드 설정별 코드 분기 | . | 디버깅/로깅 | UE_LOG, UE_CHECK, UE_ASSERT, ensure(), check() | 런타임 검증 및 로깅 | . | 성능 최적화 | UE_INLINE, UE_NOINLINE, FORCEINLINE, CORE_API | 인라인 제어 및 DLL 인터페이스 정의 | . | 메타데이터 | UMETA, DisplayName, ClampMin, ToolTip | 추가 속성 지정 | . | 모듈/플러그인 | IMPLEMENT_MODULE, IMPLEMENT_GAME_MODULE, PLUGIN_API | 모듈 초기화 및 플러그인 시스템 통합 | . | 최신 기능 | UE_DEPRECATED, UE_NODISCARD, TOptional, TSoftObjectPtr 관련 매크로 | 현대적 C++ 기능 지원 | . 참고 링크 . | 빌드 파이프라인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로-카테고리"
  },"1030": {
    "doc": "Math",
    "title": "Math",
    "content": " ",
    "url": "/docs/Math/",
    
    "relUrl": "/docs/Math/"
  },"1031": {
    "doc": "Linear Algebra",
    "title": "Linear Algebra",
    "content": ". | An Intuitive Guide to Linear Algebra | . ",
    "url": "/docs/Math/linear%20algebra/",
    
    "relUrl": "/docs/Math/linear%20algebra/"
  },"1032": {
    "doc": "Linear Algebra",
    "title": "lining up the variable",
    "content": "미지수가 3개인 방정식을 행렬로 만들어보자 . 예시 . \\[\\begin{cases} 2x + 3y - z = 11\\\\ 7y = 6 - x -4z\\\\ -8z + 3 = y \\end{cases}\\] . | 위와 같은 미지수가 3개인 방정식이 있다고 할 때, x y z = c 와 같은 꼴로 정리한다. | . \\[\\begin{cases} 2x + 3y - z = 11\\\\ x + 7y +4z = 6 \\\\ 0x - y -8z = -3 \\end{cases}\\] . | 그 후 값을 행렬에 넣어준다 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 2 &amp; 3 &amp; -1 &amp; 11\\\\ 1 &amp; 7 &amp; 4 &amp; 6 \\\\ 0 &amp; -1 &amp; -8 &amp; -3 \\end{array} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#lining-up-the-variable",
    
    "relUrl": "/docs/Math/linear%20algebra/#lining-up-the-variable"
  },"1033": {
    "doc": "Linear Algebra",
    "title": "행렬 연산 표기",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/#%ED%96%89%EB%A0%AC-%EC%97%B0%EC%82%B0-%ED%91%9C%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/#행렬-연산-표기"
  },"1034": {
    "doc": "Linear Algebra",
    "title": "Switching two rows",
    "content": "행을 맞바꿀 때 사용하는 기호 . \\[{R_1 \\leftrightarrow R_2}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{R_1 \\leftrightarrow R_2} \\begin{pmatrix} 4 &amp; 5 &amp; 6 \\\\ 1 &amp; 2 &amp; 3 \\\\ \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#switching-two-rows",
    
    "relUrl": "/docs/Math/linear%20algebra/#switching-two-rows"
  },"1035": {
    "doc": "Linear Algebra",
    "title": "Multplying a row by a constant",
    "content": "행에 곱셈을 할 때 사용하는 기호 . \\[{2R_1 \\rightarrow R_1}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{2R_1 \\rightarrow R_1} \\begin{pmatrix} 2 &amp; 4 &amp; 6 \\\\ 4 &amp; 5 &amp; 6 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#multplying-a-row-by-a-constant",
    
    "relUrl": "/docs/Math/linear%20algebra/#multplying-a-row-by-a-constant"
  },"1036": {
    "doc": "Linear Algebra",
    "title": "Add a row to another row",
    "content": "행에 덧셈을 할 때 사용하는 기호 . \\[{R_1 + R_2 \\rightarrow R_1}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{R_1 + R_2 \\rightarrow R_1} \\begin{pmatrix} 5 &amp; 7 &amp; 9 \\\\ 4 &amp; 5 &amp; 6 \\end{pmatrix}\\] . 참고하면 좋은 링크 . | 선형대수 1: 벡터 공간과 열 공간 | . ",
    "url": "/docs/Math/linear%20algebra/#add-a-row-to-another-row",
    
    "relUrl": "/docs/Math/linear%20algebra/#add-a-row-to-another-row"
  },"1037": {
    "doc": "3. The Pawn Class",
    "title": "3. The Pawn Class",
    "content": "플레이어나 AI가 제어할 수 있는 액터를 나타내는 기본 클래스 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/"
  },"1038": {
    "doc": "3. The Pawn Class",
    "title": "특징",
    "content": ". | 제어 가능성 . | 플레이어 컨트롤러나 AI 컨트롤러에 의해 제어될 수 있음 | . | 입력 처리 . | 플레이어 입력을 받을 수 있음 | SetupPlayerInputComponent() 메서드를 통해 입력 바인딩 설정 | . | 움직임 시스템 . | 기본적인 움직임 컴포넌트 제공 | UPawnMovementComponent 또는 그 파생 클래스 사용 | . | 카메라 처리 . | 기본적인 카메라 뷰 관리 기능 제공 | UCameraComponent를 사용하여 뷰 설정 가능 | . | 물리적 표현 . | 콜리전(충돌) 메시를 가지고 물리적 상호작용 가능 | USkeletalMeshComponent 또는 UStaticMeshComponent로 시각적 표현 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#특징"
  },"1039": {
    "doc": "3. The Pawn Class",
    "title": "Actor 클래스와 차이점",
    "content": "| 특징 | Pawn 클래스 | Actor 클래스 | . | 제어 가능성 | 플레이어/AI에 의해 제어 가능 | 일반적으로 자동화된 동작만 수행 | . | 입력 처리 | 직접적인 입력 처리 가능 | 입력 처리 불가능 (별도 컴포넌트 필요) | . | 움직임 | 내장된 움직임 시스템 | 기본 움직임 시스템 없음 | . | 목적 | 게임 내 조종 가능한 엔티티 | 일반적인 게임 오브젝트 | . | 컨트롤러 | 컨트롤러에 연결 가능 | 컨트롤러 연결 불가 | . | 기본 컴포넌트 | 기본적인 움직임 컴포넌트 포함 | 빈 상태로 생성 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#actor-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%B0%A8%EC%9D%B4%EC%A0%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#actor-클래스와-차이점"
  },"1040": {
    "doc": "3. The Pawn Class",
    "title": "컨트롤러 활성화",
    "content": "에디터에서 플레이어 컨트롤러 활성화 . | 사용할 Pawn 클릭 | Detail 패널에서 Pawn 검색 | Auto Poeese Player (플레이어 자동 빙의)에서 플레이어 설정 | . C++에서 플레이어 컨트롤러 활성화 . //생성자에서 AutoPossessPlayer = EAutoReceiveInput::Player0; . 단축키 . | 마우스 커서 활성화: 게임 플레이 상태에서 Shift + F1 | 컨트롤러 분리 : 마우스 커서 활성화 후 Detach 컨트롤러 아이콘 클릭 or 단축키 F8 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#컨트롤러-활성화"
  },"1041": {
    "doc": "3. The Pawn Class",
    "title": "Switch Project UE Version",
    "content": ". | 버전을 바꾸고싶은 프로젝트의 ~.uproject 우클릭 | 추가 옵션 표시 클릭 | Switch Unreal Engine Version 클릭 | 원하는 버전 클릭하고 ok | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#switch-project-ue-version",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#switch-project-ue-version"
  },"1042": {
    "doc": "2. Extend Content Browser Menu",
    "title": "1. Extend Content Browser Menu",
    "content": "에디터 내 Content Browser의 폴더/에셋을 우클릭할 때, “나만의 기능” 메뉴를 추가하기 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu"
  },"1043": {
    "doc": "2. Extend Content Browser Menu",
    "title": "에디터 메뉴 시스템 확장 과정",
    "content": ". | 모듈 생성 및 초기화 . | Editor 타입의 모듈 생성 (uplugin의 “Type”: “Editor”) | . | 명령(Command) 정의 . | 메뉴에 바인딩될 명령(이름, 단축키, 아이콘, 툴팁 등)을 TCommands를 상속받아 정의 | . | 실제 동작 (Action) 바인딩 . | 실제 실행할 동작을 정의 (함수 구현) 한 후 델리게이트로 바인딩 | 보통 플러그인이나 에디터 모듈의 StartupModule()에서 이루어짐 | . | 메뉴 확장(Menu Extension) 적용 . | FExtender/FMenuExtensionDelegate 를 통해 기존 메뉴 섹션에 새로운 엔트리(항목)를 추가 | 원하는 위치 (섹션명)은 엔진 문서 참고 | . | UI 적용 및 정리 . | 에디터가 종료될 때 ShutdownModule()를 통해 리소스 및 이벤트 정리 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EC%97%90%EB%94%94%ED%84%B0-%EB%A9%94%EB%89%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%95%EC%9E%A5-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#에디터-메뉴-시스템-확장-과정"
  },"1044": {
    "doc": "2. Extend Content Browser Menu",
    "title": "Delegate",
    "content": "이벤트 기반 프로그래밍을 구현하기 위한 강력한 시스템으로, C++의 함수 포인터나 콜백 시스템을 더 안전하고 유연하게 확장한 개념 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate"
  },"1045": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 특징",
    "content": ". | 타입 안전성: 컴파일 시점에 타입 검사를 수행 | 멤버 함수 바인딩: 객체 인스턴스와 함께 멤버 함수를 바인딩 가능 | 멀티캐스트 지원: 하나의 이벤트에 여러 함수를 등록 가능 | 다이나믹 델리게이트: 블루프린트와 연동 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-특징"
  },"1046": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 사용하기",
    "content": "Delegate 타입 선언 : 매크로 사용 . DECLARE_DELEGATE(FMyDelegate); DECLARE_DELEGATE_RetVal_OneParam(ReturnType, DelegateName, ParamType); . | ReturnType: 반환 타입 (예: int32) | DelegateName: 델리게이트 타입 이름 (예: FMyDelegateWithReturn) | ParamType: 함수에 전달될 파라미터의 타입 (예: FString) | . 바인딩 : 위에 선언한 델리게이트 타입 객체에 함수 연결 . FMyDelegate MyDelegate; // 선언(위 매크로로 정의된 타입) MyDelegate.BindRaw(this, &amp;FMyClass::Handler); . | Bind~(), Add~(), Execute(), Broadcast() 등의 멤버 함수를 사용해 연결/호출 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-사용하기"
  },"1047": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 종류",
    "content": "1. 단일 캐스트 델리게이트 (Single-cast Delegates) . | 하나의 함수만 바인딩 가능 | DECLARE_DELEGATE 매크로로 선언 | 반환 값이 있을 경우 DECLARE_DELEGATE_RetVal 사용 | . DECLARE_DELEGATE(FMyDelegate); // 기본 형태 DECLARE_DELEGATE_OneParam(FMyDelegateWithParam, FString); // 매개변수 하나 DECLARE_DELEGATE_RetVal_OneParam(int32, FMyDelegateWithReturn, FString); // 반환 값과 매개변수 // 사용 예 FMyDelegate MyDelegate; MyDelegate.BindUObject(this, &amp;AMyClass::MyFunction); MyDelegate.Execute(); . 2. 멀티캐스트 델리게이트 (Multi-cast Delegates) . | 여러 함수를 동시에 바인딩 가능 | DECLARE_MULTICAST_DELEGATE 매크로로 선언 | 반환 값 지원 안함 | . DECLARE_MULTICAST_DELEGATE(FMyMulticastDelegate); // 사용 예 FMyMulticastDelegate MyMulticastDelegate; MyMulticastDelegate.AddUObject(this, &amp;AMyClass::Function1); MyMulticastDelegate.AddUObject(OtherObject, &amp;AOtherClass::Function2); MyMulticastDelegate.Broadcast(); . 3. 다이나믹 델리게이트 (Dynamic Delegates) . | 블루프린트와 연동 가능 | 시리얼라이즈(직렬화) 지원 | 이름 기반 바인딩으로 런타임에 바인딩 가능 | DECLARE_DYNAMIC_DELEGATE로 선언 | . DECLARE_DYNAMIC_DELEGATE(FMyDynamicDelegate); // 사용 예 FMyDynamicDelegate MyDynamicDelegate; MyDynamicDelegate.BindDynamic(this, &amp;AMyClass::MyFunction); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-종류"
  },"1048": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 바인딩 메서드",
    "content": "| 메서드 | 대상 유형 | 지원 Delegate 타입 | 자동 해제 | 용도/특징 | 주의점 | . | BindRaw | 일반 C++ 객체 | Single | X | 일반 포인터 대상, Raw C++ 객체 | 수명 관리 직접 필요 | . | AddRaw | 일반 C++ 객체 | Multi | X | 멀티캐스트 Delegate에 Raw 객체 바인딩 | 수명 관리 직접 필요 | . | BindUObject | UObject 파생 객체 | Single | O | Unreal UObject에 안전하게 바인딩 | GC 연동, 자동 해제 지원 | . | AddUObject | UObject 파생 객체 | Multi | O | 멀티캐스트 Delegate에 UObject 바인딩 | GC 연동, 자동 해제 지원 | . | BindSP | TSharedPtr 객체 | Single | O | TSharedPtr 기반 객체에 안전하게 바인딩 | WeakPtr로 자동 해제 | . | AddSP | TSharedPtr 객체 | Multi | O | 멀티캐스트 Delegate에 TSharedPtr 바인딩 | WeakPtr로 자동 해제 | . | BindLambda | 람다(익명함수) | Single | X | 임시 람다식 함수 직접 바인딩 | 캡처 객체 수명 주의 | . | AddLambda | 람다(익명함수) | Multi | X | 멀티캐스트 Delegate에 람다 함수 추가 | 캡처 객체 수명 주의 | . // Raw MyDelegate.BindRaw(this, &amp;FMyClass::Func); // this는 일반 C++ 객체 // UObject MyDelegate.BindUObject(this, &amp;UMyObject::Func); // this는 UObject 파생 클래스 // SharedPtr MyDelegate.BindSP(MySharedPtr, &amp;FMySharedClass::Func); // Lambda MyDelegate.BindLambda([](){ /* ... */ }); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-바인딩-메서드"
  },"1049": {
    "doc": "2. Extend Content Browser Menu",
    "title": "2. Extend Content Browser Menu",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/"
  },"1050": {
    "doc": "Create Custom Editor Tools",
    "title": "Create Custom Editor Tools",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . 참고 링크 . | AssetRegistry | EditorUtilityLibrary | FMessageDialog | SNotificationList | FSlateNotificationManager | ContentBrowser | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/"
  },"1051": {
    "doc": "C++ in UE",
    "title": "C++ in UE",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/"
  },"1052": {
    "doc": "C++ in UE",
    "title": "Setting up Visual Studio",
    "content": "비주얼 스튜디오 세팅하기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#setting-up-visual-studio",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#setting-up-visual-studio"
  },"1053": {
    "doc": "C++ in UE",
    "title": "지도 스크롤 사용",
    "content": ". | 상단의 도구 -&gt; 설정 | 텍스트 편집기 -&gt; 모든 언어 | 스크롤 막대 -&gt; 세로 스크롤 막대에 지도 모드 사용 체크 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%A7%80%EB%8F%84-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#지도-스크롤-사용"
  },"1054": {
    "doc": "C++ in UE",
    "title": "외부 종속성 숨기기",
    "content": ". | 텍스트 편집기 -&gt; C/C++ | 고급 -&gt; 검색/탐색 | 외부 종속성 폴더 숨기기 true 로 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%99%B8%EB%B6%80-%EC%A2%85%EC%86%8D%EC%84%B1-%EC%88%A8%EA%B8%B0%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#외부-종속성-숨기기"
  },"1055": {
    "doc": "C++ in UE",
    "title": "매크로 보기",
    "content": ". | 텍스트 편집기 -&gt; C/C++ | 뷰 -&gt; 비활성 코드 | 비활성 블록 표시 -&gt; False | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#매크로-보기"
  },"1056": {
    "doc": "C++ in UE",
    "title": "Classes and Inheritance",
    "content": "클래스 상속 다이어그램 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#classes-and-inheritance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#classes-and-inheritance"
  },"1057": {
    "doc": "C++ in UE",
    "title": "클래스에서 “Is A” VS “Has A”",
    "content": ". | Is A : 상속 관계 . | 예 : a Child is a Parent | 예 : a Child is not a Grandchild | . | Has A : 맴버 변수, 속성을 가지다 . | 예: a Package has a World | 예: a Level has Actors | . | . | 월드는 패키지의 서브 객체 | 레벨은 월드의 서브 객체 | 액터는 레벨의 서브 객체 | 컴포넌트는 액터의 서브 객체 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C-is-a-vs-has-a",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#클래스에서-is-a-vs-has-a"
  },"1058": {
    "doc": "C++ in UE",
    "title": "UE_LOG",
    "content": "로깅을 위한 핵심 매크로. UE_LOG 사용 시 로그 메시지를 파일에 자동으로 저장 . | 기본적으로 최대 10MB까지 기록되며, 초과 시 새 파일 생성 | . #define UE_LOG(LogCategory, Verbosity, Format, ...) \\ UE_LOG_IMPL(LogCategory, Verbosity, Format, ##__VA_ARGS__) . 사용 예시 . UE_LOG(LogTemp, Warning, TEXT(\"This is a warning message!\")); . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#ue_log",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#ue_log"
  },"1059": {
    "doc": "C++ in UE",
    "title": "주의 사항",
    "content": "1. TEXT() 매크로 필수 . | 모든 문자열 포맷 TEXT()로 감싸기 | . UE_LOG(..., TEXT(\"Value: %.2f\"), 123.456); // 올바른 사용 UE_LOG(..., \"Value: %.2f\", 123.456); //컴파일 오류 . 2. FString 전달 . | FString은 반드시 * 연산자로 역참조하기 FString Name = \"Unreal\"; UE_LOG(..., TEXT(\"Engine: %s\"), *Name); . | . 3. 소수점 자릿수 초과 시 반올림 . | 사용자가 지정한 n의 다음 자리에서 반올림 | . float Value = 1.23456f; // UE_LOG 출력 테스트 UE_LOG(LogTemp, Warning, TEXT(\"%.0f\"), Value); // 1 (1.2에서 반올림) UE_LOG(LogTemp, Warning, TEXT(\"%.1f\"), Value); // 1.2 (1.23에서 반올림) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#주의-사항"
  },"1060": {
    "doc": "C++ in UE",
    "title": "LOG 파일 경로",
    "content": ". | 개발 중 (에디터/게임 실행 시) . | 프로젝트루트/Saved/Logs/ 폴더 내에 생성 | 파일명 형식: 프로젝트명.log (예: MyProject.log) | . | 패키징된 빌드 (Shipping 빌드) . | Windows: %LOCALAPPDATA%\\[프로젝트명]\\Saved\\Logs\\ | Mac/Linux: ~/Library/Logs/[프로젝트명]/ 또는 ~/.config/[프로젝트명]/Logs/ | . | 크래시 로그 . | 크래시 발생 시 Saved/Crashes/ 폴더에 별도 로그 저장됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-%ED%8C%8C%EC%9D%BC-%EA%B2%BD%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-파일-경로"
  },"1061": {
    "doc": "C++ in UE",
    "title": "LOG 시스템 설정",
    "content": "1. 로그 파일 설정 . | DefaultEngine.ini | . [Core.Log] Global=Verbose // 기본 로그 레벨 설정 LogConsole=Warning // 콘솔 출력 레벨 LogFile=Log // 파일 기록 레벨 . 2. 런타임 로그 필터링 . // 특정 카테고리만 파일에 기록 (콘솔 명령어) Log LogMyCategory Verbose // 상세 기록 Log LogNoisyCategory Off // 해당 카테고리 기록 중지 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-시스템-설정"
  },"1062": {
    "doc": "C++ in UE",
    "title": "LogCategory 정리",
    "content": "| 카테고리 | 설명 | 사용 예시 | . | LogTemp | 임시 로깅용 (별도 정의 필요 없음) | UE_LOG(LogTemp, Warning, TEXT(“Temp message”)) | . | LogInit | 초기화 관련 로그 | UE_LOG(LogInit, Display, TEXT(“System initialized”)) | . | LogExit | 종료/해제 관련 로그 | UE_LOG(LogExit, Verbose, TEXT(“Resource released”)) | . | LogStreaming | 리소스 스트리밍 관련 | UE_LOG(LogStreaming, Display, TEXT(“Level streaming complete”)) | . | LogPhysics | 물리 시스템 관련 | UE_LOG(LogPhysics, Warning, TEXT(“Collision detected”)) | . | LogAI | AI 시스템 관련 | UE_LOG(LogAI, Verbose, TEXT(“Behavior tree updated”)) | . | LogAnimation | 애니메이션 시스템 | UE_LOG(LogAnimation, Error, TEXT(“Missing animation sequence”)) | . | LogNet | 네트워킹 관련 | UE_LOG(LogNet, Display, TEXT(“Packet received”)) | . | LogInput | 입력 시스템 관련 | UE_LOG(LogInput, Verbose, TEXT(“Controller input detected”)) | . | 사용자 정의 | DECLARE_LOG_CATEGORY_EXTERN으로 생성 | UE_LOG(LogMyGame, Log, TEXT(“Custom log”)) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#logcategory-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#logcategory-정리"
  },"1063": {
    "doc": "C++ in UE",
    "title": "Verbosity 정리",
    "content": "| 레벨 | 설명 | 출력 대상 | 사용 예시 | . | Fatal | 치명적 오류 (크래시 발생) | 모든 출력 | UE_LOG(…, Fatal, TEXT(“Critical failure”)) | . | Error | 복구 불가능한 오류 | 에디터/콘솔/파일 | UE_LOG(…, Error, TEXT(“Invalid object”)) | . | Warning | 경고 (문제 가능성) | 에디터/콘솔/파일 | UE_LOG(…, Warning, TEXT(“Deprecated function”)) | . | Display | 일반 정보 (기본 레벨) | 에디터/콘솔/파일 | UE_LOG(…, Display, TEXT(“Level loaded”)) | . | Log | 일반 디버그 정보 | 에디터/파일 | UE_LOG(…, Log, TEXT(“Debug value: %d”), Value) | . | Verbose | 상세 디버그 정보 | 파일 (기본 설정) | UE_LOG(…, Verbose, TEXT(“Detailed trace”)) | . | VeryVerbose | 매우 상세한 정보 | 파일 (필터링 시) | UE_LOG(…, VeryVerbose, TEXT(“Frame-by-frame data”)) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#verbosity-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#verbosity-정리"
  },"1064": {
    "doc": "C++ in UE",
    "title": "Format 정리",
    "content": "| 데이터 타입 | 포맷 스타일 | 사용 예시 | . | 기본 정수 | %d | UE_LOG(LogTemp, Display, TEXT(“Score: %d”), 42) | . | 8진수 | %o | UE_LOG(LogHex, Verbose, TEXT(“Octal: %o”), 42) | . | 16진수 (소문자) | %x | UE_LOG(LogHex, Verbose, TEXT(“Hex: 0x%x”), 255) | . | 16진수 (대문자) | %X | UE_LOG(LogHex, Verbose, TEXT(“Hex: 0x%X”), 255) | . | 부동소수점 (기본) | %f | UE_LOG(LogPhysics, Warning, TEXT(“Gravity: %f”), 9.8f) | . | 부동소수점 (고정) | %.2f | UE_LOG(LogMath, Display, TEXT(“PI: %.2f”), 3.141592) | . | 과학적 표기법 | %.3e | UE_LOG(LogSci, Log, TEXT(“Atomic: %.3e”), 0.000000123) | . | Bool (텍스트 변환) | %s + 삼항 연산자 | UE_LOG(LogSystem, Log, TEXT(“IsActive: %s”), bIsActive ? TEXT(“True”) : TEXT(“False”)) | . | 포인터 주소 | %p | UE_LOG(LogMemory, Warning, TEXT(“Ptr: %p”), MyObject) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#format-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#format-정리"
  },"1065": {
    "doc": "Operations on two matrices",
    "title": "Operations on two matrices",
    "content": "두 행렬에 대한 연산 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/"
  },"1066": {
    "doc": "Multiplying matrices and vectors",
    "title": "Multiplying matrices and vectors",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/",
    
    "relUrl": "/docs/Math/linear%20algebra/Multiplying%20matrices%20and%20vectors/"
  },"1067": {
    "doc": "Matrices as vectors",
    "title": "Matrices as vectors",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/"
  },"1068": {
    "doc": "Dot products, cross products",
    "title": "Dot products, cross products",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/",
    
    "relUrl": "/docs/Math/linear%20algebra/Dot%20products,%20cross%20products/"
  },"1069": {
    "doc": "Computer Graphics",
    "title": "Computer Graphics",
    "content": "참고하면 좋은 링크 . | GAMES101 : 현대 컴퓨터 그래픽 소개 | . ",
    "url": "/docs/Computer%20Graphics/",
    
    "relUrl": "/docs/Computer%20Graphics/"
  },"1070": {
    "doc": "HLSL",
    "title": "High-Level Shading Language (HLSL)",
    "content": "쉐이더 프로그래밍은 그래픽 렌더링 파이프라인에서 특정 단계를 프로그래밍하는 기술이다 . 각각의 쉐이더는 GPU에서 병렬로 실행되는 작은 프로그램이다 . | HLSL Reference | direct3dhlsl | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#high-level-shading-language-hlsl",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#high-level-shading-language-hlsl"
  },"1071": {
    "doc": "HLSL",
    "title": "쉐이더 종류",
    "content": ". | 정점 쉐이더 (Vertex Shader, VS) . | 입력: 3D 모델의 개별 정점 데이터 (위치, 색상, 노멀, 텍스처 좌표 등) | 역할: 정점의 위치를 모델 공간에서 클립 공간으로 변환 (필수 출력: SV_POSITION) | 출력: 변환된 정점 위치와 픽셀 쉐이더로 전달할 데이터 (보간될 값) | . | 테셀레이션 (Tessellation): 높은 디테일의 메시를 동적으로 생성 . | Hull Shader (HS): 패치(patch)의 분할 수준(tessellation factor)과 패치별 상수를 계산 | Tessellator (Fixed-Function): HS가 지정한 분할 수준에 따라 하드웨어에서 정점을 세분화 | Domain Shader (DS): 세분화된 각 점의 최종 위치를 계산 | . | 기하 쉐이더 (Geometry Shader, GS) . | 입력: 프리미티브(점, 선, 삼각형) 단위의 정점 데이터 | 역할: 프리미티브를 생성, 수정 또는 제거(예: 파티클 생성, 실루엣 렌더링) | 출력: 하나 이상의 프리미티브를 스트림으로 출력 | . | 픽셀 쉐이더 (Pixel Shader, PS / Fragment Shader) . | 입력: 래스터라이저에 의해 생성된 픽셀 조각(fragment)과 VS에서 보간된 데이터 | 역할: 각 픽셀의 최종 색상을 계산 (예: 텍스처 샘플링, 조명 계산) | 출력: 최종 픽셀 색상 (SV_Target) | . | 컴퓨트 쉐이더 (Compute Shader, CS) . | 역할: 렌더링 파이프라인과 독립적으로 범용 병렬 계산(GPGPU)을 수행 | Dispatch 호출로 실행 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#%EC%89%90%EC%9D%B4%EB%8D%94-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#쉐이더-종류"
  },"1072": {
    "doc": "HLSL",
    "title": "쉐이더 프로젝트 구조",
    "content": "MyGame/ ├─ Assets/ │ └─ Textures/ … ├─ Shaders/ │ ├─ Common.hlsli // 공통 상수·구조체 │ ├─ BasicVS.hlsl // 정점 쉐이더 │ ├─ BasicPS.hlsl // 픽셀 쉐이더 │ ├─ Lighting.hlsli // 라이트 계산 공통 함수 │ └─ PostProcess/ │ └─ BloomCS.hlsl ├─ Src/ │ ├─ Renderer.cpp // D3D 초기화·리소스 관리 │ └─ ShaderManager.cpp // 컴파일·캐시·Hot-Reload └─ BuildScripts/ // fxc/dxc 오프라인 컴파일 배치 . | .hlsli : 여러 쉐이더 간 공유되는 struct, 함수, 매크로를 정의하는 헤더 파일 | .cso : 빌드 단계에서 생성되는 컴파일된 쉐이더 바이트 코드 | ShaderManager : 런타임에서 .cso를 읽어 CreateVertexShader, CreatePixelShader 등의 D3D 함수를 호출하여 쉐이더 객체를 생성 . | 개발 중에는 파일 타임스탬프를 감지하여 핫 리로딩(Hot Reloading)을 지원 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#%EC%89%90%EC%9D%B4%EB%8D%94-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#쉐이더-프로젝트-구조"
  },"1073": {
    "doc": "HLSL",
    "title": "GPU와 CPU의 역할 분담 및 쉐이더 실행 흐름 이해",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/#gpu%EC%99%80-cpu%EC%9D%98-%EC%97%AD%ED%95%A0-%EB%B6%84%EB%8B%B4-%EB%B0%8F-%EC%89%90%EC%9D%B4%EB%8D%94-%EC%8B%A4%ED%96%89-%ED%9D%90%EB%A6%84-%EC%9D%B4%ED%95%B4",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#gpu와-cpu의-역할-분담-및-쉐이더-실행-흐름-이해"
  },"1074": {
    "doc": "HLSL",
    "title": "CPU (애플리케이션)",
    "content": ". | 리소스 생성 및 관리: . | 버퍼 생성: 정점 버퍼(Vertex Buffer), 인덱스 버퍼(Index Buffer), 상수 버퍼(Constant Buffer) 등을 생성하고 데이터를 채움 | 텍스처 로딩: 텍스처 파일을 읽어 GPU 메모리에 텍스처 리소스를 생성 | 쉐이더 컴파일: D3DCompileFromFile과 같은 함수를 사용해 HLSL 코드를 바이트 코드로 컴파일 | . | 파이프라인 상태 설정 (Pipeline State Objects, PSOs): . | 입력 레이아웃 (Input Layout): 정점 버퍼의 데이터 구조가 VS의 입력 시그니처와 어떻게 매핑되는지 정의 | 쉐이더 바인딩: VSSetShader, PSSetShader 등으로 각 파이프라인 단계에 사용할 쉐이더를 설정 | 리소스 뷰 바인딩: PSSetShaderResources (SRV), OMSetRenderTargets (RTV) 등으로 쉐이더가 접근할 리소스 뷰를 바인딩 | 기타 상태 설정: 래스터라이저 상태(culling, fill mode), 블렌드 상태, 깊이/스텐실 상태 등을 설정 | . | 렌더링 명령 (Draw Calls): . | 상수 버퍼 업데이트: UpdateSubresource 또는 Map/Unmap을 통해 월드/뷰/프로젝션 행렬과 같은 데이터를 상수 버퍼에 업데이트 | 드로우 콜: DrawIndexed 또는 Draw를 호출하여 GPU에 렌더링 작업을 명령 | 이 명령은 커맨드 버퍼에 기록됨 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#cpu-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#cpu-애플리케이션"
  },"1075": {
    "doc": "HLSL",
    "title": "GPU",
    "content": ". | 커맨드 버퍼 처리: CPU가 보낸 명령들을 비동기적으로 처리 | 파이프라인 실행: . | 입력 조립기 (Input Assembler): 정점/인덱스 버퍼에서 데이터를 읽어 프리미티브를 조립 | 정점 쉐이더 (VS): 각 정점을 처리 | (테셀레이션/기하 쉐이더): (활성화된 경우) 실행 | 래스터라이저 (Rasterizer): 프리미티브를 픽셀 조각(fragment)으로 변환 | 픽셀 쉐이더 (PS): 각 픽셀 조각의 색상을 계산 | 출력 병합기 (Output Merger): 픽셀 쉐이더의 결과를 렌더 타겟 뷰(RTV)에 쓰고, 깊이/스텐실 테스트를 수행 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#gpu",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#gpu"
  },"1076": {
    "doc": "HLSL",
    "title": "초기화 단계 (보통 로딩 시 한 번)",
    "content": ". | 쉐이더를 컴파일해서 GPU에 올리는 과정 | . | 파일 읽기 및 컴파일 (CPU) . | D3DCompileFromFile() 같은 함수로 .hlsl 쉐이더 소스 코드를 읽어 바이트 코드(Bytecode)로 컴파일 | 이 바이트 코드는 아직 CPU의 메모리에 있음 | . | 쉐이더 객체 생성 (CPU -&gt; GPU) . | CreateVertexShader(), CreatePixelShader() 같은 함수 호출 | 이 함수들은 컴파일된 바이트 코드를 GPU 드라이버에 전달 | . | GPU 메모리에 저장 . | 드라이버는 이 바이트 코드를 받아서 GPU가 직접 실행할 수 있는 형태로 변환하고 GPU 메모리의 특정 공간에 저장 | . | 핸들(Handle) 반환 . | GPU는 쉐이더를 가리키는 일종의 ‘포인터’ 또는 ‘참조 ID’를 CPU에게 돌려줌 (예: ID3D11VertexShader* 객체) | CPU는 무거운 바이트 코드 덩어리 대신, 이 가벼운 핸들(포인터)를 가지고 쉐이더를 제어 | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#%EC%B4%88%EA%B8%B0%ED%99%94-%EB%8B%A8%EA%B3%84-%EB%B3%B4%ED%86%B5-%EB%A1%9C%EB%94%A9-%EC%8B%9C-%ED%95%9C-%EB%B2%88",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#초기화-단계-보통-로딩-시-한-번"
  },"1077": {
    "doc": "HLSL",
    "title": "렌더링 루프 단계 (매 프레임 반복)",
    "content": ". | 매 프레임마다 오브젝트를 그릴 때 일어나는 과정 | . | 파이프라인 상태 설정 (State Binding) . | Draw()를 호출하기 전에, CPU는 DirectX API를 통해 GPU에게 “이번에 그림을 그릴 때 사용할 도구들은 이것들이야” 라고 미리 알림 (인풋 레이아웃 설정 / 버퍼 설정) . | IASetInputLayout(…): “정점 데이터는 이런 형식으로 들어올 거야.” | IASetVertexBuffers(…): “정점 데이터는 저기 있는 버퍼에서 가져다 써.” | VSSetShader(…), PSSetShader(…): “이번 그리기에 쓸 정점 쉐이더는 아까 만들어 둔 A번 쉐이더(핸들)고, 픽셀 쉐이더는 B번 쉐이더(핸들)야.” | PSSetShaderResources(…): “픽셀 쉐이더가 쓸 텍스처는 저기 있는 C번 텍스처야.” | VSSetConstantBuffers(…): “월드/뷰/프로젝션 행렬 같은 데이터는 저기 D번 상수 버퍼에서 가져다 써.” | . | . | 그리기 명령 (Draw Call) . | 모든 설정이 끝나면, CPU는 마침내 DrawIndexed() 또는 Draw()를 호출 | 이 호출의 의미는 “GPU 너가 일할 차례야. 방금 내가 세팅해 준 그 상태 그대로, 정점 3,000개 그려!” 라는 ‘실행 트리거’ | . | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%A3%A8%ED%94%84-%EB%8B%A8%EA%B3%84-%EB%A7%A4-%ED%94%84%EB%A0%88%EC%9E%84-%EB%B0%98%EB%B3%B5",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#렌더링-루프-단계-매-프레임-반복"
  },"1078": {
    "doc": "HLSL",
    "title": "GPU의 작업 실행",
    "content": ". | 명령 수신 . | GPU는 CPU로부터 Draw 명령을 받음 | . | 상태 확인 . | GPU는 현재 파이프라인에 바인딩된 쉐이더, 버퍼, 텍스처 등을 확인 | . | 계산 수행 . | 바인딩된 정점 버퍼에서 데이터를 가져와, 바인딩된 정점 쉐이더(의 바이트 코드)를 실행하여 정점들을 변환 | 그리고 이어서 픽셀 쉐이더 등 나머지 파이프라인 단계를 실행하여 최종 픽셀 색상을 계산 | . | . 참고하면 좋은 링크 . | Real-Time Rendering Resources | The Book of Shaders | Processing | OGL Dev | . ",
    "url": "/docs/Computer%20Graphics/HLSL/#gpu%EC%9D%98-%EC%9E%91%EC%97%85-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/#gpu의-작업-실행"
  },"1079": {
    "doc": "HLSL",
    "title": "HLSL",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/"
  },"1080": {
    "doc": "ToonShader",
    "title": "ToonShader",
    "content": "HLSL로 툰 쉐이더를 구현해보자 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ToonShader/",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ToonShader/"
  },"1081": {
    "doc": "Realistic Landscapes",
    "title": "Realistic Landscapes",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/"
  },"1082": {
    "doc": "Learn the basics",
    "title": "Learn the basics",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/"
  },"1083": {
    "doc": "ResterTekTutorial",
    "title": "ResterTekTutorial",
    "content": "directX 11 tutorial . 참고 링크 . | Direct3D 11.3 Functional Specification | RasterTek | DirectX 11 - Braynzar Soft Tutorials | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/"
  },"1084": {
    "doc": "ResterTekTutorial",
    "title": "Linear Mapping (선형 변환)",
    "content": "한 범위 안에 있는 값의 상대적인 위치를 그대로 유지하면서 다른 범위로 옮기는 과정 . | 예 : [0, 255] 범위의 중간 값인 127.5는 [-1, 1] 범위로 변환했을 때도 정확히 중간 값인 0 | 값들 사이의 비례 관계가 직선(linear)처럼 유지된다고 해서 선형 변환 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#linear-mapping-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#linear-mapping-선형-변환"
  },"1085": {
    "doc": "ResterTekTutorial",
    "title": "Linear Mapping 공식 유도 과정",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#linear-mapping-%EA%B3%B5%EC%8B%9D-%EC%9C%A0%EB%8F%84-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#linear-mapping-공식-유도-과정"
  },"1086": {
    "doc": "ResterTekTutorial",
    "title": "변수 정의",
    "content": ". | 변환하려는 값: \\(x\\) | 원본 범위: \\([A_{min}, A_{max}]\\) | 목표 범위: \\([B_{min}, B_{max}]\\) | 최종 변환된 값: \\(x'\\) | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#%EB%B3%80%EC%88%98-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#변수-정의"
  },"1087": {
    "doc": "ResterTekTutorial",
    "title": "1단계: 원본 범위의 값을 [0, 1] 범위로 정규화하기",
    "content": ". 먼저, 값 \\(x\\)가 원본 범위 \\([A_{min}, A_{max}]\\) 내에서 차지하는 상대적인 비율(0~1 사이의 값)을 구한다 . 1. 범위를 0에서 시작하도록 평행이동 . | 값 \\(x\\)에서 시작점 \\(A_{min}\\)을 빼서, 범위의 시작을 0으로 만든다 | 이렇게 하면 값의 범위는 \\([0, A_{max} - A_{min}]\\) 이 됨 | . \\[x - A_{min}\\] . 예 : 범위 [100, 200], x = 150 (중간값) . | \\(x - A_{min} = 150 - 100 = 50\\), x는 여전히 중간 값 | 바뀐 범위 [0, 100] | . 2. 범위의 전체 길이로 나누어 비율 계산 . | 위에서 얻은 값을 범위의 전체 길이 \\((A_{max} - A_{min})\\)로 나누어 0과 1 사이의 비율로 만든다 | 이 값을 t라고 하자 | . \\[t = \\frac{x - A_{min}}{A_{max} - A_{min}}\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#1%EB%8B%A8%EA%B3%84-%EC%9B%90%EB%B3%B8-%EB%B2%94%EC%9C%84%EC%9D%98-%EA%B0%92%EC%9D%84-0-1-%EB%B2%94%EC%9C%84%EB%A1%9C-%EC%A0%95%EA%B7%9C%ED%99%94%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#1단계-원본-범위의-값을-0-1-범위로-정규화하기"
  },"1088": {
    "doc": "ResterTekTutorial",
    "title": "2단계: [0, 1] 범위의 값을 목표 범위로 확장하기",
    "content": ". 1단계에서 구한 비율 t를 사용해 목표 범위 \\([B_{min}, B_{max}]\\) 에서의 실제 값을 계산 . 1. 목표 범위의 길이만큼 스케일링 . 비율 t에 목표 범위의 전체 길이 \\((B_{max} - B_{min})\\) 를 곱함 . \\[t \\times (B_{max} - B_{min})\\] . | 이 값은 목표 범위가 0에서 시작한다고 가정했을 때의 상대적인 위치 | . 2. 목표 범위의 시작점에 맞게 평행이동 . 위에서 계산한 값에 목표 범위의 시작점 \\(B_{min}\\)을 더해 최종 위치 찾기 . \\[x' = (t \\times (B_{max} - B_{min})) + B_{min}\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#2%EB%8B%A8%EA%B3%84-0-1-%EB%B2%94%EC%9C%84%EC%9D%98-%EA%B0%92%EC%9D%84-%EB%AA%A9%ED%91%9C-%EB%B2%94%EC%9C%84%EB%A1%9C-%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#2단계-0-1-범위의-값을-목표-범위로-확장하기"
  },"1089": {
    "doc": "ResterTekTutorial",
    "title": "최종 공식: 두 단계를 하나로 합치기",
    "content": "2단계 공식의 t 자리에 1단계에서 구한 공식을 그대로 대입하면, 선형 변환을 위한 최종 공식이 완성 . \\[x' = \\left( \\frac{x - A_{min}}{A_{max} - A_{min}} \\right) \\times (B_{max} - B_{min}) + B_{min}\\] . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#%EC%B5%9C%EC%A2%85-%EA%B3%B5%EC%8B%9D-%EB%91%90-%EB%8B%A8%EA%B3%84%EB%A5%BC-%ED%95%98%EB%82%98%EB%A1%9C-%ED%95%A9%EC%B9%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#최종-공식-두-단계를-하나로-합치기"
  },"1090": {
    "doc": "ResterTekTutorial",
    "title": "예제",
    "content": "\\[x' = c + \\frac{(x - a)(d - c)}{b - a}\\] . | [a, b] = 원래 범위 | [c, d] = 바꿀 범위 (위 공식 유도의 B식을 분자로 옮긴것) | x = 변환할 원래 값 | x’ = 변환된 값 | . 1. [0 ~ 255] → [0 ~ 1] . | 원래 범위: [a, b] = [0, 255] | 새 범위: [c, d] = [0, 1] | . \\[x' = 0 + \\frac{(x - 0)(1 - 0)}{255 - 0}\\] \\[= \\frac{x}{255}\\] 즉 x / 255 . 2. [0 ~ 800] → [-1 ~ 1] . | 원래 범위: [a, b] = [0, 800] | 새 범위: [c, d] = [-1, 1] | . \\[x' = -1 + \\frac{(x - 0)(1 - (-1))}{800 - 0}\\] \\[= -1 + \\frac{x \\cdot 2}{800}\\] \\[= -1 + \\frac{x}{400}\\] 즉 -1 + x / 400 . 알아두기 . | \\(A_{min} = A_{max}\\) 면 정의 불가 | 범위를 거꾸로 넣으면 (예: \\(A_{max} &lt; A_{min}\\)) 부호 반전으로 역순 매핑 | . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#%EC%98%88%EC%A0%9C",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#예제"
  },"1091": {
    "doc": "ResterTekTutorial",
    "title": "Lerp (선형 보간) 와 관계",
    "content": "선형 변환 공식은 컴퓨터 그래픽스에서 매우 중요한 선형 보간(Linear Interpolation, Lerp)과 사실상 동일한 구조 . (시작값 + (끝값 - 시작값) * t) . \\(Lerp(a,b,t) = a + (b−a) \\cdot t\\) . | “시작값 + 변화량” 구조라 직관적 | 그래픽스 API, 게임 엔진에서 이 형태를 많이 씀 | . (시작값 * (1 - t) + 끝값 * t) . \\(Lerp(a,b,t) = a(1 - t) + bt\\) . | 가중 평균(weighted average) 구조라 의미가 명확 | t = 0 이면 a 100%, t = 1 이면 t 100% | 그 사이 값은 a와 b의 가중치 합으로 해석 가능 | 수치 해석, 보간, 혼합(blending) 설명할 때 자주 씀 | . | 우리가 유도한 \\(x' = ( B_{min} + (B_{max} - B_{min})) \\cdot t\\) 는 Lerp(B_min, B_max, t) 와 같음 | . 즉 선형 변환은 어떤 값의 원본 범위 내 상대적 위치(t)를 계산한 뒤 그 위치(t)를 이용해 목표 범위 내의 값을 선형 보간하는 과정이라고 정의할 수 있다 . ",
    "url": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#lerp-%EC%84%A0%ED%98%95-%EB%B3%B4%EA%B0%84-%EC%99%80-%EA%B4%80%EA%B3%84",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/ResterTekTutorial/#lerp-선형-보간-와-관계"
  },"1092": {
    "doc": "UE4 Materials 101",
    "title": "UE4 Materials 101",
    "content": "강의 영상 보면서 메모 . | Unreal Material Editor - Unreal Materials 101 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/UE4%20Materials%20101/"
  },"1093": {
    "doc": "directXTutorial",
    "title": "directXTotorial",
    "content": "direct3D 11 tutorial . 참고 링크 . | DirectX Tutorial | rastertek | . ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/#directxtotorial",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/#directxtotorial"
  },"1094": {
    "doc": "directXTutorial",
    "title": "directXTutorial",
    "content": " ",
    "url": "/docs/Computer%20Graphics/HLSL/directXTutorial/",
    
    "relUrl": "/docs/Computer%20Graphics/HLSL/directXTutorial/"
  },"1095": {
    "doc": "Graphics rendering pipeline",
    "title": "Graphics rendering pipeline",
    "content": "3D 좌표로 표현된 기하학적 객체의 장면을 2D 디스플레이에 렌더링하는 데 필요한 일련의 단계 . 참고 링크 . | Graphics Programming Compendium | a trip through the graphics pipeline | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/"
  },"1096": {
    "doc": "Graphics rendering pipeline",
    "title": "아핀 변환",
    "content": ". | 선형 변환(Linear Transformation)과 평행 이동(Translation)을 결합한 변환 | 기하학적 특성 보존: . | 직선성 유지 (직선 → 직선) | 평행성 유지 (평행선 → 평행선) | 중심점 보존 (무게중심 보존) | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EC%95%84%ED%95%80-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#아핀-변환"
  },"1097": {
    "doc": "Graphics rendering pipeline",
    "title": "주요 변환 유형",
    "content": "| 변환 유형 | 설명 | 특징 | . | 이동(Translation) | 객체 위치 변경 | 방향/크기 불변 | . | 회전(Rotation) | 각도 θ만큼 회전 | 거리 보존 | . | 크기 변환(Scaling) | 축별 크기 조정 | \\(s_x, s_y\\) 배율 | . | 대칭(Reflection) | 축에 대한 반사 | 행렬식 = -1 | . | 전단(Shear) | 층밀림 효과 | 각도 변화 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EC%A3%BC%EC%9A%94-%EB%B3%80%ED%99%98-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#주요-변환-유형"
  },"1098": {
    "doc": "Graphics rendering pipeline",
    "title": "정의",
    "content": ". \\[\\vec{y} = A\\vec{x} + \\vec{b}\\] . | A : 선형 변환을 나타내는 행렬 | \\(\\vec{b}\\) : 평행이동(translation) 벡터 | \\(\\vec{x}\\) : 입력 벡터 (좌표) | \\(\\vec{y}\\) : 변환된 출력 벡터 | . \\[\\begin{aligned} \\begin{bmatrix} x' \\\\ y' \\end{bmatrix} &amp;= \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} + \\begin{bmatrix} e \\\\ f \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix} a x + b y + e \\\\ c x + d y + f \\end{bmatrix} \\end{aligned}\\] . | \\(\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}\\) : 선형 변환을 나타내는 행렬 (아핀 변환 행렬) | \\(\\begin{bmatrix} x \\\\ y \\end{bmatrix}\\) : 입력 벡터 | \\(\\begin{bmatrix} e \\\\ f \\end{bmatrix}\\) : 평행 이동 벡터 | \\(\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\\) : 변환된 출력 벡터 | . 참고하면 좋은 링크 . | 아핀 변환 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#정의"
  },"1099": {
    "doc": "Graphics rendering pipeline",
    "title": "homogeneous coordinates (동차 좌표)",
    "content": ". | 아핀변환을 행렬 곱셈 하나로 표현하기 위해 도입된 확장 좌표계 | n차원 공간의 점을 n+1차원 공간의 벡터로 확장하여 표현하는 방식 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#homogeneous-coordinates-%EB%8F%99%EC%B0%A8-%EC%A2%8C%ED%91%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#homogeneous-coordinates-동차-좌표"
  },"1100": {
    "doc": "Graphics rendering pipeline",
    "title": "동차좌표가 필요한 이유",
    "content": ". | 문제점 : 기존의 2×2 행렬 곱셈 만으로는 이동(translation) 변환을 행렬 곱셈으로 표현할 수 없다 | . \\[\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\\] . | 이동 변환을 (예 : \\(x' = x + t_x, \\ y' = y + t_y\\)) 위 수식으로 표현 불가 | . | 따라서 좌표를 한 차원 올려 3차원 벡터 (x,y,1)로 보고 | 3×3 행렬 곱셈으로 이동/회전/스케일/전단 등을 한 번에 처리 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EB%8F%99%EC%B0%A8%EC%A2%8C%ED%91%9C%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#동차좌표가-필요한-이유"
  },"1101": {
    "doc": "Graphics rendering pipeline",
    "title": "동차 좌표에서 점(Point) vs 방향 벡터(Direction)",
    "content": "w의 값에 따라 점이냐 벡터냐를 알 수 있다 . | 기하학적 의미 차이 | . | 구분 | 동차좌표 표현 | 의미 | w 성분 | . | 점 | (x,y,1) | 공간의 특정 위치 | w = 1 | . | 방향 벡터 | (x,y,0) | 크기와 방향만 가짐 (위치 없음) | w = 0 | . | 점 : “어디에 있는가?” → 위치 정보 포함 | . \\[\\text{예: } (3, 4, 1) = \\text{좌표 (3,4)}\\] . | 방향 벡터 : “어느 방향인가?” → 이동 가능성만 표현 | . \\[\\text{예: } (1, -2, 0) = \\text{오른쪽+아래 방향}\\] . 아핀 변환의 동차좌표 표현 (2D) . \\[T = \\begin{bmatrix} A &amp; \\mathbf{b} \\\\ \\mathbf{0}^T &amp; 1 \\end{bmatrix} = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_{1} \\\\ a_{21} &amp; a_{22} &amp; b_{2} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . | \\(T\\) : \\(\\ \\vec{y} = A\\vec{x} + \\vec{b}\\) 꼴을 동차좌표계에서 표현한 아핀 변환 행렬 | \\(A \\in \\mathbb{R}^{2\\times2}\\) : 회전, 스케일, 전단, 대칭 등 선형 변환 | \\(\\mathbf{b} \\in \\mathbb{R}^{2}\\) : 이동(translation) 벡터 | \\(\\mathbf{0}^T = [0\\;0]\\) : 이동을 w성분으로 제어하기 위해 필요한 마지막 행 | . 점(Point) vs 방향 벡터(Direction) . | 점(point): \\((x, y, 1)^T\\) | 방향 벡터(direction): \\((v_x, v_y, 0)^T\\) | . 점에 적용: . \\[T \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} A\\begin{bmatrix}x \\\\ y\\end{bmatrix} + \\mathbf{b} \\\\ 1 \\end{bmatrix}\\] 방향 벡터에 적용: . \\[T \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} A\\begin{bmatrix}v_x \\\\ v_y\\end{bmatrix} \\\\ 0 \\end{bmatrix}\\] 핵심: 동일한 행렬 (T)를 써도, (w=1)이면 이동이 적용되고 (w=0)이면 이동이 자동으로 사라짐 . 예시 1: 순수 이동 . \\[T_{\\text{trans}} = \\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] 점: . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{bmatrix}\\] 방향 벡터: . \\[\\begin{bmatrix} v_x' \\\\ v_y' \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\end{bmatrix}\\] . 예시 2: 순수 회전(원점 기준) . \\[R(\\theta) = \\begin{bmatrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] 점: . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x\\cos\\theta - y\\sin\\theta \\\\ x\\sin\\theta + y\\cos\\theta \\\\ 1 \\end{bmatrix}\\] 방향 벡터: . \\[\\begin{bmatrix} v_x' \\\\ v_y' \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} v_x\\cos\\theta - v_y\\sin\\theta \\\\ v_x\\sin\\theta + v_y\\cos\\theta \\\\ 0 \\end{bmatrix}\\] . 예시 3: 임의의 점 (p_0=(p_x,p_y)) 주변 회전 . \\[T = T_{+p_0} \\; R(\\theta) \\; T_{-p_0}\\] . | 여기서 (T_{\\pm p_0})는 평행이동 행렬 | 결과 행렬의 (\\mathbf{b}\\neq 0): 점에는 이동+회전, 방향 벡터에는 회전만 적용 | . 물리적 해석 . | 점과 점 빼기 → 방향벡터 생성 | . \\[(x_2,y_2,1) - (x_1,y_1,1) = (x_2-x_1, y_2-y_1, 0)\\] . | 점 + 방향벡터 → 새로운 점 | . \\[(x,y,1) + (a,b,0) = (x+a, y+b, 1)\\] . 실제 적용 사례 . 3D 그래픽스에서 활용되는 예시 . | 점 : 객체의 월드 좌표 위치 | . \\[\\text{예: 삼각형의 꼭짓점 } (x,y,z,1)\\] . | 방향벡터 : 빛의 방향/법선 벡터 | . \\[\\text{예: 조명 방향 } (dx,dy,dz,0)\\] 방향벡터를 w=1로 설정하면 이동 변환 시 의도치 않은 왜곡이 발생한다 . ❓ 동차좌표에서 점과 방향 벡터를 왜 구분해야 해? . | 변환의 물리적 정확성: 이동 변환 시 방향은 불변해야 함 | 기하학적 연산의 명확성: 점-벡터 연산 규칙 보장 (예: 점 - 점 = 벡터) | 렌더링 시스템의 안정성: 3D 엔진에서 광원, 법선 등 방향성 데이터 오염 방지 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EB%8F%99%EC%B0%A8-%EC%A2%8C%ED%91%9C%EC%97%90%EC%84%9C-%EC%A0%90point-vs-%EB%B0%A9%ED%96%A5-%EB%B2%A1%ED%84%B0direction",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#동차-좌표에서-점point-vs-방향-벡터direction"
  },"1102": {
    "doc": "Graphics rendering pipeline",
    "title": "아핀변환의 동차좌표 표현",
    "content": ". | 2D 예시 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} a &amp; b &amp; e \\\\ c &amp; d &amp; f \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EC%95%84%ED%95%80%EB%B3%80%ED%99%98%EC%9D%98-%EB%8F%99%EC%B0%A8%EC%A2%8C%ED%91%9C-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#아핀변환의-동차좌표-표현"
  },"1103": {
    "doc": "Graphics rendering pipeline",
    "title": "아핀변환 예시",
    "content": ". | 평행 이동(Translation) : x축으로 \\(t_x\\), y축으로 \\(t_y\\) 만큼 이동 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . \\[\\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x+t_x \\\\ y+t_y \\\\ 1 \\end{bmatrix}\\] . | 회전 (Rotation) : 원점을 중심으로 \\(\\theta\\) 만큼 회전 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x\\cosθ - y\\sinθ \\\\ x\\sinθ + y\\cosθ \\\\ 1 \\end{bmatrix}\\] . | 크기 조절 (Scaling) : x축으로 \\(s_x\\) 배, y축으로 \\(s_y\\) 배 확대/축소 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} s_x &amp; 0 &amp; 0 \\\\ 0 &amp; s_y &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} s_x x \\\\ s_y y \\\\ 1 \\end{bmatrix}\\] . | 전단(Shear) : x축 방향으로 k만큼 전단 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; k &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x + k y \\\\ y \\\\ 1 \\end{bmatrix}\\] . | 대칭(Reflection) : x축에 대한 대칭 | . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; -1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}\\] . \\[\\begin{bmatrix} x' \\\\ y' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\\\ - y \\\\ 1 \\end{bmatrix}\\] . | 아핀변환 조합 : 여러 아핀변환을 연속적으로 적용할 때는 행렬을 곱하여 하나의 변환 행렬로 결합 가능 . | 열벡터 기준 오른쪽의 \\(T_1\\) 이 먼저 적용 | . | . \\[T_{\\text{total}} = T_n \\cdots T_2 T_1\\] . 참고하면 좋은 링크 . | 동차 좌표계 | 렌더링 파이프라인에서 왜 동차 좌표계를 쓸까 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#%EC%95%84%ED%95%80%EB%B3%80%ED%99%98-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/#아핀변환-예시"
  },"1104": {
    "doc": "Computer architecture",
    "title": "Computer architecture",
    "content": ". | SRISHTI:Computer Architecture | . ",
    "url": "/docs/Computer%20architecture/",
    
    "relUrl": "/docs/Computer%20architecture/"
  },"1105": {
    "doc": "Material",
    "title": "Material",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/"
  },"1106": {
    "doc": "Material",
    "title": "All-in-One Master",
    "content": "하나의 거대한 마스터 머티리얼 안에 프로젝트에 필요한 모든 기능 (바람, 투명, 피부, 코팅 등)을 전부 다 넣어두는 방식. 스위치(Switch) 파라미터를 이용해 필요한 기능만 켜고 끄는 방식으로 사용 . | 장점 . | 유연성: 마스터 머티리얼이 단 하나이므로 어떤 인스턴스든 모든 기능에 접근할 수 있다. 예를 들어 MI_Stone 인스턴스에서 갑자기 ‘바람에 흔들리는’ 스위치를 켜서 특이한 효과를 만들 수도 있다 | 단순한 파일 구조: 관리할 마스터 머티리얼 파일이 하나뿐 | . | 단점: . | 성능 저하: 가장 치명적인 단점입니다. 기능 스위치를 껐다고 해서 해당 기능의 셰이더 코드가 완전히 사라지는 것이 아닙니다. 최종적으로 컴파일된 셰이더는 사용하지 않는 기능을 포함한 모든 코드를 짊어지고 있어 매우 무겁고 비효율. 이는 셰이더 복잡도(Shader Complexity)를 높여 게임 전체의 성능을 저하시키는 주된 원인 | 복잡성: 마스터 머티리얼의 노드 그래프가 수백, 수천 개에 달할 수 있어 ‘스파게티’처럼 얽히게 됨. 한 사람이 관리하기 어려워지며, 수정 시 얘기치 못한 부분에서 문제가 발생할 위험이 큼. | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/#all-in-one-master",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/#all-in-one-master"
  },"1107": {
    "doc": "Material",
    "title": "Specialized Masters",
    "content": "기능적으로나 시각적으로 뚜렷하게 구분되는 재질의 ‘종류’마다 별도의 마스터 머티리얼 만들기 . [ M_Surface ] (기본 기능) ├─ MI_OakWood ├─ MI_SteelMetal └─ MI_RoughStone [ M_Foliage ] (기본 기능 + '바람' 기능) ├─ MI_Grass └─ MI_TreeLeaves [ M_CharacterSkin ] (기본 기능 + '피부' 기능) ├─ MI_HeroFace └─ MI_MonsterArm . 마스터 머티리얼을 재질별로 만들어보자 . 만들어야 할 마스터 머티리얼 목록 . | M_Surface,M_Foliage, M_CharacterSkin, M_Transparent(glass), M_CarPaint | . ",
    "url": "/docs/Unreal%20Engine%205/Material/#specialized-masters",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/#specialized-masters"
  },"1108": {
    "doc": "Rendering pipeline",
    "title": "Rendering pipeline",
    "content": "UE5 렌더링 파이프라인 정리하기 . 참고하면 좋은 링크 . | Rendering pipeline UE5 | UE4 Graphics Profiling: All Categories Guide (Rendering Passes) | GPU and Rendering Pipelines | Unreal’s Rendering Passes | Interplay of Light | Gamedev Guide | . 나중에 옮기기 . | hierarchical-depth-buffers | Precomputed Atmospheric Scattering: a New Implementation | visibility-and-occlusion-culling | lumen-technical-details | dynamic-global-illumination-with-lumen | 언리얼 엔진 5 루멘의 메커니즘과 중요한 부분 - 번역 | 언리얼 엔진 5 루멘의 메커니즘과 중요한 부분 - original | . ",
    "url": "/docs/Unreal%20Engine%205/Rendering%20pipeline/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Rendering%20pipeline/"
  },"1109": {
    "doc": "GPU Architecture",
    "title": "GPU Architecture",
    "content": "GPU에서 실행되는 애플리케이션 프로그램을 준비할 때 GPU 하드웨어 설계의 주요 기능을 이해하고 CPU와의 유사점과 차이점을 파악하고자 한다. | 참고링크 Conrnell Virtual Workshop | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/"
  },"1110": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/C++/",
    
    "relUrl": "/docs/C++/"
  },"1111": {
    "doc": "C++",
    "title": "스마트 포인터",
    "content": ". | C++11부터 표준 라이브러리에 포함됨 | raw pointer보다 스마트 포인터 사용이 권장됨 | 상황에 맞는 스마트 포인터를 선택하고, 반드시 소유권 규칙을 명확히 해야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/C++/#스마트-포인터"
  },"1112": {
    "doc": "C++",
    "title": "스마트 포인터 종류",
    "content": "1. std::unique_ptr . | 단일 소유권(Exclusive ownership): 오직 하나의 포인터만 객체를 소유 | 소유자가 사라질 때(포인터 scope 종료, 소멸자 호출 등) 자동으로 자원 해제 | 복사가 금지되어 있고, 소유권 이동은 move(이동)만 허용 | 용도: 소유권 이전(transfer)이 명확하고, 참조 카운팅이 필요 없는 객체 | . #include &lt;memory&gt; void func() { std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42); // std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 컴파일 에러! 복사 불가 std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1); // 소유권 이동 } . 2. std::shared_ptr . | 공유 소유권(Shared ownership): 여러 개의 포인터가 동일한 객체를 소유 | 내부적으로 참조 카운트(reference count) 관리 . | (카운트가 0이 되면 자원 해제) | . | 용도: 여러 곳에서 동시에 객체를 소유/관리해야 할 때 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42); std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 복사 가능, 참조 카운트 증가 // ptr1과 ptr2가 모두 소멸되면 메모리 해제 } . 3. std::weak_ptr . | 비소유 참조(Non-owning reference): shared_ptr로 관리되는 객체를 참조하지만, 참조 카운트에는 관여하지 않음 | 주로 순환 참조(circular reference) 방지 목적 | 용도: shared_ptr들 사이에서 서로 참조(특히 그래프, 트리 등)할 때 메모리 누수 방지 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; shared = std::make_shared&lt;int&gt;(42); std::weak_ptr&lt;int&gt; weak = shared; // 소유권 없음, 참조 카운트 변하지 않음 if (auto locked = weak.lock()) { // shared_ptr로 잠금 가능 // 객체가 아직 살아있을 때만 접근 가능 int value = *locked; } } . 스마트 포인터의 장점 . | 자동 메모리 관리: RAII(Resource Acquisition Is Initialization) 패턴 적용 | 예외 안전성: 예외 발생 시에도 자원 누수 없음 | 명확한 소유권 모델: 객체의 라이프사이클이 코드상에서 드러남 | . 스마트 포인터의 단점 . | 순환 참조 문제: shared_ptr만 사용하면 서로를 참조하는 객체들에서 해제가 안 될 수 있음(→ weak_ptr로 해결) | 성능 오버헤드: 특히 shared_ptr의 참조 카운트 갱신 비용 | 사용법 혼동 주의: 소유권 이전/공유 규칙이 코딩 컨벤션으로 정립되어야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/C++/#스마트-포인터-종류"
  },"1113": {
    "doc": "C++",
    "title": "람다",
    "content": ". | C++11에서 도입된 기능으로, 이름 없는 함수(익명 함수)를 만들 수 있게 해줌 | 간단한 함수 객체(functor)나 콜백(callback) 등을 즉석에서 정의 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#람다"
  },"1114": {
    "doc": "C++",
    "title": "기본 문법과 구조",
    "content": "람다 함수의 기본 형태 . // [캡처](매개변수) -&gt; 반환타입 { 함수본문 } [capture](parameters) -&gt; return_type { // 함수 본문 ... } // 예시 [my_mod](int v_) -&gt; int { return v_ % my_mod; } . | [capture] : 외부 변수(스코프 밖의 변수)를 람다 내부에서 사용할 때 어떻게 사용할지 지정 | (parameters) : 함수의 매개변수 목록 | -&gt; return_type : 반환 타입 (void 는 -&gt; 생략 가능 / 컴파일러가 추론) | . ",
    "url": "/docs/C++/#%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95%EA%B3%BC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/C++/#기본-문법과-구조"
  },"1115": {
    "doc": "C++",
    "title": "c++98 함수 객체 vs C++11 람다",
    "content": "c++98 . struct Compare { bool operator()(int a, int b) { return a &lt; b; } }; std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), Compare()); // 함수 객체 전달 . c++11 . std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), [](int a, int b) { return a &lt; b; // 람다로 간결하게 표현 }); . ",
    "url": "/docs/C++/#c98-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-vs-c11-%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#c98-함수-객체-vs-c11-람다"
  },"1116": {
    "doc": "C++",
    "title": "람다 핵심 개념 : 캡처 리스트",
    "content": "외부 변수를 람다에서 어떻게 참조할지 결정 . | 캡처 형태 | 의미 | 예시 | . | [] | 아무것도 캡처하지 않음 | []() { /* ... */ } | . | [=] | 모든 외부 변수를 값으로 복사 | [=]() { cout &lt;&lt; x; } | . | [&amp;] | 모든 외부 변수를 참조로 사용 | [&amp;]() { x = 42; } | . | [x, &amp;y] | 특정 변수 선택적 캡처 | [x, &amp;y]() { y += x; } | . [] . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 외부 변수 캡처 없음 → 오직 매개변수만 사용 가능 auto lambda = [](int a, int b) { return a + b; }; std::cout &lt;&lt; lambda(3, 5); // 출력: 8 // std::cout &lt;&lt; lambda(x, y); // ⚠️ x, y는 매개변수로 전달해야 함 } . [=] . | 원본 보존 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 값으로 복사 (x, y의 복사본 사용) auto lambda = [=]() { std::cout &lt;&lt; x + y; // 출력: 30 (원본 x, y는 변경되지 않음) }; lambda(); x = 100; // 원본 수정 lambda(); // 출력: 30 (복사본은 영향 없음) } . | 람다가 생성될 때 [=]는 현재 스코프의 모든 변수 (x 등)를 값으로 복사해 저장 . | 람다 객체 내부에 int x_copy = x; 같은 복사본이 생김 | . | 람다는 항상 자신이 가진 복사본(x_copy)을 참조하므로, 원본이 변경되어도 복사본은 변하지 않음 | . [&amp;] . | 원본 제어 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 참조로 캡처 (원본 직접 접근) auto lambda = [&amp;]() { x = 30; // 원본 수정 std::cout &lt;&lt; y; // 출력: 20 }; lambda(); std::cout &lt;&lt; x; // 출력: 30 (람다에서 수정된 값) } . [x, &amp;y] . | 특정 변수만 선택적으로 캡처할 때 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // x는 값으로, y는 참조로 캡처 auto lambda = [x, &amp;y]() { y += x; // y는 원본 참조 (y = 20 + 10) // x = 5; // x는 복사본이므로 수정 불가 (mutable 키워드 필요) }; lambda(); std::cout &lt;&lt; y; // 출력: 30 (원본 y 변경됨) } . 참고 링크 . | 람다(lambda) 함수 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90--%EC%BA%A1%EC%B2%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/C++/#람다-핵심-개념--캡처-리스트"
  },"1117": {
    "doc": "C++",
    "title": "아래부터 나중에 추가 정리해야 할 것",
    "content": ". ",
    "url": "/docs/C++/#%EC%95%84%EB%9E%98%EB%B6%80%ED%84%B0-%EB%82%98%EC%A4%91%EC%97%90-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%A6%AC%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83",
    
    "relUrl": "/docs/C++/#아래부터-나중에-추가-정리해야-할-것"
  },"1118": {
    "doc": "C++",
    "title": "언리얼 엔진5의 스마트 포인터",
    "content": "UE5는 C++ 표준 라이브러리와의 호환성 문제(예: 모듈 경계, 플랫폼별 동작 차이)로 자체 스마트 포인터를 제공 . TSharedPtr&lt;&gt; . | C++의 std::shared_ptr&lt;&gt;과 유사하지만 UE5 전용 최적화가 적용됨. | 관리 대상: UObject를 상속받지 않은 일반 C++ 클래스. | . 특징 . | 참조 카운팅 + 스레드 안전성 지원. | TWeakPtr&lt;&gt;으로 약한 참조 가능. | MakeShared&lt;&gt;()로 생성 최적화. | . TUniquePtr&lt;&gt; . | C++의 std::unique_ptr&lt;&gt;과 거의 동일하지만 UE5 메모리 할당자와 통합됨. | 관리 대상: UObject가 아닌 객체. | . 특징 . | 복사 불가능, 이동만 가능. | MakeUnique&lt;&gt;()로 생성. | . FObjectPtr (UE5+) . | UObject 전용으로 설계된 경량 포인터. | C++ 표준과 무관하며, UE5의 가비지 컬렉션 시스템과 연동 | . 특징 . | UObject의 안전한 참조를 위해 사용 (예: 크로스-스레드 접근 방지). | TSharedPtr&lt;&gt;과 달리 참조 카운팅 없이 엔진 내부에서 관리. | . ",
    "url": "/docs/C++/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%845%EC%9D%98-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/C++/#언리얼-엔진5의-스마트-포인터"
  },"1119": {
    "doc": "C++",
    "title": "C++ vs UE5 스마트 포인터 비교",
    "content": "| 기능 | C++ (std) | UE5 | 차이점 | . | 공유 소유권 | std::shared_ptr&lt;&gt; | TSharedPtr&lt;&gt; | UE5는 스레드 안전성 강화 | . | 독점 소유권 | std::unique_ptr&lt;&gt; | TUniquePtr&lt;&gt; | UE5는 할당자 통합 | . | 약한 참조 | std::weak_ptr&lt;&gt; | TWeakPtr&lt;&gt; | 동일한 개념 | . | 가비지 컬렉션 | 없음 | FObjectPtr | UObject 전용 | . | 생성 방법 | std::make_shared&lt;&gt; | MakeShared&lt;&gt; | UE5는 커스텀 메모리 풀 사용 가능 | . ",
    "url": "/docs/C++/#c-vs-ue5-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/C++/#c-vs-ue5-스마트-포인터-비교"
  },"1120": {
    "doc": "Unreal Engine 5",
    "title": "Unreal Engine 5",
    "content": "참고하면 좋은 링크 . | UE - get Started | UnrealEngine c++ Guide | blueprints vs c++ | Exploring Unreal’s physics framework | Unreal Engine UI Tutorials | Unreal Engine C++ API Reference | UE Classes API | . ",
    "url": "/docs/Unreal%20Engine%205/",
    
    "relUrl": "/docs/Unreal%20Engine%205/"
  },"1121": {
    "doc": "Unreal Engine 5",
    "title": "Coordinate System",
    "content": "UE 좌표계는 왼손 좌표계 기준 . | 축 | 방향 | + | - | . | X | 깊이 | 앞(카메라와 멀어짐) | 뒤 (카메라와 가까워짐) | . | Y | 측면 | 오른쪽 | 왼쪽 | . | Z | 높이 | 위 | 아래 | . 참고하면 좋은 링크 . | coordinate-system | Coordinate System and Spaces | . ",
    "url": "/docs/Unreal%20Engine%205/#coordinate-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/#coordinate-system"
  },"1122": {
    "doc": "Unreal Engine 5",
    "title": "Level Editor Viewport",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#level-editor-viewport",
    
    "relUrl": "/docs/Unreal%20Engine%205/#level-editor-viewport"
  },"1123": {
    "doc": "Unreal Engine 5",
    "title": "카메라 동작",
    "content": ". | 우측 카메라 아이콘으로 속도 조절 가능 . | 왼쪽 클릭 : 카메라 수평 이동 | 오른쪽 클릭 : 카메라 상하 이동 | 왼쪽 클릭 + C : 줌인 (확대) | 클릭 + WASD : 카메라 이동 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%B9%B4%EB%A9%94%EB%9D%BC-%EB%8F%99%EC%9E%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/#카메라-동작"
  },"1124": {
    "doc": "Unreal Engine 5",
    "title": "View Modes",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#view-modes",
    
    "relUrl": "/docs/Unreal%20Engine%205/#view-modes"
  },"1125": {
    "doc": "Unreal Engine 5",
    "title": "Show",
    "content": "왼쪽 Show (표시)를 이용해 레벨에서 보고 싶은 에셋 플래그 on/off 설정 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#show",
    
    "relUrl": "/docs/Unreal%20Engine%205/#show"
  },"1126": {
    "doc": "Unreal Engine 5",
    "title": "Lit",
    "content": "레벨 라이팅 설정 on/off, 와이어 프레임 등 여러가지 설정 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#lit",
    
    "relUrl": "/docs/Unreal%20Engine%205/#lit"
  },"1127": {
    "doc": "Unreal Engine 5",
    "title": "perspective",
    "content": "카메라 원근 설정. 직교 투영으로 오브젝트트 배치 편하게 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#perspective",
    
    "relUrl": "/docs/Unreal%20Engine%205/#perspective"
  },"1128": {
    "doc": "Unreal Engine 5",
    "title": "맨 우측 화면 분할 아이콘",
    "content": "4개의 개별 뷰포트로 분할 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#%EB%A7%A8-%EC%9A%B0%EC%B8%A1-%ED%99%94%EB%A9%B4-%EB%B6%84%ED%95%A0-%EC%95%84%EC%9D%B4%EC%BD%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/#맨-우측-화면-분할-아이콘"
  },"1129": {
    "doc": "Unreal Engine 5",
    "title": "맨 좌측 리스트 아이콘",
    "content": ". | Show FPS 로 프레임 보기 가능 . | ctrl + shift + H | . | Bookmarks 를 통해 시점 저장, 불러오기 가능 . | ctrl + 0 ~ 9 으로 북마크 저장 | 키보드 0 ~ 9 으로 저장한 북마크 불러오기 | . | 게임 뷰 . | 단축키 : G | 아이콘 사라짐 | . | 몰입 모드 . | 단축키 : F11 | 화면 크게 | . | 고해상도 스크린샷 . | 우측 상단 캡처 지정 아이콘 클릭 -&gt; 캡처 사각형 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EB%A7%A8-%EC%A2%8C%EC%B8%A1-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%95%84%EC%9D%B4%EC%BD%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/#맨-좌측-리스트-아이콘"
  },"1130": {
    "doc": "Unreal Engine 5",
    "title": "Object manipulate 오브젝트 조종",
    "content": ". | 오브젝트 선택 . | 단축키 : Q | . | 오브젝트 움직이기 (기즈모 사용) . | 단축키 : W | . | 오브젝트 회전 . | 단축키 : E | . | 오브젝트 스케일 조절 . | 단축키 : R | . | . ",
    "url": "/docs/Unreal%20Engine%205/#object-manipulate-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%A1%B0%EC%A2%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/#object-manipulate-오브젝트-조종"
  },"1131": {
    "doc": "Unreal Engine 5",
    "title": "스냅",
    "content": "스냅 유무를 아이콘을 통해 on/off. 스냅에 쓸 단위도 조절 가능 . | 그리드 아이콘 : 오브젝트 이동 스냅 | 각도 아이콘 : 오브젝트 회전 각도 스냅 | 스케일 아이콘 : 오브젝트 스케일 스냅 | 표면 스냅 아이콘 : 오브젝트 가져올 때 표면에 어떻게 놓을 것인지 설정 . | on/off로 표면에 딱 붙일 것인지 설정 | 오프셋으로 표면에서 얼마나 떨어트릴 것인지 설정 | 언리얼 엔진의 1 unit = 1cm | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%8A%A4%EB%83%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/#스냅"
  },"1132": {
    "doc": "Unreal Engine 5",
    "title": "좌표",
    "content": "오브젝트 조종 옆에 있는 아이콘을 통해 어떤 좌표를 사용할 것인지 조절 가능 . | 단축키 : ctrl + ` | 세계 좌표에 있는 경우 세계 아이콘 표시 | 로컬 좌표에 있는 경우 로컬 아이콘 표시 | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%A2%8C%ED%91%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/#좌표"
  },"1133": {
    "doc": "Unreal Engine 5",
    "title": "오브젝트 복사",
    "content": ". | Alt + 기즈모 이동을 통해 복사 | 여러개 복사하고 싶으면 shift로 오브젝트 다중 선택 후 Alt + 기즈모 이동 . | 회전도 복사 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%B3%B5%EC%82%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/#오브젝트-복사"
  },"1134": {
    "doc": "Unreal Engine 5",
    "title": "Panels 패널",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#panels-%ED%8C%A8%EB%84%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/#panels-패널"
  },"1135": {
    "doc": "Unreal Engine 5",
    "title": "Outliner",
    "content": "world에 있는 모든 오브젝트 목록 . | 아웃라이너에서 오브젝트 이름으로 오브젝트 찾기 가능 | 아웃라이너에서 오브젝트 이름 누른 뒤 F 키를 통해 오브젝트로 이동 | . ",
    "url": "/docs/Unreal%20Engine%205/#outliner",
    
    "relUrl": "/docs/Unreal%20Engine%205/#outliner"
  },"1136": {
    "doc": "Unreal Engine 5",
    "title": "Details",
    "content": "선택한 오브젝트 속성 변경 . | Location : 월드 좌표에서의 오브젝트 위치 | Physics . | Simulate physics : 체크 박스에 체크하면 물리학 활성화 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#details",
    
    "relUrl": "/docs/Unreal%20Engine%205/#details"
  },"1137": {
    "doc": "Home",
    "title": "Home",
    "content": ". ✨2025-05-02 . | 깃허브 블로그 개설 | 커스텀 설정 추가 (custom.scss) . | site-title font : Darumadrop One 으로 변경 | .nav-list-link : color 수정 | . | . ✨2025-05-03 . | 커스텀 설정 추가 . | 마크다운 font : Noto Sans KR 로 변경 | 인용 블록 : border-radius 추가, 색상 변경 | 코드 블록 : font Rubik 으로 변경, border-radius 추가, Rouge github 테마로 폰트 색상 변경 | . | . ✨2025-05-04 . | 커스텀 설정 추가 . | 테이블 : font IBM Plex Sans KR 로 변경, 라인 색상 변경, 사이드 라인 제거 | 링크 버튼 : btn-purple color 변경 | 인용 블록 종류 추가 : warning, highlight, note, important, new | . | . ✨2025-05-06 . | 로고 추가 | 푸터 추가 | . ✨2025-06-22 . | LaTex 기호 적용 | . ✨2025-07-11 . | 외부 링크 새 탭으로 열리게 적용 | . ",
    "url": "/",
    
    "relUrl": "/"
  }
}
