{"0": {
    "doc": "1. Element Array",
    "title": "1. Element Array",
    "content": "인덱스 버퍼(Index Buffer, Element Buffer)라고도 하며, GPU에서 삼각형(또는 기타 프리미티브) 형태로 모델 데이터를 효율적으로 전달하기 위한 방식 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html"
  },"1": {
    "doc": "1. Element Array",
    "title": "Vertex Array",
    "content": "모델링의 버텍스 데이터가 연속적으로 저장되어 있는 배열 . | 인덱스 : n번째 버텍스 (예: 0번째 인덱스 -&gt; 0번째 버텍스) | 값 : 버텍스의 x,y,x 좌표 | . // Vertex Array (각각 [x, y, z] 좌표) float VertexIndices[][3] = { {1, 1, 1}, // 0 번째 버텍스 {1, 1, -1}, // 1 번째 버텍스 {1, -1, 1}, // 2 번째 버텍스 {1, -1, -1}, // 3 ... {-1, 1, 1}, // 4 {-1, 1, -1}, // 5 {-1, -1, 1}, // 6 {-1, -1, -1} // 7 }; . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#vertex-array",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#vertex-array"
  },"2": {
    "doc": "1. Element Array",
    "title": "Element Array",
    "content": "버텍스 배열에서 삼각형을 어떻게 조합할지에 대한 인덱스 정보를 저장한 배열 . | 인덱스 : n번째 삼각형 (예: 0번째 인덱스 -&gt; n번째 버텍스) | 값 : n번째 삼각형을 정의하는 Vertex Array 인덱스 집합 . | 예: {0, 1, 2} = Vertex Array의 [0], [1], [2] 버텍스를 사용한 삼각형 | . | . // Element Array (삼각형을 이루는 버텍스 인덱스) unsigned int Triangle[][3] = { {0, 1, 2}, // Vertex Array의 [0], [1], [2] 버텍스를 사용한 삼각형 {2, 1, 3}, // ... {4, 6, 5}, {5, 6, 7} }; . ❓ 버텍스 배열과 삼각형 배열을 따로 분리하는 이유? . | 버텍스 중복 저장 방지 : 3D 모델에서 여러 삼각형이 동일한 버텍스를 공유하는 경우가 매우 많음 | 각 삼각형마다 중복된 좌표 데이터를 저장하지 않고, 인덱스만 다르게 참조 . | 메모리 효율성과 캐싱 효율을 높임 | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#element-array",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#element-array"
  },"3": {
    "doc": "1. Element Array",
    "title": "동작 과정",
    "content": " ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#동작-과정"
  },"4": {
    "doc": "1. Element Array",
    "title": "1. 모델링 파일 파싱",
    "content": ". | 애플리케이션/엔진에서 모델링 파일 로드 | 버텍스 좌표, 인덱스 정보 등을 메모리로 읽어옴 | . 모델링 파일 예시 (.obj) . | 모델링 파일의 버텍스 좌표는 모델 로컬 공간 기준으로 저장됨 . | 예: 모델의 한 꼭짓점 (1,1,1) 은 모델의 중심 (pivot)에서 x,y,z로 각각 1만큼 떨어진 지점에 위치 | . | 1-based 인덱스 : 인덱스가 1부터 시작 . | 실제 GPU에선 0-based로 맞춰서 변환 필요 | . | . v 1.000000 1.000000 1.000000 // 버텍스 1 (x, y, z) v 1.000000 1.000000 -1.000000 // 버텍스 2 v 1.000000 -1.000000 1.000000 // 버텍스 3 v 1.000000 -1.000000 -1.000000 // 버텍스 4 ... f 1 2 3 // face (1,2,3번 버텍스가 삼각형을 이룸) f 3 2 4 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%ED%8C%8C%EC%9D%BC-%ED%8C%8C%EC%8B%B1",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#1-모델링-파일-파싱"
  },"5": {
    "doc": "1. Element Array",
    "title": "2. 데이터 정렬",
    "content": "파싱한 값을 버텍스 배열, 삼각형 배열(Element Array)로 정렬/변환 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EB%A0%AC",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#2-데이터-정렬"
  },"6": {
    "doc": "1. Element Array",
    "title": "3. GPU 업로드",
    "content": "완료된 버텍스 배열과 삼각형 배열을 GPU에 업로드 . | GPU는 이 데이터를 바탕으로 렌더링 파이프라인을 시작 | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#3-gpu-%EC%97%85%EB%A1%9C%EB%93%9C",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/1.%20Element%20Array.html#3-gpu-업로드"
  },"7": {
    "doc": "1. GPU 특성",
    "title": "1. GPU 특성",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html"
  },"8": {
    "doc": "1. GPU 특성",
    "title": "1. Design: GPU vs. CPU",
    "content": ". GPU는 원래 그래픽 렌더링을 위해 설계되었다. 3D 객체를 구성하는 수천 개의 독립적인 폴리곤을 셰이딩, 텍스처링, 렌더링하는 데 매우 효과적이다. | Core (녹색 영역) : 명령어 실행 및 계산 처리 (연산, 레지스터 조작 등) | Control (금색 영역) : 명령어 해석 및 실행 제어 (제어 신호 생성, 흐름 제어 등) | L1 Cache (보라 영역) : 데이터 / 명령어 저장 (코어에 가장 가까운 고속 캐시 메모리) | L2/L3 chache (파랑 영역) : L1 보다 느리지만 더 큼. L3는 여러 코어 간 공유되는 경우가 많음 | . ☑️ 위 그림으로 알수 있는 점 . | CPU는 GPU만큼 산술 논리 장치나 부동 소수점 장치가 많지 않다. (Core 녹색 영역) . | 하지만 CPU 코어의 ALU와 FPU는 더 많은 기능을 갖추고 있다. | . | CPU는 GPU보다 캐시 메모리가 더 많다. | GPU는 병렬화 될 수 있는 워크로드를 위해 설계되었다. | core의 각 행마다 Control이 하나씩 있는 것으로 나타난다. | . | . | 특징 | CPU | GPU | . | 목적 | 범용 컴퓨팅 (다양한 작업 처리) | 병렬 컴퓨팅 (그래픽 및 대량 데이터 처리) | . | 코어 수 | 적음 (일반적으로 2~64개) | 매우 많음 (수백 ~ 수천 개의 코어) | . | 작업 유형 | 직렬 처리에 최적화 | 병렬 처리에 최적화 | . | 사용 사례 | 운영체제, 일반 소프트웨어, 논리 연산 | 그래픽 렌더링, 머신러닝, 과학 계산 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu"
  },"9": {
    "doc": "1. GPU 특성",
    "title": "2. Performance: GPU vs. CPU",
    "content": ". 아래의 그림은 연산 능력을 초당 수십억 번의 부동 소수점 연산( Gflop/s )으로 측정하여 보여준다. | Single Precision (단정밀도) : 부동 소수점 수의 32비트 표현 | Double Percision (배정밀도) : 부동 소수점 수의 64비트 표현 | . 단정밀도는 배정밀도보다 두 배 빠르게 처리될 수 있는 경우가 많다. ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu"
  },"10": {
    "doc": "1. GPU 특성",
    "title": "3. Threads, Cores 재정의",
    "content": ". GPU는 그래픽 파이프라인의 두 가지 핵심 속성을 통해 속도가 가속화된다. | 렌더링은 일반적으로 많은 독립적인 오브젝트 (예:표면을 근사화하는 작은 삼각형 메시)로 구성된다. | 각 오브젝트를 렌더링하는데 필요한 단계의 순서는 기본적으로 모든 오브젝트에 동일하다. | 따라서 계산 단계가 모든 오브젝트에 대해 한번번에 병렬로 수행될 수 있다. | . | . GPU와 CPU 간의 용어 비교 . | GPU 용어 | GPU에서의 간단한 정의 | CPU에서의 대응 개념 | . | Thread | 하나의 CUDA 코어에서 실행되는 명령어와 데이터의 흐름. SIMT 모델에서 실행됨. | 일반적으로 명시적 대응 없음. | . | CUDA Core | SIMT 명령어의 일부를 처리하는 단일 연산 유닛. | 벡터 유닛 내의 벡터 레인 | . | Warp | 32개의 스레드로 구성된 그룹. 서로 다른 데이터에 동일한 명령어 스트림을 함께 실행한다. | 벡터 연산에서의 벡터 | . | Kernel | GPU에서 실행되는 함수. 커널은 여러 스레드 블록으로 구성될 수 있다. | CPU의 스레드 | . | Streaming Multiprocessor (SM) | 스레드 블록을 실행할 수 있는 단위. GPU의 물리적 유닛. | CPU의 코어 | . ❓ 스레드 블록 . | 스레드 블록 (Thread Block) . | 여러 스레드가 모여 하나의 논리적 단위로 구성되는 실행 단위 | . | CUDA 프로그래밍에서 스레드는 블록 단위로 묶여 실행된다. | 하나의 블록은 n ~ n백개의 스레드를 포함할 수 있다. | 블록은 SM(Streaming Multiprocessor)에 배정된다. | . ❓ 명령어 스트림 . | 명령어 스트림 (Instruction Stream) . | 스레드들이 공유하는 명령어의 흐름 (제어 흐름 분기(조건문)가 영향을 줌) | . | 스트림(stream)이라는 말은 일련의 명령어가 순차적으로 흐르는 데이터 흐름을 의미 | SIMT 모델에서 말하는 “명령어 스트림”은 모든 스레드가 따르는 동일한 명령어 흐름 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-%EC%9E%AC%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-재정의"
  },"11": {
    "doc": "1. GPU 특성",
    "title": "4. SIMT (Single Instruction, Multiple Threads)",
    "content": ". | 한 명령어를 여러 스레드가 동시에 실행하는 GPU 실행 모델 | . __global__ void add(int *a, int *b, int *c) { int idx = threadIdx.x; c[idx] = a[idx] + b[idx]; } . | 위 함수가 32개의 스레드에서 실행되면 모든 스레드가 같은 c[idx] = a[idx] + b[idx] 명령어 수행. | 각 스레드는 자신만의 idx 값을 사용해서 다른 데이터에 접근함. | . SIMT에서 제어 흐름 분기 예시 . | SIMT에서는 선택한 스레드를 활성화 또는 비활성화할 수 있다 | . | 활성 스레드: 명령과 데이터 처리. | 비활성 스레드: 아무런 작업도 수행하지 않음. 로컬 데이터가 변경되지 않은 상태로 유지됨. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads"
  },"12": {
    "doc": "1. GPU 특성",
    "title": "5. Warps",
    "content": ". | 런타임 시, 스레드 블록은 SIMT 실행을 위해 워프로 나뉜다. | 하나의 완전한 워프는 연속된 스레드 인덱스를 가진 32개의 스레드 묶음으로 구성된다. | 워프에 포함된 스레드들은 32개의 CUDA 코어 집합에 의해 함께 처리된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps"
  },"13": {
    "doc": "1. GPU 특성",
    "title": "6. Kernels (in software)",
    "content": ". 연결된 GPU 에서 병렬로 실행되도록 설계된 함수를 커널이라고 한다. | C++ 함수 선언 앞에 __global__ 지정자가 있는 것으로 식별된다. | . | 커널은 한 번만 실행되는 것이 아니라, GPU의 N개의 서로 다른 스레드 에 의해 N번 병렬로 실행된다. | 각 스레드에는 메모리 주소를 계산하고 제어 결정을 내리는 데 사용할 수 있는 고유 ID(실제로는 인덱스)가 할당된다. | . CUDA 커널이 스레드 배열에 의해 실행되는 방식 . 커널 호출은 GPU에서 사용할 스레드 수를 지정하는 특수 인수를 제공해야 한다. 특수 인수는 아래와 같다. func&lt;&lt;&lt;1, N&gt;&gt;&gt;(x, y, z) . // 커널 함수 정의: 두 벡터를 더해서 결과 저장 __global__ void addVectors(int *a, int *b, int *c, int N) { int idx = threadIdx.x; if (idx &lt; N) { c[idx] = a[idx] + b[idx]; } } int main() { const int N = 256; // 커널 호출: 블록 1개, 스레드 256개로 구성 addVectors&lt;&lt;&lt;1, N&gt;&gt;&gt;(d_a, d_b, d_c, N); } . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software"
  },"14": {
    "doc": "1. GPU 특성",
    "title": "7. Streaming multiprocessors (in hardware)",
    "content": ". GPU에서 커널 호출은 하나 이상의 스트리밍 멀티프로세서에 의해 실행된다. 각 SM의 CUDA 코어는 항상 32개 세트로 배열되어 SM이 스레드의 전체 워프를 실행하는 데 사용할 수 있다. | GPU가 커널 호출을 실행하는 데 실제로 사용하는 SM의 수는 호출에 지정된 스레드 블록 수로 제한된다. | 예를 들어 fun&lt;&lt;&lt;M, N&gt;&gt;&gt;(x, y, z) 이 있을 때, 각 SM에 할당할 수 있는 블록은 최대 M개이다. | 스레드 블록은 여러 SM으로 분할될 수 없다. | 사용 가능한 SM보다 블록이 많은 경우, 동일한 SM에 여러 블록을 할당할 수 있다. | . | . | 매 사이클 마다 각 SM의 스케줄러 는 사용 가능한 32개의 CUDA 코어 세트에서 실행될 스레드의 전체 워프를 할당한다. | SM에는 레지스터 , L1 캐시 , 상수 캐시, 공유 메모리가 포함된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware"
  },"15": {
    "doc": "1. GPU 특성",
    "title": "☑️ 정리",
    "content": "[Kernel] ↓ [Grid] (커널의 전체 작업 공간 = 스레드 블록 집합) ┌─────────────────┐ │ Thread Block 1 │ → SM 0 (리소스 여유 있을 시 SM 1에도 할당 가능) │ Thread Block 2 │ → SM 0 or 다른 SM │ ... │ (한 SM이 여러 블록을 동시에 실행 가능) │ Thread Block N │ → SM m (m ≤ n, SM 수 ≤ 블록 수) └─────────────────┘ ↓ ↓ [Warp 0] [Warp 1] ... (각 32스레드) ↓ ↓ CUDA Cores (SIMT 방식으로 워프 단위 병렬 처리 실행) ↓ ALU/FPU/Tensor Cores (실제 연산) . | 하나의 커널(GPU 함수)은 수많은 스레드 블록으로 구성 | 각 스레드 블록은 SM에 할당되어 실행된다. | SM이 스레드 블록을 실행한다 = SM은 워프 스케줄링, 메모리, 명령어 분배 등 전체 실행을 관리한다 | 한 SM이 여러 블록을 동시에 실행 가능 (SM의 자원이 충분하다면 여러 블록을 동시에 수용 가능) | . | 스레드 블록 내부의 스레드들은 32개 단위로 워프로 나뉨 | 각 스레드는 CUDA 코어에서 개별적으로 연산을 수행한다. | CUDA Core가 연산을 수행한다 = 각 스레드의 연산은 CUDA 코어에서 처리된다. 각 스레드의 명령은 워프 단위로 동기화(SIMT)되어 CUDA Core에 할당되며, 워프 내 스레드의 명령어를 ALU/FPU에 전달해 연산을 수행한다. | CUDA Core 자체가 ALU나 FPU를 내장하고 있거나, 복합적으로 연결되어 있다. | . | Tensor Core는 행렬 곱 연산(Matrix Multiply) 등에 최적화된 특수 연산 유닛으로, 워프 단위에서만 활성화되며 CUDA Core와 독립적으로 존재 | . | 구성 요소 | 설명 | 예시 용어 | . | Kernel | GPU에서 실행되는 함 | myKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...) | . | Grid | 모든 스레드 블록의 집합 | 논리적 실행 단위 | . | Thread Block | 스레드의 집합, SM에 할당됨 | blockDim.x, blockIdx.x 등으로 접근 | . | SM | Streaming Multiprocessor. 블록을 실행하는 하드웨어 유닛 | Warp Scheduler, CUDA Cores 포함 | . | Warp | 32개 스레드로 구성된 실행 단위 | SIMT 방식 실행 | . | CUDA Core | 실제 산술/논리 연산을 수행하는 유닛 | ALU/FPU로 구성된 연산 유닛의 논리적 집합 | . | Tensor Core | 고속 행렬 곱셈 (AI 특화) | SM 내부에 있는 별도 유닛으로 워프 단위 처리 | . FPU vs ALU vs Tensor Core . | 유닛 | 연산 타입 | 주요 용도 | 예시 | . | FPU | 부동소수점 (실수) | 물리 시뮬레이션, 3D 렌더링 | float x = y * 1.5; | . | ALU | 정수/논리 연산 | 인덱스 계산, 조건문 | int i = j + 1; | . | Tensor Core | 행렬 연산 | AI 학습/추론, DLSS | A = B × C (행렬 곱셈) | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#%EF%B8%8F-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#️-정리"
  },"16": {
    "doc": "1. Material Basic",
    "title": "1. Material Basic",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html"
  },"17": {
    "doc": "1. Material Basic",
    "title": "1. Data Types",
    "content": "constant - 1 float . constant2Vector - 2 floats . constant3Vector - 3 floats . 어떤 포지션과 묶느냐에 따라 floats 값이 RGB or XYZ 가 될 수 있다. | Base Color에 1 vector, 2 vector 를 넣어도 엔진에서 자동으로 입력을 처리한다. | (r 1, g 0, b 0) 이런 식 | . | Color에서 constant value 값 . | 0 : black | 1 : white | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types"
  },"18": {
    "doc": "1. Material Basic",
    "title": "2. Roghness",
    "content": "표면의 반사 정도를 제어 . | 0 : 거울 반사 (정반사) | 1 : 완전 무광 (난반사) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness"
  },"19": {
    "doc": "1. Material Basic",
    "title": "3. Lerp",
    "content": "Linear Interpolation (선형 보간법) 약어 . | 입력 A : 시작 포인트 | 입력 B : 끝 포인트 | 알파 : 보간 계수 (두 값 사이에서 어느 지점에 위치하는지를 나타내는 비율이자 가중치) | 리턴 : 보간된 값 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp"
  },"20": {
    "doc": "1. Material Basic",
    "title": "UV Mapping",
    "content": "2D 이미지를 3D 모델 표면에 투영하는 것 . | u : 수평 | v : 수직 | . | Texture coordinate Node . | tiling : 크기가 커질수록 텍스쳐는 작아지고 반복됨 | mutilply 사용으로도 타일링 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping"
  },"21": {
    "doc": "1. Material Basic",
    "title": "component mask",
    "content": "벡터 배열 중 가져오고 싶은 인덱스만 마스킹 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask"
  },"22": {
    "doc": "1. Material Basic",
    "title": "append",
    "content": "값1, 값2 합쳐서 매개변수로 사용하고 싶을때 쓰임 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append"
  },"23": {
    "doc": "1. Material Basic",
    "title": "4. Opacity",
    "content": "투명도를 주고싶으면 블렌드 모드를 바꿔야 함. (디폴트 Opaque(불투명)) . | material blend mode -&gt; Translucent(반투명) 변경 -&gt; Opacity 속성 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity"
  },"24": {
    "doc": "1. Material Basic",
    "title": "5. moving texture",
    "content": ". | speed (음수로 두면 -&gt; 방향으로 감) | time | distance = speed * time | subtract . | -로도 검색 가능 | append를 쓰면 speed에 음수로 방향 | subtract를 쓰면 speed는 늘 양수 (subtract가 뺄셈처리) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture"
  },"25": {
    "doc": "1. Material Basic",
    "title": "6. Panner",
    "content": "위 무빙 텍스쳐를 쉽게 하나로 만든 형태 . | 입력 coordinate : 텍스쳐 UV 좌표 | 입력 Time : UV 이동에 사용할 시간 값 | 입력 Speed : UV 좌표의 이동 속도를 설정하는 2D vector | 출력 UV : 입력된 UV 좌표를 시간과 속도에 따라 변형한 결과를 출력 | . ❓ 왜 speed 를 양수로 하면 왼쪽으로 가는것 처럼 보일까? . | Speed X 값이 양수일 때, 위의 계산에 따라 UV 좌표의 U 값이 증가 | 이는 텍스처의 샘플링 위치가 오른쪽으로 이동함을 의미 | 따라서 실제로 화면에서 보이는 텍스처는 왼쪽으로 이동하는 것처럼 보임 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner"
  },"26": {
    "doc": "1. Material Basic",
    "title": "7. Material Instance",
    "content": ". | M_material | MI_materialInstance | . | 머티리얼 인스턴스를 만들고 머티리얼 파라미터를 추가해 빠르게 머티리얼을 수정할 수 있다. | 머티리얼 인스턴스는 창이 다름 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance"
  },"27": {
    "doc": "1. Material Basic",
    "title": "8. Comment",
    "content": ". | 노드 클릭 / 드래그 후 C 버튼 눌러서 주석 달기 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment"
  },"28": {
    "doc": "1. Material Basic",
    "title": "9. Sine 표현식",
    "content": "사인 함수를 호출하는 노드 . | 입력 : 라디안 단위 각도 | 출력 : 입력의 라디안 사인을 계산한 결과 (-1 ~ 1) | . | 객체를 상하로 흔들거나 파도, 진동 등 주기적 변동 구현에 사용 | 입력값을 라디안 단위로 해석하여 사용함 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-%ED%91%9C%ED%98%84%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-표현식"
  },"29": {
    "doc": "1. Material Basic",
    "title": "10. Saturate",
    "content": "0 ~ 1 범위로 한정 시킴 = 클램핑 . 클램핑이 뭐야 ❓Clamp wiki Link . | 입력 : 클램핑할 값 | 출력 : 0 이하 = 0 / 1 이상 = 1 / 그 외 = 원본값 유지 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate"
  },"30": {
    "doc": "1. Material Basic",
    "title": "11. Sine_Remapped",
    "content": ". | 입력 sine Phase : 보간 계수 | 입력 Value1 (V3) : 0으로 맵핑될 때 반환할 시작 벡터 | 입력 Value2 (V3) : 1로 맵핑될 때 반환할 목표 벡터 | 출력 Remapped Sine (Vec3) : lerp(val1, val2, (sin(Sine Phase) + 1) / 2) 로 선형보간한 결과 | . | Sine Phase(실수)를 사인파로 계산한 뒤 [-1,1] 범위의 출력을 Value 1 (V3)와 Value 2 (V3) 사이의 벡터로 선형 보간하여 반환 | 내부적으로 sin(Sine Phase)의 결과에 +1을 더해 0~2로 이동시킨 뒤 0.5로 스케일링 하여 0~1 범위로 remap | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped"
  },"31": {
    "doc": "1. Material Basic",
    "title": "12. world position offset",
    "content": ". | 입력 World Position Offset (V3) : 오브젝트 버텍스에 더해질 월드 공간 오프셋 벡터 | 출력 (V3): 최종 버텍스 위치 | . | 간단한 이동 애니메이션이나 주기적 바운스 효과(Sind_Remapped 사용) 를 줄 때 사용한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset"
  },"32": {
    "doc": "1. Material Basic",
    "title": "13. CheapContrast",
    "content": ". | 입력 in (Scalar) : 대비를 조정할 입력 채널 (흑백 값) | 입력 Contrast (Scalar) : 대비 증가 강도. 값이 커질수록 대비 강도 증가 | . | 흑백 마스크 대비 보정할 때 사용 | 내부 동작 수식 Remapped = ( (In – 0.5) * (1 + Contrast) ) + 0.5 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast"
  },"33": {
    "doc": "1. Material Basic",
    "title": "Texture Sample UVs 혼합하기",
    "content": "❓ 흑백 텍스쳐 샘플 노드가 2개 있을 때, 1번 텍스쳐 샘플의 R 채널과 0을 2번 텍스쳐 샘플의 UV로 넣는 과정은 어떤 결과가 나올까? . | (R, 0)은 “2번 텍스쳐의 수평 위치를 1번 택스쳐의 R값으로 조정”한다는 뜻! | 예: R = 0.3 → 2번 텍스쳐의 30% 위치의 색상을 가져옴. | 수직은 0으로 고정이므로 R 값에 따라 수평으로만 왜곡시키는 효과를 냄 | . 과정 상세 설명 . | 1번 텍스쳐 (흑백) / R 채널만 사용 (흑백이므로 R=G=B). 값은 0 ~ 1 사이 | Append 노드로 (R, 0) 생성 / 예 픽셀 R은 0.7 → (0.7, 0) | 2번 텍스쳐에 (R, 0)을 UV로 입력 | 원래 UV가 (0.5, 0.5)라면, 새 UV는 (0.5 + 0.7, 0.5 + 0) = (1.2, 0.5) 같은 식으로 계산. | . 결과 . | 1번 텍스쳐의 밝은 부분(R≈1) → 2번 텍스쳐가 오른쪽으로 밀림. | 어두운 부분(R≈0) → 2번 텍스쳐가 왼쪽으로 수축. | 수직(V) 방향은 0으로 고정되므로 위아래 왜곡은 없음. | . UV 혼합은 그라데이션 왜곡, 노이즈 패턴 변형, 동적 텍스쳐 오프셋 등에 활용 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-%ED%98%BC%ED%95%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-혼합하기"
  },"34": {
    "doc": "1. Material Basic",
    "title": "14. Name Reroute Node",
    "content": "Material Editor 전용으로 제공되는 노드. 와이어가 얽히지 않도록 중앙 리루트 지점을 만들어 그래프를 깔끔하게 유지 할 수 있다. | Declaration (선언) 노드 : 오직 입력(Input) 만 갖고, 값을 ‘이름’으로 보관 | Usage: 오직 출력(Output) 만 갖고, 해당 이름의 값을 그래프 전역에 사용 가능. | . 사용방법 . | 와이어 두번 클릭 | 마우스 오른쪽 버튼 클릭 | 이름을 가진 경유 노드로 변환 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node"
  },"35": {
    "doc": "1. Material Basic",
    "title": "15. 1-x / OneMinus",
    "content": "색상 반전, 마스크 반전에 쓰임 . | 입력 input (float) : 연산 대상 X의 값. 스칼라일 경우 단일 채널, 벡터일 경우 각 채널별로 처리 | 출력 float : 계산 결과 1 - Input을 각 채널에 적용한 값 출력 | . | 출력 예시 : OneMinus((0.2, 0.5, 1.0)) → (0.8, 0.5, 0.0) | . 📌 단축키 . | 단축키 | 동작 | . | 숫자 1, 2, 3, 4 키 + 좌클릭 | 해당 constant vector 노드 생성 | . | T + 좌클릭 | texture sample | . | L + 좌클릭 | lerp | . | m + 좌클릭 | multiply | . | alt -&gt; 기즈모 이동 | 오브젝트 복사 | . | ctrl + D | 이전 행동 다시 반복 | . | 좌클릭 + f2 | 파일 이름 변경 | . | S + 좌클릭 | 머티리얼 파라미터 추가 | . | c + 좌클릭 | comment 주석달기 | . | Alt + 핀 클릭 | 모든 연결 끊기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus"
  },"36": {
    "doc": "1. Open World",
    "title": "1. Open World",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html"
  },"37": {
    "doc": "1. Open World",
    "title": "전통적 월드 시스템 (맵 경계 로딩 방식)",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%A0%84%ED%86%B5%EC%A0%81-%EC%9B%94%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%A7%B5-%EA%B2%BD%EA%B3%84-%EB%A1%9C%EB%94%A9-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#전통적-월드-시스템-맵-경계-로딩-방식"
  },"38": {
    "doc": "1. Open World",
    "title": "과정",
    "content": ". | 월드 분할: 개발자가 수동으로 월드를 여러 개의 작은 맵(레벨)으로 분할 | 경계 설정: 각 맵의 로딩 트리거 영역(보이지 않는 경계 박스)을 설정 | 스트리밍 방 . | 플레이어가 특정 영역에 접근하면 해당 맵 로드 | 이전 맵은 메모리에서 언로드 또는 유지(설정에 따라) | . | 로딩 화면: 맵 전환 시 로딩 화면이 표시되는 경우가 많음 | 수동 최적화: 개발자가 LOD(Level of Detail)와 오클루전 컬링을 수동으로 설정 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#과정"
  },"39": {
    "doc": "1. Open World",
    "title": "특징",
    "content": ". | 간단한 게임에 적합 | 메모리 관리가 비교적 직관적 | 대규모 오픈 월드에는 부적합(로딩 화면 빈번) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#특징"
  },"40": {
    "doc": "1. Open World",
    "title": "언리얼 5 World Partition 시스템",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%96%B8%EB%A6%AC%EC%96%BC-5-world-partition-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#언리얼-5-world-partition-시스템"
  },"41": {
    "doc": "1. Open World",
    "title": "과정",
    "content": ". | 자동 공간 분할: 월드를 정사각형 셀(grid)로 자동 분할(기본 1km²) | 데이터 레이어: 동일한 공간에 여러 버전의 콘텐츠를 계층화 가능(예: 낮/밤 버전) | 지능형 스트리밍 . | 서버 기반 거리 계산으로 필요한 셀만 로드 | One File Per Actor 시스템으로 개별 에셋 단위 제어 가능 | . | 지속적인 업데이트 . | 플레이어 위치를 실시간으로 모니터링 | 시야 범위와 데이터 레이어 활성화 상태를 고려해 LOD 자동 조정 | . | HLOD(계층적 LOD) . | 거리에 따라 자동으로 HLOD 버전 생성 및 전환 | 원거리 오브젝트는 자동으로 단순화된 버전으로 렌더링 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EA%B3%BC%EC%A0%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#과정-1"
  },"42": {
    "doc": "1. Open World",
    "title": "특징",
    "content": ". | 대규모 오픈 월드에 최적화 | 로딩 화면 없이 원활한 월드 탐색 가능 | 개발자 편의성 향상(수동 분할 불필요) . | World Partition | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#특징-1"
  },"43": {
    "doc": "1. Open World",
    "title": "정리",
    "content": "| 특징 | 전통적 월드 시스템 | 언리얼 5 World Partition | . | 월드 분할 방식 | 수동 분할 | 자동 그리드 분할 | . | 로딩 방식 | 전체 맵 단위 로드/언로드 | 셀 단위 지능형 스트리밍 | . | 로딩 화면 | 빈번하게 발생 | 거의 없음 | . | 최적화 방식 | 수동 LOD 설정 | 자동 HLOD 생성 | . | 메모리 관리 전체 | 맵 단위 | 개별 액터 단위 제어 | . | 개발 편의성 | 낮음 (수작업 필요) | 높음 (자동화 시스템) | . | 적합 규모 | 소/중규모 게임 | 대규모 오픈 월드 | . | 실행 중 변경 | 제한적 | 동적 조정 가능 (데이터 레이어) | . | 에디터 작업 성능 | 전체 맵 로딩 필요 | 작업 영역만 로딩 (로컬 영역) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#정리"
  },"44": {
    "doc": "1. Open World",
    "title": "패널 세팅하기",
    "content": ". | 상단의 창(window) -&gt; 월드 파티션 | 월드 파티션 -&gt; 월드 파티션 에디터 클릭 | 월드 파티션 패널 등장 | 상단의 창(window) -&gt; 월드 세팅 체크 | 월드 세팅 패널 등장 | . 월드 파티션 에디터로 world가 셀로 나누어 지는 걸 볼 수 있음 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%8C%A8%EB%84%90-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#패널-세팅하기"
  },"45": {
    "doc": "1. Open World",
    "title": "프로젝트 맵 세팅하기",
    "content": "엔진을 열 때 보여질 맵 세팅 . | 상단의 편집(Edit) -&gt; 프로젝트 세팅 | 프로젝트 세팅 창에서 맵 &amp; 모드 클릭 | default Maps 목록에서 에디터 시작 맵 -&gt; 원하는 맵 클릭하여 세팅 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A7%B5-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#프로젝트-맵-세팅하기"
  },"46": {
    "doc": "1. Open World",
    "title": "LOD (Level of Detail)",
    "content": "객체의 시각적 복잡성을 거리에 따라 동적으로 조절하는 시스템 . 가까운 객체는 고품질로, 먼 객체는 저품질로 렌더링 . | 장점 | 설명 | . | 성능 향상 | 먼 객체의 폴리곤 수 감소 → GPU 부하 ↓ | . | 메모리 절약 | 저해상도 텍스처/모델 사용 | . | 렌더링 효율화 | 불필요한 오버드로우 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-level-of-detail",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-level-of-detail"
  },"47": {
    "doc": "1. Open World",
    "title": "LOD 동작 과정",
    "content": "1. 거리 계산 단계 . 렌더러가 카메라와 각 객체 사이의 거리를 실시간으로 측정 . | 예: 0-10m(고품질), 10-30m(중간), 30m+(저품질) | . 2. 모델 전환 단계 . if (distance &lt; 10m) Render(HighPolyModel); else if (distance &lt; 30m) Render(MediumPolyModel); else Render(LowPolyModel); . 3. 부드러운 전환 . | LOD 교체 시점에서 팝핑 현상 방지를 위한 페이딩 효과 적용 | 언리얼의 경우 “LOD Bias” 설정으로 전환 거리 조정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-동작-과정"
  },"48": {
    "doc": "1. Open World",
    "title": "LOD 생성 방법",
    "content": "1. 수동 제작 . 전통적 방식으로 3D 모델러가 동일 객체의 여러 버전 제작 . | 예: 나무 모델을 10,000폴리곤 → 5,000 → 1,000 → 200 폴리곤 버전으로 제작 | . 2. 자동 생성 . 현대 엔진에서 쓰이는 방식 . 언리얼의 Auto LOD Generation . | 원본 메시 임포트 | Mesh Settings → LOD Settings에서 “Generate Auto LODs” 체크 | 폴리곤 감소 % 설정 (예: LOD1=50%, LOD2=25%, LOD3=10%) | . | 블렌더/마야의 리토폴로지 도구 활용 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/1.%20Open%20World.html#lod-생성-방법"
  },"49": {
    "doc": "1. Vectors",
    "title": "1. Vectors",
    "content": "벡터는 두 가지 정보를 담는다 . | 방향 : 벡터가 가리키는 방향 | 크기 : 벡터의 길이 | . \\[\\overrightarrow{a} = (3, 4)\\] \\[\\overrightarrow{b} = (3, 4, 5)\\] 위와 같이 표현할 수 있다. ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html"
  },"50": {
    "doc": "1. Vectors",
    "title": "행, 열 벡터",
    "content": "벡터는 열 행렬 또는 행 행렬로도 쓸 수 있다 . | 열 행렬 | . \\[\\overrightarrow{a} = \\begin{bmatrix} 3 \\\\ 4 \\end{bmatrix}\\] \\[\\overrightarrow{b} = \\begin{bmatrix} 3 \\\\ 4 \\\\ 5 \\end{bmatrix}\\] . | 행 행렬 | . \\[\\overrightarrow{a} = \\begin{bmatrix} 3 &amp; 4 \\end{bmatrix}\\] \\[\\overrightarrow{b} = \\begin{bmatrix} 3 &amp; 4 &amp; 5 \\end{bmatrix}\\] . | 행렬과 벡터가 “가깝다”고 하는 이유 = | 한 열(또는 한 행)을 뽑아 보면 그 자체가 벡터 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#%ED%96%89-%EC%97%B4-%EB%B2%A1%ED%84%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#행-열-벡터"
  },"51": {
    "doc": "1. Vectors",
    "title": "행렬 속 벡터 예시",
    "content": ". | 열 벡터 성분의 개수로 몇 차원에 속하는지 알 수 있다 . | 열 벡터 성분 2 개 = \\(\\Reals^2\\) | . | 예시 | . \\[\\overrightarrow{A} = \\begin{bmatrix} 4 &amp; 6 &amp; 1 &amp; -8 &amp; 5 \\\\ 1 &amp; 1 &amp; -2 &amp; 9 &amp; 0 \\end{bmatrix}\\] . \\[\\overrightarrow{a_1} = \\begin{bmatrix} 4 &amp; 6 &amp; 1 &amp; -8 &amp; 5 \\\\ \\end{bmatrix} \\\\\\] \\[\\overrightarrow{a_2} = \\begin{bmatrix} 1 &amp; 1 &amp; -2 &amp; 9 &amp; 0 \\end{bmatrix}\\] . | 열 벡터 성분 5개 = \\(\\Reals^5\\) | 2개의 벡터 = \\(\\Reals^5\\) 안의 2차원 평면 형성 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#%ED%96%89%EB%A0%AC-%EC%86%8D-%EB%B2%A1%ED%84%B0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/1.%20Vectors.html#행렬-속-벡터-예시"
  },"52": {
    "doc": "1. simultaneous equations",
    "title": "simultaneous equations (연립방정식)",
    "content": ". ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#simultaneous-equations-%EC%97%B0%EB%A6%BD%EB%B0%A9%EC%A0%95%EC%8B%9D",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#simultaneous-equations-연립방정식"
  },"53": {
    "doc": "1. simultaneous equations",
    "title": "연립방정식 풀이",
    "content": ". | 대입법 | 소거법 | 그래프법 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#%EC%97%B0%EB%A6%BD%EB%B0%A9%EC%A0%95%EC%8B%9D-%ED%92%80%EC%9D%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#연립방정식-풀이"
  },"54": {
    "doc": "1. simultaneous equations",
    "title": "Substitution Method 대입법",
    "content": "하나의 방정식을 한 변수에 대해 정리한 후, 다른 방정식에 대입하여 해 구하기 . 예시 . \\[\\begin{cases} y = 2x + 1\\\\ 3x + 2y = 20 \\end{cases}\\] . 풀이 . 1.첫번째 식에서 y가 정리되어 있으므로 두번째 식에 대입 . \\[3x + 2(2x+1) = 20\\] . 2.괄호 풀고 계산 . \\[3x + 4x + 2 = 20 \\\\ 7x + 2 = 20\\] . 3.x 구하기 . \\[7x = 18 \\Rightarrow x = \\frac{18}{7}\\] . 4.x를 첫번째 식에 대입해 y 구하기 . \\[y = 2 \\left ( \\frac{18}{7} \\right ) + 1 = \\frac{36}{7} + \\frac{7}{7} = \\frac{43}{7}\\] . 최종 해 . \\[x = \\frac{18}{7}, \\; y = \\frac{43}{7}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#substitution-method-%EB%8C%80%EC%9E%85%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#substitution-method-대입법"
  },"55": {
    "doc": "1. simultaneous equations",
    "title": "Elimination Method 소거법",
    "content": "두 방정식을 더하거나 빼서 하나의 변수를 제거한 후 해 구하기 . 예시 . \\[\\begin{cases} 2x + 3y = 12\\\\ 4x - y = 10 \\end{cases}\\] . 풀이 . 1.두번째 식 y 계수를 첫번째 식과 맞추기 위해 3을 곱하기 . \\[3 \\times 4x - y = 10 \\\\ \\Rightarrow 12x - 3y = 30\\] . 2.첫번째 식과 두번째 식을 더해 y 소거 . \\[\\; 2x + 3y = 12\\\\ + 12x - 3y = 30\\\\ 14x = 42 \\\\ \\Rightarrow x = 3\\] . 3.x=3을 대입해 y 구하기 . \\[4(3) - y = 10 \\\\ \\Rightarrow 12 - y = 10 \\\\\\Rightarrow y = 2\\] . 최종 해 . \\[x = 3, \\; y = 2\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#elimination-method-%EC%86%8C%EA%B1%B0%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#elimination-method-소거법"
  },"56": {
    "doc": "1. simultaneous equations",
    "title": "Graphing Method 그래프법",
    "content": "두 방정식을 그래프로 그려 교점을 찾아 해 구하기 . | y = ax + n 기울기-절편식으로 주로 품 | . 예시 . \\[\\begin{cases} x + 3y = 12\\\\ 2x - y = 5 \\end{cases}\\] . 풀이 . 1.첫번째 방정식을 기울기절편 형식으로 만들기 . \\[x - x + 3y = -x + 12 \\\\ 3y = -x + 12 \\\\\\] . 2.첫번째 식 계산 . \\[\\frac{3y}{3} = -\\frac{x}{3} + \\frac{12}{3} \\\\ \\Rightarrow y = -\\frac{1}{3}x + 4\\] . 3.두번째 방정식 기울기절편 형식으로 만들기 . \\[2x -2x -y = -2x + 5 \\\\ -y = -2x + 5 \\\\ \\Rightarrow y = 2x - 5\\] . 4.그래프 그려서 두 선이 교차하는 점이 해 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#graphing-method-%EA%B7%B8%EB%9E%98%ED%94%84%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html#graphing-method-그래프법"
  },"57": {
    "doc": "1. simultaneous equations",
    "title": "1. simultaneous equations",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/1.%20simultaneous%20equations.html"
  },"58": {
    "doc": "2. pivot and Echelon Form",
    "title": "2. pivot and Echelon Form",
    "content": "피벗 성분과 행 사다리꼴 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html"
  },"59": {
    "doc": "2. pivot and Echelon Form",
    "title": "피벗의 정의",
    "content": ". | 피벗 성분 : 행렬에서 해당 행의 첫 번째 0이 아닌 성분 (선행 계수, Leading Coefficient) | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%ED%94%BC%EB%B2%97%EC%9D%98-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#피벗의-정의"
  },"60": {
    "doc": "2. pivot and Echelon Form",
    "title": "사다리꼴 행렬  (Echelon Form)",
    "content": "사다리꼴 행렬의 정의 . | 모든 성분이 0인 행은 가장 아래에 위치함 | 모든 행에서 처음으로 나타나는 0이 아닌 성분(선행 계수)은 아래 행보다 왼쪽에 위치함 | 선행 계수보다 아래쪽에 있는 성분은 모두 0임 | . 사다리꼴 행렬 예시 . 예시 1 . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 0 &amp; 4 &amp; 5 \\\\ 0 &amp; 0 &amp; 6 \\end{pmatrix}\\] 예시 2 . \\[\\begin{pmatrix} 2 &amp; -1 &amp; 0 &amp; 3 \\\\ 0 &amp; 0 &amp; 5 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 4 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC--echelon-form",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#사다리꼴-행렬--echelon-form"
  },"61": {
    "doc": "2. pivot and Echelon Form",
    "title": "기약 사다리꼴 행렬 (Reduced Echelon Form)",
    "content": "기약 사다리꼴 행렬의 정의 . | 사다리꼴 행렬의 조건을 만족함 | 모든 선행 계수는 1이며, 해당 열의 다른 모든 성분은 0임 | . 기약 사다리꼴 행렬 예시 . 예시 1 . \\[\\begin{pmatrix} 1 &amp; 0 &amp; 5 \\\\ 0 &amp; 1 &amp; -3 \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix}\\] 예시 2 . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EA%B8%B0%EC%95%BD-%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC-reduced-echelon-form",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#기약-사다리꼴-행렬-reduced-echelon-form"
  },"62": {
    "doc": "2. pivot and Echelon Form",
    "title": "연립 방정식을 사다리꼴 행렬로 변환하여 해 구하기",
    "content": "문제 . \\[\\begin{cases} x + 2y +3z = 9 \\\\ 2x - y + z = 8 \\\\ 3x - z = 3 \\end{cases}\\] . 행렬 형태로 표현 . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9\\\\ 2 &amp; -1 &amp; 1 &amp; 8 \\\\ 3 &amp; 0 &amp; -1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 첫 번째 행 기준으로 아래 행 x 계수 제거 . | \\[{R_2 \\leftarrow R_2 - 2R_1}\\] | \\[{R_3 \\leftarrow R_3 - 3R_1}\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9 \\\\ 0 &amp; -5 &amp; -5 &amp; -10 \\\\ 0 &amp; -6 &amp; -10 &amp; -24 \\end{array} \\end{pmatrix}\\] . 두 번째 행을 정규화 (y의 선행 계수를 1로 만들기) . | \\[{R_2 \\leftarrow R_2 / (-5)}\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 2 &amp; 3 &amp; 9 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; -6 &amp; -10 &amp; -24 \\end{array} \\end{pmatrix}\\] . 두 번째 행을 이용해 y항 제거 . | \\[R_1 \\leftarrow R_1 - 2R_2\\] | \\[R_3 \\leftarrow R_3 + 6R_2\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; -4 &amp; -12 \\end{array} \\end{pmatrix}\\] . 세 번째 행을 정규화 (z의 선행 계수를 1로 만들기) . | \\[R_3 \\leftarrow R_3 / (-4)\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 1 &amp; 1 &amp; 2 \\\\ 0 &amp; 0 &amp; 1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 세 번째 행을 이용해 z 항 제거 . | \\[R_1 \\leftarrow R_1 - R_3\\] | \\[R_2 \\leftarrow R_2 - R_3\\] | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; 2 \\\\ 0 &amp; 1 &amp; 0 &amp; -1 \\\\ 0 &amp; 0 &amp; 1 &amp; 3 \\end{array} \\end{pmatrix}\\] . 결과 . \\[\\begin{cases} x = 2\\\\ y = -1\\\\ z = 3 \\end{cases}\\] . 참고하면 좋은 링크 . | 행 축약 및 (기약)사다리꼴 행렬 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#%EC%97%B0%EB%A6%BD-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%84-%EC%82%AC%EB%8B%A4%EB%A6%AC%EA%BC%B4-%ED%96%89%EB%A0%AC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EC%97%AC-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/2.%20Echelon%20Form.html#연립-방정식을-사다리꼴-행렬로-변환하여-해-구하기"
  },"63": {
    "doc": "2. GPU 메모리",
    "title": "2. GPU 메모리",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html"
  },"64": {
    "doc": "2. GPU 메모리",
    "title": "1. Memory Levels",
    "content": " ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/2.%20GPU%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html#1-memory-levels"
  },"65": {
    "doc": "2. Lighting and Atmosphere",
    "title": "2. Lighting and Atmosphere",
    "content": "조명과 대기/환경광 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html"
  },"66": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Place Actors 창 꺼내기",
    "content": ". | 상단의 프로젝트에 빠르게 추가하기 버튼 (네모 박스 모양+) 클릭 | 액터 배치 패널 클릭 (리스트 최하단에 있음) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#place-actors-%EC%B0%BD-%EA%BA%BC%EB%82%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#place-actors-창-꺼내기"
  },"67": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Lighting 조명",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#lighting-%EC%A1%B0%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#lighting-조명"
  },"68": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Directional Light",
    "content": "무한히 멀리 있는 광원(태양, 달 등)을 모델링하는 방향광 (실제로는 방향만 존재, 위치는 의미 없음) . | 장면 전체에 균일한 방향으로 평행하게 빛을 투사 . | 그림자 방향, 광원의 각도에 따라 환경 전체의 조명 분위기 결정 | . | Sky Atmosphere, Sky Light와 상호작용 . | 태양광이 대기에 산란, 전체 하늘/환경에 영향 | . | . 이동 단축키 . | 첫 번째 태양 이동: Ctrl + L을 누른 채 마우스를 움직임 | 두 번째 태양 이동: Ctrl + Shift + L을 누른 채 마우스를 움직임 . | 짐벌락 현상으로 이동이 안될 때 회전 값 0으로 리셋하면 해결됨 | . | . Mobility 속성 . | Static . | 게임 중 이동/색상/강도 변화 불가 | 그림자와 라이팅 정보를 ‘베이크’(Bake, 미리 계산하여 저장) | 가장 빠르지만 동적인 변화 불가 | . | Stationary . | 색상/강도 변화 가능, 위치/회전은 불가 | 정적인 오브젝트에만 베이크, 동적 오브젝트는 실시간 그림자 | 부분적으로 베이크와 동적 그림자 혼합 | . | Movable . | 위치, 회전, 색상, 강도 모두 실시간 변화 가능 | 그림자도 모두 실시간 계산(가장 비용이 크지만 동적으로 활용 가능) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#directional-light",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#directional-light"
  },"69": {
    "doc": "2. Lighting and Atmosphere",
    "title": "광원 온도 조절",
    "content": ". | Details 패널에서 Use Temperature를 활성화 | 온도값을 변경해 광원의 색감 조절 (낮음: 빨강, 높음: 파랑) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EA%B4%91%EC%9B%90-%EC%98%A8%EB%8F%84-%EC%A1%B0%EC%A0%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#광원-온도-조절"
  },"70": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Atmosphere 대기/환경광",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#atmosphere-%EB%8C%80%EA%B8%B0%ED%99%98%EA%B2%BD%EA%B4%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#atmosphere-대기환경광"
  },"71": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Sky Atmosphere",
    "content": "현실적인 하늘과 대기 산란 효과를 구현하는 대기 렌더링 시스템 . | 최대 두 개의 Directional Light 사용 . | 예 : 하나는 태양, 또 하나는 달 / 두 번째 태양을 시뮬레이션 | . | Sky Atmosphere는 Directional Light와 매우 밀접하게 동작한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-atmosphere",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-atmosphere"
  },"72": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Sky Light",
    "content": "씬의 먼 배경(하늘, 산 등)에서 오는 간접광을 씬 전체에 균일하게 적용하는 광원 . Mobility . 속성에 따라 캡처 시점이 다름 . | Static: 라이팅 빌드 시 캡처 | Stationary/Movable: 한 번만 캡처하거나, 수동으로 캡처 가능 | Real-time Capture 활성화 시, 장면 변화(예: 낮/밤)에 맞춰 항상 업데이트 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-light",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#sky-light"
  },"73": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Exponential Height Fog",
    "content": "고도에 따라 점진적으로 농도가 짙어지는 대기 안개 표현 . | 지면 기준, 카메라 거리 기준으로 안개 농도 조절 . | 거리 감쇠(attenuation), 높이 감쇠(height falloff) 파라미터 제공 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#exponential-height-fog",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#exponential-height-fog"
  },"74": {
    "doc": "2. Lighting and Atmosphere",
    "title": "Volumetric Clouds",
    "content": "실제 부피감을 가지는 3D 볼륨 클라우드(입체 구름) 렌더링 시스템 . | 기존 스카이 스피어 메시에 머티리얼을 씌우던 방식에서 진화 | 동적으로 움직이며, 3D 볼륨 형태의 실시간/동적 구름 | 머티리얼 기반으로 효과 변형 가능 | 대기와 같이 빛 산란 효과 적용 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#volumetric-clouds",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#volumetric-clouds"
  },"75": {
    "doc": "2. Lighting and Atmosphere",
    "title": "물리 단위 참조 테이블",
    "content": "| 파라미터 | 물리 단위 | UE5 기본값 | . | Directional Light | Lux | 100,000 | . | Sky Light | cd/m² | 1.0 | . | Fog Density | 1/m | 0.02 | . | Cloud Albedo | 반사율 | 0.8 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EB%AC%BC%EB%A6%AC-%EB%8B%A8%EC%9C%84-%EC%B0%B8%EC%A1%B0-%ED%85%8C%EC%9D%B4%EB%B8%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#물리-단위-참조-테이블"
  },"76": {
    "doc": "2. Lighting and Atmosphere",
    "title": "환경광/대기 효과 렌더링 파이프라인",
    "content": ". | UE5는 Defered Rendering (지연 렌더링) 기반 | . 전체 플로우의 순차적 구조 . | Geometry Pass에서 GBuffer에 모든 기초 정보 기록 → | Lighting Pass에서 모든 라이트와 GI 적용 → | Atmosphere/Clouds/Fog 등 대기 및 볼륨 효과 순차 합성 → | Post Processing에서 각종 시각효과 추가 → | Tone Mapping/Color Grading으로 최종 색상 보정 → | Final Frame으로 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%ED%99%98%EA%B2%BD%EA%B4%91%EB%8C%80%EA%B8%B0-%ED%9A%A8%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#환경광대기-효과-렌더링-파이프라인"
  },"77": {
    "doc": "2. Lighting and Atmosphere",
    "title": "환경광/대기 효과 렌더링 파이프라인 도식화 (UE 5.3 이상)",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%ED%99%98%EA%B2%BD%EA%B4%91%EB%8C%80%EA%B8%B0-%ED%9A%A8%EA%B3%BC-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EB%8F%84%EC%8B%9D%ED%99%94-ue-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#환경광대기-효과-렌더링-파이프라인-도식화-ue-53-이상"
  },"78": {
    "doc": "2. Lighting and Atmosphere",
    "title": "주요 단계 요약",
    "content": ". | Geometry Pass (Base Pass) . | 모든 메쉬의 표면 정보를 G-buffer에 기록 | Normal, Albedo, Roughness, Metallic, Depth 등 | . | Lighting Pass . | Directional Light . | 직접광, 그림자 처리 | . | Point/Spot Lights (지역 광원) | Sky Light . | 환경광 및 HDRI 반사 적용 | 하늘/환경 정보로부터 간접광 샘플링 | . | . | Atmospheric Pass . | Sky Atmosphere . | 기본 하늘 색상, 대기 산란 계산 | 뷰 방향, 태양 각도, 대기 매개변수로 실시간 산란 연산 | . | . | Volumetric Pass . | Volumetric Clouds . | 구름 및 3D 볼륨 안개, 빛 산란 효과 | 최종적으로 구름 효과 합성 | . | . | Fog Pass . | Exponential Height Fog (안개, 빛줄기) . | 카메라 거리/고도 기반 대기 안개 | 공간 깊이감 추가 | . | . | Post Process Pass . | SSAO/GTAO (앰비언트 오클루전) | Bloom/Lens Flare (광학 효과) | TAA/FSR/DLSS (안티앨리어싱) | . | Tone Mapping . | Color Grading/LUT (색 보정 및 최종 합성) | . | Final Frame Output . | 최종 이미지 출력 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#%EC%A3%BC%EC%9A%94-%EB%8B%A8%EA%B3%84-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/2.%20Lighting%20and%20Atmosphere.html#주요-단계-요약"
  },"79": {
    "doc": "2. Linear independence",
    "title": "Linear independence",
    "content": ". ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#linear-independence",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#linear-independence"
  },"80": {
    "doc": "2. Linear independence",
    "title": "선형 독립",
    "content": ". | 벡터 집합 \\(\\{v1, v2 ... , v_n\\}\\)이 다음을 만족할 때 선형 독립 | . \\[c_1\\mathbf{v}_1 + c_2\\mathbf{v}_2 + \\cdots + c_n\\mathbf{v}_n = \\mathbf{0} \\quad \\text{을 만족하는 유일한 해는}\\\\ \\quad c_1 = c_2 = \\cdots = c_n = 0\\] . | 예: \\(\\Reals^2\\)에서 (1, 0)과 (0, 1)은 선형 독립 | . 즉, . | 집합 내 어떤 벡터도 다른 벡터들의 선형 조합으로 표현될 수 없음 | 각 벡터가 고유한 방향성을 가짐 | 벡터 공간의 기저(basis)를 구성하는 핵심 성질 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#선형-독립"
  },"81": {
    "doc": "2. Linear independence",
    "title": "선형 종속",
    "content": ". | 벡터 집합이 선형 독립이 아닐 때 선형 종속 | . \\[\\text{선형 종속} \\iff \\exists \\, c_1, c_2, \\dots, c_n \\ (\\text{모두 0은 아니며, 적어도 하나는 0이 아님})\\] . | 예: \\(\\Reals^2\\)에서에서 (1,2)와 (2,4)는 선형 종속 (∵ (2,4)=2×(1,2)) | . 즉, . | 집합 내 적어도 하나의 벡터가 다른 벡터들의 선형 조합으로 표현 가능 | “중복된” 방향 정보를 포함 | 벡터 공간의 차원을 낮추는 효과 | . | 선형 종속은 비자명해(non-trivial solution)가 존재한다 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EC%84%A0%ED%98%95-%EC%A2%85%EC%86%8D",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#선형-종속"
  },"82": {
    "doc": "2. Linear independence",
    "title": "중요 성질",
    "content": ". | \\(\\Reals^{n}\\)에서 n+1개 이상의 벡터는 항상 선형 종속 | 기저 벡터들은 선형 독립 | 선형 변환 후에도 선형 관계는 보존됨 | 기저(basis)의 정의: . | 벡터 공간 V의 기저는 V를 생성하는 선형 독립인 벡터들의 집합 | . | 랭크(rank)와의 관계: . | 행렬의 랭크 = 선형 독립인 열(또는 행) 벡터의 최대 개수 | . | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EC%A4%91%EC%9A%94-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#중요-성질"
  },"83": {
    "doc": "2. Linear independence",
    "title": "기하학적 의미 (2D/3D 예시)",
    "content": "2차원에서 . | 두 벡터가 평행하지 않음 ⇔ 선형 독립 (예: (1,0)과 (0,1)) | 두 벡터가 평행 ⇔ 선형 종속 (예: (2,2)와 (4,4)) | . 3차원에서 . | 세 벡터가 동일 평면 상에 있지 않음 ⇔ 선형 독립 | 세 벡터가 한 평면 상에 있음 ⇔ 선형 종속 (예: (1,0,0), (0,1,0), (1,1,0)) | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EA%B8%B0%ED%95%98%ED%95%99%EC%A0%81-%EC%9D%98%EB%AF%B8-2d3d-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#기하학적-의미-2d3d-예시"
  },"84": {
    "doc": "2. Linear independence",
    "title": "선형 독립 판별 방법",
    "content": ". | 벡터 개수와 차원 비교 | . \\[\\text{ℝ}^n \\text{에서}: \\begin{cases} \\text{벡터 개수} &gt; n \\Rightarrow \\text{무조건 선형 종속} \\\\ \\text{벡터 개수} = n \\Rightarrow \\text{행렬식 또는 RREF로 판별} \\\\ \\text{벡터 개수} &lt; n \\Rightarrow \\text{RREF로 판별} \\end{cases}\\] . | 행렬식(det)을 이용한 판별 . | n×n 행렬 (정사각형) 에 대해 적용 가능한 방법 | . | . \\[2×2 \\ det \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} = ad - bc\\] . | 가우스-조던 소거법을 이용한 판별 . | m×n 행렬에 대해 일반적으로 적용 가능한 방법 | . | . \\[\\text{벡터 } \\mathbf{v}_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 2 \\end{bmatrix}, \\mathbf{v}_2 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 3 \\end{bmatrix}, \\mathbf{v}_3 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 5 \\end{bmatrix}\\] \\[A = \\begin{bmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 2 &amp; 3 &amp; 5 \\end{bmatrix} \\xrightarrow{\\text{RREF}} \\begin{bmatrix} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}\\] . \\[\\text{3번째 열이 피벗 열 아님} \\Rightarrow \\text{선형 종속}\\] . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EC%84%A0%ED%98%95-%EB%8F%85%EB%A6%BD-%ED%8C%90%EB%B3%84-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#선형-독립-판별-방법"
  },"85": {
    "doc": "2. Linear independence",
    "title": "동차 시스템에서 해의 유일성 판별",
    "content": ". 1.선형 독립인 경우 (유일 해) . | 동차 방정식의 해가 자명해만 존재 . | \\[c_1 = c_2 = 0\\] | . | . | 예시 | . \\[v_1 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} v_2 = \\begin{bmatrix} 0 \\\\ 6 \\end{bmatrix}\\] . | 동차 선형 방정식 | . \\[c_1\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} + c_2 \\begin{bmatrix} 0 \\\\ 6 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . | 해 구하기 | . \\[\\begin{cases} c_1\\cdot 1 + c_2\\cdot 0 = 0 \\ (1)\\\\ c_1\\cdot 1 + c_2 \\cdot 6 = 0 \\ (2) \\end{cases}\\] . | (1) 식 : \\(c_1 = 0\\) | (2) 식에 대입 : \\(- + 6c_2 = 0 \\Rightarrow c_2 = 0\\) | . 즉, . | 유일한 해는 \\(c_1 = c_2 = 0\\) 이므로 \\(v_1, v_2\\) 는 선형 독립 | . 2.선형 종속인 경우 (비자명 해) . | 예시 | . \\[v_1 = \\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} v_2 = \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix}\\] . | 동차 선형 방정식 | . \\[c_1\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} + c_2 \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . | 해 구하기 | . \\[\\begin{cases} 2\\cdot c_1 + 4 \\cdot c_2 = 0 \\ (1)\\\\ 2\\cdot c_1 + 4 \\cdot c_2 = 0 \\ (2) \\end{cases}\\] . | 하나의 자유 변수가 존재 | . \\[c_1 = -2c_2\\] \\[c_2 = 1 \\text{이면} \\ c_1 = -2\\] . \\[-2\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} + 1 \\begin{bmatrix} 4 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} -4+4 \\\\ -4+4 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\\] . 즉, 영벡터를 만드는 0이 아닌 계수 조합이 존재 . | \\(c_1 = c_2 = 0\\) 이 영벡터를 만드는 유일한 해가 아니므로 \\(v_1, v_2\\) 는 선형 종속 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#%EB%8F%99%EC%B0%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90%EC%84%9C-%ED%95%B4%EC%9D%98-%EC%9C%A0%EC%9D%BC%EC%84%B1-%ED%8C%90%EB%B3%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html#동차-시스템에서-해의-유일성-판별"
  },"86": {
    "doc": "2. Linear independence",
    "title": "2. Linear independence",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/2.%20Linear%20independence%20in%20two%20dimensions.html"
  },"87": {
    "doc": "2. Master Material",
    "title": "2. Master Material",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html"
  },"88": {
    "doc": "2. Master Material",
    "title": "1. Master Material",
    "content": "마스터 머티리얼을 만들고 이 마스터 머티리얼의 여러 인스턴스만 사용하는 방법을 통해 공간 절약, 씬의 성능 상향이 가능함. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-master-material"
  },"89": {
    "doc": "2. Master Material",
    "title": "2. Albedo vs Diffuse",
    "content": "베이스 컬러에 쓰이는 텍스쳐가 두 가지 용어를 혼합하여 쓰길래 두 키워드의 차이점이 무엇인지 궁금해졌다. ❓베이스 컬러에 들어가는 알베도와 디퓨즈의 차이점이 뭐지? . | Albedo : 물리 기반 렌더링(PBR)에서 도입. 표면이 반사하는 확산 반사 비율 또는 색상을 의미 | Diffuse : 전통적인 3D 그래픽스에서 디퓨즈 맵은 표면의 기본 색상을 정의한다. 빛의 영향을 받아 명암이 생기는 재질 표현에 사용 | . Albedo vs Diffuse 정리 . | 항목 | Albedo | Diffuse | . | 정의 | 순수한 반사율 (빛의 간섭 없음) | 빛의 난반사로 인한 색상 + 명암 | . | 사용 예 | PBR (물리 기반 렌더링) | 전통적 라이팅 모델 (램버트 반사 등) | . | 데이터 | 환경광의 영향이 제거된 순수 색상 | 그림자/광택 일부 포함 가능 | . | 예시 | Unreal, Unity등에서 PBR 재질의 Base Color로 사용 | Photoshop 등에서 조명까지 표현한 diffuse map 제작 가능 | . | Diffuse 텍스처에는 실제 광원이 없어도 명암이 들어감. | 조명 대응 불가 (광원 위치를 바꿔도 그림자는 바뀌지 않음) | . | . | 텍스처에 조명, 그림자, 반사 등을 “베이크”해서 포함시킨 것 = diffuse map | 조명과 독립적인 순수한 색상. 빛은 셰이더에서 계산함 = Albedo | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-albedo-vs-diffuse"
  },"90": {
    "doc": "2. Master Material",
    "title": "3. Texture Coordinate",
    "content": "UV 매핑을 제어하는 노드로 머티리얼이 메시 표면에 어떻게 텍스쳐를 투영할지 결정한다. | 모델의 각 정점(Vertex)에는 UV 좌표(0~1 범위의 2D 좌표)가 할당되어 있으며, 이 노드는 해당 좌표를 조정하거나 변형할 때 사용할 수 있다. | . | 기본 출력: UV 채널의 2D 벡터(X, Y). 각 성분은 일반적으로 0.0 ~ 1.0 범위 . | X(U): 가로 축 좌표 (좌 → 우) | Y(V): 세로 축 좌표 (하 → 상) | . | Coordinate Index: 다중 UV 채널을 선택할 수 있다. | 정적 메시의 Lightmap UV(UV1) 등 추가 좌표 계층을 활용할 때 유용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-texture-coordinate"
  },"91": {
    "doc": "2. Master Material",
    "title": "4. Vector4",
    "content": ". | Vector4 노드의 R,G,B,A에 각각 U tile, V tile, U offset, V offset 이라고 이름을 붙여 텍스쳐 타일링에 사용할 수 있다. | 타일링 *= multiply | 오프셋 += add | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-vector4"
  },"92": {
    "doc": "2. Master Material",
    "title": "5. static swich parameter",
    "content": "머티리얼 그래프 내에서 분기를 정의하고, 머티리얼 인스턴스 에디터에서 체크박스로 설정 가능하게 해준다. | 정적(static) 이 붙은 이유 : 런타임에 변경되지 않고 머티리얼 컴파일 타임에 결정됨 | 사용되지 않는 쪽의 분기는 완전히 제거되어 실행 시간이 최적화 | . | 입력 A : A 로직 (스위치가 True일 때 적용) | 입력 B : B 로직 (스위치가 False일 때 적용) | 출력 : True는 A, False는 B 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#5-static-swich-parameter"
  },"93": {
    "doc": "2. Master Material",
    "title": "RGB 표현",
    "content": "❓언리얼 엔진에서는 RGB가 0~255 값이 아니라고? . | 언리얼에서는 RGB 표현을 정규화된 0~1 범위로 사용한다. | 0~255 와 0~1 두 범위 모두 동일한 색상을 나타내지만, 사용하는 컨텍스트와 시스템에 따라 다른 스케일로 표현된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-표현"
  },"94": {
    "doc": "2. Master Material",
    "title": "왜 언리얼 엔진은 0~1 범위를 사용할까?",
    "content": ". | 수학적 일관성 . | 3D 그래픽스에서는 벡터 연산이 빈번하게 일어남 | 0~1 범위는 퍼센트 개념과 연결되며, 모든 계산을 비율 기반으로 통일할 수 있다. | 예: 0.5 = 50% 밝기 -&gt; 0.5 * 2.0 = 1.0 (100%) | . | . | HDR (High Dynamic Range) 지원 . | 0~1 범위를 벗어나는 값 (예: 2.0) 으로 더 밝은 빛을 표현할 수 있다. | . | GPU 친화적 . | 현대 GPU는 부동소수점(float) 계산에 최적화되어 있어 0~1 범위가 셰이더 연산과 호환성이 좋다. | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%99%9C-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84%EC%9D%80-01-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#왜-언리얼-엔진은-01-범위를-사용할까"
  },"95": {
    "doc": "2. Master Material",
    "title": "RGB 정규화 방법",
    "content": ". | 0~255 -&gt; 0~1 (정규화) = 값 / 255 | . RGB(255, 127, 0) -&gt; RGB(1.0, 0.498, 0.0) . | 0~1 -&gt; 0~255 (역정규화) = 값 * 255 (반올림 적용) | . RGB(0.5, 0.75, 1.0) -&gt; RGB(128, 191, 255) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rgb-정규화-방법"
  },"96": {
    "doc": "2. Master Material",
    "title": "Color Control",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#color-control"
  },"97": {
    "doc": "2. Master Material",
    "title": "1. 밝기: Brightness",
    "content": ". | RGB 값에 1보다 큰 수를 곱하는 것으로 설정 가능. | RGB는 0.0 ~ 1.0 범위로 표현됨 . | 0.0 = 완전한 어둠 (검정) | 1.0 = 최대 밝기 (순수한 색상) | . | R * 2 = R의 밝기 2배 증가 | R * 0.5 = R의 밝기 50% 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-%EB%B0%9D%EA%B8%B0-brightness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#1-밝기-brightness"
  },"98": {
    "doc": "2. Master Material",
    "title": "2. 채도: Satration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-%EC%B1%84%EB%8F%84-satration",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#2-채도-satration"
  },"99": {
    "doc": "2. Master Material",
    "title": "desaturation (탈색)",
    "content": "특정 색상을 흑백(grayscale)에 가깝게 변환하는 데 사용되는 노드. 이 노드를 사용하여 채도를 조절한다. | 입력 input (V3) : 일반적으로 텍스쳐의 RGB가 입력됨 | 입력 Fraction (V1) : 채도를 얼마나 줄일지 결정하는 값. | 0 : 원본 색상 유지 | 1 : 완전히 회색 | . | 출력 (V3) : desaturation 적용 결과 | . 내부 연산 공식 . Gray = R * 0.3 + G * 0.59 + B * 0.11 Output = lerp(Input, Gray, Fraction) . | Gray는 NTSC 표준 기반의 가중 평균. 인간의 눈이 가장 민감한 녹색에 높은 가중치를 둠 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-%ED%83%88%EC%83%89",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#desaturation-탈색"
  },"100": {
    "doc": "2. Master Material",
    "title": "3. 대비: Contrast",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-%EB%8C%80%EB%B9%84-contrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#3-대비-contrast"
  },"101": {
    "doc": "2. Master Material",
    "title": "power",
    "content": "입력 값의 지수 승(power/exponentiation) 을 계산하는 노드 . Output = Base ^ Exponent . | 입력 Base (V,V3) : 일반적으로 RGB 텍스쳐 입력 | 입력 Exponent (V) : 지수 값. | 출력 (V, V3): 계산된 결과 값 (Base의 Exponent 승) | . ❓왜 Contrast 조절에 Power를 쓰는거야? . | power는 단순 곱셈으로는 할 수 없는 비선형적인 변화를 제공하기 때문이다 | . 곱셈 (Multiply) vs 지수승 (Power) . | 특성 | 곱셈 | 지수승 | . | 수학적 표현 | RGB × Scale | RGB ^ Gamma | . | 연산 유형 | 모든 픽셀의 밝기를 균일하게 스케일링 어두운 영역과 밝은 영역이 동일한 비율로 변화 | 비선형변환으로 밝기 분포를 비균형적으로 조정 | . | 밝기 변화 | 모든 픽셀 균일하게 스케일링 | 밝은 픽셀은 더 밝게 어두운 픽셀은 더 어둡게 (분포 왜곡) | . | 대비(Contrast) 영향 | 대비 유지 | 대비 증가 (Gamma &gt; 1) 대비 감소 (Gamma &lt; 1) | . | 시각적 효과 | 전체적으로 밝아지거나 어두워짐 | 어두운 영역과 밝은 영역의 차이 강조 or 완화 | . | 사용 예시 | 밝기 조정, 라이트 강도 증감 | Contrast 조정, 감마 보정 | . RGB (0.2, 0.5, 0.8) Power(2.0) -&gt; RGB(0.04, 0.25, 0.64) // 어두운 부분은 급격히 어두워지고 밝은 픽셀은 상대적으로 덜 영향받음. = 대비 강해짐 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#power"
  },"102": {
    "doc": "2. Master Material",
    "title": "4. 색조: Tint",
    "content": "Base color의 RGB에 다른 색상의 RGB를 곱해서 얻을 수 있다. | 채널별 스케일링 . | 곱해지는 색상의 각 채널 값이 원본 색상의 해당 채널을 강화하거나 약화시킴 | 1.0 : 해당 채널 100% 유지 | 0.5 : 해당 채널 50% 감소 | 0.0 : 해당 채널 완전히 제거 | . | . // 원본 색상 RGB(0.8, 0.5, 0.2) // Tint 색상 RGB(1.0, 0.3, 0.3) // 결과 -&gt; R은 유지, G/B는 감소 (0.8*1.0, 0.5*0.3, 0.2*0.3) = (0.8, 0.15, 0.06) . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-%EC%83%89%EC%A1%B0-tint",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#4-색조-tint"
  },"103": {
    "doc": "2. Master Material",
    "title": "6. MI Organize Paramaters",
    "content": "파라미터 노드를 그룹화 하여 마테리얼 인스턴스의 파라미터들을 원하는 순서대로 분류할 수 있다. | 파라미터 노드 클릭 | Details 창의 Material Expression 에서 Group 설정 . | 그룹은 0 - Z 알파벳 네임 순서대로 정렬되므로 00 Global Control, 01 Base Color 등으로 순서를 정함. | . | 그룹에 들어가길 원하는 파라미터 노드를 설정한 그룹에 넣어줌 | 그룹 하위 파라미터 노드들은 Sort Priority (정렬 우선순위)의 낮은 수 순서대로 마테리얼 인스턴스 그룹 목록에 정렬됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#6-mi-organize-paramaters"
  },"104": {
    "doc": "2. Master Material",
    "title": "7. Metallic",
    "content": "머티리얼 에디터에서 Metallic 소켓은 표면이 금속성인지 여부를 정의하는 입력값이다. 입력 값 범위: 0.0에서 1.0 사이의 스칼라(float) 값. | 0.0: 비금속(non-metal) 재질. (예: 나무, 플라스틱, 돌 등.) | 1.0: 금속(metal) 재질. (예: 철, 금, 알루미늄 등.) | 0.0과 1.0 사이의 값: 녹슨 금속과 같은 재질을 표현할 때 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#7-metallic"
  },"105": {
    "doc": "2. Master Material",
    "title": "8. Specular",
    "content": "표면이 반사하는 거울 반사(specular reflection)의 강도를 조절하는 소켓. 디폴트 값은 0.5이다. Specular 값은 비금속 재질의 반사 특성을 조절하며, 금속 재질(Metallic)에는 영향을 주지 않는다. | 0.0: 표면이 전혀 반사하지 않음 (완전한 확산 반사) | 0.5: 표면이 약 4%의 빛을 반사함 (일반적인 비금속 재질의 기본값) | 1.0: 표면이 최대 8%의 빛을 반사함 (매우 반짝이는 비금속 재질) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#8-specular"
  },"106": {
    "doc": "2. Master Material",
    "title": "9. Roughness",
    "content": "표면의 거칠기를 정의하는 소켓으로 빛이 표면에 어떻게 반사되는지를 결정한다. 디폴트 값은 0.5이다. | 0.0: 매우 매끄러운 표면. 반사가 거울처럼 선명함 (예: 유리, 금속) | 0.5: 중간 정도 거칠기 반사가 흐릿하고 부드럽게 번짐 | 1.0: 매우 거친 표면. 반사가 거의 없거나 전혀 없음 (예: 콘크리트, 모래) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#9-roughness"
  },"107": {
    "doc": "2. Master Material",
    "title": "Metallic vs Specular Workflow",
    "content": "메탈릭 워크플로우와 스페큘러 워크플로우는 PBR에서 재질을 표현하는 두 가지 다른 방식이며, 계산 공식과 입력값이 근본적으로 다르다. | UE5는 메탈릭/러프니스(Metallic/Roughness) 워크플로우에 최적화되어있다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallic-vs-specular-workflow"
  },"108": {
    "doc": "2. Master Material",
    "title": "Metallic/Roughness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | BaseColor | 비금속: 재질의 기본 색상(Diffuse) 금속: 반사 색상(Fresnel F₀) | RGB | 금속은 diffuse(산란) 사용 X. 반사 색상이 사용됨 | . | Metallic | 재질이 금속인지 여부를 정의. 0: 비금속 1: 금속 | Grayscale | - 흰색: 금속 - 검은색: 비금속 | . | Roughness | 표면의 거칠기를 정의 0: 매끄러움 1: 거칠음 | Grayscale | Glossiness와 반대 | . | 메탈릭은 Metallic 맵으로 금속/비금속을 강제 분리해 물리적 일관성을 확보함 . | Metallic 파라미터 (0,1)로 재질 타입을 이진화 | 금속 (Metallic = 1) . | BaseColor = Fresnel 반사 색상 (F0). | Diffuse 성분 = 0 (물리적으로 정확한 금속 모델). | . | 비금속 (Metallic = 0) . | BaseColor = Diffuse 알베도. | Specular는 고정값 (~0.04) 또는 Specular 입력으로 미세 조정 | . | . | 메모리 효율적 (Specular 맵 불필요), 실시간 렌더링에 최적화. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#metallicroughness-주요-맵-설명"
  },"109": {
    "doc": "2. Master Material",
    "title": "Specular/Glossiness 주요 맵 설명",
    "content": "| 맵(Map) | 설명 | 형식 | 비고 | . | Diffuse | 비금속 재질의 기본 색상. 금속: 디퓨즈 맵 사용 X | RGB | 메탈릭 워크플로우의 BaseColor와 유사하지만, 금속에서는 무시됨. | . | Specular | 모든 재질의 반사 색상 및 강도 금속: RGB 비금속: Grayscale | RGB / Grayscale | 메탈릭 워크플로우의 Metallic + BaseColor 역할을 동시에 함. | . | Glossiness | 표면 광택도 0: 거칠음 1: 매끄러움 | Grayscale | Roughness와 반대 | . | 스페큘라는 Specular 맵으로 반사 색상과 강도를 직접 제어함 | 반사 색상의 자유도 높음, 오프라인 렌더링(V-Ray)과 호환됨 | . 참고하면 좋은 링크 . | Metalness Maps and Workflow Explained . | PBR: metallic vs specular workflow . | Specular vs Metalness Workflows for PBR Shading in Blender . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-%EC%A3%BC%EC%9A%94-%EB%A7%B5-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#specularglossiness-주요-맵-설명"
  },"110": {
    "doc": "2. Master Material",
    "title": "sRGB (standard Red Green Blue)",
    "content": "sRGB는 모니터, TV 등 대부분의 디스플레이에서 사용하는 표준 색 공간이다. | 사람이 인지하는 색감을 기준으로 설계됨 . | 인간의 눈은 어두운 색상의 변화에 더 민감함 | sRGB는 이를 반영해 암부(어두운 영역)의 색상 정보를 강조하는 비선형 곡선을 사용 | . | 감마 보정이 포함되어 있음 (약 γ = 2.2) . | 즉 색상 데이터가 밝게 저장됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#srgb-standard-red-green-blue"
  },"111": {
    "doc": "2. Master Material",
    "title": "Gamma vs inear Workflow",
    "content": ". | 감마 워크플로우 (Gamma Workflow) . | 전통적인 방식으로, sRGB 공간에서 렌더링을 수행 | 텍스처와 최종 출력이 sRGB로 가정되기 때문에, 라이팅 계산 시 자동으로 리니어로 변환되지 않음 | 실시간 라이팅 계산이 부정함 (예: 어두운 영역에서 색상 밴딩 발생) | PBR(물리 기반 렌더링)과 호환성이 떨어짐 | . | 리니어 워크플로우 (Linear Workflow) . | 리니어 컬러 스페이스에서 렌더링을 수행 | 텍스처는 sRGB에서 로드될 때 자동으로 리니어로 변환되고, 최종 출력 시 다시 sRGB로 감마 보정 | 물리적으로 정확한 라이팅 계산이 가능 | . | . 감마, 리니어 워크플로우 처리과정 . | 감마 워크플로우 . | 텍스처(sRGB) → (감마 보정 해제 없음) → 라이팅 계산 → 출력(sRGB) | . | 리니어 워크플로우 . | 텍스처(sRGB) → 자동 리니어 변환 → 물리적 라이팅 계산 → sRGB로 출력 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#gamma-vs-inear-workflow"
  },"112": {
    "doc": "2. Master Material",
    "title": "☑️결론",
    "content": "언리얼 엔진 5에서의 동작 . 텍스처 . | sRGB 플래그가 켜진 텍스처 (알베도, 디퓨즈)는 리니어로 변환되어 쉐이더에서 사용 | sRGB 플래그가 꺼진 텍스처 (메탈릭, 러프니스)는 변환 없이 리니어로 읽힘 | . 라이팅 계산 . | 모든 쉐이더 연산은 리니어 공간에서 이루어짐 | 실시간 광원, GI, 반사 등이 물리적으로 정확하게 계산 | . 최종 출력 . | 최종 프레임 버퍼는 모니터 표준(sRGB)에 맞게 자동 감마 보정되어 출력 | . 참고하면 좋은 링크 . | computer color is broken | Gamma Vs. Linear Workflow for KeyShot Users | UNDERSTANDING GAMMA CORRECTION | Gamma Color space와 Linear Color space란? | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EF%B8%8F%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#️결론"
  },"113": {
    "doc": "2. Master Material",
    "title": "Texture Compression Settings (텍스쳐 압축 세팅)",
    "content": "텍스쳐를 더블 클릭하면 열리는 창으로 텍스쳐 압축 세팅 설정 가능. | 알파가 없는 텍스쳐는 알파 없이 압축 체크 (Compress Without Alpha) | sRGB가 아닌 텍스쳐는 sRGB 체크 해제 | Compression Settings 에서 세팅 설정 . | Masks (no sRGB) | . | . 텍스쳐 샘플러 노드의 설정으로 샘플러 타입 설정 가능. | 텍스쳐가 sRGB라면 Sampler Type = color | 텍스쳐가 sRGB가 아니아면 Sampler Type = Linear color . | BlackPlaceholder | . | . 압축 설정과 샘플러 타입 설정이 모두 같게 설정 되어야 한다. (sRGB가 아닌경우 샘플러 Linear) . 참고하면 좋은 링크 . | Texture Compression Settings | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-%ED%85%8D%EC%8A%A4%EC%B3%90-%EC%95%95%EC%B6%95-%EC%84%B8%ED%8C%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#texture-compression-settings-텍스쳐-압축-세팅"
  },"114": {
    "doc": "2. Master Material",
    "title": "10. Normal",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#10-normal"
  },"115": {
    "doc": "2. Master Material",
    "title": "로우 폴리 vs 하이 폴리 모델",
    "content": ". | 로우 폴리 모델은 표면이 평평하고 법선이 단순. | 하이 폴리 모델은 표면이 복잡하고 법선이 다양. | . 노멀 맵은 하이 폴리 모델의 법선 정보를 로우 폴리 모델에 “옮기는” 기술이다. | 로우 폴리 모델의 정점 법선은 평평해 보이지만, 노멀 맵으로 인해 픽셀 단위로 법선이 조정되어 하이 폴리 같은 디테일이 나온다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%A1%9C%EC%9A%B0-%ED%8F%B4%EB%A6%AC-vs-%ED%95%98%EC%9D%B4-%ED%8F%B4%EB%A6%AC-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#로우-폴리-vs-하이-폴리-모델"
  },"116": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 좌표계 (탄젠트 공간)",
    "content": "노멀 맵은 탄젠트 공간에 저장된다. | 노멀 맵의 픽셀 값 (R, G, B)은 탄젠트 공간에서의 법선 방향을 나타냄 | Z축은 “표면 바깥쪽”을 가리킨다. (일반적으로 (0,0,1)이 기본 법선) | 탄젠트 공간은 각 정점마다 다르다. | 노멀 맵의 법선 벡터는 각 정점의 탄젠트 공간(= 각 정점의 로컬 좌표계) 기준으로 저장된다. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%A2%8C%ED%91%9C%EA%B3%84-%ED%83%84%EC%A0%A0%ED%8A%B8-%EA%B3%B5%EA%B0%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-좌표계-탄젠트-공간"
  },"117": {
    "doc": "2. Master Material",
    "title": "노멀 맵의 생성 과정",
    "content": "노멀 맵은 하이 폴리 모델의 법선을 로우 폴리 모델의 탄젠트 공간에 투영하여 저장한다. 1.하이 폴리 모델의 법선 추출 . | 하이 폴리 모델의 각 정점 법선을 계산 | 하이 폴리 모델의 법선은 월드 공간 또는 오브젝트 공간에 있음 | . 2.로우 폴리 모델의 탄젠트 공간 계산 . | 로우 폴리 모델의 각 정점에서 TBN 기저(basis)를 계산 | 로우 폴리 모델의 각 정점은 자신만의 T, B, N 벡터를 가진다. | 노멀 맵을 탄젠트 공간에 저장하기 위한 기준 좌표계를 제공 . | T (Tangent): UV의 U 방향 (텍스처 가로) | B (Bitangent): UV의 V 방향 (텍스처 세로) | N (Normal): 로우 폴리 모델의 표면 법선 | . | . 3.하이 폴리의 법선 → 로우 폴리의 탄젠트 공간으로 변환 . | 하이 폴리 법선을 로우 폴리 모델의 TBN 행렬의 역행렬로 변환한다. | 하이 폴리 법선을 탄젠트 공간으로 변환한 결과 값은 -1 ~ 1 범위를 가짐 | 변환된 법선을 RGB 값 (0 ~ 1)으로 리매핑해 저장 | . // 하이 폴리 법선 (오브젝트 공간) vec3 normal_high = normalize(hitNormal); // 탄젠트 공간으로 변환 (TBN은 로우 폴리의 기저) vec3 normal_tangent = transpose(TBN) * normal_high; // 노멀 맵 저장 (0~1 리매핑) vec3 normalMapValue = normal_tangent * 0.5 + 0.5; . | 채널 | 벡터 구성요소 | 설명 | . | R | X | Tangent(가로) 방향의 법선 벡터 성분 | . | G | Y | Bitangent(세로) 방향의 법선 벡터 성분 | . | B | Z | Surface Normal(법선) 방향의 법선 벡터 성분 | . 4.노멀 맵 데이터 생성 . | 노멀 맵에 “하이 폴리 법선이 로우 폴리 모델의 탄젠트 공간에서 어떻게 변형되어야 하는지”가 데이터로 저장됨. | . 5.노멀 맵의 사용 . 렌더링 시에는 노멀맵의 값을 다시 TBN 행렬을 통해 월드 공간 법선으로 복원한다. | 노말맵은 법선을 0 ~ 1로 리매핑해 저장된 상태. | 실제로 렌더링에 사용할 때는 다시 -1 ~ 1로 복원 | . // 노멀 맵에서 법선 추출 (0~1 → -1~1) vec3 normal_tangent = texture(normalMap, uv).rgb * 2.0 - 1.0; // 월드 공간 법선으로 변환 vec3 normal_world = normalize(TBN * normal_tangent); // 조명 계산 (예: Lambertian Diffuse) float diffuse = max(0.0, dot(normal_world, lightDir)); . 추가로 알면 좋은 점 . | 노멀맵이 대부분 파란 이유 . | 평평한 표면의 벡터가 (0, 0, 1)이기 때문 | 색 변화가 의미하는 것 = 파랑 외의 색은 법선이 좌우(X), 상하(Y)로 기울어진 정도를 의미 | . | 스무딩 그룹(Smoothing Groups) . | 로우 폴리 모델의 정점 법선을 보간할지 말지 결정 | 보간 O (같은 스무딩 그룹): 정점 사이가 부드럽게 연결 | 보간 X (다른 스무딩 그룹): 정점 사이가 날카롭게 끊어짐 | 로우 폴리의 법선이 스무딩 그룹에 따라 변하면 노멀맵에 저장되는 차이도 달라진다. | . | . 참고하면 좋은 링크 . | Tutorial: How Normal Maps Work &amp; Baking Process | Deconstructing a Normal Map | Normal Mapping | OpenGL Tutorial - Normal Maps | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EB%85%B8%EB%A9%80-%EB%A7%B5%EC%9D%98-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#노멀-맵의-생성-과정"
  },"118": {
    "doc": "2. Master Material",
    "title": "Flatten Normal",
    "content": "노멀 벡터의 Z(Depth) 성분을 조절해 노멀맵을 평탄화 하는 노드 . | 입력 Normal (V3) (XYZ) : 탄젠트 공간에서의 노멀 벡터. 원본 노말 맵 | 입력 Flatten Strength (Scalr) : Float (0.0 ~ 1.0), 평탄화 강도 (1.0에 가까울수록 Z가 약해짐) | 출력 Result (V3) : 평탄화가 완료된 노멀 벡터터 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flatten-normal"
  },"119": {
    "doc": "2. Master Material",
    "title": "Flip Green Channel",
    "content": "텍스처의 노멀 맵에서 G(Green) 채널을 반전시키는 옵션 . | 노멀 맵이 OpenGL 방식과 DirectX 방식 중 어떤 포맷으로 저장되었는지에 따라 옵션 사용 유무가 달라진다. | OpenGL과 DirectX는 Y(Green) 좌표계가 반대기 때문 | . 언리얼 엔진은 DirectX 기반이다. | OpenGL 기반 툴 (Blender, Substance Painter 등)에서 내보낸 노멀 맵을 언리얼에서 사용할 때 . | Flip Green Channel ☑️ (체크) | . | DirectX 기반 툴 (3ds Max, Maya 등)에서 내보낸 노멀 맵 . | Flip Green Channel ❌ (체크하지 않음) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#flip-green-channel"
  },"120": {
    "doc": "2. Master Material",
    "title": "11. Ambient Occlusion",
    "content": "광원과 관계없이, 환경 전체에서 모든 방향에서 들어오는 간접광(Ambient Light) 이 차폐되는 정도에 따라 어두움을 표현하는 기법 . | AO는 순수히 기하학적 구조(geometry)에 의해 결정되는 그림자 차폐 효과 | AO는 오직 모델의 형태와 표면 간 거리만으로 차폐 정도를 계산 | 광원이 움직여도 AO 결과는 변하지 않음 (방향성 없음) | 깊이감이나 접촉면 강조를 통해 공간 인지를 높임 | . 그림자와 AO의 차이 . | 항목 | 그림자 (Shadow) | 앰비언트 오클루전 (AO) | . | 광원 의존성 | 광원의 위치와 방향에 따라 달라짐 | 광원과 상관없이 항상 동일함 | . | 생성 원리 | 광원에서 물체까지 직진하는 빛이 막혔을 때 발생 | 공간적 차폐 정도에 따라 빛이 덜 도달하는 효과 | . | 형태 | 명확한 실루엣 형태 | 부드러운 음영 효과 | . | 변화 여부 | 광원이 움직이면 그림자도 변화 | 광원이 움직여도 AO는 고정됨 | . | 렌더링 목적 | 광원 존재감, 선명한 명암 표현 | 깊이감, 접촉 강조, 사실감 부여 | . AO는 오프라인 렌더링과 실시간 렌더링이 있는데 계산 방식이 다르다. 아래는 오프라인 렌더링 AO MAP 생성 과정이다. | 계산 기반 : 표면 점에서 주변 반구(헤미스피어)로 발사된 광선이 차단되는 비율”을 계산 | 실제 빛의 동작을 단순화한 모델이지만, 레이 트레이싱과 유사한 광선 충돌 검사를 사용 | 차폐 정도(Occlusion Factor)는 0.0(완전히 열림)에서 1.0(완전히 차폐됨) 사이의 값으로 표현 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#11-ambient-occlusion"
  },"121": {
    "doc": "2. Master Material",
    "title": "오프라인 AO 맵 생성 과정",
    "content": "AO 맵은 “표면 점 → 반구형 광선 발사 → 충돌 검사 → 차폐 비율 계산” 과정으로 생성됨 . 1.모델 준비 . 2.표면 점(Surface Point) 선택 . | 모델의 각 버텍스 또는 텍셀에서 AO를 계산 | 예시: 4K 텍스처(4096×4096)라면 1,600만 개 이상의 점을 처리. | . 3.반구형 샘플링(Hemispheric Sampling) . | 표면 법선(Normal) 기반 반구 정의 : 점의 법선 벡터(N)를 기준으로 반구(헤미스피어)를 생성 . | 광선은 이 반구 내에서만 무작위 방향으로 발사됨 | . | 광선 발사(Ray Casting) . | 각 점에서 N개 광선을 무작위 방향(θ, φ)으로 발사 | θ(세타) : 법선 기준 각도 (0°~90°). | φ(피) : 방위각 (0°~360°). | 광선 거리(Ray Distance): 일반적으로 장면 크기의 10~20%로 제한 | . | 광선 충돌 검사: 발사된 광선이 다른 지오메트리와 충돌하는지 확인 . | 충돌 시 : “차폐됨(Occluded)” | 충돌 없음 : “개방됨(Open)” | . | 차폐 비율 계산: AO 값 = (차폐된 광선 수) / (전체 광선 수) . | 예: 100개 광선 중 30개가 차폐됐다면 AO = 0.3 | . | . 4.텍스처 베이킹 . | 계산된 AO 값을 흑백 텍스처로 저장함 | 픽셀 보간: 버텍스 기반 결과를 텍스처 픽셀에 매핑할 때 보간(Interpolation)이 일어남 | . 참고하면 좋은 링크 ambient occlusion in unrealengine5 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-ao-%EB%A7%B5-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#오프라인-ao-맵-생성-과정"
  },"122": {
    "doc": "2. Master Material",
    "title": "픽셀 보간(Interpolation)",
    "content": "텍스처 베이킹에서 “픽셀 보간(Interpolation)”이란? . | 3D 모델의 버텍스(정점)에서 계산된 값을 텍스처의 픽셀에 자연스럽게 채우기 위해 평활화하는 과정 | . ❓왜 보간(Interpolation)이 필요해? . | 버텍스는 한정적이지만, 텍스처는 고해상도라 픽셀 수가 훨씬 많음 | 버텍스 값만으로는 텍스처가 계단 현상(Aliasing)이나 뚝뚝 끊긴 패턴이 생길 수 있음 | . 버텍스(Vertex) vs 텍셀(Texel) . | 버텍스 : 3D 모델의 꼭짓점. AO는 보통 버텍스 단위로 먼저 계산됨 (각 버텍스에서 광선 발사) | 텍셀 : 텍스처의 픽셀. UV 맵으로 매핑될 때 버텍스 사이의 빈 공간을 채워야 함 | . 픽셀 보간 과정 . | 버텍스 AO 값 생성 모델의 각 버텍스에서 AO 계산이 완료되면, 다음과 같은 값이 만들어짐 . | 버텍스 A : AO = 0.2 | 버텍스 B : AO = 0.7 | 버텍스 C : AO = 0.5 | . | UV 공간에서의 보간 . | 삼각형 내부 픽셀 처리 : UV 맵에서 삼각형(Face) 내부의 픽셀은 주변 버텍스의 AO 값의 가중 평균으로 채워짐 | 예시 : 아래 그림에서 P 픽셀의 AO는 A, B, C 버텍스 값의 Barycentric Coordinates(무게중심좌표)로 보간됨 P의 AO = (A의 AO × 가중치₁) + (B의 AO × 가중치₂) + (C의 AO × 가중치₃) . | 결과 : A(0.2), B(0.7), C(0.5) 사이의 픽셀은 0.2~0.7 사이의 부드러운 그레이드로 채워짐 | . | 보간 알고리즘 . | Bilinear Interpolation : 인접한 4개 버텍스 값으로 2D 평면 보간 | Barycentric Interpolation : 삼각형 내부에서 3개 버텍스 기반 보간 (가장 흔함) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#%ED%94%BD%EC%85%80-%EB%B3%B4%EA%B0%84interpolation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#픽셀-보간interpolation"
  },"123": {
    "doc": "2. Master Material",
    "title": "12. channel packing",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-channel-packing"
  },"124": {
    "doc": "2. Master Material",
    "title": "RMA MAP / ARM MAP",
    "content": "하나의 RGB 텍스처에 Grayscale 속성 맵 3개를 각각의 채널(R/G/B)에 패킹해서 저장하는 방식이다. 실시간 렌더링에서 텍스처 메모리와 샘플 호출을 절약하는 데 매우 유리하다. ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-map--arm-map"
  },"125": {
    "doc": "2. Master Material",
    "title": "RMA 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 | 설명 | . | R | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | G | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | B | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#rma-텍스쳐-구성"
  },"126": {
    "doc": "2. Master Material",
    "title": "ARM 텍스쳐 구성",
    "content": "| 채널 | 저장 정보 |   | . | R | Ambient Occlusion (AO) | 환경광 차폐 정보. 어두운 음영 영역을 강조 | . | G | Roughness | 표면의 거칠기. 0은 매끄러움, 1은 거침 | . | B | Metallic | 재질의 금속성. 0은 비금속, 1은 금속 | . | 경우에 따라 Alpha 채널에 다른 정보(예: Height, Opacity)를 저장하기도 한다. | 텍스쳐쳐 패킹 시 원본 맵의 명암비, 선명도가 유지되는지 확인해야 한다. | . | 장점 . | 메모리 절약: 3개의 별도 텍스처 대신 단일 텍스처로 관리 → VRAM 사용량 감소. | 성능 향상: 쉐이더에서 텍스처 샘플링 횟수 줄어듦 → 실시간 렌더링(게임)에 유리. | . | 단점 . | 텍스쳐 압축 알고리즘 특성 상 채널 간 데이터가 서로 영향을 미침 → Metallic(G) 채널의 강한 경계가 Roughness(R) 채널의 값을 흐리게 만들 수 있음 | 8비트 텍스처 (0~255)는 채널당 256단계만 표현 가능하므로 각 채널의 정밀도가 떨어진다. | 예: AO(B) 값의 127과 128 사이의 미세한 차이를 잃을 수 있음 | . | . | . 따라서 고퀄리티 아트워크에서는 RMA 대신 별도 맵 사용을 고려해야 한다. | 모바일 게임: RMA로 메모리 절약. | 시네마틱 렌더링: Roughness, Metallic, AO를 별도로 관리. | . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-%ED%85%8D%EC%8A%A4%EC%B3%90-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#arm-텍스쳐-구성"
  },"127": {
    "doc": "2. Master Material",
    "title": "12. displacement MAP",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#12-displacement-map"
  },"128": {
    "doc": "2. Master Material",
    "title": "13. project template",
    "content": "마테리얼 우클릭 -&gt; 에셋 액션 -&gt; migrate(마이그레이션) / 노드 그래프만 가져오고 싶으면 베이스 컬러 텍스쳐 -&gt; 디폴트 텍스쳐로 바꿔서 가져오면 됨 . ",
    "url": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/2.%20Master%20Material.html#13-project-template"
  },"129": {
    "doc": "2. Vertex Shader",
    "title": "2. Vertex Shader",
    "content": "가상의 3D 공간에 있는 꼭지점(vertex)들의 위치를 2차원 화면의 좌표로 변환하는 작업을 수행 . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html"
  },"130": {
    "doc": "2. Vertex Shader",
    "title": "Vertex Shader Overview",
    "content": "버텍스 쉐이더의 흐름 . | 로컬 좌표(local coordinates) . | 오브젝트의 로컬 원점(local origin)을 기준으로 한 좌표를 의미 | 오브젝트가 처음 위치하는 좌표계 | . | 월드 좌표(World-space coordinates) . | 더 큰 세계의 글로벌 원점(global origin)을 기준으로 한 좌표 | 여러 오브젝트들이 모두 이 원점을 기준으로 위치함 | . | 뷰 공간 좌표 (view-space coordinates) . | 카메라나 뷰어의 시점에서 바라본 좌표 | . | 클립 좌표(clip coordinates) . | -1.0 과 1.0 범위로 정규화된 좌표 | 어떤 버텍스가 화면에 나타날지 결정하는 역할을 한다 | . | 스크린 좌표(screen coordinates) . | Viewport | 에서 정의한 화면 좌표계 범위로 변환된 좌표 | . | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-shader-overview",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#vertex-shader-overview"
  },"131": {
    "doc": "2. Vertex Shader",
    "title": "좌표 변환 과정",
    "content": " ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#%EC%A2%8C%ED%91%9C-%EB%B3%80%ED%99%98-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#좌표-변환-과정"
  },"132": {
    "doc": "2. Vertex Shader",
    "title": "Object Space → World Space",
    "content": "참고 링크 . | learnopengl : CoordinateSystems | songho.ca : gl_transform | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#object-space--world-space",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/2.%20Vertex%20Shader.html#object-space--world-space"
  },"133": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "3. Gauss-Jordan elimination",
    "content": "연립일차방정식의 해를 구하거나 행렬의 역행렬을 계산하는 데 사용되는 체계적인 알고리즘 . 행렬을 기약 행 사다리꼴(RREF, Reduced Row Echelon Form)로 변환하는 과정을 수행함 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html"
  },"134": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "기본 행 연산",
    "content": "가우스-조던 소거법에서 사용하는 세 가지 기본 행 연산 . | 행 교환 | . \\[R_i \\leftrightarrow R_j\\] . | 행 스칼라 곱 | . \\[R_i \\rightarrow kR_i \\quad (k \\neq 0)\\] . | 행 합 | . \\[R_i \\rightarrow R_i + kR_j\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EA%B8%B0%EB%B3%B8-%ED%96%89-%EC%97%B0%EC%82%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#기본-행-연산"
  },"135": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "가우스-조던 소거법의 알고리즘 단계",
    "content": ". | (선택 사항) 각 행의 스칼라 값에 공통 인수가 있는 경우 공통 인수를 통해 약분함 . | 예 : 1행이 2 4 8 10 일 경우, 1 2 4 5 로 만듦 | . | 첫번째 행의 첫번째 원소가 0 이라면 첫 번째 열에 0이 아닌 원소가 있는 다른 행과 위치를 교환한다 | 첫번째 행의 첫번째 원소를 1로 만든다 | 첫번째 열의 다른 모든 요소를 0으로 만든다 | 다음 열과 행에 대해 위 과정을 반복한다 | 모든 선행 계수가 1이 되고, 각 열에서 선행 계수 외의 다른 요소들이 모두 0이 될 때 까지 진행한다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EA%B0%80%EC%9A%B0%EC%8A%A4-%EC%A1%B0%EB%8D%98-%EC%86%8C%EA%B1%B0%EB%B2%95%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#가우스-조던-소거법의-알고리즘-단계"
  },"136": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "선형 시스템 해의 개수",
    "content": "선형계에는 세 가지의 가능성이 존재한다 . | 유일해 (Unique Solution) | 해 없음 (no solution) | 무수히 많은 해 (infinitely many solutions) | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EC%84%A0%ED%98%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%95%B4%EC%9D%98-%EA%B0%9C%EC%88%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#선형-시스템-해의-개수"
  },"137": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "유일해",
    "content": ". | 행렬을 RREF로 만들었을 때 아래와 같은 형태가 나오면 해가 하나 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; a\\\\ 0 &amp; 1 &amp; 0 &amp; b \\\\ 0 &amp; 0 &amp; 1 &amp; c \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 한 점에서 만남 | 3차원 : 세 평면이 한 점에서 만남 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EC%9C%A0%EC%9D%BC%ED%95%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#유일해"
  },"138": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "해가 없음",
    "content": ". | 마지막 행이 0 ... 0 | c (c≠0) 이면 방정식 0 = c가 되어 모순이므로 해가 없음 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 0 &amp; a\\\\ 0 &amp; 1 &amp; 0 &amp; b \\\\ 0 &amp; 0 &amp; 0 &amp; c \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 평행 | 3차원 : 두 평면이 평행한 상황 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%ED%95%B4%EA%B0%80-%EC%97%86%EC%9D%8C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#해가-없음"
  },"139": {
    "doc": "3. Gauss-Jordan elimination",
    "title": "무한히 많은 해",
    "content": ". | RREF에서 피벗 열의 개수 &lt; 변수의 개수 . | 피벗 열 : 각 행의 첫 번째 0이 아닌 성분이 있는 열 | 변수의 개수 : 행렬에서 계수 행렬의 열 수 | . | 예를들어 마지막 행이 전부 0인 상태라면 (예: 0 0 0 | 0) | 0z = 0이 성립하므로 z에 어떤 값을 넣어도 성립하게 된다 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 1 &amp; 0 &amp; 2 &amp; a\\\\ 0 &amp; 1 &amp; -1 &amp; b \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\end{pmatrix}\\] . | 2차원 : 두 직선이 완전히 겹침 | 3차원 : 세 평면이 한 직선에서 만나거나, 두 평면이 일치하는 경우 | . 참고하면 좋은 링크 . | 가우스-조던 행렬 소거법이란? | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#%EB%AC%B4%ED%95%9C%ED%9E%88-%EB%A7%8E%EC%9D%80-%ED%95%B4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/3.%20Gauss-Jordan%20elimination.html#무한히-많은-해"
  },"140": {
    "doc": "3. Landscape",
    "title": "3. Landscape",
    "content": "대규모 지형(terrain)을 생성, 편집, 텍스처링, 디테일 배치까지 한 번에 관리할 수 있는 도구 . | 하이트맵(Heightmap) 기반의 지형 생성 | 높이 정보(흑백 이미지)만으로 입체적인 지형 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html"
  },"141": {
    "doc": "3. Landscape",
    "title": "시작하기",
    "content": ". | 우측 상단의 Select Mode 패널에서 Landscape 선택 | 단축키 : Shift + 2 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#시작하기"
  },"142": {
    "doc": "3. Landscape",
    "title": "Tool 구성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#tool-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#tool-구성"
  },"143": {
    "doc": "3. Landscape",
    "title": "1. Manage 관리",
    "content": "랜드 스케이프 생성, 관리 . | 사이즈는 컴포넌트 수로 결정 . | 랜드 스케이프 크기 조절 (가로 x 세로) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#1-manage-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#1-manage-관리"
  },"144": {
    "doc": "3. Landscape",
    "title": "2. Sculpt 조형",
    "content": "지형을 올리거나 내리고, 평평하게 만들고, 자연스러운 노이즈를 추가 . | 우클릭 : 시점 이동 | 좌클릭 : 쌓기 | Shift + 좌클릭 : 파기 | . 랜드 스케이프 브러쉬 . | 브러시 이름 | 적용 영역/방식 | 용도 | 주요 설정값 | . | Circle(원형) | 중심점 기준 원 범위 | 자연스러운 지형 변화, 기본 조형 | Size, Falloff, Strength | . | Alpha(알파) | 마스크 이미지 범위 | 독특한 무늬, 디테일, 자연스러운 불규칙 조형 | Image, Size, Rotation, Strength | . | Pattern(패턴) | 반복 무늬 타일 전체 | 논, 밭, 도로 등 규칙적/반복적 구조물 | Tile Size, Offset, Rotation, Strength | . | Component(컴포넌트) | Landscape 컴포넌트 전체 영역 | 구획별 일괄 편집, 성능 테스트, 대규모 영역 빠른 조형 | 선택 영역, Falloff, Strength | . | 랜드 스케이프 브러쉬 : 자세한 내용은 이 링크 참조 | . 스컬프팅 툴 . | 툴 이름 | 기본 목적 | 주 용도 | 기타 특성 | . | Sculpt | 높이 올리기/내리기 | 자연 조형, 산/언덕/계곡 | 강도, 크기, falloff 조절 | . | Smooth | 부드럽게 | 날카로운 곳 완화, 경계 다듬기 | 여러 번 적용할수록 더 부드러움 | . | Flatten | 평탄화 | 도로, 인공 구조물, 절벽 | 기준 높이 설정 | . | Ramp | 경사로 | 슬로프, 산길, 언덕길 | 시작/끝 지점 지정 | . | Noise | 노이즈 추가 | 자연스러운 거칠기, 바위, 산 | 세기, 패턴 조절 | . | Erosion | 침식 | 자연 계곡, 골짜기, 침식 표면 | 반복 적용 효과 누적 | . | Hydro Erosion | 수분 침식 | 리얼 수로, 강줄기, 침식 계곡 | 실제 수분 흐름 기반 결과 | . | Retopologize | 메쉬 최적화 | LOD 개선, 삼각형 분포 정리 | 대규모 지형 작업 후 주로 사용 | . | 스컬프팅 모드 : 스컬프팅 툴 설명 목록 참조 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#2-sculpt-%EC%A1%B0%ED%98%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#2-sculpt-조형"
  },"145": {
    "doc": "3. Landscape",
    "title": "3. Paint 페인팅",
    "content": "레이어 기반 텍스처 페인팅 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#3-paint-%ED%8E%98%EC%9D%B8%ED%8C%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#3-paint-페인팅"
  },"146": {
    "doc": "3. Landscape",
    "title": "Landscape Material",
    "content": "랜드스케이프(Landscape)에만 적용되는 특별한 머티리얼 . | 여러 종류의 텍스처(흙, 잔디, 바위, 눈 등)를 ‘레이어’로 분리해 페인팅(칠하기) 방식으로 조합 | 레이어 개수는 가급적 4~6개 이하 권장 | . ??? sampler source shared wrap . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material"
  },"147": {
    "doc": "3. Landscape",
    "title": "Landscape Material 생성하기",
    "content": ". | Material Editor에서 Layer Blend 노드 생성 . | 속성에서 어드밴스 : 완전 러프 체크 | . | Layer Blend 노드에서 인덱스 생성 -&gt; 레이어 이름 지정 | 랜드 스케이프에 사용할 텍스쳐, 노말 맵 들고 와서 각각 지정된 인덱스에 연결 | . | 랜드 스케이프 머티리얼 : 랜드 스케이프 머티리얼 생성 시 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#landscape-material-생성하기"
  },"148": {
    "doc": "3. Landscape",
    "title": "Layer info object",
    "content": "랜드스케이프에 칠할 수 있는 각 페인트 레이어(지형 재질 레이어)의 데이터를 저장하는 오브젝트 . | Landscape Material에는 여러 개의 레이어(예: Grass, Dirt, Sand 등)를 쓸 수 있다 | . ❓ 레이어 인포 오브젝트가 필요한 이유? . | 어느 위치에 어떤 레이어가 얼마나 칠해졌는지 정보를 저장하기 위해서 사용된다 | 즉, 브러시로 칠한 모든 정보(텍스처, 마스크, 웨이트맵)가 레이어 인포 오브젝트 에셋으로 보존된다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object"
  },"149": {
    "doc": "3. Landscape",
    "title": "Layer Info Object 종류",
    "content": ". | Weight-Blended Layer (가중치 기반) . | 여러 레이어가 한 영역에 겹칠 수 있음 | 대표적으로 흙(Soil), 풀(Grass), 눈(Snow) 등 자연스럽게 블렌딩 | . | Non-Weight-Blended Layer (마스크 기반, 단일 값) . | 한 영역에 단 하나의 레이어만 활성 | 주로 인공 구조물, 길 등 명확히 구분해야 할 경우 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-종류"
  },"150": {
    "doc": "3. Landscape",
    "title": "Layer info object 생성하기",
    "content": ". | 랜드 스케이프 머티리얼 생성 및 레이어 노드 추가 . | Landscape Material에 Layer Blend 노드를 통해 레이어 지정 | . | Landscape 선택 → 페인트 모드 진입 . | Paint 탭에서 머티리얼에 정의된 레이어 목록 확인 . | UE5.5이상 : 할당된 머티리얼에서 레이어 생성 아이콘 클릭 | . | . | 각 레이어에 Layer Info Object 할당 . | ‘None’ 상태인 레이어 옆의 ‘+’ 버튼 클릭 | Weight-Blended 혹은 Non-Weight-Blended 생성 | 경로 및 파일명 지정 후 프로젝트에 저장 (에셋 형태로 관리) | . | 브러시로 페인팅 . | 각 레이어 별로 칠해진 영역, 강도(Weight) 등 정보가 자동 저장됨 | . | . | 랜드 스케이프 페인트 모드 : 레이어 인포 오브젝트 생성 시 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#layer-info-object-생성하기"
  },"151": {
    "doc": "3. Landscape",
    "title": "직접 만들어본 랜드 스케이프",
    "content": ". 참고하면 좋은 링크 . -Tiling In Landscape Textures . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B8-%EB%9E%9C%EB%93%9C-%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/3.%20Landscape.html#직접-만들어본-랜드-스케이프"
  },"152": {
    "doc": "3. Linear Subspaces",
    "title": "Linear Subspaces",
    "content": "선형 부분공간 . | 4개 주요 부분 공간 간의 관계 | . ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#linear-subspaces",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html#linear-subspaces"
  },"153": {
    "doc": "3. Linear Subspaces",
    "title": "3. Linear Subspaces",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/3.%20Linear%20Subspaces.html"
  },"154": {
    "doc": "3. Scene create",
    "title": "3. Scene create",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html"
  },"155": {
    "doc": "3. Scene create",
    "title": "1. 씬 계획하기",
    "content": ". | Find Reference Image : 컨셉 이미지 찾아보기 | block out : 대략적인 레이아웃 잡기 | Layering : 디테일 쌓기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-%EC%94%AC-%EA%B3%84%ED%9A%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#1-씬-계획하기"
  },"156": {
    "doc": "3. Scene create",
    "title": "fab export",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#fab-export"
  },"157": {
    "doc": "3. Scene create",
    "title": "2. post process vlome",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#2-post-process-vlome"
  },"158": {
    "doc": "3. Scene create",
    "title": "lumen",
    "content": "이머시브 마테리얼도 라이트에 영향을 줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#lumen"
  },"159": {
    "doc": "3. Scene create",
    "title": "nanite ? what",
    "content": "이 설정 꺼야 버텍스 페인팅 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#nanite--what"
  },"160": {
    "doc": "3. Scene create",
    "title": "3. material blend",
    "content": "베이스, 중간, 탑 . 버텍스 브러쉬 . | 검정 : 칠해짐 | 흰색 : 지워짐 | r : 중간 텍스쳐 | g : 탑 텍스쳐 | b : puddle 레이어 (젖은 웅덩이 생성) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#3-material-blend"
  },"161": {
    "doc": "3. Scene create",
    "title": "vertex painting",
    "content": "표면의 꼭짓점에 어떠한 것을 칠할 수 있도록 해줌 . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#vertex-painting"
  },"162": {
    "doc": "3. Scene create",
    "title": "4. decal",
    "content": ". | 표면에 붙일 수 있는 스티커 | 메시에 투사시킬수 있는 머티리얼 | sort order : 레이어 순서 (데칼이 겹쳤을 때 어느것이 위인지 결정) | wet decal : 데칼이 웅덩이에 영향을 받게 하고싶으면 마스터 머티리얼 복사해서 wet_decal 만든 뒤 러프니스 연결 끊기 | 스태틱 메시가 데칼의 영향을 받지 않게끔 하려면 Advanced의 Receives Decals 옵션 끄기 decal | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#4-decal"
  },"163": {
    "doc": "3. Scene create",
    "title": "Editor Utility Tool / Editor Scripting",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . cpp-quick-start . | g: 뷰포트 아이콘 끄기 켜기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/3.%20Scene%20create.html#editor-utility-tool--editor-scripting"
  },"164": {
    "doc": "4. Foliage",
    "title": "4. Foliage",
    "content": "자연 환경을 빠르고 효율적으로 구현하기 위한 식생(풀, 나무, 관목 등) 배치 툴 . | Foliage 모드로 진입 : Shift + 3 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html"
  },"165": {
    "doc": "4. Foliage",
    "title": "Paint",
    "content": "다수의 폴리지를 선택하여 브러시 형태로 칠해 배치한다 . | 여러 식생 동시에 배치 가능 | 페인트 밀도가 중요함 | . | 전체 선택 : Ctrl + A . | 배치 후 선택 해제 꼭 하기 | . | 지우기 : Shift | 폴리지 수직 정렬 : 폴리지 메시 더블 클릭 -&gt; 설정 창의 배치 -&gt; 노멀에 정렬 체크 해제 | . Paint 세부 옵션 . | 밀도(Density): 브러시 당 배치 빈도 (0~100%) | 반경(Radius): 인스턴스 간 최소 간격 | Scale Randomness: 크기 랜덤화 (자연스러운 변이 감소) | Align to Normal: 지형 노멀 방향 정렬 (경사면 적용 시 중요) | Random Yaw: Y축 회전 랜덤화 (단조로움 방지) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#paint",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#paint"
  },"166": {
    "doc": "4. Foliage",
    "title": "프레임 저하 현상 발생할 때",
    "content": ". | 상단 툴바의 edit 클릭 | 프로젝트 세팅 클릭 | 프로젝트 세팅의 렌더링에서 shadow 검색 | shadow의 Map Method -&gt; shadow map으로 변경 | Anti-Aliasing method -&gt; TAA로 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%94%84%EB%A0%88%EC%9E%84-%EC%A0%80%ED%95%98-%ED%98%84%EC%83%81-%EB%B0%9C%EC%83%9D%ED%95%A0-%EB%95%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#프레임-저하-현상-발생할-때"
  },"167": {
    "doc": "4. Foliage",
    "title": "나무 충돌 설정",
    "content": ". | 충돌 설정할 나무 폴리지 우클릭 | 에셋 액션 -&gt; 프로퍼티 매트릭스에서 선택 편집 | Display 탭에서 collision 검색 | Collision Profile Name : BlockAll 로 설정 | . | 충돌 설정 안될 때, 페인트 툴 옆 재적용 브러시 사용하기 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%EB%82%98%EB%AC%B4-%EC%B6%A9%EB%8F%8C-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#나무-충돌-설정"
  },"168": {
    "doc": "4. Foliage",
    "title": "Foliage 모드의 성능 최적화 원리",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#foliage-%EB%AA%A8%EB%93%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#foliage-모드의-성능-최적화-원리"
  },"169": {
    "doc": "4. Foliage",
    "title": "1. Instanced Static Mesh 시스템",
    "content": ". | Foliage가 배치하는 오브젝트는 Instanced Static Mesh Actor로 묶여서 관리됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#1-instanced-static-mesh-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#1-instanced-static-mesh-시스템"
  },"170": {
    "doc": "4. Foliage",
    "title": "ISM 구조",
    "content": ". | 동일한 Mesh Asset의 모든 오브젝트는 하나의 Instanced Static Mesh 컴포넌트로 관리 | 각 오브젝트(Instance)는 개별 위치, 회전, 스케일 등 변환(transform) 정보만 다름 | 메시 데이터(Vertex, Index, 머티리얼 등)는 공유됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#ism-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#ism-구조"
  },"171": {
    "doc": "4. Foliage",
    "title": "효과",
    "content": ". | CPU → GPU Draw Call 감소 . | Static Mesh Actor 1개는 1개의 드로우 콜 발생 . | 예: Static Mesh Actor 나무 1000 그루 -&gt; 1000 개의 드로우 콜 | . | Instanced Static Mesh는 한 번의 드로우콜로 10,000개를 모두 처리 | . | GPU의 Instancing 기능을 이용해 한 번에 여러 오브젝트 렌더링 | . | 메모리 사용량 절감 . | 메시와 머티리얼이 공유되어 각 인스턴스는 transform 정보(16~32 bytes)만 별도로 저장 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%9A%A8%EA%B3%BC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#효과"
  },"172": {
    "doc": "4. Foliage",
    "title": "2. Hierarchical Instanced Static Mesh (HISM) 시스템",
    "content": "Foliage Tool은 일반 ISM보다 더 고성능의 HISM을 기본적으로 사용 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#2-hierarchical-instanced-static-mesh-hism-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#2-hierarchical-instanced-static-mesh-hism-시스템"
  },"173": {
    "doc": "4. Foliage",
    "title": "HISM 구조",
    "content": "각 인스턴스를 공간으로 분할하여 Scene의 특정 영역에 속한 인스턴스만 빠르게 선택, 제거 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#hism-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#hism-구조"
  },"174": {
    "doc": "4. Foliage",
    "title": "효과",
    "content": ". | View Frustum Culling . | 화면 밖에 있는 인스턴스는 GPU에서 자동으로 렌더링에서 제외 | . | Cluster 단위로 Draw Call 발생 . | 화면에 보이는 인스턴스만 묶어서 최소 Draw Call로 처리 | . | LOD(레벨 오브 디테일) 최적화 . | 거리에 따라 LOD를 다르게 적용, 멀리서는 저해상도/심지어 안 보이게 처리 | . | Occlusion Culling . | 다른 오브젝트에 가려진 인스턴스도 렌더링 생략 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%ED%9A%A8%EA%B3%BC-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#효과-1"
  },"175": {
    "doc": "4. Foliage",
    "title": "직접 해본 폴리지",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#%EC%A7%81%EC%A0%91-%ED%95%B4%EB%B3%B8-%ED%8F%B4%EB%A6%AC%EC%A7%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/4.%20Foliage.html#직접-해본-폴리지"
  },"176": {
    "doc": "4. Matrix addition & subtraction",
    "title": "4. Matrix addition &amp; subtraction",
    "content": "행렬의 덧셈과 뺄셈 . 행렬의 덧셈과 뺄셈은 같은 크기의 행렬에 대해서만 수행가능 하다 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#4-matrix-addition--subtraction",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#4-matrix-addition--subtraction"
  },"177": {
    "doc": "4. Matrix addition & subtraction",
    "title": "Matrix addition",
    "content": "행렬 덧셈 . \\[A + B = \\begin{pmatrix} a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \\cdots &amp; a_{1n} + b_{1n} \\\\ a_{21} + b_{21} &amp; a_{22} + b_{22} &amp; \\cdots &amp; a_{2n} + b_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \\cdots &amp; a_{mn} + b_{mn} \\end{pmatrix}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-addition",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-addition"
  },"178": {
    "doc": "4. Matrix addition & subtraction",
    "title": "Matrix subtraction",
    "content": "행렬 뺄셈 . \\[A - B = \\begin{pmatrix} a_{11} - b_{11} &amp; a_{12} - b_{12} &amp; \\cdots &amp; a_{1n} - b_{1n} \\\\ a_{21} - b_{21} &amp; a_{22} - b_{22} &amp; \\cdots &amp; a_{2n} - b_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{m1} - b_{m1} &amp; a_{m2} - b_{m2} &amp; \\cdots &amp; a_{mn} - b_{mn} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-subtraction",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#matrix-subtraction"
  },"179": {
    "doc": "4. Matrix addition & subtraction",
    "title": "결합법칙",
    "content": ". | 행렬 덧셈은 결합 법칙이 성립한다 | . \\[(A + B) + C = A + (B + C)\\] . 결합법칙 증명 계산 . \\(A = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 5 &amp; 6 \\\\ 7 &amp; 8 \\end{pmatrix}, \\quad C = \\begin{pmatrix} 9 &amp; 10 \\\\ 11 &amp; 12 \\end{pmatrix}\\) . | \\((A + B) + C\\) 계산 | . \\[A + B = \\begin{pmatrix} 1+5 &amp; 2+6 \\\\ 3+7 &amp; 4+8 \\end{pmatrix} = \\begin{pmatrix} 6 &amp; 8 \\\\ 10 &amp; 12 \\end{pmatrix}\\] \\[(A + B) + C = \\begin{pmatrix} 6+9 &amp; 8+10 \\\\ 10+11 &amp; 12+12 \\end{pmatrix} = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . | \\(A + (B + C)\\) 계산 | . \\[B + C = \\begin{pmatrix} 5+9 &amp; 6+10 \\\\ 7+11 &amp; 8+12 \\end{pmatrix} = \\begin{pmatrix} 14 &amp; 16 \\\\ 18 &amp; 20 \\end{pmatrix}\\] \\[A + (B + C) = \\begin{pmatrix} 1+14 &amp; 2+16 \\\\ 3+18 &amp; 4+20 \\end{pmatrix} = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . | 결론 | . \\[(A + B) + C = A + (B + C) = \\begin{pmatrix} 15 &amp; 18 \\\\ 21 &amp; 24 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#결합법칙"
  },"180": {
    "doc": "4. Matrix addition & subtraction",
    "title": "행렬 뺄셈과 결합법칙",
    "content": ". | 행렬 뺄셈은 결합법칙이 성립하지 않는다 | 행렬 뺄셈은 결합 방향에 따라 결과가 달라진다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%ED%96%89%EB%A0%AC-%EB%BA%84%EC%85%88%EA%B3%BC-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#행렬-뺄셈과-결합법칙"
  },"181": {
    "doc": "4. Matrix addition & subtraction",
    "title": "뺄셈은 결합법칙이 성립하지 않는 이유",
    "content": ". | \\((A - B) - C\\) : 먼저 A에서 B를 빼고, 그 결과에서 C를 다시 뺌 | \\(A - (B - C)\\) : 먼저 B에서 C를 빼고, A에서 그 결과를 뺌 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EB%BA%84%EC%85%88%EC%9D%80-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#뺄셈은-결합법칙이-성립하지-않는-이유"
  },"182": {
    "doc": "4. Matrix addition & subtraction",
    "title": "뺄셈에서 결합법칙이 성립하지 않는 이유 예시",
    "content": "\\[A = \\begin{pmatrix} 5 &amp; 7 \\\\ 3 &amp; 2 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 2 &amp; 3 \\\\ 1 &amp; 4 \\end{pmatrix}, \\quad C = \\begin{pmatrix} 1 &amp; 2 \\\\ 1 &amp; 1 \\end{pmatrix}\\] . | \\((A - B) - C\\) 계산 | . \\[A - B = \\begin{pmatrix} 5-2 &amp; 7-3 \\\\ 3-1 &amp; 2-4 \\end{pmatrix} = \\begin{pmatrix} 3 &amp; 4 \\\\ 2 &amp; -2 \\end{pmatrix}\\] \\[(A - B) - C = \\begin{pmatrix} 3-1 &amp; 4-2 \\\\ 2-1 &amp; -2-1 \\end{pmatrix} = \\begin{pmatrix} 2 &amp; 2 \\\\ 1 &amp; -3 \\end{pmatrix}\\] . | \\(A - (B - C)\\) 계산 | . \\[B - C = \\begin{pmatrix} 2-1 &amp; 3-2 \\\\ 1-1 &amp; 4-1 \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 3 \\end{pmatrix}\\] \\[A - (B - C) = \\begin{pmatrix} 5-1 &amp; 7-1 \\\\ 3-0 &amp; 2-3 \\end{pmatrix} = \\begin{pmatrix} 4 &amp; 6 \\\\ 3 &amp; -1 \\end{pmatrix}\\] – . | 결과 비교 | . \\[(A - B) - C = \\begin{pmatrix} 2 &amp; 2 \\\\ 1 &amp; -3 \\end{pmatrix} \\neq A - (B - C) = \\begin{pmatrix} 4 &amp; 6 \\\\ 3 &amp; -1 \\end{pmatrix}\\] . | 결론 | . 행렬 뺄셈은 결합법칙이 성립하지 않음 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#%EB%BA%84%EC%85%88%EC%97%90%EC%84%9C-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html#뺄셈에서-결합법칙이-성립하지-않는-이유-예시"
  },"183": {
    "doc": "4. Matrix addition & subtraction",
    "title": "4. Matrix addition & subtraction",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/4.%20Matrix%20addition%20&%20subtraction.html"
  },"184": {
    "doc": "5. Post Process Volume",
    "title": "5. Post Process Volume",
    "content": "시각적 효과 후처리 도구. 장면의 전체적인 모습과 분위기를 바꾸는데 사용된다 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html"
  },"185": {
    "doc": "5. Post Process Volume",
    "title": "특징",
    "content": ". | 범위 기반 효과 적용 . | 특정 볼륨 내부에서만 효과가 적용되도록 설정 가능 | 무한 범위로 설정하면 전체 레벨에 적용 가능 | . | 다양한 시각 효과 . | 색조, 대비, 채도 조정 | 블룸(빛 번짐 효과), 렌즈 플레어 | 모션 블러, 피사계 심도(DOF) | 안개, 색상 분위기(Grading) | 글로벌 일루미네이션 강도 조정 | . | 블렌딩 기능 . | 여러 볼륨이 겹칠 경우 효과를 부드럽게 혼합 | 우선순위 설정으로 어떤 효과가 먼저 적용될지 결정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#특징"
  },"186": {
    "doc": "5. Post Process Volume",
    "title": "동작 방식",
    "content": ". | 카메라 위치를 기준으로 활성화된 Post Process Volume 결정 . | 매 프레임마다 카메라 위치 검사 | 카메라가 볼륨 경계 내에 있거나 “무한 범위(Unbound)”로 설정된 볼륨 선택 | . | 여러 볼륨이 겹칠 경우 . | 우선순위(Priority), 블렌드 가중치(Blend Weight)에 따라 효과 혼합 | . | . | Intro to Post-processing | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#동작-방식"
  },"187": {
    "doc": "5. Post Process Volume",
    "title": "주요 설정 항목",
    "content": "| 카테고리 | 설정 항목 | 기본값 | 설명 | . | 기본 설정 | bEnabled | true | 볼륨 효과 활성화/비활성화 | . |   | bUnbound | false | true 시 전체 월드에 효과 적용 (볼륨 경계 무시) | . |   | Priority | 0 | 효과 적용 우선순위 (높을수록 우선 적용) | . | 블렌딩 | Blend Radius | 100 | 볼륨 경계에서 효과가 부드럽게 혼합되는 범위 | . |   | Blend Weight | 1.0 | 효과 강도 (0.0 ~ 1.0) | . | 렌즈 효과 | Vignette Intensity | 0.0 | 화면 모서리 어둡게 처리 (비네팅 효과) | . |   | Depth of Field (DOF) | - | 피사계 심도 설정 (Focal Distance, Aperture 등 하위 옵션 존재) | . | Bloom | Intensity | 0.675 | 빛 번짐 효과 강도 | . | 색조/대비 | Color Contrast | 1.0 | 색상 대비 조정 (1.0 = 기본값) | . |   | Color Saturation | 1.0 | 채도 조정 (0.0 = 흑백) | . |   | Color Gamma | 1.0 | 감마 보정 | . |   | White Balance | 6500K | 화이트 밸런스 (색온도 조절) | . | 글로벌 일루미네이션 | Global Illumination Intensity | 1.0 | Lumen 또는 Lightmass GI 강도 조정 | . | 안개/대기 | Fog Density | 0.02 | 볼륨트릭 안개 밀도 | . |   | Atmospheric Fog Intensity | 1.0 | 대기 효과 강도 | . | 모션 효과 | Motion Blur Amount | 0.5 | 모션 블러 강도 (0.0 = 비활성화) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#%EC%A3%BC%EC%9A%94-%EC%84%A4%EC%A0%95-%ED%95%AD%EB%AA%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/5.%20Post%20Process%20Volume.html#주요-설정-항목"
  },"188": {
    "doc": "5. Zero Matrix",
    "title": "5. Zero Matrix",
    "content": "영행렬은 모든 성분이 0인 행렬 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html"
  },"189": {
    "doc": "5. Zero Matrix",
    "title": "정의",
    "content": "m × n 영행렬 O는 모든 i (1 ≤ i ≤ m)와 j (1 ≤ j ≤ n)에 대해 다음을 만족한다 . \\[O_{ij} = 0\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#정의"
  },"190": {
    "doc": "5. Zero Matrix",
    "title": "주요 성질",
    "content": ". | 행렬 덧셈의 항등원 : 어떤 행렬 A에 대해 A + O = A와 O + A = A가 성립 | . \\[A + O = O + A = A\\] . | 행렬 뺄셈 : 같은 크기의 행렬 A에 대해 A - A = O 와 A - O = A 성립 | . \\[A - A = O\\] \\[A − O = A\\] . | 스칼라 곱 : 어떤 스칼라 k에 대해 kO = O 이다 | . \\[kO = O\\] . | 행렬 곱 : A가 m × n 행렬일 때 | . \\[A_{m \\times n}O_{n \\times p} = O_{m \\times p}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#%EC%A3%BC%EC%9A%94-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#주요-성질"
  },"191": {
    "doc": "5. Zero Matrix",
    "title": "opposite matrix &amp; Zero matrix",
    "content": "역행렬과 영행렬 . | 역행렬 : 임의의 행렬 K에 -1을 곱한 행렬 | . \\[-K = (-1)K\\] . | 행렬과 행렬의 역행렬을 더하면 같은 차원의 영행렬이 됨 | . \\[K + (-K) = O_{m×n}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#opposite-matrix--zero-matrix",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/5.%20Zero%20Matrix.html#opposite-matrix--zero-matrix"
  },"192": {
    "doc": "6. Matrix multiplication",
    "title": "6. Matrix multiplication",
    "content": "행렬 곱셈 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html"
  },"193": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 차원 (Dimension) 규칙",
    "content": ". | 행렬 곱셈이 가능하기 위해서는 . | 첫 번째 행렬의 열 개수 | 두 번째 행렬의 행 개수가 같아야 함 | . | . \\[A \\text{ is } m \\times n \\text{ and } B \\text{ is } n \\times p \\rightarrow AB \\text{ is } m \\times p\\] \\[(m \\times n) \\times (n \\times p) = (m \\times p)\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EC%B0%A8%EC%9B%90-dimension-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-차원-dimension-규칙"
  },"194": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 예시",
    "content": "\\[A = \\begin{pmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{pmatrix}, \\quad B = \\begin{pmatrix} b_{11} &amp; b_{12} \\\\ b_{21} &amp; b_{22} \\end{pmatrix}\\] . \\[A \\times B = \\begin{pmatrix} a_{11}b_{11} + a_{12}b_{21} &amp; a_{11}b_{12} + a_{12}b_{22} \\\\ a_{21}b_{11} + a_{22}b_{21} &amp; a_{21}b_{12} + a_{22}b_{22} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-예시"
  },"195": {
    "doc": "6. Matrix multiplication",
    "title": "행렬 곱셈 법칙",
    "content": ". | 결합 법칙 | . \\[(A \\times B) \\times C = A \\times (B \\times C)\\] . | 분배 법칙 | . \\[A \\times (B + C) = A \\times B + A \\times C\\] . \\[(A + B) \\times C = A \\times C + B \\times C\\] . | 교환 법칙은 성립하지 않음 | . \\[A \\times B \\neq B \\times A \\quad \\text{(일반적으로)}\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#%ED%96%89%EB%A0%AC-%EA%B3%B1%EC%85%88-%EB%B2%95%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/6.%20Matrix%20multiplication.html#행렬-곱셈-법칙"
  },"196": {
    "doc": "6. Packed Level Actor",
    "title": "6. Packed Level Actor",
    "content": "여러 액터들을 하나의 단위로 묶어서 관리할 수 있게 해주는 특수한 유형의 액터 . | 배경에 반복 배치되는 소규모 오브젝트를 집합으로 관리 (HLOD 최적화 용) | 동적인 오브젝트에는 부적합하다 | . ❓ Packed Level Actor를 어떻게 이해하면 돼? . | 100개의 나무 액터를 Packed Level Actor로 Pack → 통합된 “나무 군집 메시” | 여러 Static Mesh → 단일 Static Mesh로 병합 | 원본의 복잡한 콜리전 → 간략화된 볼륨(Box/Convex Hull)으로 대체 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html"
  },"197": {
    "doc": "6. Packed Level Actor",
    "title": "사용 목적",
    "content": ". | 복잡한 액터 계층 구조 단순화: 여러 하위 액터들을 하나의 논리적 단위로 묶어 관리 | 재사용성 향상: 패키지된 레벨 액터를 다른 레벨이나 프로젝트에서 재사용 가능 | 성능 최적화: 그룹화된 액터들을 더 효율적으로 로드/언로드 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#사용-목적"
  },"198": {
    "doc": "6. Packed Level Actor",
    "title": "특징",
    "content": ". | 계층 구조 유지: 하위 액터들의 상대적 위치와 관계 보존 | 블루프린트 통합: PLA를 블루프린트로 변환하여 로직 추가 가능 | 월드 파티션 호환: 대형 월드 지원 시스템과 잘 통합됨 | 동적 로딩: 필요 시점에만 로드되도록 설정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#특징"
  },"199": {
    "doc": "6. Packed Level Actor",
    "title": "생성 방법",
    "content": ". | 여러 액터를 선택 . | 예시: 10개의 Static Mesh Actor, 2개의 Light, 3개의 Decal 등 | . | 선택된 액터 우클릭 -&gt; “Packed Level Actor 생성” | 오브젝트 중심점 설정 | 저장될 폴더 위치 지정 후 저장 | 새로운 Packed Level Actor BPP 에셋 생성 . | 선택된 액터들의 Static Mesh, 머티리얼, 콜리전 등 리소스 머지 | 단일 Static Mesh와 머티리얼 세트 생성 (Bake) | . | . | Level Instancing | World Partition - Hierarchical Level of Detail | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/6.%20Packed%20Level%20Actor.html#생성-방법"
  },"200": {
    "doc": "7. Level Instance",
    "title": "7. Level Instance",
    "content": "하나의 레벨(.umap)을 ‘오브젝트’처럼 메인 레벨에 인스턴스로 배치할 수 있는 시스템 . | Packed Level Actor가 오브젝트를 그룹으로 묶어 재사용화 했다면 | 레벨 인스턴스는 한 레벨 맵 (.umap)을 월드 안에 인스턴스로 재사용화 하는 개념 | . 즉, 레벨을 액터처럼 여러 번, 여러 위치에 복제/배치할 수 있음 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html"
  },"201": {
    "doc": "7. Level Instance",
    "title": "특징",
    "content": ". | 재사용성: 동일한 레벨 조각을 여러 위치에 반복적으로 배치 가능 | 동기화: 원본 레벨이 변경되면 모든 인스턴스에 자동 반영 | 계층 구조: 부모-자식 관계를 유지하며 복잡한 구조 생성 가능 | 에디터 지원: 인스턴스 편집 모드를 통해 인스턴스 내용 직접 수정 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#특징"
  },"202": {
    "doc": "7. Level Instance",
    "title": "사용 방법",
    "content": ". | 서브 레벨(.umap) 준비 . | 인스턴스화할 방, 건물, 블록 등 서브 레벨을 미리 생성 및 저장 | (예시: Room_A.umap, Building_Block.umap) | . | 메인 레벨(예: MainLevel.umap)을 열기 . | Place Actors 패널에서 Level Instance 또는 LevelInstance를 검색 | → 드래그해서 씬에 배치 | . | .umap 지정 . | 배치한 Level Instance 액터 선택 | Details 패널에서 Level 또는 Level Asset 속성에 사용할 .umap 파일 지정 (예시: Room_A.umap 파일을 드래그&amp;드롭, 또는 경로 지정) | . | 트랜스폼/복제 . | 일반 액터와 동일하게 위치, 회전, 스케일 조정 가능 | 각 인스턴스는 개별 트랜스폼을 가짐 | . | 게임을 실행하면, Level Instance로 배치한 모든 서브 레벨이 해당 위치에서 독립적으로 동작 | . - Main World (World.umap) ├─ Level Instance: Ocean (Ocean.umap) ├─ Level Instance: Jungle (Jungle.umap) └─ Level Instance: Desert (Desert.umap) . 팀 협업 시 맵 섹션을 분할 제작 → 병렬 개발 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#사용-방법"
  },"203": {
    "doc": "7. Level Instance",
    "title": "주요 설정 옵션",
    "content": "| 설정 항목 | 설명 | . | Level Asset | 인스턴스할 .umap 파일 지정 | . | Transform | 위치, 회전, 스케일(씬에서 직접 수정 가능) | . | Actor Merge Policy | 충돌 시 동작 정책(기본값: Use Level, Merge, 또는 Override 등) | . | Override Loading Policy | 월드 파티션/스트리밍 환경에서 Level Instance의 로드 정책(Always Loaded, Blueprint 등) | . | Edit in Place | 인스턴스된 레벨을 ‘현장 편집’ 모드로 전환하여, 해당 인스턴스 내 액터 직접 편집 가능 | . | Lock Transform | 트랜스폼(위치/회전/스케일) 잠금 여부 | . | Blueprint Class | Level Instance를 Blueprint로 래핑하여 로직 확장 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#%EC%A3%BC%EC%9A%94-%EC%84%A4%EC%A0%95-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#주요-설정-옵션"
  },"204": {
    "doc": "7. Level Instance",
    "title": "Packed Level Actor VS Level Instance",
    "content": "| 구분 | Packed Level Actor | Level Instance | . | 목적 | 렌더링 최적화(HLOD), 드로우콜 감소, LOD 관리 | 씬(맵) 구성 모듈화, 반복 배치, 유지보수/재사용성 강화 | . | 내부 구조 | 여러 액터 → 통합 메쉬/머티리얼 등으로 Bake된 단일 액터 | 레벨(.umap) 전체를 액터처럼 인스턴싱(복제) | . | 계층/정보 유지 | 원본 액터의 개별 정보 대부분 사라짐 (Bake 결과물만 남음) | 원본 레벨(액터, 컴포넌트, 논리 등) 구조 그대로 유지 | . | 동적 변경 | Packed Level Actor 자체는 런타임에 내용 수정 불가 | Level Instance는 에디터/런타임 모두 개별 인스턴스 수정 가능 | . | HLOD/LOD 연관 | HLOD 시스템과 직접 연결 | HLOD와 별개 필요 시 인스턴스화한 레벨에도 HLOD 적용 가능 | . | 스트리밍 연관 | HLOD/Level Streaming에서 효율화 목적 | Level Streaming, 월드 파티션에서 반복 구조 및 스트리밍에 용이 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#packed-level-actor-vs-level-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/7.%20Level%20Instance.html#packed-level-actor-vs-level-instance"
  },"205": {
    "doc": "7. identity matrix",
    "title": "7. identity matrix",
    "content": "항등 행렬 . 곱셈 결과를 바꾸지 않는 ‘1’에 해당하는 행렬 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html"
  },"206": {
    "doc": "7. identity matrix",
    "title": "항등 행렬의 개념",
    "content": ". | 항등행렬은 주로 I로 표시된다 | 반드시 정방( n×n ) 행렬이어야 한다 | 주 대각선은 1, 나머지는 0 이다 | . \\[I_n = \\begin{bmatrix} 1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix}_{n \\times n}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등-행렬의-개념"
  },"207": {
    "doc": "7. identity matrix",
    "title": "항등 행렬의 곱셈 성질",
    "content": "항등 행렬은 행렬 곱셈의 항등원 역할을 한다 . | 항등원 : 임의의 수에 어떤 수를 연산 했지만 연산 결과가 연산 전과 항상 같음 | . \\[IA = A \\\\ AI = A\\] . | 항등원과 행렬 곱셈 예시 | . \\[A = \\begin{bmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{bmatrix}, \\quad A I_3 = \\begin{bmatrix} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88-%EC%84%B1%EC%A7%88",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등-행렬의-곱셈-성질"
  },"208": {
    "doc": "7. identity matrix",
    "title": "항등행렬의 차원 규칙",
    "content": "| 곱셈 형태 | 필요한 I의 크기 | . | IA | A의 행 수만큼 \\(I_m\\) | . | AI | A의 열 수만큼 \\(I_n\\) | . 곱하는 순서에 따라 사용해야 할 항등행렬의 차원이 달라질 수 있다 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#%ED%95%AD%EB%93%B1%ED%96%89%EB%A0%AC%EC%9D%98-%EC%B0%A8%EC%9B%90-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/7.%20identity%20matrix.html#항등행렬의-차원-규칙"
  },"209": {
    "doc": "8. Elimination Matrix",
    "title": "8. Elimination Matrix",
    "content": "제거 행렬 . | 가우스 소거법(Gaussian Elimination)을 행렬 형태로 표현한 것 | 기본행연산(elementary row operations)을 수행한다 | . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html"
  },"210": {
    "doc": "8. Elimination Matrix",
    "title": "소거 행렬의 핵심",
    "content": ". | 각 행 연산은 하나의 행연산 행렬로 표현할 수 있다 | . | 수행하는 모든 행 연산의 전체를 하나의 행렬로 모은 행렬을 소거 행렬이라고 부른다 | . | 예시 | . \\[A = \\begin{bmatrix} -1 &amp; -5 &amp; \\;\\;1 \\\\ -5 &amp; -5 &amp; \\;\\;5 \\\\ \\;\\;2 &amp; \\;\\;5 &amp; -3 \\end{bmatrix}\\] . | 소거 행렬 | . \\[-R_1 \\to R_1\\] \\[E_1 = \\begin{bmatrix} -1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[\\tfrac15 R_2 \\to R_2\\] \\[E_2 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\tfrac15 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[R_1 + R_2 \\to R_2\\] \\[E_3 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[R_3 - 2R_1 \\to R_3\\] \\[E_4 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ -2 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[\\tfrac14 R_2 \\to R_2\\] \\[E_5 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\tfrac14 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[-5R_2 + R_1 \\to R_1\\] \\[E_6 = \\begin{bmatrix} 1 &amp; -5 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . \\[5R_2 + R_3 \\to R_3\\] \\[E_7 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 5 &amp; 1 \\end{bmatrix}\\] \\[-R_3 \\to R_3\\] \\[E_8 = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; -1 \\end{bmatrix}\\] \\[R_1 + R_3 \\to R_1\\] \\[E_9 = \\begin{bmatrix} 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . 따라서 . \\[E = E_9E_8E_7E_6E_5E_4E_3E_2E_1 = \\begin{bmatrix} -\\tfrac12 &amp; -\\tfrac12 &amp; -1\\\\[4pt] -\\tfrac14 &amp; \\tfrac1{20} &amp; 0\\\\[4pt] -\\tfrac34 &amp; -\\tfrac14 &amp; -1 \\end{bmatrix}\\] . \\[EA = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%86%8C%EA%B1%B0-%ED%96%89%EB%A0%AC%EC%9D%98-%ED%95%B5%EC%8B%AC",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#소거-행렬의-핵심"
  },"211": {
    "doc": "8. Elimination Matrix",
    "title": "소거 행렬은 행렬의 역행렬과 같다",
    "content": "\\[A^{-1} = \\begin{bmatrix} -\\tfrac12 &amp; -\\tfrac12 &amp; -1\\\\[4pt] -\\tfrac14 &amp; \\tfrac1{20} &amp; 0\\\\[4pt] -\\tfrac34 &amp; -\\tfrac14 &amp; -1 \\end{bmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%86%8C%EA%B1%B0-%ED%96%89%EB%A0%AC%EC%9D%80-%ED%96%89%EB%A0%AC%EC%9D%98-%EC%97%AD%ED%96%89%EB%A0%AC%EA%B3%BC-%EA%B0%99%EB%8B%A4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#소거-행렬은-행렬의-역행렬과-같다"
  },"212": {
    "doc": "8. Elimination Matrix",
    "title": "역행렬에 행렬을 곱하면 결과는 항등 행렬이다",
    "content": "\\[A^{-1}A = I\\] ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#%EC%97%AD%ED%96%89%EB%A0%AC%EC%97%90-%ED%96%89%EB%A0%AC%EC%9D%84-%EA%B3%B1%ED%95%98%EB%A9%B4-%EA%B2%B0%EA%B3%BC%EB%8A%94-%ED%95%AD%EB%93%B1-%ED%96%89%EB%A0%AC%EC%9D%B4%EB%8B%A4",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/8.%20Elimination%20Matrix.html#역행렬에-행렬을-곱하면-결과는-항등-행렬이다"
  },"213": {
    "doc": "APlayerController",
    "title": "APlayerController",
    "content": "플레이어의 입력(Input)을 받아 액터(주로 Pawn/Character)를 조작하는 역할을 담당하는 클래스 . | doc - APlayerController | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/APlayerController.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/APlayerController.html"
  },"214": {
    "doc": "Actor Component",
    "title": "Actor Component",
    "content": "Actor는 레벨에 출력되는 기본 단위이다. 이 Actor에 Component를 붙여 세부 기능을 추가할 수 있다 . | 컴포넌트란 액터의 부품으로 작동하며, 기능을 추가하는 모듈이다 (예: 메시, 충돌체, AI 로직 등) | Actor는 컴포넌트 시스템을 통해 기능을 확장할 수 있다 | . 참고하면 좋은 링크 . | Components | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html"
  },"215": {
    "doc": "Actor Component",
    "title": "컴포넌트 클래스 상속 구조",
    "content": "UObject (최상위 베이스 클래스) ├── UActorComponent (모든 컴포넌트의 기본 클래스) │ └── USceneComponent (변환(위치/회전/스케일)을 가진 컴포넌트) │ ├── UPrimitiveComponent (시각적 표현과 물리적 상호작용 가능) │ │ ├── UMeshComponent (메시 기반 컴포넌트) │ │ │ ├── UStaticMeshComponent (정적 메시 렌더링) │ │ │ └── USkeletalMeshComponent (스켈레탈 메시 렌더링) │ │ └── ULightComponent (광원 컴포넌트) │ └── UCameraComponent (카메라 기능 제공) └── AActor (월드에 배치 가능한 객체) └── APawn (플레이어 또는 AI가 제어할 수 있는 액터) └── ACharacter (캐릭터 특화 액터) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#컴포넌트-클래스-상속-구조"
  },"216": {
    "doc": "Actor Component",
    "title": "UActorComponent",
    "content": "가장 기본적인 컴포넌트로, 논리적 기능만 제공 . 액터 컴포넌트는 액터에 추가하여 동작을 확장할 수 있다 . 사용 사례 . | 데이터 관리 | 타이머 기반 로직 | 네트워크 동기화가 필요한 기능 | . 특징 . | 변환(Transform) 정보 없음 | 렌더링 기능 없음 | . // UHealthComponent.h UCLASS() class UHealthComponent : public UActorComponent { GENERATED_BODY() UPROPERTY(EditDefaultsOnly) float MaxHealth = 100.0f; UFUNCTION() void TakeDamage(float Damage); }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uactorcomponent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uactorcomponent"
  },"217": {
    "doc": "Actor Component",
    "title": "USceneComponent",
    "content": "위치, 회전, 스케일 정보를 가짐 . | 위치(location): Fvector | 회전(rotation): FRotator | 크기(scale): FVector | . GetActorLocation() : Root Compoent인 SceneComponent에서 위치 가져옴 . 사용 사례 . | 계층 구조 형성 (부모-자식 관계) | 다른 컴포넌트의 부모 역할 | 다른 컴포넌트에 Attachment 기능을 지원 | . 특징 . | 컴포넌트 간의 상대적 위치 지정 가능 | 액터의 RootComponent로 사용됨 | . Attachment . | 루트 구성요소가 이동하면 하위 SceneComponent도 같이 이동한다 | 루트와 하위 구성요소의 상대적인 거리는 항상 유지된다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uscenecomponent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#uscenecomponent"
  },"218": {
    "doc": "Actor Component",
    "title": "Static Mesh Component",
    "content": "스태틱 매시 컴포넌트를 Root Component로 만들 수도 있다 . | UStaticMeshComponent는 USceneComponent를 상속받으므로 가능 | . StaticMesh 컴포넌트를 Root로 만들기 . | 블루프린트 에디터 열기 | 좌측 컴포넌트 패널의 Add 버튼 누르기 | StaticMesh 컴포넌트 선택 -&gt; Details 패널에서 Static Mesh로 쓸 모델링 선택 | StaticMesh 컴포넌트를 드래그 하여 SceneRoot에 드롭 | StaticMesh 컴포넌트가 Root 컴포넌트가 됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#static-mesh-component",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Actor%20Component.html#static-mesh-component"
  },"219": {
    "doc": "Add Custom Delegate",
    "title": "목표: 콘텐트 브라우저 모듈을 로드하고 해당 모듈의 델리게이트 배열에 Custom 메뉴 델리게이트 추가하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%A1%9C%EB%93%9C%ED%95%98%EA%B3%A0-%ED%95%B4%EB%8B%B9-%EB%AA%A8%EB%93%88%EC%9D%98-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%B0%EC%97%B4%EC%97%90-custom-%EB%A9%94%EB%89%B4-%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#목표-콘텐트-브라우저-모듈을-로드하고-해당-모듈의-델리게이트-배열에-custom-메뉴-델리게이트-추가하기"
  },"220": {
    "doc": "Add Custom Delegate",
    "title": "Pragma region",
    "content": ". | IDE에서 확장하거나 축소할 수 있는 코드 블록 지정 | 버튼을 통해 소스 코드 블록을 접었다 펼 수 있다 | . #pragma region 리전이름 void Test(){ // ... } #pragma endregion 리전이름 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#pragma-region"
  },"221": {
    "doc": "Add Custom Delegate",
    "title": "InitCBMenuExtention() 함수 구현에 사용한 메서드",
    "content": "1. Module.GetAllPathViewContextMenuExtenders() . Content Browser의 폴더 뷰(경로 뷰)에서 우클릭 시 메뉴를 추가할 수 있도록 델리게이트(Extender) 리스트를 리턴해줌 . TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; GetAllPathViewContextMenuExtenders(); . | 반환값: . | TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; | 폴더 뷰 컨텍스트 메뉴 확장자(델리게이트) 리스트의 레퍼런스 | 이 리스트에 새로운 확장 델리게이트를 추가(Add) 하면, 폴더(경로) 우클릭 시 커스텀 메뉴가 동적으로 삽입됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#initcbmenuextention-함수-구현에-사용한-메서드"
  },"222": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 리스트",
    "content": "언리얼에서는 기존 시스템을 건드리지 않고 사용자만의 기능을 쉽게 추가할 수 있도록 모듈 내부에 델리게이트 배열을 가지고 있다 . | 모듈별로 델리게이트 리스트가 있음 | 여기에 커스텀 델리게이트를 추가하면 이벤트 발생 시 엔진이 모든 델리게이트를 순회하여 호출함 | . | 모듈 | 확장 대상 | 델리게이트 리스트 함수 | . | FContentBrowserModule | 폴더(경로) 컨텍스트 메뉴 | GetAllPathViewContextMenuExtenders() | . | FContentBrowserModule | 에셋(파일) 컨텍스트 메뉴 | GetAllAssetViewContextMenuExtenders() | . | FContentBrowserModule | 컬렉션 컨텍스트 메뉴 | GetAllCollectionViewContextMenuExtenders() | . | FLevelEditorModule | 툴바 메뉴 | GetAllLevelEditorToolbarMenuExtenders() | . | FLevelEditorModule | 뷰포트 컨텍스트 메뉴 | GetAllLevelViewportContextMenuExtenders() | . | FLevelEditorModule | 레벨 에디터 컨텍스트 메뉴 | GetAllLevelEditorContextMenuExtenders() | . | FSequencerModule | 시퀀서 메뉴 | GetAddMenuExtensibilityManager() | . | FMainFrameModule | 메인 프레임 메뉴/툴바 | GetMainFrameMenuExtensibilityManager() | . | FBlueprintEditorModule | 블루프린트 툴바/메뉴 | GetMenuExtensibilityManager()GetToolbarExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 메뉴 | GetMenuExtensibilityManager() | . | FPersonaModule | 캐릭터 에디터 툴바 | GetToolbarExtensibilityManager() | . | FComponentAssetBrokerModule | 에디터 에셋 관련 메뉴 | GetAssetBrokerMenuExtensibilityManager() | . 폴더(경로) 메뉴 확장 델리게이트 등록 예시 . void RegisterContentBrowserFolderMenuExtender() { // 1. ContentBrowser 모듈 인스턴스 획득 FContentBrowserModule&amp; ContentBrowserModule = FModuleManager::LoadModuleChecked&lt;FContentBrowserModule&gt;(TEXT(\"ContentBrowser\")); // 2. 폴더 뷰 컨텍스트 메뉴 델리게이트 리스트 획득 TArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; Extenders = ContentBrowserModule.GetAllPathViewContextMenuExtenders(); // 3. 사용자 델리게이트 생성 (람다 예시) FContentBrowserMenuExtender_SelectedPaths MyFolderMenuExtender = FContentBrowserMenuExtender_SelectedPaths::CreateLambda( [](const TArray&lt;FString&gt;&amp; SelectedPaths) -&gt; TSharedRef&lt;FExtender&gt; { TSharedRef&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); // 여기서 Extender-&gt;AddMenuExtension 등으로 커스텀 메뉴 항목을 추가 return Extender; } ); // 4. 델리게이트 리스트에 등록 (Add) Extenders.Add(MyFolderMenuExtender); } . 2. FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate . 콘텐츠 브라우저(Content Browser)의 컨텍스트 메뉴를 확장하기 위해 사용되는 델리게이트 타입 . | GetAllPathViewContextMenuExtenders()가 리턴하는 타입으로 델리게이트 타입 추론 가능 | 해당 타입의 정의를 가보면 반환값, 파라미터를 설명한 델리게이트 매크로를 볼 수 있음 | . 3. CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender) . 델리게이트에서 제공하는 여러 바인딩 메서드를 사용해 바인딩 할 수 있다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-리스트"
  },"223": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 바인딩 케이스",
    "content": "Case 1 : 명시적 변수 선언 + 바인딩 + 델리게이트 배열에 추가 . // 델리게이트 객체 선언 FContentBrowserMenuExtender_SelectedPaths CustomCBMenuDelegate; // 델리게이트를 통해 내가 쓸 커스텀 함수에 바인딩 CustomCBMenuDelegate.BindRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender); // 모듈의 델리게이트 배열에 내 함수를 바인딩한 델리게이트 추가 ContentBroswerModuleMenuExtenders.Add(CustomCBMenuDelegate); . | 가독성: delegate 선언 → 바인딩 → 추가, 각각의 단계가 명확하게 분리됨 | 디버깅 용이: 바인딩된 delegate를 변수로 직접 디버깅/추적/조작할 수 있음 | . Case 2 : CreateRaw()로 delegate 생성과 배열 추가 한번에 하기 . ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); . | 델리게이트 시스템에서 제공하는 정적 메서드 CreateRaw()로 생성과 배열 추가 한번에 가능 | 임시 변수가 없음: delegate 객체가 따로 이름을 가지지 않음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%BC%80%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-바인딩-케이스"
  },"224": {
    "doc": "Add Custom Delegate",
    "title": "델리게이트 static 생성 메서드",
    "content": "언리얼 델리게이트 타입이 아래 메서드들을 일관되게 제공 . 1. Raw 포인터 바인딩 . CreateRaw( RawObjectPtr, &amp;Class::Method ) FMyDelegate::CreateRaw(this, &amp;MyClass::Handler) . | 비-UObject C++ 클래스용 | . 2. UObject 바인딩 (자동 수명 관리) . CreateUObject( UObject*, &amp;UClass::Method ) FMyDelegate::CreateUObject(this, &amp;AMyActor::EventHandler) . | 가비지 컬렉션 대상 객체용 | . 3. 스마트 포인터 바인딩 . CreateSP( SharedPtr, &amp;Class::Method ) FMyDelegate::CreateSP(MySharedPtr.ToSharedRef(), &amp;FMyClass::Callback) . | TSharedPtr/TSharedRef와 함께 사용 | . 4. 스레드-안전 약한 포인터 . CreateThreadSafeSP( WeakPtr, &amp;Class::Method ) FMyDelegate::CreateThreadSafeSP(MyWeakPtr.Pin(), &amp;FMyClass::ThreadCallback) . | 멀티스레드 환경용 | . 5. 람다 함수 바인딩 . CreateLambda( []{ ... } ) FMyDelegate::CreateLambda([this](){ UE_LOG(LogTemp, Warning, TEXT(\"Lambda called!\")); . | 인라인 콜백 구현 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-static-%EC%83%9D%EC%84%B1-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html#델리게이트-static-생성-메서드"
  },"225": {
    "doc": "Add Custom Delegate",
    "title": "Add Custom Delegate",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Add%20Custom%20Delegate.html"
  },"226": {
    "doc": "Add Prifixes To Assets",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 클래스에 맞는 접두사(예: BP_) 붙이기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%A0%91%EB%91%90%EC%82%AC%EC%98%88-bp_-%EB%B6%99%EC%9D%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#목표-콘텐트-폴더에서-선택한-에셋-클래스에-맞는-접두사예-bp_-붙이기"
  },"227": {
    "doc": "Add Prifixes To Assets",
    "title": "Add Prifixes To Assets",
    "content": ". | TMap&lt;UClass*, FString&gt; PrefixMap 에 Prifixes 목록 작성 . | 예: {UBlueprint::StaticClass(),TEXT(\"BP_\")} | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html"
  },"228": {
    "doc": "Add Prifixes To Assets",
    "title": "add Prifixes 함수 구현에 사용한 메서드",
    "content": "1. UObject* S-&gt;GetClass()-&gt;GetName() . | 클래스 이름을 반환 . | (예: “AActor”, “UMyComponent”) | . | 해당 오브젝트가 어떤 클래스로 생성되었는지 알 수 있음 | . 2. UObject* S-&gt;GetName() . | 오브젝트 인스턴스의 이름을 반환 . | (예: “Player_123”, “Weapon_Sword”) | . | 에디터에서 부여한 이름이나 동적으로 생성된 이름이 반환 | . AActor* MyActor = GetWorld()-&gt;SpawnActor&lt;AActor&gt;(...); FString ClassName = MyActor-&gt;GetClass()-&gt;GetName(); // \"AActor\" FString InstanceName = MyActor-&gt;GetName(); // \"MyActor_42\" . 3. FString::StartsWith() . | 문자열이 특정 문자열로 시작하는지 여부를 bool로 반환 | 대소문자 구분 여부 선택 옵션 존재 | 주의 : InPrefix가 빈 문자열이면 항상 true를 반환 | . 함수 시그니처 . bool StartsWith( const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . 사용 예시 . FString FilePath = \"Content/Textures/PlayerTexture.png\"; // 대소문자 무시 (기본값) bool bIsContent = FilePath.StartsWith(\"Content\"); // true // 대소문자 구분 bool bIsExact = FilePath.StartsWith(\"content\", ESearchCase::CaseSensitive); // false // 실제 활용 예시 if (FilePath.StartsWith(\"Content/Textures/\")) { UE_LOG(LogTemp, Warning, TEXT(\"텍스처 경로가 유효합니다.\")); } . 4. FString::RemoveFromStart . | 대상 문자열의 앞부분이 특정 문자열로 시작할 경우, 해당 부분을 제거 | . bool RemoveFromStart(const FString&amp; InPrefix, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase); . | 매개변수 . | InPrefix: 앞에서 제거하고자 하는 문자열(접두사, Prefix) | SearchCase: 대소문자 구분 여부 (ESearchCase::IgnoreCase 또는 ESearchCase::CaseSensitive) | . | 반환값 . | 제거 성공 true / 실패 false | . | . 5. FString::RemoveFromEnd . | 대상 문자열의 끝이 특정 문자열로 끝날 경우, 해당 부분을 제거 | 위 메서드와 동일하게 뒤에서 제거하고자 하는 문자열과 대소문자 구분 여부를 받는다. | . FString Str = TEXT(\"HelloWorld\"); bool bRemoved = Str.RemoveFromEnd(TEXT(\"World\")); // Str은 \"Hello\"가 되고, bRemoved는 true FString Str2 = TEXT(\"HelloWorld\"); bool bRemoved2 = Str2.RemoveFromEnd(TEXT(\"Hi\")); // Str2는 그대로 \"HelloWorld\", bRemoved2는 false . 6. UObject::IsA() . | 해당 오브젝트가 특정 클래스 타입이거나 그 클래스의 자식 클래스인지를 확인하는 메서드 | 비슷한 경우로 IsA(UClass*) 가 있다 | . 예시 . // IsA&lt;T&gt;() template&lt;typename T&gt; FORCEINLINE bool IsA() const { return IsA(T::StaticClass()); } if (SelectedObject-&gt;IsA&lt;UMaterialInstanceConstant&gt;()) { // UMaterialInstanceConstant 타입일 때 실행 } // IsA() bool IsA(const UClass* TargetClass) const; if (SelectedObject-&gt;IsA(AActor::StaticClass())) { UE_LOG(LogTemp, Warning, TEXT(\"이 오브젝트는 Actor입니다!\")); } . ❓ 왜 머티리얼 인스턴스 클래스를 찾으려면 UMaterialInstanceConstant를 사용해야 할까? . | 계층구조 UMaterialInterface (베이스) ├─ UMaterial (실제 마테리얼 에셋) └─ UMaterialInstance (인스턴스 베이스) ├─ UMaterialInstanceDynamic (런타임 생성 인스턴스) └─ UMaterialInstanceConstant (에디터에서 생성된 인스턴스) . | . | UMaterialInstance . | 추상 베이스 클래스. 직접 인스턴스화되지 않음 | . | UMaterialInstanceConstant . | 에디터에서 미리 생성해 놓은 정적 마테리얼 인스턴스 | 런타임 중 파라미터 변경이 불가능 | . | UMaterialInstanceDynamic (MID) . | 런타임에 동적으로 생성되며, 파라미터를 실시간으로 변경할 수 있음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Add%20Prifixes%20To%20Assets.html#add-prifixes-함수-구현에-사용한-메서드"
  },"229": {
    "doc": "Asset Batch Duplication",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 복사하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#목표-콘텐트-폴더에서-선택한-에셋-복사하기"
  },"230": {
    "doc": "Asset Batch Duplication",
    "title": "Scripting Libraries",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#scripting-libraries"
  },"231": {
    "doc": "Asset Batch Duplication",
    "title": "1. UEditorUtilityLibrary::",
    "content": "에디터에서 에셋(Asset) 관련 작업을 자동화하기 위한 기능 제공 . | 에셋의 로드, 저장, 복사, 이동, 삭제 등 파일 시스템 수준의 작업 | 에셋 메타데이터(metadata) 접근 및 수정 | 에셋 의존성(dependencies) 분석 | 에셋 브라우저(Content Browser)와 연동된 작업 | . 메소드 . | GetSelectedAssetData() : TArray&lt;FAssetData&gt;를 반환 | GetSelectedAssets() : TArray&lt;UObject*&gt;를 반환 . | FAssetData는 UObject* 보다 더 많은 정보를 포함 | . | 모두 static 함수임 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#1-ueditorutilitylibrary"
  },"232": {
    "doc": "Asset Batch Duplication",
    "title": "2. UEditorAssetLibrary:: 클래스",
    "content": "에디터 UI 및 일반 유틸리티 작업을 지원 . | 선택된 객체(Selected Actors/Assets)에 접근 | 에디터 UI(알림, 다이얼로그) 제어 | 월드/레벨 편집과 관련된 작업 | 블루프린트/파이썬 스크립트와의 연동 용이 | . 정리 . | 에디터 상호작용 (선택된 객체 제어, 알림 표시, 다이얼로그 생성) → UEditorUtilityLibrary | 에셋 작업 (일괄 임포트, 이름 변경, 메타데이터 편집) → UEditorAssetLibrary | . | UEditorUtilityLibrary로 선택한 에셋을 가져온 후 UEditorAssetLibrary로 해당 에셋을 수정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#2-ueditorassetlibrary-클래스"
  },"233": {
    "doc": "Asset Batch Duplication",
    "title": ".uasset",
    "content": "Unreal Engine이 에디터에서 사용하는 에셋(데이터) 저장 파일 포맷 (파일 확장자) . | 모든 에셋은 UObject를 상속한 특정 클래스(예: UMaterial, UStaticMesh 등)로 만들어진다 | 에디터에서 만드는 에셋은 각기 다른 UObject 파생 클래스의 인스턴스가 디스크에 .uasset으로 저장된 것 . | BP_NewBlueprint.uasset | MyMaterial.uasset | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#uasset"
  },"234": {
    "doc": "Asset Batch Duplication",
    "title": "객체 식별",
    "content": ". | Asset Name: 에셋(객체) 이름. 에디터에서 보이는 에셋의 이름 . | (예: BP_NewBluePrint) | . | Package Path: 에셋이 저장된 폴더 경로 + 에셋 이름 . | (예:/Game/MyFolder/BP_NewBluePrint) | ‘패키지’란 언리얼에서 하나의 저장 단위 | 하나의 .uasset 파일 = 하나의 패키지 . | 패키지 파일(.uasset) 안에는 여러 객체(에셋)가 저장 될 수 있음 | . | 패키지 경로는 항상 /로 시작 | 패키지 경로에는 .uasset 확장자가 포함되지 않음 | . | Object Path: 패키지 경로 + .에셋(객체) 이름 . | (예: /Game/MyFolder/BP_NewBluePrint.BP_NewBlueprint) | 패키지 내부에는 여러 객체가 있을 수 있으므로, 반드시 객체 이름까지 명시해야 객체를 특정할 수 있다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#%EA%B0%9D%EC%B2%B4-%EC%8B%9D%EB%B3%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#객체-식별"
  },"235": {
    "doc": "Asset Batch Duplication",
    "title": "duplicate 함수 구현에 사용한 메서드",
    "content": "1..ToString() . | FString, FName, FText, FVector, FGuid 등 일부 엔진 주요 클래스에서 각 타입에 맞는 방식으로 문자열 변환 | . 2.FString::FromInt() . | 정수형 값을 FString 객체로 변환하는 정적(static) 메서드 . | 매개변수 . | int32 Value: 변환할 정수 값 | . | 반환값 . | FString: 정수를 문자열로 변환한 결과 | . | . int32 Number = 42; FString Str = FString::FromInt(Number); // \"42\" . 3.FPaths::Combine() . | 여러 개의 경로 문자열을 OS별로 올바른 구분자로 결합해 하나의 경로 문자열로 만듦. | 내부적으로 /, \\ 자동 정리 | . | 매개변수 . | 오버로드가 많으나, 대표적으로 다음과 같은 버전 | const FString&amp; PathA, const FString&amp; PathB | . | 반환값 . | FString: 결합된 경로 문자열 | . | . FString FullPath = FPaths::Combine(TEXT(\"C:/Project\"), TEXT(\"Content\"), TEXT(\"Textures\")); // \"C:/Project/Content/Textures\" . 4.UEditorAssetLibrary::DuplicateAsset() . | 에디터 전용 라이브러리 함수. Content Browser에서 특정 자산(에셋)을 지정 경로로 복제(복사)함 . | 매개변수 . | const FString&amp; SourceAssetPath: 원본 자산의 경로 . | (예: “/Game/StarterContent/Textures/T_Wood”) | . | const FString&amp; DestinationAssetPath: 복제될 위치의 경로 . | (예: “/Game/MyFolder/T_Wood_Copy”) | . | . | 반환값 . | UObject*: 복제된 자산의 포인터 . | (복제 실패 시 nullptr 반환) | . | . | . UObject* Duplicated = UEditorAssetLibrary::DuplicateAsset(TEXT(\"/Game/AssetA\"), TEXT(\"/Game/Folder/AssetB\")); if (Duplicated) { /* 성공 */ } . 5.UEditorAssetLibrary::SaveAsset() . | 에디터에서 지정한 자산(에셋)을 디스크에 저장 . | 매개변수 . | const FString&amp; AssetPath: 저장할 자산의 경로 (예: “/Game/MyFolder/AssetB”) | . | 반환값 . | bool (true: 저장 성공 / false: 저장 실패) | . | . bool bSaved = UEditorAssetLibrary::SaveAsset(TEXT(\"/Game/MyFolder/AssetB\")); . 6.TEXT() . | C++의 문자열 리터럴을 엔진 내부 문자 타입(TCHAR)로 변환하는 매크로 . | TEXT() 매크로는 C++의 매크로 전처리 기능을 사용 | . | . FString MyString = TEXT(\"Hello\"); // ↓ 매크로 확장 후 FString MyString = L\"Hello\"; // C++ 컴파일러가 처리할 코드 생성 . | L”Hello” : UTF-16/유니코드 문자열 리터럴로 컴파일 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#duplicate-함수-구현에-사용한-메서드"
  },"236": {
    "doc": "Asset Batch Duplication",
    "title": "Custom Editor Message",
    "content": ". | FMessageDialog를 사용해 메시지 대화 상자 출력하기 (모달) | FNotificationInfo를 사용해 알림 정보 출력하기 (오른쪽 하단에 나타나는 비동기 알림) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#custom-editor-message"
  },"237": {
    "doc": "Asset Batch Duplication",
    "title": "FMessageDialog",
    "content": ". | 에디터 환경에서 사용자에게 메시지 박스(모달 대화상자)를 띄울 때 사용하는 유틸리티 클래스 | core 소속 | 블로킹(Blocking) 방식으로, 다이얼로그가 닫히기 전까지 다음 코드가 실행되지 않음 | 정적(static) 메서드로만 구성 | . 1. FMessageDialog::Open(EAppMsgType::Type MsgType, const FText&amp; Message) . | 지정한 메시지 유형과 메시지 텍스트로 다이얼로그 표시 | . 2. EAppReturnType::Type . EAppReturnType::Type ShowMsgDialog( EAppMsgType::Type MsgType, const FString&amp; Message, bool bShowMsgAsWarning = true ) . | MsgType: 메시지 박스 버튼 조합(Ok, YesNo 등) 지정 | Message: 출력할 메시지 문자열 | bShowMsgAsWarning: 경고(Warning) 스타일로 메시지를 띄울지 여부, 기본값 true . | true면 경고 스타일(노란색 경고 아이콘, “Warning” 타이틀 등)로 표시 | false면 일반 정보 스타일(파란색 info 아이콘, “Message” 또는 “Info” 타이틀 등)로 표시 | . | . EAppMsgType::Type 정리 . | 타입 | 다이얼로그 버튼 조합 | 대표적 사용 상황 | . | Ok | OK | 단순 확인, 정보 알림 | . | YesNo | Yes / No | 선택(이행/거부) | . | YesNoCancel | Yes / No / Cancel | 저장 여부 등 3분기 선택 | . | OkCancel | OK / Cancel | 진행/중단 | . | CancelRetryContinue | Cancel / Retry / Continue | 재시도 여부(예: 파일 저장 실패) | . | YesNoYesAllNoAll | Yes / No / Yes to All / No to All | 여러 작업에 대해 일괄 처리 | . | YesNoYesAllNoAllCancel | Yes / No / Yes to All / No to All / Cancel | 여러 파일 작업에서 개별/일괄/취소 | . | YesNoCancelContinue | Yes / No / Cancel / Continue | 드문 복합적 분기 | . | YesNoYesAllNoAllCancelContinue | Yes / No / Yes to All / No to All / Cancel / Continue | 매우 복잡한 결정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fmessagedialog"
  },"238": {
    "doc": "Asset Batch Duplication",
    "title": "FNotificationInfo",
    "content": ". | 에디터 하단 (주로 오른쪽 아래)에 잠시 나타나는 비동기 알림(Notification Toast) 정보를 정의하는 구조체 | FSlateNotificationManager를 통해 실제 알림을 생성/표시 | slate 소속 | . FNotificationInfo Info(FText::FromString(TEXT(\"작업이 완료되었습니다.\"))); Info.bFireAndForget = true; Info.ExpireDuration = 2.0f; // 2초 후 자동 닫힘 Info.bUseThrobber = false; // 스피너 비표시 FSlateNotificationManager::Get().AddNotification(Info); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html#fnotificationinfo"
  },"239": {
    "doc": "Asset Batch Duplication",
    "title": "Asset Batch Duplication",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Asset%20Batch%20Duplicatio.html"
  },"240": {
    "doc": "Binding Funcionts",
    "title": "목표: hook을 사용해 메뉴 엔트리, 메뉴 항목, 사용할 함수 바인딩 하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EB%AA%A9%ED%91%9C-hook%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%A9%94%EB%89%B4-%EC%97%94%ED%8A%B8%EB%A6%AC-%EB%A9%94%EB%89%B4-%ED%95%AD%EB%AA%A9-%EC%82%AC%EC%9A%A9%ED%95%A0-%ED%95%A8%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#목표-hook을-사용해-메뉴-엔트리-메뉴-항목-사용할-함수-바인딩-하기"
  },"241": {
    "doc": "Binding Funcionts",
    "title": "에디터에서 Extension hook 보기",
    "content": ". | 언리얼 에디터 툴바에서 편집 클릭 | 하단 환경설정의 에디터 환경설정 클릭 | 에디터 환경설정 창의 검색에 ui extension 입력 | Developer Tools의 Display UI Extension Points 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%97%90%EB%94%94%ED%84%B0%EC%97%90%EC%84%9C-extension-hook-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#에디터에서-extension-hook-보기"
  },"242": {
    "doc": "Binding Funcionts",
    "title": "FExtender와 FExtensionBase의 동작 원리 이해하기",
    "content": ". | FExtender = 각각의 FExtensionBase 정보를 통합 | FExtensionBase = 메뉴, 툴바 등 실제 확장 정보 데이터 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender%EC%99%80-fextensionbase%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender와-fextensionbase의-동작-원리-이해하기"
  },"243": {
    "doc": "Binding Funcionts",
    "title": "FExtensionBase",
    "content": "언리얼 엔진 Slate UI에서 메뉴/툴바 확장 시스템에서 사용하는 기본 추상 베이스 클래스 . | 실질적인 메뉴/툴바 확장 정보를 가지고 있음 | . class FExtensionBase { public: /** 멤버가 제대로 정리되도록 가상 소멸자가 필요함 */ virtual ~FExtensionBase() { } /** @return 확장 객체의 유형을 반환합니다. 파생 클래스에서 구현하세요 */ virtual EExtensionType::Type GetType() const = 0; /** 확장 포인트의 ID */ FName Hook; /** 확장 지점과 관련하여 후크할 위치 */ EExtensionHook::Position HookPosition; /** UI에 추가되는 액션에 사용할 커맨드 목록 */ TSharedPtr&lt; FUICommandList &gt; CommandList; }; . 주요 파생 클래스들 . 주요 파생 클래스들에는 델리게이트까지 추가됨 . | FMenuExtension : 메뉴 확장 구현 | FToolBarExtension : 툴바 확장 구현 | FMenuBarExtension : 메뉴 바 확장 구현 | . | 인자 | 역할 | 설명 | . | FName Hook | 확장 위치 지정 | 어떤 Hook(지점) 근처에 엔트리를 추가할지(예: “Delete”) | . | EExtensionHook::Position HookPosition | 상대 위치 | Hook 기준 Before/After/First 중 어디에 넣을지 | . | const TSharedPtr&lt;FUICommandList&gt;&amp; CommandList | 커맨드 집합 | 메뉴 엔트리의 활성/실행/단축키/상태 관리용, 없으면 nullptr | . | const FMenuExtensionDelegate&amp; MenuExtensionDelegate | 생성 콜백 | 실제로 메뉴 엔트리 Slate 위젯을 추가하는 함수/람다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextensionbase"
  },"244": {
    "doc": "Binding Funcionts",
    "title": "FExtender",
    "content": "여러 소스에서 메뉴/툴바에 엔트리를 동적으로 삽입할 때, 각각의 확장 요청을 병합하는 기능을 담당 . | 여러 소스에서 반환한 확장 요청을 실제 Slate UI에 적용하기 전 단일 리스트로 통합 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender"
  },"245": {
    "doc": "Binding Funcionts",
    "title": "FExtender 동작 과정",
    "content": "1. 확장자 생성 . TSharedPtr&lt;FExtender&gt; Extender = MakeShared&lt;FExtender&gt;(); TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); . | 빈 FExtender 컨테이너 생성 | . 2. 확장 항목 생성 및 등록 . MenuExtender-&gt;AddMenuExtension( FName(\"Delete\"), // 확장 지점 (예: 컨텐트 폴더 우클릭 창의 삭제) EExtensionHook::After, // 위치 (예: 삭제 항목 다음에 추가) TSharedPtr&lt;FUICommandList&gt;(), // 명령 처리기 (단축키 설정) FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry) // 메뉴 엔트리 생성 함수 ); . | AddMenuExtension 호출 시 새로운 FMenuExtension 인스턴스 생성 | FMenuExtension 인스턴스는 아래 정보 저장 . | 확장 지점 이름(FName(“Delete”)) | 위치 정보(After) | 연결된 명령 리스트 | 메뉴 생성 델리게이트 | . | 생성된 객체는 FExtender의 내부 배열에 저장 . | TArray&lt; TSharedPtr&lt; const FExtensionBase &gt; &gt; Extensions | . | . FExtender 다이어그램 . 3. 실제 메뉴 생성 . 사용자가 콘텐트 폴더를 우클릭하면 Slate가 FExtender::Apply()를 호출 . | FExtender의 Extensions를 순회하면서 조건에 맞는 확장 지점 찾음 | 해당 지점에 등록된 모든 FExtensionBase 파생 객체 순회 | 각 확장의 HookPosition에 따라 적절한 위치에 메뉴 항목 삽입 | 파생 객체의 delegate를 실행해 메뉴/툴바에 실제 메뉴 항목 생성 | 확장 해제(RemoveExtension) 가능 . | 사용자가 직접 반환받은 FExtensionBase 핸들을 이용해 해당 확장 객체를 Extensions에서 제거 | . | . 확장 제거 . // 확장 제거 예시 TSharedRef&lt;const FExtensionBase&gt; MyExtension = Extender-&gt;AddMenuExtension(...); // ... Extender-&gt;RemoveExtension(MyExtension); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fextender-동작-과정"
  },"246": {
    "doc": "Binding Funcionts",
    "title": "정리",
    "content": ". | 등록과 실행이 분리된다 . | 확장은 미리 등록만 해두고 실제로 필요할 때만 생성 (예: 메뉴가 열릴 때만 메뉴 항목 생성) | . | 확장 지점 기반으로 작동한다 . | 예: 같은 확장 지점 Delete에서 Before, After 생성 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#정리"
  },"247": {
    "doc": "Binding Funcionts",
    "title": "FMenuBuilder",
    "content": "FExtender와 함께 사용되어 컨텍스트 메뉴, 툴바 메뉴, 메인 메뉴 등을 구성 . | FExtender : “어디에 메뉴를 추가할지” 결정 | FMenuBuilder : “메뉴에 무엇을 추가할지” 정의 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#fmenubuilder"
  },"248": {
    "doc": "Binding Funcionts",
    "title": "자유 사용되는 메서드",
    "content": "1. AddMenuEntry() . 기본 메뉴 항목 추가 . AddMenuEntry( FText::FromString(\"메뉴 항목\"), // 표시 이름 FText::FromString(\"툴팁 설명\"), // 툴팁 FSlateIcon(FAppStyle::GetStyleSetName(), \"Icons.Play\"), // 아이콘 FUIAction(FExecuteAction::CreateLambda([](){ /* 액션 로직 */ })) // 델리게이트 ); . FUIAction . Slate의 액션(메뉴 엔트리, 버튼 등)을 나타내는 컨테이너 구조체 -&gt; 통합적 관리 가능 . | 실행(FExecuteAction) : (void() 시그니처 콜백) . | 실행할 함수 | . | 활성화 가능 여부(FCanExecuteAction) : (bool() 시그니처 콜백, 선택적) . | 메뉴가 활성화되는지/비활성화되는지 | . | 체크 상태(FIsActionChecked) : (bool() 시그니처 콜백, 토글 메뉴/버튼용, 선택적) . | 체크(토글) 상태를 반영할지 말지 | . | . FExecuteAction만 단독 사용 . FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) . | 내부적으로 활성/체크 상태 등은 기본값으로 취급 | . 2. AddMenuSeparator() . 메뉴 항목 사이에 구분선을 추가 . AddMenuEntry(...); // 첫 번째 항목 AddMenuSeparator(); // ----- 구분선 ----- AddMenuEntry(...); // 두 번째 항목 . 3. AddWidget() . 커스텀 위젯 추가 / 체크박스, 슬라이더, 버튼 등 복잡한 UI를 메뉴에 삽입할 때 사용 . AddWidget( SNew(SCheckBox) .IsChecked(false) .OnCheckStateChanged_Lambda([](ECheckBoxState State){ /* 체크 상태 변경 */ }) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%9E%90%EC%9C%A0-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#자유-사용되는-메서드"
  },"249": {
    "doc": "Binding Funcionts",
    "title": "총 세번의 바인딩",
    "content": ". | 메뉴 엔트리 생성 위치(1차 바인딩) | . InitCBMenuExtention() { ContentBroswerModuleMenuExtenders.Add(FContentBrowserMenuExtender_SelectedPaths:: CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); } // CreateRaw(this, &amp;FBacgroundToolsModule::CustomCBMenuExtender)); TSharedRef&lt;FExtender&gt; FBacgroundToolsModule::CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelectedPaths) { TSharedRef&lt;FExtender&gt; MenuExtender(new FExtender()); if (SelectedPaths.Num() &gt; 0) { MenuExtender-&gt;AddMenuExtension(FName(\"Delete\"), EExtensionHook::After, TSharedPtr&lt;FUICommandList&gt;(), FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); } return MenuExtender; } . | 메뉴 항목의 모양 및 동작(2차 바인딩) | . // FMenuExtensionDelegate::CreateRaw(this, &amp;FBacgroundToolsModule::AddCBMenuEntry)); void FBacgroundToolsModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder) { MenuBuilder.AddMenuEntry ( FText::FromString(TEXT(\"Delete Unused Assets\")), FText::FromString(TEXT(\"Safely delete all unused assets under folder\")), FSlateIcon(), FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) ); } . | 실제 실행할 함수(3차 바인딩) | . // FExecuteAction::CreateRaw(this, &amp;FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked) void FBacgroundToolsModule::OnDeleteUnsuedAssetButtonClicked() { } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#%EC%B4%9D-%EC%84%B8%EB%B2%88%EC%9D%98-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html#총-세번의-바인딩"
  },"250": {
    "doc": "Binding Funcionts",
    "title": "Binding Funcionts",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Binding%20Funcionts.html"
  },"251": {
    "doc": "Component in C++",
    "title": "Component in C++",
    "content": "컴포넌트 등록을 c++로 해보자 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html"
  },"252": {
    "doc": "Component in C++",
    "title": "CDO (Class Default Object)",
    "content": "클래스의 기본 설정값을 가지는 싱글톤 객체 . 해당 클래스의 모든 인스턴스가 참조하는 템플릿 . ❓ CDO는 언제 생성돼? . | 게임/에디터 시작 시 UClass가 로드될 때 한 번만 생성 | 그 후 인스턴스를 생성할 때 마다 CDO를 참조해 프로퍼티를 복사 | 즉 UClass의 CDO는 기본값 정의이다 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#cdo-class-default-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#cdo-class-default-object"
  },"253": {
    "doc": "Component in C++",
    "title": "특징",
    "content": ". | UClass별 유일 객체: 각 UClass당 하나만 존재 | 템플릿 역할: 새 객체 생성 시 CDO의 프로퍼티 값들이 기본값으로 복사됨 . | 인스턴스가 직접 CDO를 참조하는 구조 X, 복사 원본 역할 | . | 에디터 통합: 블루프린트/프로퍼티 윈도우에서 편집하는 값들이 CDO에 저장 | 메모리 효율: 모든 인스턴스가 공유하는 기본값을 중앙에서 관리 | . | CDO Constructor : 모든 인스턴스에 공통적으로 적용되는 설정 초기화 . | 월드 의존 로직 X (월드 내 위치 값 등), 인풋 바인딩 X (컨트롤러 미확정) | . | BeginPlay : 런타임에서 실제 게임이 시작될 때 호출 . | 게임 중 변하는 값은 BeginPlay에서 로드 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#특징"
  },"254": {
    "doc": "Component in C++",
    "title": "Default Sub Object",
    "content": "컴포넌트의 기본 서브 오브젝트 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#default-sub-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#default-sub-object"
  },"255": {
    "doc": "Component in C++",
    "title": "특징",
    "content": ". | 액터 클래스에 기본적으로 포함되는 서브 컴포넌트 | CDO에 귀속되어 저장되고 생성/관리됨 | CreateDefaultSubobject&lt;T&gt;() 로 생성 . | Type* 반환 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#특징-1"
  },"256": {
    "doc": "Component in C++",
    "title": "사용 예시",
    "content": "// 헤더 파일에서 선언 UPROPERTY(VisibleAnyWhere, Category=\"Components\") UStaticMeshComponent* MeshComp; // CPP 파일에서 생성 AMyActor::AMyActor() { MeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"MeshComp\")); MeshComp-&gt;SetupAttachment(RootComponent); // 컴포넌트 간 부모-자식 관계 설정 } // 혹은 바로 루트 컴포넌트로 설정 가능 AItem::AItem() { PrimaryActorTick.bCanEverTick = true; ItemMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"ItemMeshComponent\")); RootComponent = ItemMesh; } // 혹은 바로 루트 컴포넌트로 설정 가능 2 AItem::AItem() { PrimaryActorTick.bCanEverTick = true; ItemMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT(\"ItemMeshComponent\")); SetRootComponent(ItemMesh); } . | MyActor()의 생성자는 CDO 생성 때 한 번만 실행됨 | 인스턴스 생성 시에는 CDO의 Default Subobject들이 복사되어 개별 인스턴스의 컴포넌트 트리로 초기화됨 . | 해당 클래스의 모든 인스턴스가 동일한 컴포넌트 트리를 갖도록 하는 기본 역할 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Component%20in%20C++.html#사용-예시"
  },"257": {
    "doc": "Construct SButton",
    "title": "목표 : SListView 에 delete 버튼 생성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%AA%A9%ED%91%9C--slistview-%EC%97%90-delete-%EB%B2%84%ED%8A%BC-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#목표--slistview-에-delete-버튼-생성"
  },"258": {
    "doc": "Construct SButton",
    "title": "SButton",
    "content": "사용자 상호작용 (클릭, 호버 등)을 처리하는 클릭 가능한 버튼을 구현한 위젯 . | SPrimitiveButton을 상속 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton"
  },"259": {
    "doc": "Construct SButton",
    "title": "특징",
    "content": ". | 다양한 상호작용 상태 . | Normal 기본 | Hovered 호버 | Pressed 클릭 | Disabled 비활성 | . | 커스텀 콘텐츠 지원 : 텍스트, 아이콘, 복합 위젯 수용 가능 | 접근성 기능 : 키보드 포커스, 게임패드 네비게이션 지원 | 시각적 피드백 : 클릭 애니메이션, 상태별 스타일 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#특징"
  },"260": {
    "doc": "Construct SButton",
    "title": "생성 예시",
    "content": "TSharedRef&lt;SButton&gt; MyButton = SNew(SButton) .Text(LOCTEXT(\"Submit\", \"제출\")) .OnClicked(FOnClicked::CreateLambda([](){ UE_LOG(LogTemp, Warning, TEXT(\"Button Clicked!\")); return FReply::Handled(); })); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%83%9D%EC%84%B1-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#생성-예시"
  },"261": {
    "doc": "Construct SButton",
    "title": "동작 원리",
    "content": ". | SButton이 클릭/호버/누름 상태를 감지해 스타일을 변경 | 클릭 등 입력 이벤트 발생 시, Delegate(예: OnClicked)에 바인딩된 함수가 호출 | 버튼 내부에 포함된 Slate 위젯은 Slot에 넣는 방식으로 조합 가능 | 비활성(Disable) 상태는 입력 차단 및 스타일 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#동작-원리"
  },"262": {
    "doc": "Construct SButton",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-속성"
  },"263": {
    "doc": "Construct SButton",
    "title": ".OnClicked",
    "content": "버튼 클릭 시 호출될 델리게이트. 반드시 FReply를 반환 . SNew(SButton) .OnClicked(this, &amp;SMyWidget::OnButtonClicked) FReply SMyWidget::OnButtonClicked() { // 버튼 클릭 시 동작 구현 return FReply::Handled(); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onclicked",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onclicked"
  },"264": {
    "doc": "Construct SButton",
    "title": ".OnPressed",
    "content": "버튼이 눌리는 순간(마우스 다운 등)에 호출되는 델리게이트 . SNew(SButton) .OnPressed(this, &amp;SMyWidget::OnButtonPressed) void SMyWidget::OnButtonPressed() { // 버튼을 누르는 순간의 처리 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onpressed",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onpressed"
  },"265": {
    "doc": "Construct SButton",
    "title": ".OnReleased",
    "content": "버튼을 눌렸다가 뗄 때(마우스 업)에 호출되는 델리게이트 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onreleased",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#onreleased"
  },"266": {
    "doc": "Construct SButton",
    "title": ".IsEnabled()",
    "content": "버튼의 활성/비활성(Enable/Disable) 상태를 지정 . SNew(SButton) .IsEnabled(true) // 항상 활성 // 동적 제어 예시 .IsEnabled(this, &amp;SMyWidget::IsButtonEnabled) bool SMyWidget::IsButtonEnabled() const { return bCanClickButton; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#isenabled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#isenabled"
  },"267": {
    "doc": "Construct SButton",
    "title": "SButton 속성 정리",
    "content": "| 속성명 | 설명 | 코드 예시 | . | .OnClicked | 버튼 클릭 시 호출될 델리게이트 (반환: FReply) | .OnClicked(this, &amp;SMyWidget::OnButtonClicked) | . | .OnPressed | 마우스 버튼 눌렀을 때 호출 | .OnPressed(this, &amp;SMyWidget::OnButtonPressed) | . | .OnReleased | 마우스 버튼 뗐을 때 호출 | .OnReleased(this, &amp;SMyWidget::OnButtonReleased) | . | .IsEnabled | 버튼 활성/비활성 바인딩 | .IsEnabled(bEnableButton) | . | .ContentPadding | 버튼 내부 패딩 | .ContentPadding(FMargin(10,5)) | . | .ButtonColorAndOpacity | 버튼 배경 색 및 투명도 | .ButtonColorAndOpacity(FLinearColor::Blue) | . | .ForegroundColor | 버튼 내부 컨텐츠(주로 텍스트) 색상 | .ForegroundColor(FLinearColor::White) | . | .HAlign | 내부 컨텐츠 수평 정렬 | .HAlign(HAlign_Center) | . | .VAlign | 내부 컨텐츠 수직 정렬 | .VAlign(VAlign_Center) | . | .Style | 버튼 스타일(FButtonStyle) 지정 | .Style(&amp;MyCustomStyle) | . | [ ... ] | 버튼 내부 컨텐츠 (STextBlock, SImage 등) | [SNew(STextBlock).Text(...)] | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton-%EC%86%8D%EC%84%B1-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#sbutton-속성-정리"
  },"268": {
    "doc": "Construct SButton",
    "title": "FReply",
    "content": "UI 입력 이벤트에 대한 처리 결과와 후속 동작을 Slate에 전달하는 응답 객체 . | SlateCore 모듈에 정의된 불변(Immutable) 객체 . | 불변 객체 : 생성 후 값이 변하지 않는 객체 | 체이닝 방식 (setter 메서드)은 내부적으로 새로운 객체를 복사, 반환 | 멀티스레드 환경에서 안전, 예측 가능한 동작 보장 | . | 대부분의 Slate 입력 이벤트 델리게이트(특히 OnClicked, OnMouseButtonDown 등)의 반환 타입 | 이벤트 버블링(Bubbling) 및 전파(Propagation) 제어 . | 이벤트 전파 방향: 하위 -&gt; 상위 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply"
  },"269": {
    "doc": "Construct SButton",
    "title": "특징",
    "content": ". | 체이닝 디자인: 메서드 체인으로 복합 동작 구성 가능 | 스레드 안전성: 모든 메서드가 const로 선언되어 재사용 가능 | 이벤트 라우팅: 입력 이벤트의 계층적 전파 제어 | 다양한 응답 타입: 핸들링 여부, 포커스 변경, 커서 모드 등 지원 | 고성능: 힙 할당 없이 스택에서 작동 (약 16바이트 크기) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#특징-1"
  },"270": {
    "doc": "Construct SButton",
    "title": "사용 예시",
    "content": "FReply MyWidget::OnMouseButtonDown(const FGeometry&amp; Geometry, const FPointerEvent&amp; Event) { if (Event.GetEffectingButton() == EKeys::LeftMouseButton) { // 이벤트 처리 완료 return FReply::Handled().ReleaseMouseCapture(); } return FReply::Unhandled(); // 이벤트 계속 전파 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#사용-예시"
  },"271": {
    "doc": "Construct SButton",
    "title": "FReply 생성과 라이프사이클",
    "content": ". | FReply는 함수 내에서 “임시로” 생성되는, 단순한 값 객체(value type, struct) | 이벤트 핸들러(예: OnClicked, OnMouseButtonDown)가 호출될 때마다 매번 새로운 FReply 인스턴스가 반환됨 | 반환 이후에는 Slate가 해당 객체를 해석해서 입력 전파/포커스 등 후속 처리 . | 그 후 FReply 인스턴스는 더 이상 사용되지 않음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freply-생성과-라이프사이클"
  },"272": {
    "doc": "Construct SButton",
    "title": "동작 원리",
    "content": ". | 이벤트 수신 . | 슬레이트 입력 시스템이 이벤트 분배 | . | 응답 생성 . | 위젯이 Handled() 또는 Unhandled() 반환 | . | 전파 결정 . | Unhandled 시 부모 위젯으로 이벤트 버블링 | . | 부가 작업 (이벤트 체이닝) . | 핸들링 후 추가 명령 실행(포커스 변경 등) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#동작-원리-1"
  },"273": {
    "doc": "Construct SButton",
    "title": "주요 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-메서드"
  },"274": {
    "doc": "Construct SButton",
    "title": "FReply::Handled()",
    "content": "입력 처리 . FReply SMyWidget::OnButtonClicked() { // 버튼 클릭에 대한 동작 수행 return FReply::Handled(); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyhandled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyhandled"
  },"275": {
    "doc": "Construct SButton",
    "title": "FReply::Unhandled()",
    "content": "입력 무시 -&gt; 부모나 다른 위젯에게 이벤트 위임 . FReply SMyWidget::OnButtonClicked() { // 클릭을 무시(부모나 다른 위젯에게 이벤트 위임) return FReply::Unhandled(); } . Handled() vs Unhandled() 동작 비교 . | 구분 | Handled() | Unhandled() | . | 의미 | “이 이벤트는 처리 완료됨” | “이 이벤트를 더 처리해야 함” | . | 전파 | 즉시 중단 | 부모 위젯으로 계속 전달 | . | 사용 사례 | 버튼 클릭 처리 후 | 이벤트를 추가로 처리해야 할 때 | . | 체이닝 | 추가 액션 연결 가능 | 추가 액션 연결 불가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyunhandled",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#freplyunhandled"
  },"276": {
    "doc": "Construct SButton",
    "title": "포커스 제어 (체이닝)",
    "content": "입력 후 추가 행동 설정 . // 체이닝 예시 FReply Reply = FReply::Handled().SetUserFocus(...).CaptureMouse(...); FReply SMyWidget::OnButtonClicked() { return FReply::Handled().SetUserFocus(MyWidgetSharedRef, EFocusCause::SetDirectly); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%ED%8F%AC%EC%BB%A4%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EC%B2%B4%EC%9D%B4%EB%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#포커스-제어-체이닝"
  },"277": {
    "doc": "Construct SButton",
    "title": "주요 메서드 정리",
    "content": "| 메서드 | 설명 | . | Handled() | 이벤트를 처리함(기본 FReply 생성) | . | Unhandled() | 이벤트를 무시함 | . | SetUserFocus(TSharedRef&lt;SWidget&gt;) | 특정 위젯에 키보드 포커스 부여 | . | ClearUserFocus(bool bInAllUsers) | 포커스 제거 | . | CaptureMouse(TSharedPtr&lt;SWidget&gt;) | 위젯에 마우스 캡처(드래그 등) | . | ReleaseMouseCapture() | 마우스 캡처 해제 | . | SetMousePos(FVector2D) | 마우스 커서 위치 강제 이동 | . | SetCursor(EMouseCursor::Type) | 커서 모양 변경 | . | .SetKeyboardFocus(TSharedPtr&lt;SWidget&gt;) | 키보드 포커스 설정 | . | .SetUserFocus(EFocusCause::SetDirectly) | 사용자 포커스 설정 | . | .ClearUserFocus(EFocusCause::Cleared) | 포커스 해제 | . | PreventThrottling() | Slate Tick 최적화 예외(강제 업데이트) | . | DetectDrag(TSharedPtr&lt;SWidget&gt;, EKeys) | 드래그 시작 이벤트 감지 | . | BeginDragDrop(TSharedRef&lt;FDragDropOperation&gt;) | 커스텀 드래그 앤 드롭 시작 | . | EndDragDrop() | 드래그 앤 드롭 종료 | . | RouteReplyThrough(TSharedPtr&lt;SWidget&gt;) | 이벤트를 다른 위젯을 통해 라우팅 | . | ScrollToWidget(TSharedPtr&lt;SWidget&gt;) | 특정 위젯 위치로 스크롤 이동 | . 응답 객체 상태 검사 관련 메서드 . | 메서드 | 설명 | . | IsEventHandled() | 이벤트 처리 여부 | . | GetMouseCaptor() | 마우스 캡처한 위젯 반환 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html#주요-메서드-정리"
  },"278": {
    "doc": "Construct SButton",
    "title": "Construct SButton",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SButton.html"
  },"279": {
    "doc": "Construct SCheckBox",
    "title": "목표 : 체크 박스를 통해 SListView 의 에셋 선택",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EB%AA%A9%ED%91%9C--%EC%B2%B4%ED%81%AC-%EB%B0%95%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%B4-slistview-%EC%9D%98-%EC%97%90%EC%85%8B-%EC%84%A0%ED%83%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#목표--체크-박스를-통해-slistview-의-에셋-선택"
  },"280": {
    "doc": "Construct SCheckBox",
    "title": "SCheckBox",
    "content": "슬레이트(UI 프레임워크)에서 제공하는 체크박스 위젯. 사용자가 선택/해제할 수 있는 상호작용 요소 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#scheckbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#scheckbox"
  },"281": {
    "doc": "Construct SCheckBox",
    "title": "특징",
    "content": ". | 기본 기능 . | 켜짐/꺼짐 상태를 나타내는 박스와 레이블로 구성 | 마우스 클릭이나 키보드로 상태 전환 가능 | 일반 체크박스, 라디오 버튼, 토글 버튼 등 다양한 형태로 사용 가능 | . | 상태 종류 . | ECheckBoxState::Unchecked : 선택된 상태 | ECheckBoxState::Unchecked : 선택되지 않은 상태 | ECheckBoxState::Undetermined : 부분 선택 또는 결정되지 않은 상태(3-state 체크박스) . | 스위치 케이스 문을 통해 각 상태 별로 동작 다르게 설정 가능 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#특징"
  },"282": {
    "doc": "Construct SCheckBox",
    "title": "기본 사용법",
    "content": "TSharedRef&lt;SCheckBox&gt; MyCheckBox = SNew(SCheckBox) .IsChecked(ECheckBoxState::Unchecked) // 초기 상태 설정 .OnCheckStateChanged(this, &amp;MyClass::HandleCheckStateChanged) // 상태 변경 핸들러 [ SNew(STextBlock) .Text(LOCTEXT(\"CheckBoxLabel\", \"옵션 활성화\")) ]; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#기본-사용법"
  },"283": {
    "doc": "Construct SCheckBox",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#주요-속성"
  },"284": {
    "doc": "Construct SCheckBox",
    "title": ".Type",
    "content": "SCheckBox의 시각적/기능적 동작 모드를 결정하는 속성 . | ESlateCheckBoxType::을 통해 타입 지정 가능 | . enum ESlateCheckBoxType . enum class ESlateCheckBoxType : uint8 { /** 표준 체크박스 (사각형, 체크 표시) */ CheckBox, /** 라디오 버튼 (원형, 동그라미가 채워지는 형태, 그룹 내 단일 선택) */ RadioButton, /** Toggle 버튼 (스위치 느낌의 토글형 UI, UE5에서 추가됨) */ ToggleButton }; .Type 속성 사용예시 . SNew(SCheckBox) .Type(ESlateCheckBoxType::CheckBox) .IsChecked(...) .OnCheckStateChanged(...) [ SNew(STextBlock).Text(FText::FromString(TEXT(\"옵션 1\"))) ] . | 값 | 설명 및 사용 예시 | . | CheckBox | - 일반적인 체크박스 UI- 여러 항목을 중복 선택 가능- ✔ 표시 또는 3-state(불확정) 표시 지원 | . | RadioButton | - 원형 라디오 버튼 UI- 한 그룹에서 한 항목만 선택 가능- 중복 선택 불가 | . | ToggleButton | - 스위치 UI처럼 On/Off 시각적 효과- 단일 토글용 (스마트폰의 토글 스위치와 유사) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#type",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#type"
  },"285": {
    "doc": "Construct SCheckBox",
    "title": ".IsChecked",
    "content": "체크박스의 현재 체크 상태를 반환하는 델리게이트 지정 . | Slate Tick 주기마다 IsChecked에 지정된 함수를 호출하여 UI에 표시할 상태를 동적으로 갱신 | 내부 데이터(bOptionEnabled)가 바뀌면, Slate가 자동으로 체크 상태를 갱신해서 보여줌 | .IsChecked 속성 사용예시 .IsChecked(this, &amp;SMyWidget::GetCheckBoxState) ECheckBoxState SMyWidget::GetCheckBoxState() const { return bOptionEnabled ? ECheckBoxState::Checked : ECheckBoxState::Unchecked; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#ischecked",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#ischecked"
  },"286": {
    "doc": "Construct SCheckBox",
    "title": ".OnCheckStateChanged",
    "content": "사용자가 체크박스를 클릭하여 체크 상태가 변경될 때마다 호출되는 델리게이트 . | 이벤트의 파라미터로 새 상태(ECheckBoxState)가 전달 | 이 핸들러에서 보통 내부 상태를 갱신하거나, 추가 로직(예: 설정값 저장 등)을 처리 | 보통 .IsChecked와 연결된 멤버 변수(bOptionEnabled)를 여기서 변경 | .OnCheckStateChanged 속성 사용예시 .OnCheckStateChanged(this, &amp;SMyWidget::OnCheckBoxStateChanged) void SMyWidget::OnCheckBoxStateChanged(ECheckBoxState NewState) { bOptionEnabled = (NewState == ECheckBoxState::Checked); } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#oncheckstatechanged",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#oncheckstatechanged"
  },"287": {
    "doc": "Construct SCheckBox",
    "title": ".Visibility",
    "content": "SWidget에서 사용 가능한 표시/숨김 상태를 제어하는 속성 . | EVisibility::Visible : 위젯이 보이고 상호작용 가능 | EVisibility::Collapsed : 위젯이 보이지 않고, 공간도 차지하지 않음 | EVisibility::Hidden : 위젯이 보이지 않지만, 공간은 차지함 | .Visibility 속성 사용예시 . SNew(SCheckBox) .Visibility(EVisibility::Visible) // 항상 보임 . // 동적 컨트롤 SNew(SCheckBox) .Visibility(this, &amp;SMyWidget::GetCheckBoxVisibility) EVisibility SMyWidget::GetCheckBoxVisibility() const { return bShouldShow ? EVisibility::Visible : EVisibility::Collapsed; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#visibility",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html#visibility"
  },"288": {
    "doc": "Construct SCheckBox",
    "title": "Construct SCheckBox",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SCheckBox.html"
  },"289": {
    "doc": "Construct SListView",
    "title": "목표 : 에셋 이름, 클래스, 선택, 삭제 버튼이 들어간 리스트 생성하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%AA%A9%ED%91%9C--%EC%97%90%EC%85%8B-%EC%9D%B4%EB%A6%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%ED%83%9D-%EC%82%AD%EC%A0%9C-%EB%B2%84%ED%8A%BC%EC%9D%B4-%EB%93%A4%EC%96%B4%EA%B0%84-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#목표--에셋-이름-클래스-선택-삭제-버튼이-들어간-리스트-생성하기"
  },"290": {
    "doc": "Construct SListView",
    "title": "위젯 창 전체 레이아웃 구조",
    "content": ". | 첫 번째 슬롯: 타이틀 텍스트 | 두 번째 슬롯: 리스트 조건 선택 드롭다운 | 세 번째 슬롯: 실제 에셋 리스트 -&gt; SListView 사용 | 네 번째 슬롯: 3개의 버튼(예: Delete All 등) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%9C%84%EC%A0%AF-%EC%B0%BD-%EC%A0%84%EC%B2%B4-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#위젯-창-전체-레이아웃-구조"
  },"291": {
    "doc": "Construct SListView",
    "title": "SListView",
    "content": "Slate UI 프레임워크에서 제공하는 리스트 위젯. 데이터 항목들을 스크롤 가능한 리스트 형태로 표시하는 데 사용 . 메모리 안전성 및 레퍼런스 관리를 위해 거의 항상 TSharedPtr&lt;T&gt; 형태로 운용 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview"
  },"292": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 템플릿 기반 디자인 : SListView&lt;T&gt; 형태로 사용. T는 표시할 데이터 항목의 타입 | 가상화 지원 : 많은 수의 항목을 효율적으로 처리하기 위해 가상화를 지원 (화면에 보이는 항목만 렌더링) | 커스터마이징 : 항목 표현 방식, 선택 동작, 스크롤 동작 등을 자유롭게 커스터마이즈 | 다양한 상호작용 : 선택, 더블 클릭, 컨텍스트 메뉴 등 다양한 사용자 상호작용을 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징"
  },"293": {
    "doc": "Construct SListView",
    "title": "기본 사용법",
    "content": "// 데이터 소스 준비 TArray&lt;FString&gt; Items = {\"Item 1\", \"Item 2\", \"Item 3\"}; // 리스트 뷰 생성 SNew(SListView&lt;FString&gt;) .ItemHeight(24) // 항목 높이 .ListItemsSource(&amp;Items) // 데이터 소스 설정 .OnGenerateRow(this, &amp;SMyWidget::HandleGenerateRow) // 항목 생성 핸들러 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#기본-사용법"
  },"294": {
    "doc": "Construct SListView",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#주요-속성"
  },"295": {
    "doc": "Construct SListView",
    "title": ".ListItemsSource()",
    "content": "리스트에 표시할 데이터(배열)의 포인터를 지정. 필수 속성임 . | 형식 : TArray&lt;T&gt;* 또는 TArray&lt;TSharedPtr&lt;T&gt;&gt;* | . TArray&lt;TSharedPtr&lt;FMyItem&gt;&gt; MyItems; ChildSlot [ SNew(SListView&lt;TSharedPtr&lt;FMyItem&gt;&gt;) .ListItemsSource(&amp;MyItems) // &lt;- 리스트에 표시할 아이템 배열의 포인터 // ... 생략 ... ]; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#listitemssource",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#listitemssource"
  },"296": {
    "doc": "Construct SListView",
    "title": ".OnGenerateRow()",
    "content": "리스트 뷰가 스크롤 시 화면에 보이는 행(Row)을 어떻게 생성할지 정의하는 핵심 함수. 가장 중요 . 필수 구현 사항 : 반드시 ITableRow 인터페이스를 반환 . FOnGenerateRow&lt;T&gt;::FDelegate OnGenerateRow TSharedRef&lt;ITableRow&gt; YourClass::OnGenerateRowFunc( TSharedPtr&lt;T&gt; InItem, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable ); . | T: 리스트에 표시하는 데이터 타입 | OwnerTable : SListView가 내부적으로 자동 생성하여 전달하는 인자 . | STableRow&lt;T&gt;의 부모가 되는 리스트 뷰 | . | 반환: TSharedRef&lt;ITableRow&gt; . | SNew(STableRow&lt;T&gt;, OwnerTable)로 생성 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#ongeneraterow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#ongeneraterow"
  },"297": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 동적 생성 : 실제로 화면에 보여질 때만 행을 생성 | 메모리 효율 : 스크롤 시 보이지 않는 항목은 즉시 해제되며, 생성된 행은 풀(Pool)에서 재사용 | 가상화 : 10,000개 항목이 있어도 실제로는 10~20개의 행 위젯만 존재 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징-1"
  },"298": {
    "doc": "Construct SListView",
    "title": "동작 원리",
    "content": ". | 스크롤 발생 . | 사용자가 리스트를 스크롤하면 엔진은 화면에 새로 들어올 항목의 인덱스를 계산 | . | 행 생성 요청 . | 새로 보여야 할 항목에 대해 OnGenerateRow를 호출 | 기존에 생성된 행이 풀에 있으면 재사용, 없으면 새로 생성 | . | 데이터 바인딩 . | 인자로 전달된 Item 데이터로 위젯을 구성 (TSharedRef&lt;ITableRow&gt;) | . | 화면에 배치 . | 생성된 행을 적절한 위치에 배치하고 스크롤 영역에 추가함 | . | 스크롤 밖으로 나간 행 처리 . | 화면에서 벗어난 행은 풀로 반환되며, 메모리에서 삭제되지 않음 | . | . 항목 재사용 (Pooling) . | 생성된 행은 STableRow로 래핑되어 풀에서 관리된다 | 같은 타입의 행은 재사용되므로 상태 유지에 주의가 필요하다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작-원리"
  },"299": {
    "doc": "Construct SListView",
    "title": "ITableRow",
    "content": "테이블/리스트의 개별 행(row)을 나타내는 인터페이스 . | SListView, STreeView, STableViewBase 등에서 각 행을 추상화 함 | STableRow&lt;T&gt;가 ITableRow를 상속(구현) . | 사용자는 STableRow만 직접 생성하면 되고, Slate 내부에서는 ITableRow*로 Row를 관리 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#itablerow",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#itablerow"
  },"300": {
    "doc": "Construct SListView",
    "title": "특징",
    "content": ". | 행의 기본 동작 정의 . | 선택(Selection), 호버(Hover), 드래그(Drag) 등의 상호작용 처리 | . | 행의 레이아웃 및 가시성 관리 | 부모 테이블 뷰와의 통신 | 가상화 지원 | . // 화면 밖의 행은 자동으로 해제 virtual void ExitRow() = 0; . | 폴링 시스템 : 행 인스턴스 재사용 | . TSharedRef&lt;ITableRow&gt; ReuseRow(TSharedPtr&lt;ItemType&gt; NewItem) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%ED%8A%B9%EC%A7%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#특징-2"
  },"301": {
    "doc": "Construct SListView",
    "title": "정리",
    "content": ". | 위젯에서 스크롤 리스트 이벤트를 부름 . | 사용자가 스크롤하거나, 데이터가 바뀌거나, 리스트가 처음 표시될 때 이벤트 발생 | . | SListView에서 해당 스크롤에 들어갈 Row 함수 호출 (OnGenerateRow) . | SListView는 지금 화면에 보여져야 하는 Row에 대해서만 .OnGenerateRow() 콜백(델리게이트)을 호출함 | . | STableRow에서 실제 Row 객체 생성 . | OnGenerateRow에서 STableRow&lt;T&gt; 인스턴스를 생성해서 반환 | . | 스크롤에 따라 Row 객체 관리 . | 화면 밖으로 나간 행은 메모리에서 삭제되지 않고 풀에 보관 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#정리"
  },"302": {
    "doc": "Construct SListView",
    "title": "SListView 에서 자주 쓰이는 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview-%EC%97%90%EC%84%9C-%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#slistview-에서-자주-쓰이는-메서드"
  },"303": {
    "doc": "Construct SListView",
    "title": "리스트 갱신",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B0%B1%EC%8B%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#리스트-갱신"
  },"304": {
    "doc": "Construct SListView",
    "title": "RequestListRefresh()",
    "content": "다음 프레임에 리스트를 안전하게 갱신 . void SListView::RequestListRefresh() { // Invalidate만 호출하고 즉시 작업 수행 X Invalidate(EInvalidateWidgetReason::Layout); } . | RebuildList()보다 성능 부하가 적음 | 빈번한 업데이트에 적합 (예: 실시간 필터링) | . ConstructedAssetListView-&gt;RequestListRefresh(); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#requestlistrefresh",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#requestlistrefresh"
  },"305": {
    "doc": "Construct SListView",
    "title": "동작",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작"
  },"306": {
    "doc": "Construct SListView",
    "title": "RebuildList()",
    "content": "즉시 전체 리스트 재구성 . | 주의점: 대량 데이터에서 성능 저하 가능 | . void SListView::RebuildList() { Private::TableViewBase::RebuildList(); // 전체 재생성 로직 // 모든 행을 새로 만들고 레이아웃 재계산 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#rebuildlist",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#rebuildlist"
  },"307": {
    "doc": "Construct SListView",
    "title": "동작",
    "content": ". RebuildList() vs RequestListRefresh() 선택 가이드 . | 특징 | RebuildList() | RequestListRefresh() | . | 실행 시점 | 즉시 | 다음 프레임 | . | 갱신 범위 | 전체 리스트 | 변경된 부분만 | . | 행 재사용 | 모든 행 새로 생성(pool 초기화) | 기존 행 유지(pool 재활용) | . | 성능 영향 | 항목 수에 선형적 부하 | 변경량에 비례한 부하 | . | 사용 시나리오 | 리스트 구조 변경 시 | 데이터 내용 변경 시 | . | 여러 항목을 연속 삭제할 때 RebuildList()는 매 삭제마다 전체 재구성하므로 성능 저하 발생 가능 | RequestListRefresh()는 변경 사항을 모아 한 번에 처리, 렌더링 프레임과 동기화되어 깜빡임 현상 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8F%99%EC%9E%91-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#동작-1"
  },"308": {
    "doc": "Construct SListView",
    "title": "네비게이션 &amp; 스크롤 제어",
    "content": "ScrollToTop() / ScrollToBottom() . // 리스트의 시작/끝으로 스크롤 ListView-&gt;ScrollToTop(); ListView-&gt;ScrollToBottom(); . ScrollToItem() . // 특정 아이템으로 스크롤 (가시 영역 보장) ListView-&gt;ScrollToItem(SelectedItem); . SetScrollOffset() . // 픽셀 단위 정밀 스크롤 제어 ListView-&gt;SetScrollOffset(200.f); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98--%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%A0%9C%EC%96%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#네비게이션--스크롤-제어"
  },"309": {
    "doc": "Construct SListView",
    "title": "선택 관리 메서드",
    "content": "SetSelection() . // 단일 아이템 선택 ListView-&gt;SetSelection(SelectedItem); // 다중 선택 모드 ListView-&gt;SetSelection(SelectedItems, ESelectInfo::OnMouseClick); . ClearSelection() . // 모든 선택 해제 ListView-&gt;ClearSelection(); . GetSelectedItems() . // 현재 선택된 아이템들 가져오기 TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; SelectedItems; ListView-&gt;GetSelectedItems(SelectedItems); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EC%84%A0%ED%83%9D-%EA%B4%80%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#선택-관리-메서드"
  },"310": {
    "doc": "Construct SListView",
    "title": "데이터 소스 제어",
    "content": "SetItemsSource() . // 데이터 소스 변경 (자동 갱신 X) ListView-&gt;SetItemsSource(&amp;NewDataArray); // 변경 후 수동 갱신 필요 ListView-&gt;RequestListRefresh(); . GetNumItems() . // 아이템 총 개수 확인 int32 ItemCount = ListView-&gt;GetNumItems(); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%8C%EC%8A%A4-%EC%A0%9C%EC%96%B4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html#데이터-소스-제어"
  },"311": {
    "doc": "Construct SListView",
    "title": "Construct SListView",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Construct%20SListView.html"
  },"312": {
    "doc": "Container",
    "title": "Container",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html"
  },"313": {
    "doc": "Container",
    "title": "TArray",
    "content": "동일한 타입의 데이터를 순차적으로 저장, 관리, 반복, 조작하기 위한 동적 배열 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tarray"
  },"314": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 하나의 TArray에는 반드시 동일 타입만 저장 가능 | 동적 크기 조절: 요소 추가/삭제에 따라 자동으로 메모리 할당/해제 및 재조정 | 슬랙(slack) 최적화: 추가/삭제에 따른 빈번한 할당/해제를 방지하기 위해 여유 메모리 유지 . | 실제 할당된 메모리는 Num(요소 개수) 이상일 수 있음(성능 최적화 목적) | . | 깊은 복사(Deep copy): 배열 자체의 복사는 내부 요소 모두 복사 | 메모리 및 성능 측면에서 튜닝 가능(Allocator, Reserve/Empty/Reset 등) | 블루프린트에서도 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징"
  },"315": {
    "doc": "Container",
    "title": "생성자 속성",
    "content": "TArray를 생성할 때 element Type, Allocator 두 가지 속성을 사용할 수 있다. TArray&lt;int32&gt; IntArray; // 요소 타입 지정 TArray&lt;int32, TInlineAllocator&lt;4&gt;&gt; IntArray; // 요소, 할당자 속성 지정, 할당자는 선택 옵션 . 요소 타입 (Element Type) . TArray는 동일한 타입의 요소들을 저장하는 동질적(homogeneous) 컨테이너 . | 즉, 배열에 저장되는 모든 요소는 동일한 타입이어야 한다 | 이는 TArray, TArray, TArray&lt;UMyObject*&gt; 등으로 선언 | . 요소 타입은 다음과 같은 조건을 만족해야 함 . | 복사 가능(Copyable): 요소는 복사 생성자를 통해 복사될 수 있어야 함 | 소멸 가능(Destructible): 요소는 소멸자를 통해 적절히 정리될 수 있어야 함 | . 할당자 (Allocator) . TArray는 메모리 할당 방식을 결정하는 할당자(Allocator)를 선택적으로 지정할 수 있음 . | 할당자 | 설명 | . | FDefaultAllocator | 기본 힙 기반 할당자 | . | TInlineAllocator&lt;N&gt; | 처음 N개의 요소는 스택에 할당하고, 그 이후는 힙에 할당. 작은 배열에 유리하며, 스택 할당으로 인해 성능이 향상될 수 있음 | . | TFixedAllocator&lt;N&gt; | 고정 크기의 할당자로, 최대 N개의 요소만 저장할 수 있다. 초과할 경우 런타임 에러가 발생 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%83%9D%EC%84%B1%EC%9E%90-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#생성자-속성"
  },"316": {
    "doc": "Container",
    "title": "ADD vs Emplace",
    "content": "ADD . 함수에 넘긴 인자를 임시 객체(temporary)로 만든 후, 그 임시 객체를 배열 끝에 복사하거나 이동해서 저장함 . TArray&lt;FString&gt; Arr; Arr.Add(TEXT(\"Hello\")); . | TEXT(\"Hello\")는 우선 임시로 FString이 만들어지고, 그 임시 객체가 TArray 내부에 복사/이동됨 | . Emplace . 배열 내부에 직접 인자를 전달해 객체를 생성함 . TArray&lt;FString&gt; Arr; Arr.Emplace(TEXT(\"Hello\")); . | TEXT(\"Hello\")를 인자로 받아서, 배열 메모리 공간에 바로 FString 생성자 호출 | . 결론 . | Add: 임시 객체 → TArray 내부 복사(힙) (임시 객체는 함수 끝나면 사라짐) . | 이미 만들어진 객체를 추가할 때 사용 | “이 객체를 배열에 더한다”는 의도가 명확함 | . | Emplace: 임시 객체 없이, 바로 TArray 내부(힙)에 생성 . | 임시 객체 생성/복사를 피함 → 성능 최적화 | 복잡한 객체 (복사/이동 비용이 큰 구조체 등)에서 효율적 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#add-vs-emplace"
  },"317": {
    "doc": "Container",
    "title": "TMap",
    "content": "키-값 쌍(key-value pair)을 저장하는 해시 맵(hash map) 구조 컨테이너 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tmap"
  },"318": {
    "doc": "Container",
    "title": "특징",
    "content": ". | 키-값 쌍 저장: 키(Key)와 값(Value)을 쌍으로 저장하는 자료 구조 | 빠른 검색: 해시 테이블 기반으로 구현되어 있어 평균 O(1) 시간 복잡도로 검색 가능 | 템플릿 기반: TMap&lt;KeyType, ValueType&gt; 형태로 사용 | UPROPERTY로 선언 시, 세이브/로드, 네트워크 레플리케이션, 블루프린트에서 접근 가능 . | Key, Value 모두 리플렉션 및 직렬화 지원 타입이어야 함 | 예: TMap&lt;FString, float&gt; → O , TMap&lt;int32, UObject*&gt; → X | . | TMap은 삽입 순서나 정렬 순서를 보장하지 않음 | . 기본 사용법 . // TMap 선언 TMap&lt;FString, int32&gt; FruitPrices; // 요소 추가 FruitPrices.Add(TEXT(\"Apple\"), 1000); FruitPrices.Add(TEXT(\"Banana\"), 800); // 요소 접근 int32 ApplePrice = FruitPrices[\"Apple\"]; // 값 찾기 int32* Score = FruitPrices.Find(TEXT(\"Apple\")); int32 SafePrice = FruitPrices.FindRef(TEXT(\"Apple\")); // 존재하지 않으면 ValueType의 기본값 반환( int32면 0) // 값 변경 FruitPrices[TEXT(\"Apple\")] = 90; // 키 존재 확인 if (FruitPrices.Contains(TEXT(\"Banana\"))) { // 처리 코드 } // 키-쌍 제거 FruitPrices.Remove(TEXT(\"Apple\")); // 맵 비우기 FruitPrices.Empty(); // 반복문 순회 for (const TPair&lt;FString, int32&gt;&amp; Elem : FruitPrices) { UE_LOG(LogTemp, Log, TEXT(\"%s: %d\"), *Elem.Key, Elem.Value); } // 포인터 값 저장 시 안전한 삭제 예시 TMap&lt;FString, MyClass*&gt; ObjectMap; ObjectMap.Add(TEXT(\"Obj1\"), new MyClass()); TMap&lt;FString, TSharedPtr&lt;MyClass&gt;&gt; SafeMap; SafeMap.Add(TEXT(\"Obj1\"), MakeShared&lt;MyClass&gt;()); SafeMap.Empty(); // 자동 해제됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#특징-1"
  },"319": {
    "doc": "Container",
    "title": "주요 메서드 정리",
    "content": "| 메서드 | 설명 | . | Add(Key, Value) | 키-값 쌍 추가, 이미 키가 있으면 값 갱신 | . | Find(Key) | 키에 해당하는 값 포인터 반환, 없으면 nullptr | . | FindRef(Key) | 키에 해당하는 값의 복사본 반환 (키 없으면 기본값) | . | Contains(Key) | 해당 키 존재 여부 반환 (bool) | . | Remove(Key) | 키-값 쌍 제거, 성공 여부 반환 | . | RemoveAndCopyValue(Key, OutValue) | 키 삭제 + 값 복사 (성공 여부 반환) | . | Num() | 저장된 쌍의 개수 반환 | . | Empty() | 모든 데이터 삭제 | . | Reset() | 메모리 해제 및 초기화 | . | operator[] | [] 연산자로 값 접근/생성 | . | GenerateKeyArray() | 모든 키를 TArray로 반환 | . | GenerateValueArray() | 모든 값을 TArray로 반환 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주요-메서드-정리"
  },"320": {
    "doc": "Container",
    "title": "주의사항",
    "content": ". | 포인터를 저장할 때는 메모리 관리에 유의 → 스마트 포인터(TSharedPtr) 사용 추천 . | Remove()나 Empty()는 맵에서의 연결만 끊을 뿐, 메모리 해제는 하지 않음 | 만약 new로 할당한 객체를 저장했다면, 별도로 delete 하기 | . | operator[]는 키가 없으면 기본값(0, nullptr 등) 생성 후 반환하므로, 의도치 않은 값 생성 가능성 있음 . | 검색 전 Contains()로 확인하거나 Find()를 권장 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#주의사항"
  },"321": {
    "doc": "Container",
    "title": "TSet",
    "content": "참고 링크 . | TArray | TMap | TSet | TArray vs std::vector | Optimizing TArray Usage for Performance | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Container.html#tset"
  },"322": {
    "doc": "Delete unused Assets From Selelction",
    "title": "목표: 콘텐트 폴더에서 선택한 에셋 중 미사용 에셋 삭제하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#%EB%AA%A9%ED%91%9C-%EC%BD%98%ED%85%90%ED%8A%B8-%ED%8F%B4%EB%8D%94%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%97%90%EC%85%8B-%EC%A4%91-%EB%AF%B8%EC%82%AC%EC%9A%A9-%EC%97%90%EC%85%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#목표-콘텐트-폴더에서-선택한-에셋-중-미사용-에셋-삭제하기"
  },"323": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Asset Referencers",
    "content": ". | 레벨에서 사용된 에셋의 경우 Asset References(에셋 참조)가 존재함 | 즉 미사용 상태의 에셋의 경우 참조 개수 = 0 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#asset-referencers"
  },"324": {
    "doc": "Delete unused Assets From Selelction",
    "title": "AssetRegistry",
    "content": "모든 프로젝트 에셋의 메타 데이터를 인덱싱/검색/관리하는 중앙 관리 모듈 . | 에디터 구동 시 모든 프로젝트 에셋(.uasset, .umap 등)을 빠르게 탐색/관리할 수 있도록 내부적으로 모든 에셋의 메타데이터를 스캔 | 에셋 인덱싱: 실제 에셋 객체(UObject 등)는 메모리에 로드하지 않고, 각 에셋의 메타 데이터를 메모리에 인덱싱 (FAssetData 생성) | 빠른 검색: 이름, 클래스, 태그 등 다양한 조건으로 에셋을 빠르게 조회 | 런타임/에디터 지원: 런타임 자동화, 에디터 UI, 플러그인 등에서 활용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#assetregistry"
  },"325": {
    "doc": "Delete unused Assets From Selelction",
    "title": "FAssetData",
    "content": "에셋 레지스트리에서 찾은 에셋에 대한 중요한 정보를 저장하는 구조체 . | Asset Registry는 FAssetData의 집합 | 실제 에셋의 전체 데이터나 객체는 아님 (일시적) | AssetRegistry를 통해 조회 시 TArray&lt;FAssetData&gt;로 반환됨 | . AssetRegistry 다이어그램 . | FARFilter : AssetRegistry 에서 검색에 사용되는 필터 | FAssetData → UObject: 필요에 따라 일시적으로 참조(사용)한다 (예: GetAsset() 호출) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#fassetdata"
  },"326": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Remove Unused Assets 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::FindPackageReferencersForAsset . | 특정 에셋(Asset)을 참조하는 모든 패키지(Package)의 목록을 찾아 반환 | 에셋 의존성 분석에 사용. 특히 에셋을 삭제하거나 수정할 때 어떤 다른 에셋들이 영향을 받을지 확인 | 에디터 전용 기능 | . static TArray&lt;FString&gt; UEditorAssetLibrary::FindPackageReferencersForAsset( const FString&amp; AssetPath, bool bLoadAssetsToConfirm = false ); . | 매개변수 . | AssetPath (필수): 분석할 대상 에셋의 경로 (Object path) | bLoadAssetsToConfirm (옵션, 기본값 false) . | true: 참조하는 패키지를 메모리에 로드하여 정확성을 확인 (느리지만 정확하다) | false: 에셋 레지스트리(Asset Registry)의 메타데이터만 사용하여 빠르게 검색 (빠르지만 간접 참조 누락 가능) | . | . | 반환 값 . | 참조하는 패키지의 경로 문자열(FString) 배열 (TArray) | 에셋이 사용되지 않으면 빈 배열 반환 | . | . 2. Num() . | 컨테이너에 저장된 요소의 개수(길이)를 반환 | c++의 .Size()와 같음 | . 3. ObjectTools::DeleteAssets(UnusedAssetsData); . Asset들을 안전하게 일괄 삭제하는 유틸리티 . // UnrealEd 모듈 내 ObjectTools.h 선언부 static bool DeleteAssets(const TArray&lt;FAssetData&gt;&amp; AssetDataList, bool bShowConfirmation = true, bool bForceDelete = false); . | 대표적으로 FAssetData 배열을 인자로 받음 (다른 타입 매개변수 사용 가능) | . 동작과정 . | 입력 받은 FAssetData 리스트에서 실제 에셋 객체(UObject)를 찾아옴 | 에셋이 참조되는지 (Reference Graph) 검사 . | 다른 에셋이나 오브젝트에서 참조하고 있는 경우, 경고 대화창을 띄워 사용자에게 확인 받음 | 옵션에 따라, 강제 삭제(bForceDelete) 가능 | . | 사용자에게 삭제 확인(Confirmation) 요청 . | bShowConfirmation 인자가 true일 경우, 실제 삭제 전에 “정말 삭제할까요?”와 같은 확인창 표시 | . | 트랜잭션 생성 및 삭제 실행 . | 삭제 과정 전체를 에디터 트랜잭션(Undo/Redo)에 등록 → 실수 시 실행 취소 가능 | 내부적으로 FScopedTransaction을 사용하여 트랜잭션 단위로 관리 | . | 실제 삭제 . | 에셋을 Content Browser 및 파일 시스템(디스크)에서 제거 | 참조된 경우, 일부 삭제가 제한되거나, 사용자가 강제 삭제시 후처리(레퍼런스 클린업 등) 발생 | . | 결과 반환 . | 성공적으로 삭제된 경우 true, 실패 또는 취소시 false 반환 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#remove-unused-assets-함수-구현에-사용한-메서드"
  },"327": {
    "doc": "Delete unused Assets From Selelction",
    "title": "ObjectTools.h",
    "content": "에디터 환경에서 UObject 관련 유틸리티 함수 집합을 정의한 헤더 파일 . | 삭제/이동/복사 동작과 관련해, 사용자에게 경고 및 결과 알림 대화창을 띄워줌 | UnrealEd 모듈에 소속 . | 런타임 환경(게임 실행)에서는 사용 불가. 에디터에서만 사용하는 기능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html#objecttoolsh"
  },"328": {
    "doc": "Delete unused Assets From Selelction",
    "title": "Delete unused Assets From Selelction",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Delete%20unused%20Assets%20From%20Selelction.html"
  },"329": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug",
    "content": "디버그 메서드를 블루프린트와 C++로 어떻게 구현하는지 알아보자 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html"
  },"330": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Spheres",
    "content": "디버그용 구 그리기 . DrawDebugSphere() 함수 원형 . void DrawDebugSphere( const UWorld* InWorld, const FVector&amp; Center, float Radius, int32 Segments, FColor Color, bool bPersistentLines = false, float LifeTime = -1.f, uint8 DepthPriority = 0, float Thickness = 0.f ); . | 매개변수 . | InWorld: 월드 객체 포인터 | Center: 구의 중심 좌표 | Radius: 반지름 | Segments: 구 세그먼트 수 | Color: 색상 | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속) | DepthPriority: 렌더링 우선순위 | Thickness: 선 두께 | . | bPersistentLines . | true: 엔진 내부에서 해당 디버그 요소를 지속성 목록(Persistent List)에 등록하여 관리 . | FlushPersistentDebugLines()로 수동 제거 가능 | 지속적인 메모리 사용이 발생하지만 매 프레임 재생성 비용 절감 | . | false: 프레임 임시 배열에만 저장 . | 매 프레임 생성/삭제 반복 | . | . | LifeTime | . | 값 | 예시 | . | LifeTime = -1 | 무한 지속 | . | LifeTime = 0 | 1 프레임만 출력되고 사라짐 | . | LifeTime &gt; 0 | 지정된 시간(초) 동안 지속 후 사라짐 | . BP . | Draw Debug Sphere . | Get Actor Location : 디버그용 구의 Center 지정에 사용 | . | . C++ . #include \"DrawDebugHelpers.h\" // 디버그 헤더 인클루드 void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { DrawDebugSphere(World, Location, 25.f, 24, FColor::Red, false, 30.f); } } . | define 사용하기 | . #define DRAW_SPHERE(Location) if (GetWorld()) DrawDebugSphere(GetWorld(), Location, 25.f, 12, FColor::Red, true); AItem::AItem() { FVector Location = GetActorLocation(); DRAW_SPHERE(Location) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-spheres",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-spheres"
  },"331": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Lines",
    "content": "디버그용 벡터 라인 시각화하기 . Drawing Debug Lines() 함수 원형 . void DrawDebugLine( const UWorld* InWorld, const FVector&amp; LineStart, const FVector&amp; LineEnd, FColor Color, bool bPersistentLines = false, float LifeTime = -1.f, uint8 DepthPriority = 0, float Thickness = 0.f ); . | 매개변수 . | InWorld: 월드 객체 포인터 | LineStart: 시작 좌표 | LineEnd: 끝 좌표 | Color: 색상 | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 라인이 화면에 유지될 시간(초, -1은 무한 지속) | DepthPriority: 렌더링 우선순위 | Thickness: 선 두께 | . | . BP . | Draw Debug Line . | Get Actor Location : 디버그용 라인의 Start 지정에 사용 | Get Actor Foward Vector : 전방 벡터 불러오기 . | 위 두개를 ADD 해 Line End에 잇는다 | 벡터 단위는 cm . | 따라서 Foward Vector 크기 곱셈 필요 | . | . | . | . C++ . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { FVector Forward = ForwardVector(); DrawDebugLine(World, Location, Location + Forward * 100.f, FColor::Red, true); } } . | define 사용하기 | . #define DRAW_LINE(StartLocation, EndLocation) if (GetWorld()) DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f); AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_LINE(Location, Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-lines",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-lines"
  },"332": {
    "doc": "Drawing Debug",
    "title": "Drawing Debug Point",
    "content": "디버그용 포인트 찍기 . | 벡터의 처음과 끝을 표시하기에 좋음 | 포인트 크기는 거리에 따라 변하지 않음 (고정) | . DrawingDebugPoint() 함수 원형 . void DrawDebugPoint( const UWorld* InWorld, FVector const&amp; Position, float Size, FColor const&amp; Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority ); . | 매개변수 . | InWorld: 디버그 포인트를 그릴 월드 컨텍스트 | Position: 포인트의 위치 (FVector) | Size: 포인트의 크기 (float) | Color: 포인트의 색상 (FColor) | bPersistentLines: 지속적으로 표시할지 여부 | LifeTime: 디버그 포인트가 화면에 유지될 시간(초) | DepthPriority: 렌더링 우선순위 | . | . BP . | Draw Debug Point . | Get Actor Location : 디버그용 포인트 찍을 Position | . | . C++ . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); FVector Location = GetActorLocation(); if (World) { FVector Forward = ForwardVector(); DrawDebugPoint(World, Location + Forward * 100.f, 15.f, FColor::Red, true); // 벡터 끝에 점찍기 } } . | define 사용하기 | . #define DRAW_POINT(Location) if (GetWorld()) DrawDebugPoint(GetWorld(), Location, 15.f, FColor::Red, true); AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_POINT(Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-point",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#drawing-debug-point"
  },"333": {
    "doc": "Drawing Debug",
    "title": "Line + Point 로 벡터 그리기",
    "content": ". | \\ 사용해 매크로 계속 이어갈 수 있음 | . #define DRAW_VECTOR(StartLocation, EndLocation) if (GetWorld()) \\ { \\ DrawDebugLine(GetWorld(), StartLocation, EndLocation, FColor::Red, true, -1.f, 0, 1.f); \\ DrawDebugPoint(GetWorld(), EndLocation, 15.f, FColor::Red, true); \\ }; AItem::AItem() { FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f) } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#line--point-%EB%A1%9C-%EB%B2%A1%ED%84%B0-%EA%B7%B8%EB%A6%AC%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/Drawing%20Debug.html#line--point-로-벡터-그리기"
  },"334": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input (UE 5.1)",
    "content": "기존 시스템보다 더 강력하고 유지보수가 용이한 입력 처리를 제공 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-ue-51",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-ue-51"
  },"335": {
    "doc": "Enhanced Input",
    "title": "특징",
    "content": ". | 데이터 기반 입력 시스템 . | 입력 액션과 매핑을 에디터에서 설정 가능 | 코드 재컴파일 없이 입력 설정 변경 가능 | . | 고급 입력 트리거 . | Started (눌림 시작), Triggered (지속), Completed (놓임), Canceled (중단) 등 다양한 트리거 이벤트 | 탭, 홀드, 더블탭 등 복잡한 입력 패턴 지원 | . | 입력 컨텍스트 시스템 . | 상황에 따라 다른 입력 매핑을 활성화/비활성화 가능 | . | 예: 걷기 상태와 운전 상태에서 다른 입력 매핑 사용 | . | 입력 모디파이어 . | 입력 값을 변환하는 모디파이어 적용 가능 (예: 감도 조정, 데드존 설정) . | 게임패드 스틱의 민감도 곡선 조정 등 | . | . | 크로스 플랫폼 입력 지원 . | 여러 입력 장치를 통합 관리 | 장치 유형에 따라 다른 입력 처리 가능 | . | 블루프린트 통합 . | C++뿐만 아니라 블루프린트에서도 완전히 지원 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#특징"
  },"336": {
    "doc": "Enhanced Input",
    "title": "이전 입력 처리 방식 (Legacy Input System)",
    "content": "1. 프로젝트 세팅에서 입력 매핑 정의 . | 상단의 Edit -&gt; Project Settings 클릭 | 목록의 Engine 섹션에서 input 클릭 | Binding에서 Axis Mappings(연속적인 입력, 예: WASD 이동) 추가 | Binding에서 Action Mappings(단발적인 입력, 예: 점프)를 추가 | . 단순히 “어떤 키가 어떤 입력 이름에 매핑되는지”를 정의할 뿐, 실제 게임 로직과 연결되지 않음 . 2. C++/블루프린트에서 입력 바인딩 . | SetupPlayerInputComponent() 함수에서 명시적으로 입력 이벤트와 함수를 연결 | 프로젝트 세팅에서 정의한 입력 이름(MoveForward, Jump 등)을 코드에서 하드코딩으로 참조 | . void AMyPawn::MoveForward(float Value) { UE_LOG(LogTemp, warning, TEXT(\"Value: %f\"), Value); } void AMyPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); // 프로젝트 세팅에서 정의한 이름과 동일하게 작성해야 함! PlayerInputComponent-&gt;BindAxis(\"MoveForward\", this, &amp;AMyPawn::MoveForward); PlayerInputComponent-&gt;BindAction(\"Jump\", IE_Pressed, this, &amp;AMyPawn::Jump); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#%EC%9D%B4%EC%A0%84-%EC%9E%85%EB%A0%A5-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EC%8B%9D-legacy-input-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#이전-입력-처리-방식-legacy-input-system"
  },"337": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input 시스템",
    "content": "Blueprint 로 설정하기 . | Input Action 생성 . | Content Browser에서 우클릭 → Input → Input Action | . | ‘IA_Move’로 이름 지정 | Value Type 설정 | . | Input Mapping Context 생성 . | Content Browser에서 우클릭 → Input → Input Mapping Context | . | ‘IMC_Context’로 이름 지정 | IMC_Context BP 더블클릭 후 Mappings + 아이콘 클릭 . | ‘IA_Move’와 같은 Input Action 블루프린트 설정 | 맵핑하고 싶은 키 선택하여 연결 가능 | . | . | Pawn 블루프린트에 매핑 컨텍스트 연결 . | BP_Pawn 블루프린트 열기 | Event Graph에서 BeginPlay에 다음 노드 연결 | . | Get Controller 함수 노드 → Cast To PlayerController 노드 - Cast To PlayerController 노드의 As player Comtroller 핀에 | Enhanced Input Local Player Subsystem 노드 연결 - Enhanced Input Local Player Subsystem → Add Mapping Context 함수 노드의 타겟 핀 연결 - Cast To PlayerController → Add Mapping Context 연결 | . | IA_Move Input Actoin 노드 가져오기 . | Action Value를 Print String 노드에 연결하여 True/False 출력 | . | 디버그로 작동 확인 . | 게임 플레이 상태에서 ` 키로 콘솔창 띄우기 | 콘솔 명령어 show debug enhancedinput 입력 | . | . C++ 로 설정하기 . | Input Mapping Context 멤버 변수 선언 UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"input\") UInputMappingContext* BirdMappingContext; . | BeginPlay에서 Enhanced Input Subsystem에 매핑 컨텍스트 등록 . | build.cs에 EnhancedInput 모듈 추가 // build.cs PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"EnhancedInput\" }); . | 헤더에 \"EnhancedInputSubsystems.h\" 인클루드 | PlayerController 캐스팅 / Subsystem에 MappingContext 추가 if (APlayerController* PlayerController = Cast&lt;APlayerController&gt;(GetController())) { if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem &lt; UEnhancedInputLocalPlayerSubsystem &gt;(PlayerController-&gt;GetLocalPlayer())) { Subsystem-&gt;AddMappingContext(BirdMappingContext, 0); } } . | . | Input Action 멤버 변수 선언 UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = input) UInputAction* MoveAction; . | 입력 콜백 함수 구현 //hpp void Move(const FInputActionValue&amp; Value); //cpp void ABird::Move(const FInputActionValue&amp; value) { const bool CurrentValue = value.Get&lt;bool&gt;(); if (CurrentValue) { UE_LOG(LogTemp, Warning, TEXT(\"IA_Move triggered\")); } } . | SetupPlayerInputComponent에서 InputAction에 바인딩 void ABird::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); if (UEnhancedInputComponent* EnhancedInputComponent = CastChecked&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) { // UInputAciont* MoveAction에 콜백 함수 (ABird::Move) 바인딩 EnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;ABird::Move); } } . | . 참고하면 좋은 링크 . | doc - enhanced-input | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html#enhanced-input-시스템"
  },"338": {
    "doc": "Enhanced Input",
    "title": "Enhanced Input",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Enhanced%20Input.html"
  },"339": {
    "doc": "Exposing Function to Blueprint",
    "title": "Exposing Function to Blueprint",
    "content": "클래스 함수 블루 프린트에 노출 시키기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html"
  },"340": {
    "doc": "Exposing Function to Blueprint",
    "title": "사용 예시",
    "content": ". | UFUNCTION 매크로 사용 . | C++ 함수에 UFUNCTION 매크로 + 특정 Specifier를 붙이면 블루프린트에서 호출하거나, 이벤트/오버라이드/멀티캐스트 등 다양한 방식으로 사용할 수 있음 | . | . UCLASS() class MYPROJECT_API AMyActor : public AActor { GENERATED_BODY() public: // 블루프린트에서 호출 가능(이벤트 그래프에서 노드로 생성 가능) UFUNCTION(BlueprintCallable, Category=\"MyCategory\") void MyFunction(); // 블루프린트에서 오버라이드 가능한 이벤트로 노출 UFUNCTION(BlueprintImplementableEvent, Category=\"MyCategory\") void MyEvent(); // 블루프린트에서 직접 구현 및 호출 가능한 함수로 노출 UFUNCTION(BlueprintNativeEvent, Category=\"MyCategory\") void MyNativeEvent(); }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#사용-예시"
  },"341": {
    "doc": "Exposing Function to Blueprint",
    "title": "UFUNCIONT()",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#ufunciont",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#ufunciont"
  },"342": {
    "doc": "Exposing Function to Blueprint",
    "title": "Specifiers 정리",
    "content": "| 속성 | 설명 | 예시 | . | BlueprintCallable | 블루프린트에서 노드로 호출 가능 | UFUNCTION(BlueprintCallable) | . | BlueprintPure | 순수 함수. 값만 반환함 | UFUNCTION(BlueprintPure) | . | BlueprintImplementableEvent | 함수의 구현을 블루프린트에서 작성 (C++ 구현 없음) | UFUNCTION(BlueprintImplementableEvent) | . | BlueprintNativeEvent | C++ 기본 구현 + 블루프린트에서 오버라이드 가능 | UFUNCTION(BlueprintNativeEvent) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#specifiers-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#specifiers-정리"
  },"343": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintCallable",
    "content": ". | 블루프린트의 함수 노드로 직접 호출 가능 | 입력/출력 인자를 모두 지원. 함수의 실행 흐름에 실행 핀(Exec Pin)이 생김 | C++에서 구현하며, 블루프린트 그래프 내에서 다양한 조건문, 이벤트와 연결할 수 있음 . | 실행 흐름 제어가 필요한 곳에 적합 | . | . // 헤더 UFUNCTION(BlueprintCallable, Category=\"Gameplay\") void DealDamage(float DamageAmount); // CPP void AMyCharacter::DealDamage(float DamageAmount) { Health -= DamageAmount; } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintcallable",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintcallable"
  },"344": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintPure",
    "content": ". | 순수 함수로 값만 반환함 (반드시 반환값이 있어야함) | 실행 핀이 없이 입력값이 바뀌면 즉시 계산 결과 반환 . | 수식처럼 사용 | . | . // 헤더 UFUNCTION(BlueprintPure, Category=\"Stats\") float GetHealthPercentage() const; // CPP float AMyCharacter::GetHealthPercentage() const { return Health / MaxHealth; } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintpure",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintpure"
  },"345": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintImplementableEvent",
    "content": ". | C++에서는 함수 선언만 하고 구현은 블루프린트에서 작성 | C++에서 이벤트를 발동(Trigger) 시키기 가능 | . // 헤더 UFUNCTION(BlueprintImplementableEvent, Category=\"AI\") void OnEnemySpotted(AActor* SpottedEnemy); // CPP (구현부 없음!) -&gt; 블루프린트에서: \"On Enemy Spotted\" 이벤트 구현 가능 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintimplementableevent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintimplementableevent"
  },"346": {
    "doc": "Exposing Function to Blueprint",
    "title": "BlueprintNativeEvent",
    "content": ". | C++ 기본 구현 + 블루프린트 오버라이드를 모두 지원 | _Implementation 접미사 규칙을 사용한다 | . // 헤더 UFUNCTION(BlueprintNativeEvent, Category=\"Inventory\") bool TryUseItem(UItem* Item); // CPP (기본 구현) bool AMyCharacter::TryUseItem_Implementation(UItem* Item) { return Item-&gt;bIsUsable; } // 블루프린트에서: \"Try Use Item\" 노드로 오버라이드 가능 . | C++ 호출은 TryUseItem(Item)로 호출 (자동으로 _Implementation 연결) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintnativeevent",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Function%20to%20Blueprint.html#blueprintnativeevent"
  },"347": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Exposing Variables to Blueprint",
    "content": "클래스 변수 블루프린트에 노출시키기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html"
  },"348": {
    "doc": "Exposing Variables to Blueprint",
    "title": "사용 예시",
    "content": ". | UPROPERTY 매크로 사용 . | 변수에 메타데이터 및 속성을 부여해 언리얼의 리플렉션 시스템과 에디터, 블루프린트 등에서 활용할 수 있게 함 | . | . UCLASS() class YOURPROJECT_API UMyClass : public UObject { GENERATED_BODY() public: // 블루프린트에서 읽기/쓰기 가능한 변수 UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"MyCategory\") float MyFloatVariable; // 블루프린트에서 읽기만 가능한 변수 UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=\"MyCategory\") int32 MyReadOnlyInt; }; . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#사용-예시"
  },"349": {
    "doc": "Exposing Variables to Blueprint",
    "title": "UPROPERTY()",
    "content": "UPROPERTY([specifier1, specifier2, ...], [meta=(key1=value1, key2=value2, ...]) . | Specifiers : 변수의 기본 동작을 정의하는 필수 속성들 . | 쉼표로 구분하여 여러 개 지정 가능 | . | Meta Data : 선택적 추가 설정 (meta=로 시작) . | key=value 형태로 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#uproperty",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#uproperty"
  },"350": {
    "doc": "Exposing Variables to Blueprint",
    "title": "특징",
    "content": ". | 블루프린트 노출 . | 변수를 블루프린트에서 사용하려면 반드시 BlueprintReadOnly 또는 BlueprintReadWrite를 지정 | . | 카테고리 지정 . | Category 속성을 사용하면 에디터에서 속성이 그룹화되어 표시 | . | 네트워크 복제 . | 멀티플레이어 게임에서는 Replicated 속성을 사용하여 변수를 복제 | . | 에디터 표시 . | meta 속성들을 사용하여 에디터에서 변수가 어떻게 표시되고 동작할지 세부 조정 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#특징"
  },"351": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Specifiers 정리",
    "content": ". | EditDefaultsOnly : 블루프린트 기본 설정 (이벤트 그래프) 디테일 패널에 노출 | EditInstanceOnly : 블루프린트 인스턴스 (레벨 뷰) 디테일 패널에 노출 | EditAnywhere : 둘 다 보임. 인스턴스에서 설정 건드리면 기본 설정 바꿔도 인스턴스 설정 그대로 따라감 | . | BlueprintReadWrite : 블루 프린트 노드로 클래스 변수 사용 가능하게 해줌 . | private 안에서 사용 불가 | . | . | 속성 | 설명 | 사용 예시 | . | EditAnywhere | 에디터의 모든 인스턴스에서 편집 가능 | UPROPERTY(EditAnywhere) | . | VisibleAnywhere | 에디터에서 볼 수 있지만 편집 불가 | UPROPERTY(VisibleAnywhere) | . | EditDefaultsOnly | 클래스 기본값에서만 편집 가능 | UPROPERTY(EditDefaultsOnly) | . | VisibleDefaultsOnly | 클래스 기본값에서만 보임 | UPROPERTY(VisibleDefaultsOnly) | . | EditInstanceOnly | 인스턴스에서만 편집 가능 | UPROPERTY(EditInstanceOnly) | . | BlueprintReadWrite | 블루프린트에서 읽기/쓰기 가능 | UPROPERTY(BlueprintReadWrite) | . | BlueprintReadOnly | 블루프린트에서 읽기만 가능 | UPROPERTY(BlueprintReadOnly) | . | Category | 에디터에서 표시될 카테고리 | UPROPERTY(Category=”Gameplay”) | . | Replicated | 네트워크 복제 활성화 | UPROPERTY(Replicated) | . | ReplicatedUsing | 복제 시 호출할 함수 지정 | UPROPERTY(ReplicatedUsing=OnRep_MyVar) | . | SaveGame | 세이브 게임에 포함 | UPROPERTY(SaveGame) | . | Transient | 저장되지 않는 임시 변수 | UPROPERTY(Transient) | . | Config | config 파일에서 값 로드 | UPROPERTY(Config) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#specifiers-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#specifiers-정리"
  },"352": {
    "doc": "Exposing Variables to Blueprint",
    "title": "Meta Data 정리",
    "content": "| 속성 | 기능 | 사용 예시 | . | AllowPrivateAccess | private C++ 변수를 블루프린트에서 접근 가능하게 함 | meta = (AllowPrivateAccess = “true”) | . 참고하면 좋은 링크 . | gameplay classes Properties | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#meta-data-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/Exposing%20Variables%20to%20Blueprint.html#meta-data-정리"
  },"353": {
    "doc": "Fix Up Redirectors From Code",
    "title": "목표: 리다이렉터 정리하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%AA%A9%ED%91%9C-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#목표-리다이렉터-정리하기"
  },"354": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Redirector",
    "content": "에셋이 이동하거나 이름이 변경되었을 때 기존 참조를 유지하기 위해 사용 . | 에디터의 콘텐트 브라우저에서 이동하거나 변경하면 자동으로 생성함 | 탐색기나 터미널을 사용하여 에셋 이동 시 리다이렉터가 생성되지 않음 . | 에디터 API 를 사용하는 경우는 리다이렉터 정상 생성 | . | 리다이렉터가 많아지면 빌드/로딩 속도가 느려짐 -&gt; 정리 필요 | 콘텐츠 브라우저에서 우클릭 → ‘레퍼런스 뷰어’로 참조 관계 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#redirector"
  },"355": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터가 필요한 이유",
    "content": ". | 언리얼 엔진 프로젝트는 에셋 간의 참조(Reference) 관계가 복잡하게 얽혀 있음 | 만약 어떤 블루프린트, 머티리얼, 레벨 등이 특정 에셋을 참조하고 있는데, 그 에셋의 위치나 이름이 바뀌면 기존 참조가 모두 깨짐 | 이 문제를 방지하기 위해, 기존 위치(예전 경로)에 ‘리다이렉터’ 에셋을 생성함 | 이 리다이렉터 에셋은 “이 에셋은 이제 새로운 위치에 있습니다”라고 알려줌으로써, 예전 참조들이 새 위치의 에셋을 계속 사용할 수 있게 해줌 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터가-필요한-이유"
  },"356": {
    "doc": "Fix Up Redirectors From Code",
    "title": "리다이렉터 작동 방식",
    "content": "1. 디스크(파일) 저장 . 리다이렉터는 ObjectRedirector 타입의 .uasset 파일로 저장 . | 자신이 원래 위치했던 경로(Original Path) | 참조해야 하는 대상 오브젝트(DestinationObject, 새 경로의 에셋에 대한 소프트 참조) 가 저장됨 | 이 상태의 리다이렉터는 그냥 하나의 “Proxy” 에셋(패키지)일 뿐이며, 실제 오브젝트 인스턴스(UObject 인스턴스)는 생성되어 있지 않음 | . 리다이렉터 에셋 개념적 구조 . // ObjectRedirector.uasset (실제 파일은 바이너리이지만, 개념적으로 다음과 같은 정보를 저장) { \"OriginalObjectPath\": \"/Game/Characters/OldCharacter\", // 원본 경로 \"DestinationObjectPath\": \"/Game/Heroes/NewCharacter\", // 새 경로 (SoftObjectPath) \"Flags\": RF_Public | RF_Standalone, // 객체 플래그 \"DestinationObject\": \"Soft Reference\" // 실제로는 포인터가 아니라 소프트 참조(경로 정보) 형태 } . 2. 메모리 로드(에디터/엔진에서 참조할 때) . | 리다이렉터가 메모리로 로드됨 . | 어떤 에셋이 리다이렉터 경로를 참조하고 있을 때, 언리얼은 먼저 리다이렉터(.uasset) 파일을 로드해서 UObjectRedirector 인스턴스로 메모리에 올림 | . | DestinationObject로 즉시 변환 . | 엔진은 리다이렉터를 참조하는 순간, DestinationObject(실제 에셋)를 메모리로 로드하고 참조를 자동으로 대체함 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#리다이렉터-작동-방식"
  },"357": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Redirectors 함수 구현에 사용한 메서드",
    "content": "Fix 과정의 핵심 . | 모든 리다이렉터를 탐색 | 각 리다이렉터의 DestinationObject를 메모리에 로드 | 예전 참조(리다이렉터 경로)를 새 참조(DestinationObject 경로)로 교체 | 리다이렉터 파일 삭제 | . 1. IAssetRegistry&amp; AssetRegistry . 에셋 레지스트리 가져오기 . ❓ 왜 인터페이스 레퍼런스 타입으로 가져오는거야? . | AssetRegistry는 엔진 내부적으로 이미 생성되어 관리되는 객체 | new로 직접 인스턴스를 만들면, 엔진의 전역 에셋 DB와 분리된 “쓸모 없는 객체”가 만들어짐 | 즉, 반드시 엔진이 소유/관리하는 인스턴스를 사용해야 하며, 이를 제공받는 공식 경로는 아래와 같다. | . FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get() . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#fix-redirectors-함수-구현에-사용한-메서드"
  },"358": {
    "doc": "Fix Up Redirectors From Code",
    "title": "함수명에 붙은 Checked란?",
    "content": "함수명에 “Checked”가 붙었을 때는 무조건 성공해야 하며, 실패 시 프로그램을 즉시 중단(Assert/Crash)한다는 의미 . | CastChecked (타입 불일치 → 크래시) | LoadModuleChecked (모듈 없음/실패 → 크래시) | . 비교 예시 . | 함수 | 동작 | 실패 시 | . | LoadModule() | 모듈 로드, 실패 시 nullptr 반환 | 안전 | . | LoadModuleChecked() | 모듈 로드, 실패 시 Assertion Failure(크래시) | 위험 (강제 중단) | . | GetModule() | 이미 로드된 모듈만 반환, 없으면 nullptr | 안전 | . 2. FModuleManager::LoadModuleChecked&lt;T&gt; . 엔진/에디터 모듈을 런타임에 안전하게 로드 . | FModuleManager:: . | 모듈 동적 로딩 시스템을 관리하는 핵심 클래스 | . | LoadModuleChecked() . | 템플릿 함수로, 지정된 모듈 타입(T)을 강제로 로드하고 검증 후 반환 | 모듈이 존재하지 않으면 크래시 | . | . template&lt;class T&gt; static T&amp; LoadModuleChecked(FName ModuleName); . 동작 . | ModuleName에 해당하는 모듈이 이미 로드되어 있으면 . | → 바로 그 모듈의 레퍼런스(포인터/레퍼런스)를 반환 | . | 아직 로드되지 않았다면 . | 모듈을 로드(동적 DLL 또는 엔진 플러그인 로딩) 시도 | 성공하면 인스턴스 반환 | 실패시 크래시 | . | 반환 타입은 T&amp; (예: FAssetRegistryModule&amp;) | . 3. CastChecked&lt;T&gt;() . 주어진 포인터가 실제 런타임에 T 타입(혹은 그 하위 타입)인지 체크한 뒤, 맞으면 T로 변환해서 반환 . | 틀리면 에디터 빌드(Development/Debug)에서는 강제로 크래시(Assertion 실패)를 일으킴 | . CastChecked&lt;T&gt;와 Cast&lt;T&gt;의 차이 . | 함수 | 타입 체크 실패 시 동작 | 주로 사용하는 상황 | . | Cast&lt;T&gt;() | 실패 시 nullptr 반환 | 타입이 확실하지 않을 때, if문으로 분기 필요할 때 | . | CastChecked&lt;T&gt;() | 실패 시 크래시/Assertion Failure | 타입이 반드시 T여야 할 때 (논리 오류 방지) | . 3. FARFilter . AssetRegistry 모듈에서 사용하는 에셋 검색 조건을 표현하는 구조체 . | AssetRegistry API (GetAssets 등) 호출 시, 이 구조체를 넘겨주면 조건에 맞는 에셋만 결과로 반환 | . FARFilter 주요 멤버 . | 필드 | 역할 | . | TArray&lt;FName&gt; PackagePaths | 검색할 폴더 경로(예:/Game, /Game/MyFolder) | . | TArray&lt;FName&gt; ClassPaths | 검색할 클래스 유형(예: Blueprint, ObjectRedirector) | . | bool bRecursivePaths | 하위 폴더까지 검색할지 여부 | . | TArray&lt;FName&gt; ObjectPaths | 특정 오브젝트 경로 지정(옵션) | . | … | 이 외에도 Tag, Metadata 등 다양한 조건 가능 | . FARFilter 사용 예시 . // AssetRegistry 모듈 참조 얻기 IAssetRegistry&amp; AssetRegistry = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\")).Get(); // FARFilter 구조체 생성 FARFilter Filter; // 검색할 폴더 지정 (여러 개 가능) Filter.PackagePaths.Add(FName(\"/Game/MyFolder\")); // 예시: /Game/MyFolder 폴더만 검색 // 하위 폴더까지 재귀적으로 검색할지 여부 Filter.bRecursivePaths = true; // 검색할 클래스 지정 (여러 개 가능) Filter.ClassPaths.Add(UStaticMesh::StaticClass()-&gt;GetClassPathName()); // 스태틱 메시만 대상 // Filter.ClassPaths.Add(UMaterial::StaticClass()-&gt;GetClassPathName()); // 필요하면 다른 클래스도 추가 // 특정 태그 기반 검색 예시 (선택 사항) // Filter.TagsAndValues.Add(FName(\"MyTag\"), TEXT(\"MyValue\")); // 결과 저장할 배열 TArray&lt;FAssetData&gt; AssetList; // 실제 검색 수행 AssetRegistry.GetAssets(Filter, AssetList); // 결과 사용 예시 for (const FAssetData&amp; Asset : AssetList) { UE_LOG(LogTemp, Log, TEXT(\"Asset found: %s\"), *Asset.AssetName.ToString()); } . 4. AssetRegistry.GetAssets(Filter, AssetList) . Filter에 지정된 조건(폴더, 클래스, 태그 등)에 맞는 에셋의 메타데이터 목록을 OutAssetData(배열)에 추가 . virtual bool GetAssets( const FARFilter&amp; InFilter, TArray&lt;FAssetData&gt;&amp; OutAssetData, bool bSkipARFilteredAssets ) const = 0; . | 매개변수 . | const FARFilter&amp; Filter . | 에셋 검색 조건 | . | TArray&amp; OutAssetData . | 검색 결과가 담길 배열 (에셋 메타데이터(FAssetData) 객체) | . | bool bSkipARFilteredAssets . | AssetRegistry에 이미 “숨김(Filtered Out)” 처리된 에셋을 결과에서 제외 | 기본값 true (숨김 에셋 제외) | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#%ED%95%A8%EC%88%98%EB%AA%85%EC%97%90-%EB%B6%99%EC%9D%80-checked%EB%9E%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#함수명에-붙은-checked란"
  },"359": {
    "doc": "Fix Up Redirectors From Code",
    "title": "AssetViewUtils",
    "content": "콘텐츠 브라우저(에셋 뷰)에서 에셋의 표시, 로딩, 정렬, 필터링 등과 관련된 작업 유틸리티 . | ContentBrowser 모듈에 포함 . | 에셋을 실제로 메모리로 로드(Load) | 에셋 목록을 정렬(Sort), 필터(Filter) | 콘텐츠 브라우저에서 사용할 다양한 유틸리티 제공 | . 5. AssetViewUtils::FLoadAssetsSettings . 에셋 로딩 동작을 세부적으로 제어하는 옵션 구조체 . | 위에서 설명한 Filter와 마찬가지로 설정 옵션을 정의하는 용도로 쓰임 | . FLoadAssetsSettings 주요 맴버 . | 필드 | 역할 | . | bFollowRedirectors | 에셋 경로가 리다이렉터인 경우, 자동으로 실제 에셋을 따라갈지 여부 - true면 리다이렉터를 따라가 실제 에셋을 로딩 - false면 리다이렉터 그 자체만 로드 | . | bAllowCancel | 로딩 도중 사용자가 취소(Interrupt/Cancel)할 수 있는 UI가 노출될지 여부 - 에디터에서 대량 에셋 로딩시 “취소” 가능 | . 6. AssetViewUtils::LoadAssetsIfNeeded . 에셋의 오브젝트 경로(ObjectPath) 리스트를 받아, 실제로 필요한 에셋만 메모리로 로드하는 에디터 유틸리티 함수 . | 이미 메모리에 로드된 에셋은 재로드하지 않음 | 콘텐츠 브라우저 및 에디터 툴에서 대량 에셋 로딩에 특화 | . // 매개변수 설명 ELoadAssetsResult LoadAssetsIfNeeded( const TArray&lt;FString&gt;&amp; AssetObjectPaths, // 오브젝트 경로 문자열 리스트 TArray&lt;UObject*&gt;&amp; LoadedAssets, // 실제 로딩된 에셋 객체가 저장될 배열 const FLoadAssetsSettings&amp; Settings // 로딩 옵션(구조체) ); AssetViewUtils::LoadAssetsIfNeeded(AssetObjectPaths, LoadedAssets, Settings); . 반환값 . | 값 | 의미 | . | ELoadAssetsResult::Succeeded | 모든 에셋 정상 로드 | . | ELoadAssetsResult::Cancelled | 로딩 중 사용자 취소 | . | ELoadAssetsResult::Failed | 로딩 자체 실패 | . 7. AssetToolsModule.Get().FixupReferencers() . FixupReferencers()는 깨진 참조를 수정하는 핵심 함수이다 . | 깨진 참조 자동 복구 . | 에셋 경로 변경으로 인해 깨진 참조를 검색하고 자동으로 수정 | 리다이렉터가 존재할 경우 대상 경로로 참조를 업데이트 | . | 대상 범위 . | 선택한 에셋(들)을 참조하는 모든 다른 에셋을 검사 | 블루프린트, 머티리얼, 레벨 등 모든 에셋 타입의 참조 처리 가능 | . | 리다이렉터 처리 . | 기존 리다이렉터를 제거하고 직접 참조로 변환할 수 있음 | . | . virtual void FixupReferencers( const TArray&lt;UObjectRedirector*&gt;&amp; Redirectors, bool bCheckoutDialogPrompt = false, ERedirectFixupMode FixupMode = ERedirectFixupMode::DeleteFixedUpRedirectors ) = 0; . | 매개변수 . | Redirectors: UObjectRedirector*의 배열로, 참조를 갱신할 리다이렉터 목록 | bCheckoutDialogPrompt: true로 설정하면, 소스 컨트롤 사용 시 체크아웃 다이얼로그를 표시 | FixupMode: 리다이렉터 처리 방식을 지정 . | ERedirectFixupMode::DeleteFixedUpRedirectors: 참조가 갱신된 리다이렉터를 삭제 | ERedirectFixupMode::LeaveFixedUpRedirectors: 참조가 갱신되더라도 리다이렉터를 유지 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html#assetviewutils"
  },"360": {
    "doc": "Fix Up Redirectors From Code",
    "title": "Fix Up Redirectors From Code",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/Fix%20Up%20Redirectors%20From%20Code.html"
  },"361": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration (전방 선언)",
    "content": "클래스나 구조체의 완전한 정의 없이 컴파일러에게 해당 타입의 존재만을 알리는 선언 . | 포인터(또는 참조) 변수만 쓸 때는 클래스 전체 정의가 필요 없음 | 포인터는 타입의 실제 크기를 몰라도 주소값만 저장하므로 forward declaration만으로 충분 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%A0%84%EB%B0%A9-%EC%84%A0%EC%96%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-전방-선언"
  },"362": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration 사용 이유",
    "content": ". | 컴파일 시간 감소 . | 헤더 파일을 포함하면 해당 헤더와 모든 종속성이 재컴파일되지만, 전방 선언은 이를 방지함 | . | 순환 참조 해결 . | 두 클래스가 서로를 참조할 때 발생하는 순환 종속성을 해결 | . | 코드 팽창 방지 . | 불필요한 헤더 포함으로 인한 코드 크기 증가를 막음 | . | 빌드 시스템 간소화 . | 종속성 감소로 빌드 시스템이 단순화 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-사용-이유"
  },"363": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration 예시",
    "content": "hpp . // MyClass.h 헤더 파일 #pragma once class ADependencyClass; // 전방 선언 UCLASS() class UMyClass : public UObject { GENERATED_BODY() private: ADependencyClass* DependencyPtr; // 포인터로 사용 가능 }; . cpp . // MyClass.cpp 소스 코드 #include \"ADependencyClass.h\" // 실제 객체를 생성하거나 멤버 함수, 변수 접근 시 필요 UMyClass::UMyClass() { DependencyPtr = CreateDefaultSubobject&lt;ADependencyClass&gt;(TEXT(\"MyComp\")); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#forward-declaration-예시"
  },"364": {
    "doc": "Forward Declaration",
    "title": "언제 헤더 파일을 include 해야 하나",
    "content": ". | 클래스를 상속할 때 . | 부모 클래스의 완전한 정의가 필요 | . | 실제 객체(인스턴스)를 생성할 때 . | new 또는 CreateDefaultSubobject 등 메모리 할당이 필요한 경우 | 타입의 크기를 알아야 할 때 (sizeof 등) | . | 멤버 변수 또는 함수에 접근할 때 . | 클래스의 실제 멤버 정보가 필요 | . | 템플릿 인스턴스화가 필요할 때 . | 템플릿 타입을 특정 타입으로 인스턴스화할 때 완전한 정의 필요 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#%EC%96%B8%EC%A0%9C-%ED%97%A4%EB%8D%94-%ED%8C%8C%EC%9D%BC%EC%9D%84-include-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#언제-헤더-파일을-include-해야-하나"
  },"365": {
    "doc": "Forward Declaration",
    "title": "권장 인클루드 순서",
    "content": ". | 현재 클래스의 헤더 . | \"MyClass.h\" | 자기 완결성 검증: 자신의 헤더가 다른 헤더에 의존하지 않고 독립적인지 확인 | 컴파일 오류 조기 발견: 헤더 파일의 누락된 종속성을 즉시 확인 가능 | . | 엔진/프레임워크 헤더 . | &lt;CoreMinimal.h&gt; 등 | 시스템 종속성 분리: 플랫폼별 정의나 엔진 매크로가 먼저 로드되도록 보장 | . | 다른 모듈의 헤더 . | \"MyGame/Public/ModuleX.h\" | 모듈 경계 명확화: 프로젝트 내부 모듈 간의 종속성을 가시화 | . | 로컬, 프라이빗 헤더 . | Private/Subsystem.h | 구현 세부사항 은닉: 내부 구현용 헤더를 마지막에 위치시켜 public 헤더와 분리 | . | UCLASS, USTRUCT와 같은 매크로 사용시 #include \"MyClass.generated.h\" 맨 마지막에 선언 . | 강제 규칙: 반드시 마지막에 위치 (UHT 처리 요구사항) | . | . 예시 . // 1. 현재 모듈 헤더 (생략) // 2. 엔진 헤더 #include \"CoreMinimal.h\" #include \"GameFramework/Character.h\" // 3. 다른 모듈 헤더 #include \"MyGame/Public/Components/HealthComponent.h\" #include \"MyGame/Public/Weapons/WeaponManager.h\" // 4. 로컬 헤더 #include \"MyCharacterCustomAnimInstance.h\" // 5. 생성 헤더 #include \"MyCharacter.generated.h\" . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#%EA%B6%8C%EC%9E%A5-%EC%9D%B8%ED%81%B4%EB%A3%A8%EB%93%9C-%EC%88%9C%EC%84%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html#권장-인클루드-순서"
  },"366": {
    "doc": "Forward Declaration",
    "title": "Forward Declaration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Forward%20Declaration.html"
  },"367": {
    "doc": "Forward vs Deferred",
    "title": "Forward Rendering (선행 렌더링)",
    "content": "참고하면 좋은 링크 . | forward-and-deferred-rendering | Interactive Graphics 21 - Deferred, Variable-Rate, &amp; Adaptive Shading | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering-%EC%84%A0%ED%96%89-%EB%A0%8C%EB%8D%94%EB%A7%81",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html#forward-rendering-선행-렌더링"
  },"368": {
    "doc": "Forward vs Deferred",
    "title": "Forward vs Deferred",
    "content": " ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/Forward%20vs%20Deferred.html"
  },"369": {
    "doc": "Function",
    "title": "나중에 리플렉션, 가비지 컬렉션, 직렬화, 네트워크 동기화, 에디터 통합으로 마크다운 파일 나누기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%82%98%EC%A4%91%EC%97%90-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%A7%81%EB%A0%AC%ED%99%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9%EC%9C%BC%EB%A1%9C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%ED%8C%8C%EC%9D%BC-%EB%82%98%EB%88%84%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#나중에-리플렉션-가비지-컬렉션-직렬화-네트워크-동기화-에디터-통합으로-마크다운-파일-나누기"
  },"370": {
    "doc": "Function",
    "title": "UObject 특징",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#uobject-특징"
  },"371": {
    "doc": "Function",
    "title": "1. 리플렉션(Reflection)",
    "content": "런타임에 객체의 타입, 필드, 메서드 정보를 조회하고 동적으로 접근/수정할 수 있는 기능 . | 리플렉션 데이터는 컴파일 시점에 UHT(Unreal Header Tool)이 자동 생성 . | GENERATED_BODY() 매크로가 이를 활성화 | . | 런타임 타입 정보(RTTI): UCLASS, UPROPERTY, UFUNCTION 등 매크로를 통해 리플렉션 데이터 생성 | 동적 캐스팅: Cast&lt;UMyClass&gt;(SomeObject) 형태로 안전한 타입 변환 가능 | 프로퍼티 검사: 런타임에 객체의 프로퍼티를 검사하고 수정할 수 있음 . | C++ 표준에는 런타임 리플렉션 기능이 없음 . | 예를 들어, 클래스에 어떤 필드가 있는지, 메서드가 무엇인지 런타임에 알 수 없음 | RTTI로 typeid, dynamic_cast 정도만 제공 | . | 언리얼의 리플렉션 . | 자체적인 리플렉션 시스템을 만들어 UObject 계열 클래스에 한해 런타임 타입 정보, 속성, 함수 목록 등을 관리 | C++ 매크로(UCLASS, UPROPERTY, UFUNCTION)와 Unreal Header Tool(UHT)이 자동으로 메타데이터를 생성해 코드에 삽입 | . | . 내부 매커니즘 . | 각 UObject 인스턴스는 UClass 타입 메타데이터(속성, 함수, 부모 정보 등)를 보유. | 런타임에 GetClass(), FindField, GetDefaultObject, ProcessEvent 등의 API로 동적 접근. | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98reflection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#1-리플렉션reflection"
  },"372": {
    "doc": "Function",
    "title": "2. 가비지 컬렉션(Garbage Collection)",
    "content": "더 이상 필요하지 않은 객체(메모리)를 자동으로 탐지하여 해제하는 메커니즘 . | 자동 메모리 관리: UObject는 UE의 가비지 컬렉션 시스템과 통합되어 있어 참조가 없어지면 자동으로 제거 | UPROPERTY() 매크로로 표시된 멤버 변수는 가비지 컬렉터가 추적 . | C++은 명시적 메모리 관리(new/delete, 스마트 포인터)를 요구 . | 실수로 delete를 빼먹거나, 중복해서 delete하면 메모리 누수/오류가 발생할 수 있음. | . | 언리얼의 가비지 컬렉션 . | UObject 파생 객체만 엔진의 GC 대상이 됨 (일반 C++ 객체는 해당 없음) | 엔진은 참조 그래프(Reference Graph)를 따라 “루트 오브젝트에서부터 도달할 수 없는 UObject”를 자동 삭제 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98garbage-collection",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#2-가비지-컬렉션garbage-collection"
  },"373": {
    "doc": "Function",
    "title": "레퍼런스 그래프(Reference Graph)",
    "content": "GC가 객체 간 참조 관계를 추적하는 핵심 메커니즘 . | 주기적으로 또는 명시적으로(엔진 Tick, 레벨 변경 등) GC가 수행됨 | UObject만 추적. 일반 C++ 객체/스마트 포인터는 GC 영향 없음 | 순환 참조 문제 자동 해결 | . // A가 B를 참조, B가 A를 참조해도 루트 연결이 없으면 모두 삭제됨 class A { UPROPERTY() B* RefB; }; class B { UPROPERTY() A* RefA; }; . 1. 루트 객체(Root Objects) 식별 . | 가비지 컬렉션의 시작점으로 절대 삭제되지 않는 객체들 | . - 월드에 배치된 `AActor` - `AddToRoot()`로 등록된 객체 - 게임 인스턴스(`UGameInstance`) - 에디터에서 열린 에셋 (`UPackage`) . 2. 그래프 탐색 (Mark 단계) . | 루트 객체부터 UPROPERTY() 참조를 재귀적으로 따라가며 도달 가능한 객체 마킹 | . Mark 단계 순서 . | GC Root(예: 월드, 게임 인스턴스, 에디터 오브젝트 등)에서 탐색 시작 | RootObjectA를 방문(Mark) | RootObjectA의 UPROPERTY 필드 참조를 따라 ObjB, ObjC를 방문(Mark) | ObjB의 UPROPERTY 필드 참조를 따라 ObjD, ObjE 방문(Mark) | … 이하 반복 | 모든 방문이 끝나면, Mark되지 않은 나머지 객체들은 GC 대상으로 간주 | . 3. 미사용 객체 삭제 (Sweep 단계) . | 마킹되지 않은 객체를 안전하게 제거 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EA%B7%B8%EB%9E%98%ED%94%84reference-graph",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#레퍼런스-그래프reference-graph"
  },"374": {
    "doc": "Function",
    "title": "3. 직렬화(Serialization)",
    "content": "UObject 기반 클래스 객체는 파일이나 네트워크로 저장/불러오거나 복제할 수 있음. | 맵, 에셋, 게임 세이브 파일, 블루프린트 인스턴스 등은 모두 UObject 파생 클래스의 직렬화에 기반해 저장/복원 | FArchive 기반의 엔진 직렬화 시스템이 모든 UPROPERTY 데이터를 자동으로 기록 및 재구성 . | UPROPERTY()로 선언된 변수는 별도의 코드 없이도 자동 직렬화 대상 | 예: SaveGame, 네트워크 동기화, 복제 등 | . | Serialize(FArchive&amp; Ar) 메서드를 오버라이드하면, 특정 데이터를 커스텀하게 저장/복원할 수 있음 | . 자동 직렬화 예시 . UCLASS() class UMySaveGame : public USaveGame { GENERATED_BODY() public: UPROPERTY() int32 PlayerLevel; UPROPERTY() FString PlayerName; }; // 이렇게 선언된 변수는 SaveGame 파일에 자동 저장/복원 . 커스텀 직렬화 시 버전 호환성을 위한 패턴 . void Serialize(FArchive&amp; Ar) { Super::Serialize(Ar); int32 Version = 0; Ar &lt;&lt; Version; // 버전 기록 if (Version &gt;= 1) { Ar &lt;&lt; MyNewVariable; } } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-%EC%A7%81%EB%A0%AC%ED%99%94serialization",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#3-직렬화serialization"
  },"375": {
    "doc": "Function",
    "title": "데이터 저장 흐름",
    "content": ". | UObject 계열 클래스는 저장 대상이 되면 . | 엔진 내부의 FArchive 객체(파일/메모리/네트워크 스트림)를 통함 | 각 UPROPERTY 값을 자동으로 기록(Serialize)한다 | . | 불러오기(로드) 시 저장된 바이너리 데이터가 FArchive로 읽혀짐 . | UPROPERTY 정보를 기반으로 객체(=UObject)의 멤버 변수로 복원(Deserialize) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#데이터-저장-흐름"
  },"376": {
    "doc": "Function",
    "title": "SaveGame 동작 예시",
    "content": "// SaveGame 객체 선언 UMySaveGame* SaveGameObj = NewObject&lt;UMySaveGame&gt;(); SaveGameObj-&gt;PlayerLevel = 25; SaveGameObj-&gt;PlayerName = TEXT(\"홍길동\"); // 저장 UGameplayStatics::SaveGameToSlot(SaveGameObj, TEXT(\"MySlot\"), 0); // 불러오기 UMySaveGame* LoadedGame = Cast&lt;UMySaveGame&gt;( UGameplayStatics::LoadGameFromSlot(TEXT(\"MySlot\"), 0) ); int32 LoadedLevel = LoadedGame-&gt;PlayerLevel; // 직렬화된 값이 자동 복원 . | 저장(Serialize) 과정 . | SaveGame 클래스 객체를 생성 | UGameplayStatics::SaveGameToSlot() 같은 API 호출 | 내부적으로 SaveGame 객체 → FArchive → UPROPERTY 자동 순회 및 값 기록 결과적으로 바이너리 파일(.sav 등)로 저장 | . | 불러오기(Deserialize) 과정 . | UGameplayStatics::LoadGameFromSlot() 같은 API 호출 | FArchive가 파일을 읽고, SaveGame 객체를 새로 만듦 | FArchive 데이터 → UPROPERTY 기반으로 멤버 변수 값이 자동 복원 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#savegame-동작-예시"
  },"377": {
    "doc": "Function",
    "title": "네트워크 동기화 (Replicate) 동작 예시",
    "content": "나중에 멀티 플레이 공부할 때 채워넣겠음 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8F%99%EA%B8%B0%ED%99%94-replicate-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#네트워크-동기화-replicate-동작-예시"
  },"378": {
    "doc": "Function",
    "title": "4. 에디터 통합",
    "content": "메타데이터로 자동으로 디테일 패널 생성. | 디테일 패널 표시: UPROPERTY 지정자를 통해 에디터에서 편집 가능 | 블루프린트 노출: UFUNCTION에 BlueprintCallable 등의 지정자 추가로 블루프린트에서 사용 가능 | . 커스텀 프로퍼티 에디터 예시 . FPropertyEditorModule&amp; PropModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\"); . 정리 . // 1. 객체 생성 + 메타데이터 UCLASS(BlueprintType, meta=(DisplayName=\"My Cool Object\")) class UMyObject : public UObject { GENERATED_BODY() public: // 2. 라이프사이클 관리 virtual void BeginDestroy() override { CleanupResources(); Super::BeginDestroy(); } // 3. 메타데이터 활용 UPROPERTY(EditAnywhere, meta=(ClampMin=0)) int32 Value; }; // 결과: // - 블루프린트에서 \"My Cool Object\"로 노출 (리플렉션) // - Value는 에디터에서 0 이상 값만 입력 가능 (에디터 통합) // - 객체 파괴 시 CleanupResources() 자동 호출 (GC 연동) . 참고 링크 . | Memory Management &amp; Garbage Collection in Unreal Engine 5 | 04. Reflection and Garbage Collection | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-%EC%97%90%EB%94%94%ED%84%B0-%ED%86%B5%ED%95%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html#4-에디터-통합"
  },"379": {
    "doc": "Function",
    "title": "Function",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Function.html"
  },"380": {
    "doc": "Instruction",
    "title": "Instruction (명령어)",
    "content": "CPU가 수행할 작업을 지시하는 기본 단위 . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-명령어"
  },"381": {
    "doc": "Instruction",
    "title": "명령어의 기본 구성",
    "content": ". | 연산 코드(Opcode) . | 수행할 연산을 지정 (예: ADD, SUB, LOAD, JUMP) | . | 피연산자(Operand) . | 연산에 사용될 데이터 또는 데이터의 주소 (레지스터, 메모리 주소, 상수 등) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#명령어의-기본-구성"
  },"382": {
    "doc": "Instruction",
    "title": "Instruction Format (명령어 형식)",
    "content": "CPU 설계에 따라 다양한 형식으로 나뉘지만 주요 형식은 아래와 같음 . | 0-주소 명령어 (Stack Machine) . | 피연산자를 명시하지 않음 / 스택(Stack) 의 최상위 값(TOS)을 암묵적으로 사용 | Op-code | . | . | 예: ADD (스택의 top 두 값을 꺼내 더한 후 결과를 push) | . | 1-주소 명령어 (Accumulator Machine) . | 하나의 피연산자만 명시 | 누산기(ACC)가 암묵적인 피연산자 . | 누산기(Accumulator) : CPU 내부에서 산술 및 논리 연산 결과를 임시로 저장하는 특별한 레지스터 | Op-code | Address | . | . | . | 예: LOAD X (메모리 주소 X의 값을 ACC에 적재) | . | 2-주소 명령어 (General Register Machine) . | 두 피연산자를 명시 | 결과는 첫 번째 피연산자에 저장 | Op-code | Address1 | Address2 | . | . | 예: ADD R1, R2 (R1 = R1 + R2) | . | 3-주소 명령어 (RISC 구조) . | 두 피연산자와 결과 저장 위치를 모두 명시 | Op-code | Address1 | Address2 | Address3 | . | . | 예: ADD R1, R2, R3 (R1 = R2 + R3) | . | . | 형식 | 0-주소 명령어 | 1-주소 명령어 | 2-주소 명령어 | 3-주소 명령어 | . | 장점 | 명령어 길이가 짧음 | 간단한 하드웨어 구현 | 유연성 높음 (대부분의 현대 CPU에서 사용) | 명확한 의미 전달 병렬 처리 용이 | . | 단점 | 스택 관리 복잡 | 연산마다 ACC 접근이 필요해 병목 현상 발생 가능 | 명령어 길이가 상대적으로 김 | 명령어 길이가 가장 김 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-format-%EB%AA%85%EB%A0%B9%EC%96%B4-%ED%98%95%EC%8B%9D",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-format-명령어-형식"
  },"383": {
    "doc": "Instruction",
    "title": "명령어의 피연산자 유형",
    "content": "주소 지정 방식 명령어를 이해하기 위해 피연산자 유형이 어떻게 지정되는지 설명 . | 즉시 (Immediate) . | 명령어 내에 상수 값 포함 | 예: ADD R1, #5 (R1 = R1 + 5) | . | 레지스터 (Register) . | CPU 내 레지스터 참조 | 예: MOV R1, R2 (R1 = R2) | . | 메모리 주소 (Memory Address) . | 직접 주소, 간접 주소, 인덱스 주소 등 | 예: LOAD R1, [0x1000] (메모리 주소 0x1000의 값을 R1에 적재) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%ED%94%BC%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#명령어의-피연산자-유형"
  },"384": {
    "doc": "Instruction",
    "title": "Addressing Mode (주소 지정 방식)",
    "content": "명령어가 지정한 피연산자(operand)를 메모리·레지스터·즉시값 등에서 어떤 방식으로 찾는가에 대한 규칙 . | 주소 지정 방식 | 설명 | 명령어 예시 | 의미 | . | 즉시(Immediate) | 주소 필드에 들어있는 값 자체를 operand로 사용 | ADD R1, #5 | (R1 = R1 + 5) | . | 직접(Direct) | 주소 필드에 적힌 주소를 operand의 메모리 주소로 사용 | LOAD R1, [1000] | 메모리 주소 0x1000의 값을 R1에 적재 | . | 간접(Indirect) | 주소 필드에 적힌 주소에 가서 그 안의 값을 operand 주소로 사용 | LOAD R1, [[0x1000]] | 1000번지에 저장된 값이 진짜 주소, 거기 있는 값을 R1에 로드 | . | 레지스터(Register) | 주소 필드가 레지스터 번호 해당 레지스터 값을 operand로 사용 | MOV R1, R2 | R1 = R2 | . | 레지스터 간접(Register Indirect) | 주소 필드가 가리키는 레지스터 안에 저장된 값(주소)을 실제 메모리 주소로 사용 | LOAD R1, [R2] | R2의 값이 500이면, 500번지의 데이터를 R1에 로드 | . | 상대(Relative/PC-relative) | 주소 필드 값과 현재 PC(program counter)의 값을 더해 실주소를 만듦 | JMP 20 | (JUMP PC + 20) 현재 PC가 100이라면 120번지로 점프 | . | 인덱스(Index) | 베이스 레지스터 + 인덱스 레지스터 | LOAD R1, [ADRS + R2] | R2가 10이고 ADRS가 1000이면 1010 주소 값 적재 | . | 기타(변형) | 자동 증가/감소, 변위(Displacement), 스택 등 |   |   | . 인덱스 레지스터 동작 과정 . 배열, 테이블, 벡터와 같이 메모리에 연속적으로 저장된 데이터에 반복적으로 접근할 때 사용 . | Base Address (기준 주소): 배열의 시작 주소 (예: 1000 = A[0]의 주소) | Offset (인덱스 레지스터): 시작 주소로부터의 거리 (예: R2는 i × 원소 크기) | 실제 주소: Base + Offset으로 계산 | . // LOAD R1, [ADRS + R2] LOAD R1, 1000(R2) . | 배열 원소의 크기는 4바이트로 가정 | 배열 A[0]의 시작주소 = 1000 | R2는 바이트 단위 Offset이 저장됨 . | R2 = 원하는 인덱스 × 원소 크기 | 예: A[3] 접근 시 R2 = 3 × 4 = 12 | . | 메모리 접근 . | 예: LOAD R1, 1000(20) → R1 = 메모리[1020] (즉, A[5]의 값) | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#addressing-mode-%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#addressing-mode-주소-지정-방식"
  },"385": {
    "doc": "Instruction",
    "title": "Types of Instructions (명령어 종류)",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html#types-of-instructions-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#types-of-instructions-명령어-종류"
  },"386": {
    "doc": "Instruction",
    "title": "Data Transfer Instructions",
    "content": ". | 데이터 전송 명령어 | 입출력 명령어가 포함됨 | . | 전송명령어 | 니모닉 | 기 능 | . | Load | LD | 기억장치로부터 레지스터로 전송 | . | Store | ST | 레지스터로부터 기억장치로의 전송 | . | Move | MOVE | 레지스터로부터 다른 레지스터로의 전송 | . | Exchange | XCH | 두 레지스터 또는 한 레지스터와 기억장치 간의 데이터 교환 | . | Push | PUSH | 레지스터의 값을 스택에 저장 | . | Pop | POP | 스택에서 레지스터로 값 복원 | . | Input | IN | 입출력장치로부터 레지스터로 데이터 전송 | . | Output | OUT | 레지스터와 입출력장치 간의 데이터 전송 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#data-transfer-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#data-transfer-instructions"
  },"387": {
    "doc": "Instruction",
    "title": "Data Processing Instructions",
    "content": ". | 데이터 처리 명령어 | 데이터에 대한 연산을 실행하고 계산함 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#data-processing-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#data-processing-instructions"
  },"388": {
    "doc": "Instruction",
    "title": "Arithmetic Instructions",
    "content": ". | 산술 명령어 | . | 산술 명령어 | 니모닉 | 기 능 | . | Increment | INC | 1 증가 | . | Decrement | DEC | 1 감소 | . | Add | ADD | 덧셈 | . | Subtract | SUB | 뺄셈 | . | Multiply | MUL | 곱셈 | . | Divide | DIV | 나눗셈 | . | Add with carry | ADDC | 캐리 포함한 덧셈 | . | Subtract with borrow | SUBB | 빌림 포함한 뺄셈 | . | Negate | NEG | 2의 보수 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#arithmetic-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#arithmetic-instructions"
  },"389": {
    "doc": "Instruction",
    "title": "Logical Instructions",
    "content": ". | 논리비트 명령어 | 레지스터나 기억장치에 저장된 데이터에 2진 연산 | . | 논리 명령어 | 니모닉 | 기 능 | . | Clear | CLR | 모든 비트를 0으로 리셋 | . | Set | SET | 모든 비트를 1로 셋 | . | Complement | COM | 오퍼랜드에 저장된 모든 비트값 반전 | . | AND | AND | 비트별 AND 연산 | . | OR | OR | 비트별 OR 연산 | . | Exclusive-OR | XOR | 비트별 XOR 연산 | . | Clear carry | CLRC | 캐리 비트 리셋 | . | Set carry | SETC | 캐리 비트 셋 | . | Complement carry | COMC | 연산 결과에서 발생하는 캐리 비트만 반전 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#logical-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#logical-instructions"
  },"390": {
    "doc": "Instruction",
    "title": "Shift Instructions",
    "content": ". | 시프트 명령어 | logical : 비트열을 단순히 왼쪽 또는 오른쪽으로 밈 . | 비어지는 자리는 항상 0 으로 채움 | 부호 비트도 이동 | . | Arithmetic : 부호 비트(MSB)를 유지하면서 나머지 비트만 이동 . | 오른쪽 시프트의 경우 부호 비트는 원래 값 유지 | 왼쪽 시프트의 경우 부호 비트까지 움직임 (비는 자리는 0으로 채움) | . | Rotate : 비트열을 밀 때, 밀려나간 비트가 반대쪽 끝으로 다시 들어감 | Rotate with carry : 밀려나간 비트는 캐리 플래그로 이동 . | 캐리 플래그의 값은 오퍼랜드의 반대편 끝에 들어옴 | . | . | 시프트 명령어 | 니모닉 | 기 능 | . | Logical shift left | SHL | 논리적 왼쪽 시프트(빈 비트는 0으로 채움) | . | Logical shift right | SHR | 논리적 오른쪽 시프트(빈 비트는 0으로 채움) | . | Arithmetic shift left | SAL | 산술적 왼쪽 시프트 | . | Arithmetic shift right | SAR | 산술적 오른쪽 시프트 | . | Rotate left | ROL | 비트를 왼쪽으로 순환 | . | Rotate right | ROR | 비트를 오른쪽으로 순환 | . | Rotate left with carry | ROLC | 캐리 비트 포함 왼쪽 순환 | . | Rotate right with carry | RORC | 캐리 비트 포함 오른쪽 순환 | . 시프트 예시 . 로테이트 오른쪽 시프트의 경우 - 원래 값: 1 0 1 1 1 0 0 1 - 시프트 : 1 1 0 1 1 1 0 0 로데이트 캐리 왼쪽 시프트의 경우 - 캐리 플래그: C = 1 - 레지스터: 0 1 0 1 1 0 1 0 1.가장 왼쪽 비트(0)가 캐리로 이동 - 새 캐리 : 0 2.기존 캐리(1)가 오른쪽 끝(LSB)으로 들어감 - 레지스터 : 1 0 1 1 0 1 0 **1** &lt;- 캐리에서 온 1 추가 . ",
    "url": "/docs/Computer%20architecture/Instruction.html#shift-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#shift-instructions"
  },"391": {
    "doc": "Instruction",
    "title": "Control Flow Instructions",
    "content": ". | 프로그램 제어 명령어 | 다른 프로그램의 세그먼트로 분기 | . | 프로그램 제어 명령어 | 니모닉 | 기 능 | . | Branch | BR | 조건 혹은 무조건적으로 유효 주소로 분기 | . | Jump | JMP | 조건 혹은 무조건적으로 유효 주소로 분기 | . | Skip next instruction | SKP | 조건이 만족되면 다음 명령어를 수행하지 않고 넘어감 | . | Call | CALL | 서브루틴 호출 | . | Return | RET | 서브루틴에서 복귀 | . | Compare(by subtrction) | CMP | 두 오퍼랜드의 뺄셈을 통해 상태 레지스터의 값을 반환 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#control-flow-instructions",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#control-flow-instructions"
  },"392": {
    "doc": "Instruction",
    "title": "Instruction Set Architecture",
    "content": "CPU가 이해하는 명령어의 집합으로, 주요 유형은 아래와 같다 . | CISC (Complex Instruction Set Computer) . | 복잡한 명령어, 다양한 주소 지정 방식 | 예: x86 아키텍처 | . | RISC (Reduced Instruction Set Computer) . | 간단한 명령어, 고정된 길이, 레지스터 중심 | 예: ARM, MIPS | . | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#instruction-set-architecture",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#instruction-set-architecture"
  },"393": {
    "doc": "Instruction",
    "title": "아키텍처 요약",
    "content": "| 아키텍처 | 등장 시기/장소 | 설계 철학 | 주요 사용처 | 현재 | . | MIPS | 1981, 스탠포드 대학 | RISC | 임베디드, 라우터, PS1/2 | 쇠퇴, 일부 임베디드/네트워크에 잔존 | . | x86 | 1978, 인텔 | CISC | PC, 서버, 산업용 | PC/서버 시장 지배, 저전력은 약세 | . | ARM | 1985, 영국 Acorn | RISC | 모바일, IoT, 임베디드 | 모바일/임베디드 압도, PC/서버 확대 | . ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#아키텍처-요약"
  },"394": {
    "doc": "Instruction",
    "title": "나중에 아키텍처 별 명령어 집합 유형 추가하기",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html#%EB%82%98%EC%A4%91%EC%97%90-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B3%84-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A7%91%ED%95%A9-%EC%9C%A0%ED%98%95-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html#나중에-아키텍처-별-명령어-집합-유형-추가하기"
  },"395": {
    "doc": "Instruction",
    "title": "Instruction",
    "content": " ",
    "url": "/docs/Computer%20architecture/Instruction.html",
    
    "relUrl": "/docs/Computer%20architecture/Instruction.html"
  },"396": {
    "doc": "Management",
    "title": "UObject 사용 방법",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#uobject-사용-방법"
  },"397": {
    "doc": "Management",
    "title": "1. 객체 생성 및 관리",
    "content": ". | UObject의 인스턴스화(Instantiation)와 기본 설정을 담당하는 단계 | “어떻게 객체가 만들어지고, 참조되고, 접근되는가?” | . (1) UObject 객체 생성 . | Outer와 Package: 객체의 계층 구조와 저장 위치 결정 // Outer: 객체의 소유자 (일반적으로 현재 객체를 생성하는 객체) // Package: 에셋으로 저장될 경우 대상 패키지 (예: /Game/MyAsset) UMyObject* Obj = NewObject&lt;UMyObject&gt;(Outer, Package, NAME_None, RF_Transactional); . | RF_Transactional: 에디터 실행 취소(Undo) 시스템에 등록할 때 사용하는 플래그 | RF_Standalone: 패키지와 무관한 독립적 존재 (에셋이 아닌경우) | RF_Transient : 임시 객체 (저장되지 않음) | RF_Public :에셋으로 저장 시 공개적으로 표시 | . // 1. 일반적인 생성 (Outer와 Name 지정 가능) UMyObject* Obj = NewObject&lt;UMyObject&gt;(GetTransientPackage(), TEXT(\"MyObj\")); // 2. 서브오브젝트 생성 (주로 Actor/Component에서 사용) UMyComponent* Comp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"Comp\")); . | NewObject&lt;T&gt;(): 새로운 UObject 인스턴스 생성 | CreateDefaultSubobject(): 생성자에서 서브오브젝트 생성 시 사용 | TWeakObjectPtr&lt;T&gt;: GC 영향을 받지 않는 참조 생성 | . (2) UObject 객체 접근 및 유효성 검사 . // 유효성 체크 (GC에 의해 파괴되지 않았는지 확인) if (IsValid(Obj)) { Obj-&gt;DoSomething(); } // 약한 참조 (WeakPtr)로 GC 방지 TWeakObjectPtr&lt;UMyObject&gt; WeakObj = Obj; . (3) UObject 객체 등록 관리 . // 객체를 특정 패키지에 등록 Obj-&gt;Rename(nullptr, MyPackage); // 에셋으로 저장 가능하게 함 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#1-객체-생성-및-관리"
  },"398": {
    "doc": "Management",
    "title": "2. 라이프 사이클 관리",
    "content": ". | UObject가 생성부터 파괴까지 거치는 전체 과정을 관리 | “객체가 어떤 단계를 거쳐 존재하고 소멸하는가?”를 정의 | 가비지 컬렉션과 연동 가능 | . (1) 라이프 사이클 - 생성 . // 예시: 초기화 흐름 UCLASS() class UMyAsset : public UObject { GENERATED_BODY() public: UMyAsset() { /* 생성자 */ } // 프로퍼티 초기화 후 호출 virtual void PostInitProperties() override { Super::PostInitProperties(); InitDefaultValues(); // 기본값 설정 } // 명시적 초기화 (필요한 경우) void Initialize() { LoadExternalData(); } // 에셋 로드 완료 시 호출 virtual void PostLoad() override { Super::PostLoad(); ApplyLoadedData(); // 로드된 데이터 적용 } }; . (2) 라이프 사이클 - 사용 . // 활성화/비활성화 제어 (AActor 파생클래스 예시) virtual void BeginPlay() override; // 게임 시작 시 호출 virtual void EndPlay() override; // 게임 종료 또는 제거 시 호출 . (3) 라이프 사이클 - 파괴 . virtual void BeginDestroy() override { // 리소스 해제 로직 Super::BeginDestroy(); } virtual void FinishDestroy() override { // 최종 정리 작업 Super::FinishDestroy(); } . UObject 라이프 사이클 3단계 요약 . 생성 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | 생성자 | NewObject() 호출 시 | 메모리 할당 + 기본값 설정 | UPROPERTY는 아직 초기화되지 않음 | . | PostInitProperties() | 생성자 직후 | 프로퍼티 초기화 완료 시점 | 에디터에서 설정한 기본값 적용됨 | . | PostLoad() | 에셋 로드 완료 시 | 디스크 데이터 처리 | 에셋 전용 (동적 생성 객체는 호출 X) | . 사용 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | AddToRoot() | 수동 호출 시 | GC 대상에서 제외 | 남용 시 메모리 누수 가능성 | . | BeginPlay() | 게임 시작 시(AActor 한정) | 게임플레이 로직 초기화 | UObject 직접 사용 불가 (Actor/Component 필요) | . | Tick() | 매 프레임 (AActor 한정) | 지속적인 업데이트 | 성성능 저하 가능성 → 꼭 필요할 때만 사용 | . 파괴 . | 주요 함수/이벤트 | 호출 시기 | 용도 | 주의사항 | . | ConditionalBeginDestroy() | 수동 호출 또는 GC 시작 시 | 파괴 시작 신호 | 객체는 즉시 삭제되지 않음 | . | BeginDestroy() | GC 마킹 후 | 리소스 해제 (텍스처, 메모리 등) | 가상 함수 오버라이드 필수 | . | FinishDestroy() | 메모리 해제 직전 | 최종 정리 | 이후 모든 접근 불가능 | . (4) 가비지 컬렉션 연동 . // GC 대상에서 제외 (특수한 경우만 사용) Obj-&gt;AddToRoot(); // GC 대상으로 복귀 Obj-&gt;RemoveFromRoot(); . | BeginDestroy(): 객체가 파괴되기 전에 호출 | IsValidLowLevel(): 객체가 유효한지 확인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-%EB%9D%BC%EC%9D%B4%ED%94%84-%EC%82%AC%EC%9D%B4%ED%81%B4-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#2-라이프-사이클-관리"
  },"399": {
    "doc": "Management",
    "title": "3. 메타 데이터 시스템",
    "content": ". | UObject의 데이터(프로퍼티, 함수, 클래스 등)에 대해 추가 정보를 부여하는 키-값 쌍의 데이터 | “이 객체를 어떻게 표시하고, 직렬화하고, 에디터에서 다룰 것인가?”를 제어 . | “어떻게 에디터에서 표시할지”, “어떤 제약 조건을 둘지”, “블루프린트에 노출 여부” 등 | . | UCLASS, UPROPERTY 등에 메타데이터 추가 가능 | . UPROPERTY(EditAnywhere, meta=(DisplayName=\"My Custom Name\")) FString CustomizedName; . (1) 에디터 연동 및 UI 제어 . UPROPERTY(EditAnywhere, meta=(DisplayName=\"플레이어 이름\", Tooltip=\"캐릭터의 이름입니다.\")) FString CharacterName; . (2) 직렬화 동작 설정 . UPROPERTY(SaveGame, meta=(NoAutoLoad=true)) FString SaveSlotName; // 세이브 파일에 저장되지만 자동 로드 안 함 . (3) 리플렉션 시스템 연동 . UFUNCTION(meta=(WorldContext=\"WorldContextObject\")) static void MyFunction(UObject* WorldContextObject); //블루프린트에서 자동으로 World Context 연결 . (4) 제약 및 제어 커스텀 . UPROPERTY(meta=(ClampMin=0, ClampMax=100)) int32 Health; // 에디터에서 0~100 사이값만 입력 가능 . 메타데이터 시스템에서 자주 쓰는 키 목록 . | 메타 키 | 용도 | 예시 | . | BlueprintType | 블루프린트 변수로 사용 허용 | UCLASS(BlueprintType) | . | Category | 디테일 패널에서 그룹으로 묶임 | UPROPERTY(Category=\"Gameplay\") | . | AdvancedDisplay | 디테일 패널에서 접기 | meta=(AdvancedDisplay=true) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-%EB%A9%94%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#3-메타-데이터-시스템"
  },"400": {
    "doc": "Management",
    "title": "세 시스템 차이점 요약",
    "content": "| 시스템 | 핵심 질문 | 주요 도구 | 사용 예시 | . | 객체 생성 및 관리 | “객체를 어떻게 만들고 참조할까?” | NewObject CreateDefaultSubobject IsValid | 동적 객체 생성서브오브젝트 관리 | . | 라이프사이클 관리 | “객체가 생애주기 동안 무엇을 하는가?” | PostInitPropertiesBeginDestroyFinishDestroy | 리소스 할당/해제게임 로직 초기화 | . | 메타데이터 시스템 | “이 객체를 어떻게 표시/조작할까?” | meta=(…),UPROPERTY()/UFUNCTION() | 에디터 UI 커스터마이징직렬화 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#%EC%84%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html#세-시스템-차이점-요약"
  },"401": {
    "doc": "Management",
    "title": "Management",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/Management.html"
  },"402": {
    "doc": "Module",
    "title": "Module",
    "content": "특정 에디터 도구, 런타임 기능, 라이브러리 또는 기타 기능들을 독립적인 코드 단위로 캡슐화한 것 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html"
  },"403": {
    "doc": "Module",
    "title": "특징",
    "content": ". | 코드 분리 : 모듈은 코드 분리를 강제하여, 기능을 캡슐화하고 내부 구현을 숨길 수 있음 | 독립적 빌드 : 모듈은 독립적인 컴파일 단위로 빌드됨 . | 변경된 모듈만 다시 빌드되므로, 대규모 프로젝트의 빌드 속도가 크게 향상 | . | 의존성 그래프 및 헤더 관리 : 모듈 간 의존성 그래프가 생성되고, 실제 사용되는 코드에만 헤더 포함이 허용 . | 사용하지 않는 모듈은 컴파일에서 안전하게 제외 | . | 런타임 로드/언로드 제어 : 특정 모듈을 언제 로드/언로드할지 제어 가능 . | 이를 통해 프로젝트의 성능 최적화가 가능 | . | 플랫폼별 포함/제외 : 모듈을 플랫폼별로 포함하거나 제외할 수 있음 . | 예: 윈도우, 맥, 리눅스, 안드로이드 등에서 포함하거나 제외 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#특징"
  },"404": {
    "doc": "Module",
    "title": "모듈 디렉터리 구조",
    "content": "YourProject/ ├── Source/ # 모든 모듈은 반드시 프로젝트 또는 플러그인의 Source 디렉토리 하위에 위치 │ ├── YourModule/ # 모듈 루트 폴더명은 모듈명과 동일해야 함 │ │ ├── Public/ # 외부에 노출할 헤더 파일 │ │ ├── Private/ # 내부 구현 파일 (.cpp 및 내부 헤더) │ │ └── YourModule.Build.cs │ ├── YourPlugin.uplugin ├── YourProject.uproject . | Public/: 외부 모듈에서 사용할 수 있도록 공개된 헤더 파일 (.h) | Private/: 해당 모듈 내부에서만 사용하는 구현 파일 (.cpp) 과 헤더 파일 포함 . | .cpp 파일은 모두 private 폴더에 두는 것이 권장됨 | . | Build.cs: 모듈의 빌드 설정과 의존성을 정의하는 파일 . | Target.cs는 최종 빌드 옵션과 엔트리 포인트를 정의 | . | .uproject / .uplugin : “Modules” 리스트가 있어, 어떤 모듈이 어떻게 로드될지 정의 . | 이름, 타입, 지원 플랫폼, 로딩 단계 등을 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-디렉터리-구조"
  },"405": {
    "doc": "Module",
    "title": "모듈 타입 설정",
    "content": ".uproject 또는 .uplugin 파일의 Type 에서 정의 . | 모듈 타입에 따라 로드/언로드, 의존성, 포함 가능 플랫폼이 달라짐 | . { \"Modules\": [ { \"Name\": \"YourModule\", \"Type\": \"Runtime\", // 모듈 타입 지정 \"LoadingPhase\": \"Default\" // 로딩 단계 지정 } ] } . | Type (모듈 타입) . | \"Runtime\" : 게임 실행 시 필수적인 기능 제공 (예: Core, Engine) | \"Editor\" : 에디터 전용 기능 제공 (예: 플러그인) | \"Program\" : 독립 실행형 프로그램으로 사용 (예: UnrealHeaderTool) | \"Developer\" : 개발 전용 (예: Profiler, Visualizer) . | Shipping(릴리즈) 빌드에 포함되지 않는 특수 모듈 | . | \"ThirdParty\" : 외부 라이브러리 래핑용 . | 외부 바이너리/헤더 포함 및 관리 목적 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%AA%A8%EB%93%88-%ED%83%80%EC%9E%85-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#모듈-타입-설정"
  },"406": {
    "doc": "Module",
    "title": "로딩 단계 지정",
    "content": ".uproject 또는 .uplugin 파일의 LoadingPhase 에서 정의 . | LoadingPhase (주요 로딩 단계) . | \"PreDefault\" : 엔진 초기화 전 로드 (예: 코어 시스템) | \"Default\" : 대부분 모듈의 기본 단계 (기본값) | \"PostDefault\" : 기본 모듈 로드 후 (예: 게임플레이 코드) | \"PostConfigInit\" : 설정 파일 로드 후 (예: 설정 의존성 모듈) | \"PostSplashScreen\" : 스플래시 스크린 표시 후 (예: UI 모듈) | . | . 로딩 주의 사항 . A 모듈이 B 모듈에 의존할 때, B의 로딩 단계가 A보다 빠르거나 같아야 함 . | 예: B가 PreDefault, A가 Default여야 정상 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EB%A1%9C%EB%94%A9-%EB%8B%A8%EA%B3%84-%EC%A7%80%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#로딩-단계-지정"
  },"407": {
    "doc": "Module",
    "title": "Build.cs 파일에서 의존성 설정",
    "content": "언리얼 빌드 시스템은 프로젝트의 Target.cs와 각 모듈의 Build.cs 파일을 기준으로 프로젝트를 빌드함 . | 각 모듈에는 반드시 [ModuleName].Build.cs가 필요 | ModuleRules 클래스를 상속받아 자신의 모듈을 정의 | . Build.cs 파일 예시 . using UnrealBuildTool; public class ModuleTest : ModuleRules { public ModuleTest(ReadOnlyTargetRules Target) : base(Target) { PrivateDependencyModuleNames.AddRange(new string[] { \"Core\" }); } ... } . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#buildcs-파일에서-의존성-설정"
  },"408": {
    "doc": "Module",
    "title": "주요 의존성 설정",
    "content": "1. PublicDependencyModuleNames . // 사용할 모듈(폴더) 이름 적기 PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); . | 해당 리스트에 들어간 모듈은 내 모듈의 Public 코드(즉, Public 헤더 파일)와 Private 코드에서 모두 사용 가능 . | 예: #include “A/Public/A.h” | . | 해당 모듈에 의존하는 다른 모듈의 Public 코드에서도 이 의존성 모듈의 Public 헤더를 사용 | . 2. PrivateDependencyModuleNames . PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" }); . | Private 리스트에 들어간 모듈은 내 모듈의 Private 코드에서만 사용 가능 . | 내 모듈의 Public 헤더에서는 해당 모듈의 헤더를 include할 수 없음 | . | 이 모듈을 의존하는 다른 모듈에서는 이 의존성이 전파되지 않음 | . 3. PublicIncludePaths / PrivateIncludePaths . // Public 또는 Private 폴더 외부에 헤더 파일이 위치한 경우 PublicIncludePaths.Add(Path.Combine(ModuleDirectory, \"ThirdParty/SomeLibrary/include\")); // 서브디렉토리를 포함해야 하는 경우 PrivateIncludePaths.Add(Path.Combine(ModuleDirectory, \"Private/SubModule\")); // 외부 라이브러리 사용 PublicIncludePaths.Add(\"C:/ExternalLibs/SomeLibrary/include\"); . | 헤더 파일의 추가 경로를 지정함 . | 비표준 디렉토리 구조를 사용하는 경우 | 서브디렉토리를 포함해야 하는 경우 | 외부 라이브러리를 사용하는 경우 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주요-의존성-설정"
  },"409": {
    "doc": "Module",
    "title": "의존성 정리",
    "content": "| 구분 | PublicDependencyModuleNames | PrivateDependencyModuleNames | . | 내 모듈의 Public 코드 | O (사용 가능) | X (사용 불가) | . | 내 모듈의 Private 코드 | O (사용 가능) | O (사용 가능) | . | 의존 모듈의 Public 코드 | O (전파됨) | X (전파 안 됨) | . PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"Engine\" }); PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\" }); . | Core, Engine . | 내 모듈의 Public/Private 코드 모두에서 사용 가능 | 내 모듈을 사용하는 다른 모듈의 Public 코드에서도 사용 가능(전파) | . | Slate . | 내 모듈의 Private 코드에서만 사용 가능 | 내 모듈의 Public 코드, 내 모듈을 사용하는 다른 모듈에서는 Slate 의존성이 전파되지 않음 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#의존성-정리"
  },"410": {
    "doc": "Module",
    "title": "주의사항",
    "content": ". | 프로젝트 파일 재생성: Build.cs 파일이나 소스 폴더를 이동/수정한 경우, 반드시 프로젝트 파일을 재생성해야 함 . | GenerateProjectFiles.bat 실행 | .uproject 파일 우클릭 후 “Generate Project Files” 선택 | Unreal Editor의 메뉴: File &gt; Refresh Visual Studio Project | . | UE 빌드 시스템은 모듈 간 순환 참조(의존성)를 허용하지 않음 | 반드시 실제로 사용하는 헤더만 명시적으로 추가함 . | 실제 사용하는 헤더만 #include하고 그 헤더의 위치가 Public/Private이라면 빌드 시스템이 알아서 처리 | . | . 참고 링크 . | Unreal Engine Modules | Module Properties | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Module.html#주의사항"
  },"411": {
    "doc": "Reference",
    "title": "주요 매크로 유형",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A3%BC%EC%9A%94-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%9C%A0%ED%98%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#주요-매크로-유형"
  },"412": {
    "doc": "Reference",
    "title": "1. UCLASS",
    "content": ". | 클래스를 언리얼 리플렉션 시스템에 등록 (직렬화, GC, 에디터/블루프린트/네트워크 노출 가능) UCLASS(Blueprintable) class MYGAME_API AMyActor : public AActor { GENERATED_BODY() }; . | UCLASS()는 클래스 선언부 바로 위에 위치 | Blueprintable 등 옵션으로 블루프린트 생성 가능 여부 등 제어 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#1-uclass"
  },"413": {
    "doc": "Reference",
    "title": "2. USTRUCT",
    "content": ". | 구조체를 리플렉션 시스템에 등록 USTRUCT(BlueprintType) struct FMyStruct { GENERATED_BODY() UPROPERTY(EditAnywhere) int32 Value; }; . | BlueprintType : 블루프린트에서도 사용 가능하게 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#2-ustruct"
  },"414": {
    "doc": "Reference",
    "title": "3. UENUM",
    "content": "열거형(enum)을 리플렉션/에디터/블루프린트에 노출 . UENUM(BlueprintType) enum class EMyType : uint8 { TypeA UMETA(DisplayName = \"Type A\"), TypeB UMETA(DisplayName = \"Type B\") }; . | BlueprintType : 블루프린트에서 사용 가능 | UMETA(DisplayName = …) : 에디터에 표시될 이름 지정 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#3-uenum"
  },"415": {
    "doc": "Reference",
    "title": "4. UPROPERTY",
    "content": ". | 클래스 멤버 변수를 언리얼 리플렉션 시스템에 등록하기 위해 사용 | 에디터에서의 노출, 직렬화, 복제 등 다양한 기능 제어 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"Stats\") int32 Health; }; . | UPROPERTY로 연결된 객체만이 가비지 컬렉션에서 참조로 간주되어 소멸 방지 | 옵션(AccessSpecifier, Category 등): 노출 범위, 에디터 분류 등 지정 | 에디터, 블루프린트에서 실시간으로 값 변경 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#4-uproperty"
  },"416": {
    "doc": "Reference",
    "title": "5. UFUNCTION",
    "content": ". | 맴버 함수를 블루프린트에서 호출 가능하게 하거나 리플렉션 시스템에 등록 | . UCLASS() class MYGAME_API AMyActor : public AActor { GENERATED_BODY() public: UFUNCTION(BlueprintCallable, Category=\"Actions\") void TakeDamage(int32 Amount); }; . | BlueprintCallable : 블루프린트에서 호출 가능 | Server, Client 등 RPC 옵션 부여 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#5-ufunction"
  },"417": {
    "doc": "Reference",
    "title": "6. GENERATED_BODY",
    "content": ". | UHT(Unreal Header Tool)가 생성한 코드를 포함시키기 위해 사용 | 클래스 선언 끝에 반드시 포함되어야 함 UCLASS() class MYGAME_API AMyCharacter : public ACharacter { GENERATED_BODY() // ... }; . | GENERATED_BODY() 매크로가 없으면 UHT가 오류를 발생시킴 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#6-generated_body"
  },"418": {
    "doc": "Reference",
    "title": "7. UINTERFACE",
    "content": ". | 인터페이스 선언 . | 두 개의 타입을 동시에 정의함 . | UINTERFACE로 선언되는 UObject 기반 클래스 (메타데이터/리플렉션 목적) | 실제 인터페이스 본체 (관례적으로 I 접두어) | . | . | . UObject 기반 클래스 . // 헤더 파일: MyInterface.h // 1. UINTERFACE로 UObject 파생 클래스 선언 UINTERFACE(BlueprintType) class UMyInterface : public UInterface { GENERATED_BODY() }; // 2. 실제 인터페이스 본체(I 접두사 사용) class IMyInterface { GENERATED_BODY() public: // 인터페이스 함수 선언 (구현은 해당 인터페이스를 상속받는 클래스에서!) UFUNCTION(BlueprintCallable, Category=\"MyInterface\") void MyFunction(); }; . 상속 및 구현 예시 . UCLASS() class AMyActor : public AActor, public IMyInterface { GENERATED_BODY() public: virtual void MyFunction() override; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-uinterface"
  },"419": {
    "doc": "Reference",
    "title": "7. DECLARE_* 및 IMPLEMENT_* 매크로",
    "content": ". | 다양한 기능을 선언하고 구현하기 위한 매크로 쌍 . | DECLARE_*: 헤더 파일(.h)에 위치, 선언만 노출 (클래스/함수/변수의 존재를 시스템에 알림) | IMPLEMENT_*: 소스 파일(.cpp)에 위치, 실제 구현을 생성 (선언된 요소의 구체적인 동작 정의) | . | 모듈/플러그인 등록 (DECLARE_MODULE + IMPLEMENT_MODULE) | 로그 카테고리 생성 (DECLARE_LOG_CATEGORY_EXTERN + DEFINE_LOG_CATEGORY) | 인터페이스 구현 (DECLARE_INTERFACE + IMPLEMENT_INTERFACE) | . 기본 예시 . // MyModule.h class FMyModule : public IModuleInterface { public: DECLARE_MODULE(FMyModule) // 1. 모듈 선언 }; // MyModule.cpp IMPLEMENT_MODULE(FMyModule, MyModule) // 2. 모듈 구현 . | IMPLEMENT_MODULE이 자동으로 StartupModule(), ShutdownModule() 함수를 생성하고 모듈을 엔진에 등록 | . 내부 동작 . // 순수 C++ 방식 class MyClass {}; // 직접 구현 // 언리얼 방식 DECLARE_CLASS(MyClass) // UHT가 자동으로 다음 코드 생성: /* class MyClass { static StaticClass(); virtual UClass* GetClass() const; ... }; */ IMPLEMENT_CLASS(MyClass) // UHT가 자동으로 StaticClass() 구현체 생성 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-%EB%B0%8F-implement_-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#7-declare_-및-implement_-매크로"
  },"420": {
    "doc": "Reference",
    "title": "정리",
    "content": "| 매크로 | 적용 대상 | 리플렉션 | 직렬화 | GC | 네트워크 | 블루프린트 | 비고 | . | UCLASS() | 클래스 | O | O | O | O | O |   | . | USTRUCT() | 구조체 | O | O | X | X | O |   | . | UENUM() | enum | O | O | X | X | O |   | . | UPROPERTY() | 멤버 변수 | O | O | O | 옵션에 따라 | O | 옵션(Replicated 등) | . | UFUNCTION() | 멤버 함수 | O | X | X | 옵션에 따라 | O | 옵션(BlueprintCallable 등) | . | UINTERFACE() | 인터페이스 클래스 | O | X | X | X | O |   | . | GENERATED_BODY() | 클래스/구조체/인터페이스 | - | - | - | - | - | UHT 생성 코드 삽입 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#정리"
  },"421": {
    "doc": "Reference",
    "title": "매크로 사용 시 주의사항",
    "content": ". | 리플렉션 매크로는 템플릿 클래스와 호환되지 않음 | 가상 함수에 UFUNCTION 사용 시 반드시 override 키워드 추가 | Replicated 변수는 반드시 기본값 초기화 필요 UPROPERTY(Replicated) int32 Health = 100; // 초기화 필수 . | 에디터 전용 코드 . | WITH_EDITOR 매크로로 감싸지 않으면 런타임 크래시 가능성 #if WITH_EDITOR void EditorOnlyFunction() { ... } #endif . | . | 메모리 관리 : TObjectPtr 도입 (UE5.1+) . | UObject 파생 클래스는 절대 일반 C++ 포인터로 저장하지 말 것 | . | . // 잘못된 예 UPROPERTY() AActor* RawPtr; // 가비지 컬렉션 대상에서 누락될 수 있음 // 올바른 예 UPROPERTY() TObjectPtr&lt;AActor&gt; SafePtr; // UE5 권장 방식 . 참고 링크 . | UStruct | UFuncion | UInterface | 메타데이터 지정자 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html#매크로-사용-시-주의사항"
  },"422": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/Reference.html"
  },"423": {
    "doc": "Search And Delete Empty Folders",
    "title": "목표: 빈 폴더 찾아내서 삭제하기",
    "content": "강의에서는 UEditorAssetLibrary::ListAssets() 메서드를 통해 빈 폴더를 찾았지만, 내 버전 (UE 5.5)에서는 제대로 동작하지 않았다 . 그래서 AssetRegistry Module을 통해 해결했다 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#%EB%AA%A9%ED%91%9C-%EB%B9%88-%ED%8F%B4%EB%8D%94-%EC%B0%BE%EC%95%84%EB%82%B4%EC%84%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#목표-빈-폴더-찾아내서-삭제하기"
  },"424": {
    "doc": "Search And Delete Empty Folders",
    "title": "OnDeleteEmptyFoldersButtonClicked() 함수 구현에 사용한 메서드",
    "content": "AssetRegistryModule.Get().GetSubPaths() . 특정 경로(폴더) 기준으로, 하위에 존재하는 모든 서브 폴더의 목록을 조회하는 기능 . void IAssetRegistry::GetSubPaths( const FString&amp; InBasePath, TArray&lt;FString&gt;&amp; OutPathList, bool bInRecurse ) const; . | 매개변수 . | const FString&amp; InBasePath : 서브 폴더를 검색할 기준이 되는 상위 폴더 경로 . | 예시: “/Game/MyFolder” | 반드시 패키지 경로 형식이어야 하며, 슬래시(/)로 시작함 | . | TArray&amp; OutPathList : 검색 결과로 반환될 서브 폴더 경로 문자열의 배열 . | 함수 호출 시 빈 배열을 넘기면 됨 | 함수가 반환되면, InBasePath의 하위에 존재하는 직속/모든(옵션) 폴더 경로가 여기 저장됨 | 패키지 경로 형식으로 배열에 담김김 | . | bool bInRecurse . | true : InBasePath의 모든 하위 폴더(재귀적으로 모든 Depth)를 탐색 | false : InBasePath 바로 직속 1 Depth의 폴더만 반환 (재귀 X) | . | . | 반환값 . | 반환값은 없으며, 결과는 OutPathList에 담김 | . | . UEditorAssetLibrary::DoesDirectoryExist() . 언리얼 에디터가 인식하는 특정 패키지 경로(폴더)가 실제로 존재하는지 확인하는 기능 . 이 함수는 “UE 에디터에서 인식”하는 패키지 경로 기준으로 폴더의 존재 유무만 판단한다 . 파일 시스템상의 디렉터리 유무와는 다를 수 있음 (에디터 DB에 등록된 경로만 인식) . static bool UEditorAssetLibrary::DoesDirectoryExist( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 존재 여부를 확인할 대상 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 에디터와 AssetRegistry에서 인식하는 경로임 | . | . | 반환값 . | true : 해당 경로의 폴더가 에디터 내에 실제로 존재함 . | 폴더가 비어있더라도, 존재하면 true를 반환 | . | false : 해당 경로의 폴더가 존재하지 않음 . | 완전히 삭제된 경우(에셋/폴더 모두 삭제 후 GC 반영 등), false를 반환 | . | . | . UEditorAssetLibrary::DoesDirectoryHaveAssets() . 지정한 패키지 경로(폴더)에 최소 1개 이상의 에셋(Asset)이 존재하는지를 확인하는 기능 . static bool UEditorAssetLibrary::DoesDirectoryHaveAssets( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 에셋 존재 유무를 확인할 폴더의 경로 . | 실제 파일 시스템 경로가 아니라, 언리얼 에디터가 인식하는 경로임 | . | . | 반환값 . | true : 해당 폴더 내에 최소 1개 이상의 에셋이 존재 | false : 폴더가 비어있거나(에셋 0개), 폴더 자체가 존재하지 않을 경우 | . | . FString::Append() . 문자열(또는 TCHAR 포인터, FString, FText 등) 값을 뒤에 이어붙이는 함수. 문자열 결합용 . FString S = TEXT(\"Hello\"); S.Append(TEXT(\" World\")); // S = \"Hello World\" . TArray::Append() . 다른 배열이나 범위의 모든 요소를 현재 배열 뒤에 “한꺼번에” 추가 . TArray&lt;Type&gt; Array; Array.Append(OtherArray); // OtherArray의 모든 원소를 뒤에 추가 Array.Append({ \"a\", \"b\", \"c\" }); // initializer list로 여러 개 추가 TArray&lt;FString&gt; Names = { \"Apple\" }; TArray&lt;FString&gt; NewFruits = { \"Banana\", \"Cherry\" }; Names.Append(NewFruits); // 배열: [\"Apple\", \"Banana\", \"Cherry\"] . | 결론 . | Add(): 배열에 “한 개”의 값을 추가 | Append(): 배열에 “여러 개(0개~N개)”의 값을 한 번에 추가 | . | . UEditorAssetLibrary::DeleteDirectory() . 지정한 패키지 경로(폴더) 및 그 하위의 모든 에셋과 폴더를 완전히 삭제하는 기능 . 삭제된 폴더/에셋은 휴지통(Trash) 등으로 이동되지 않고, 실제로 프로젝트에서 사라짐 . static bool UEditorAssetLibrary::DeleteDirectory( const FString&amp; DirectoryPath ); . | 매개변수 . | const FString&amp; DirectoryPath : 삭제할 대상 폴더의 패키지 경로 | . | 반환값 . | true : 폴더 및 하위 모든 에셋/폴더의 삭제에 성공 | false : 삭제 실패(예: 에디터가 폴더/에셋을 참조 중이거나, 파일 권한 문제 등) . | 일부 에셋/폴더만 삭제된 경우에도, 하나라도 실패 시 false | . | . | . 동작 설명 . DirectoryPath에 해당하는 폴더 및 모든 하위 폴더/에셋을 재귀적으로 완전 삭제 . | 해당 폴더 내 모든 에셋 및 폴더를 찾음 | 하위 폴더, 에셋 순으로 모두 삭제 | 삭제가 정상적으로 끝나면 true 반환 | 만약 삭제 불가(읽기 전용, 다른 곳에서 사용 중 등)한 경우 false | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html#ondeleteemptyfoldersbuttonclicked-함수-구현에-사용한-메서드"
  },"425": {
    "doc": "Search And Delete Empty Folders",
    "title": "Search And Delete Empty Folders",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Empty%20Folders.html"
  },"426": {
    "doc": "Search And Delete Unused Assets",
    "title": "목표 : 바인딩 된 함수 동작 구현하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EB%AA%A9%ED%91%9C--%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%90%9C-%ED%95%A8%EC%88%98-%EB%8F%99%EC%9E%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#목표--바인딩-된-함수-동작-구현하기"
  },"427": {
    "doc": "Search And Delete Unused Assets",
    "title": "글로벌 함수의 링크 에러 및 static/네임스페이스 처리",
    "content": "G 접두사가 붙은 변수나 함수에 static을 추가하기 . | 링크 에러 : 여러 cpp 파일에서 동일한 헤더를 include하고, 그 헤더에 글로벌 함수가 정의되어 있다면 컴파일 시 “중복 정의된 심볼” 에러 발생 | 전역 객체 : 전역 객체에 직접 접근하는 함수를 static으로 만들면 해당 함수를 사용하는 모듈이 전역 객체가 정의된 모듈에 대한 불필요한 종속성을 만들지 않음 | . -&gt; 디버그 헤더에 namespace 추가 (클래스가 아니라 namespace::로 사용하기 위해) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#%EA%B8%80%EB%A1%9C%EB%B2%8C-%ED%95%A8%EC%88%98%EC%9D%98-%EB%A7%81%ED%81%AC-%EC%97%90%EB%9F%AC-%EB%B0%8F-static%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#글로벌-함수의-링크-에러-및-static네임스페이스-처리"
  },"428": {
    "doc": "Search And Delete Unused Assets",
    "title": "OnDeleteUnsuedAssetButtonClicked() 함수 구현에 사용한 메서드",
    "content": "1. UEditorAssetLibrary::ListAssets() . 특정 폴더 경로 내의 모든 에셋(assets) 목록을 가져오는 기능 . static TArray&lt;FString&gt; UEditorAssetLibrary::ListAssets( const FString&amp; Path, bool bRecursive = true, bool bIncludeFolder = false ); . | 매개변수 . | Path : 에셋을 검색할 디렉터리 경로 | bRecursive : 하위 폴더까지 탐색 여부 (기본값 true) | bIncludeFolder : 폴더 자체도 결과 배열에 포함할지 여부 (기본값 false) | . | 반환값 . | TArray : 폴더 내 모든 에셋/폴더의 \"Object Path\" 문자열 배열 . | 예 : /Game/Test/Sub/SM_Sphere.SM_Sphere | . | . | . 2. Contains() . 문자열 또는 컨테이너 내 특정 요소의 존재 여부를 검사 . bool FString::Contains( const TCHAR* SubStr, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase ) const; . | 매개변수 . | const TCHAR* : 검색할 부분 문자열 (예: “Test”) | ESearchCase::Type : 대소문자 구분 여부 . | ESearchCase::IgnoreCase : 구분 안함 | ESearchCase::CaseSensitive : 구분함 | . | . | 반환값 . | 포함되면 true / 아니면 false | . | . 컨테이너 별 용도 . | 문자열 검색 → FString::Contains() | 빠른 요소 확인 → TSet::Contains() | 키 존재 여부 → TMap::Contains() | . 3. UEditorAssetLibrary::DoesAssetExist() . 에셋 경로(.uasset)가 실제로 존재하고 로드 가능한지 여부를 확인 . static bool UEditorAssetLibrary::DoesAssetExist( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검사할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환 값 . | 에셋이 존재하면 true, 아니면 false | . | . 4. UEditorAssetLibrary::FindAssetData() . 주어진 에셋 경로(.uasset)로부터 에셋의 메타데이터(FAssetData) 를 조회 . static FAssetData UEditorAssetLibrary::FindAssetData( const FString&amp; AssetPath ); . | 매개변수 . | const FString&amp; : 검색할 에셋의 전체 경로 (예: “/Game/Characters/Hero.uasset”) | . | 반환값 . | FAssetData : 에셋 정보를 담은 객체 (없으면 빈 객체) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html#ondeleteunsuedassetbuttonclicked-함수-구현에-사용한-메서드"
  },"429": {
    "doc": "Search And Delete Unused Assets",
    "title": "Search And Delete Unused Assets",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/Search%20And%20Delete%20Unused%20Assets.html"
  },"430": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "목표: SCompoundWidget 상속받아 커스텀 위젯 클래스 만든 후 바인딩하기",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EB%AA%A9%ED%91%9C-scompoundwidget-%EC%83%81%EC%86%8D%EB%B0%9B%EC%95%84-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%A0-%ED%9B%84-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#목표-scompoundwidget-상속받아-커스텀-위젯-클래스-만든-후-바인딩하기"
  },"431": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "커스텀 위젯 등록과 바인딩",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%EB%93%B1%EB%A1%9D%EA%B3%BC-%EB%B0%94%EC%9D%B8%EB%94%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#커스텀-위젯-등록과-바인딩"
  },"432": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule에서 이벤트 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%97%90%EC%84%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule에서-이벤트-등록"
  },"433": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "StartupModule의 역할",
    "content": "어떤 일이 생길 때, 무슨 코드를 실행할지를 엔진의 전역 관리자에게 등록 . 등록: 함수 포인터/Delegate, 생성자 콜백, 이름(ID) 등만 엔진 전역 자료구조에 저장 메모리상에는 해당 모듈이 필요해지면 이 콜백을 실행해서 만든다는 정보만 들어있음 . | 전역 테이블(맵, 배열, 리스트 등)에 ‘예약’만 해놓음 | . void FBacgroundToolsModule::StartupModule() { InitCBMenuExtention(); RegisterAdvanceDeletionTab(); } . | StartupModule()에서 RegisterAdvanceDeletionTab()을 호출 . | 탭(Advanced Deletion 패널)을 에디터에 “등록”하는 과정이 실행 | . | . void FBacgroundToolsModule::RegisterAdvanceDeletionTab() { FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;FBacgroundToolsModule::OnSpawnAdvanceDeletionTab)) .SetDisplayName(FText::FromString(TEXT(\"Advance Deletion\"))); } . FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner . | FGlobalTabmanager(언리얼 에디터의 전역 탭 관리자)에 “AdvanceDeletion” 이라는 ID로 탭 생성자를 등록 실제로 이 탭을 띄우기 전까지는 “정의만 되어있는 상태”이다 . 즉, “Advanced Deletion”이라는 이름의 탭을 만들 준비만 마친 것 . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#startupmodule의-역할"
  },"434": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "탭을 실제로 여는 시점 (이벤트 발생)",
    "content": ". | OnAdvancedDeletionButtonClicked 함수 . | TryInvokeTab(\"AdvanceDeletion\")을 통해 등록된 스포너(생성 콜백)를 호출 | . | OnSpawnAdvanceDeletionTab() 함수를 통해 실제 인스턴스 생성 . | 이 순간부터 Advance Deletion 탭이 실제로 화면에 나타남 TSharedRef&lt;SDockTab&gt; FBacgroundToolsModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs) { return SNew(SDockTab).TabRole(ETabRole::NomadTab) [ SNew(SAdvanceDeletionTab) .TestString(TEXT(\"I am passing data\")) ]; } . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%ED%83%AD%EC%9D%84-%EC%8B%A4%EC%A0%9C%EB%A1%9C-%EC%97%AC%EB%8A%94-%EC%8B%9C%EC%A0%90-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%9C%EC%83%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#탭을-실제로-여는-시점-이벤트-발생"
  },"435": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "정리",
    "content": ". | StartupModule()의 RegisterAdvanceDeletionTab()는 해당 이벤트 발생 전 준비만 바인딩 . | 이름만 등록, 실제 위젯 인스턴스 없음 | . | OnAdvancedDeletionButtonClicked()는 실제 사용자가 해당 이벤트를 발생시켰을 때 동작 바인딩 . | 실제 인스턴스 생성, SDockTab의 ChildSlot에 내가 생성한 위젯이 들어감 | . | . StartupModule() (에디터/플러그인 모듈 초기화) └→ RegisterAdvanceDeletionTab() └→ FGlobalTabmanager::RegisterNomadTabSpawner(\"AdvanceDeletion\", OnSpawnTab...) └→ \"AdvanceDeletion\" 탭 생성 콜백(준비만 해둠) └→ (사용자 요청이 있을 때까지 기다림) (사용자: 우클릭→Advanced deletion 메뉴 클릭) └→ OnAdvancedDeletionButtonClicked() → TryInvokeTab(\"AdvanceDeletion\") └→ FGlobalTabmanager에서 해당 탭 콜백 호출 └→ OnSpawnAdvanceDeletionTab() 실행 └→ SDockTab 생성, ChildSlot에 SAdvanceDeletionTab(Slate 위젯) 추가 └→ 트리 구조로 에디터 Slate 트리에 편입, 렌더링 시작 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#정리"
  },"436": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FGlobalTabmanager",
    "content": "언리얼 에디터 Slate 시스템의 탭(도킹 패널) 전체를 총괄하는 전역 관리자 . | 전역 객체 구조 . | FGlobalTabmanager::Get() : 항상 같은 전역 인스턴스 가져옴 | 실제로는 FSlateApplication 내부에 저장된 전역 포인터이다 | . | 역할 . | 탭의 등록/생성/소멸/상태관리 | 탭의 열림/닫힘/포커스/배치 등 관리 | ID(이름) ↔ 탭 생성자(Delegate) 맵 관리 | Slate 트리(SDockTab, SDockingArea, SWindow 등)와 연동 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#fglobaltabmanager"
  },"437": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "주요 메서드",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#%EC%A3%BC%EC%9A%94-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#주요-메서드"
  },"438": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "RegisterNomadTabSpawner",
    "content": "RegisterNomadTabSpawner( FName TabId, FOnSpawnTab OnSpawnTabDelegate ) . | TabId : 이름의 도킹/플러그인 패널을 등록 | OnSpawnTabDelegate : 생성자 델리게이트 등록 | . 사용 예시 . // 탭 등록 FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner( FName(\"AdvanceDeletion\"), FOnSpawnTab::CreateRaw(this, &amp;MyModule::OnSpawnAdvanceDeletionTab) ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#registernomadtabspawner"
  },"439": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "TryInvokeTab",
    "content": "TSharedPtr&lt;SDockTab&gt; TryInvokeTab(FName TabId); . | “TabId”의 탭이 열려있으면 포커스 | 없으면 등록된 Delegate로 탭 새로 생성/열기 | . 사용 예시 . // 탭 열기 (생성) FGlobalTabmanager::Get()-&gt;TryInvokeTab(FName(\"AdvanceDeletion\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#tryinvoketab"
  },"440": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "UnregisterNomadTabSpawner",
    "content": "void UnregisterNomadTabSpawner(FName TabId); . | 등록해둔 탭 생성자(Delegate)와 ID 연결을 해제 . | 모듈이 종료될 때, ShutdownModule에서 주로 사용 | . | . 사용 예시 . // 탭 해제 FGlobalTabmanager::Get()-&gt;UnregisterNomadTabSpawner(FName(\"MyCustomTab\")); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#unregisternomadtabspawner"
  },"441": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "FindExistingLiveTab",
    "content": "TSharedPtr&lt;SDockTab&gt; FindExistingLiveTab(FName TabId); . | 이미 열려 있는 특정 TabId의 SDockTab Slate 객체를 반환 . | 없으면 nullptr | . | . 사용 예시 . // 이미 열린 탭 객체 얻기 TSharedPtr&lt;SDockTab&gt; LiveTab = FGlobalTabmanager::Get()-&gt;FindExistingLiveTab(FName(\"MyCustomTab\")); if (LiveTab.IsValid()) { // Tab이 이미 열려 있음 → 추가 동작 가능 } . ❓부모 모듈에서 에셋 데이터를 넘겨줘야 하는 이유? . | AdvanceDeletionTab은 “선택된 폴더 내의 에셋 데이터”를 리스트로 보여줘야 하므로, 그 데이터를 생성 시점에 한 번에 전달받아야 함 | 따라서 자식 위젯 클래스에서 설정한 SLATE_ARGUMENT에 부모가 에셋 리스트를 넘겨줘야 위젯의 생성자 초기화가 올바르게 세팅됨 | 부모에서 자식 탭을 생성할 때 반드시 값을 전달해야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html#findexistinglivetab"
  },"442": {
    "doc": "Set Up A Class For Slate Widget",
    "title": "Set Up A Class For Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20A%20Class%20For%20Slate%20Widget.html"
  },"443": {
    "doc": "Set Up Basic Layout",
    "title": "목표: 슬레이트 탭 레이아웃 작성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%AA%A9%ED%91%9C-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%ED%83%AD-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%9E%91%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#목표-슬레이트-탭-레이아웃-작성"
  },"444": {
    "doc": "Set Up Basic Layout",
    "title": "레이아웃 샘플 예시 보기",
    "content": ". | 에디터 플러그인 폴더 -&gt; 모듈 콘텐츠 폴더로 이동 | 우클릭 -&gt; 에디터 유틸리티 -&gt; 에디터 유틸리티 위젯 클릭 | 생성된 에디터 유틸리티 위젯 더블클릭 | 검색을 통해 슬롯에 추가 등 샘플 미리 볼 수 있음 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%83%98%ED%94%8C-%EC%98%88%EC%8B%9C-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#레이아웃-샘플-예시-보기"
  },"445": {
    "doc": "Set Up Basic Layout",
    "title": "위젯 여러개 배치",
    "content": "SVerticalBox(세로 박스) 또는 SHorizontalBox(가로 박스)와 같은 패널 위젯을 사용 . | 해당 박스들은 여러개의 슬롯을 가질 수 있음 (보통 위젯은 하나의 슬롯만 가짐) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%9C%84%EC%A0%AF-%EC%97%AC%EB%9F%AC%EA%B0%9C-%EB%B0%B0%EC%B9%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#위젯-여러개-배치"
  },"446": {
    "doc": "Set Up Basic Layout",
    "title": "SNew",
    "content": "위젯을 생성하기 위한 핵심 매크로로, 타입 안전성과 메모리 관리를 자동화하는 데 사용 . | 생명주기를 동적으로 제어해야 할 때 SNew를 TSharedPtr 변수에 담아둔다 . | 메모리 관리와 수명 제어가 유연하게 필요하면 TSharedPtr | 절대 null이 될 수 없고, 항상 살아있어야 하면 TSharedRef | . | . // SNew()로 생성된 TSharedRef를 바로 반환하면: return SNew(SListView&lt;...&gt;); // 임시 객체가 즉시 파괴될 위험 // TSharedPtr에 보관하면 참조 카운트 유지 TSharedPtr &lt; SListView &lt; TSharedPtr &lt;FAssetData&gt; &gt; &gt; ConstructedAssetListView = SNew(SListView&lt;...&gt;); // 참조 +1 return ConstructedAssetListView.ToSharedRef(); // 참조 +1 (총 2) . | 방식 | 장점 | 단점 |   | . | TSharedRef | 직접 반환 | 간결함 | 이후 접근 불가능 | . | TSharedPtr | 저장 후 변환 | 생명주기 관리 용이 | 코드가 약간 길어짐 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#snew",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#snew"
  },"447": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 메모리 관리 자동화 . | 반환된 TSharedRef가 범위를 벗어나면 자동으로 메모리 해제 | 명시적인 delete 호출 불필요 | . | 빌더 패턴 지원 (.속성으로 속성 설정, [] 자식 위젯 추가) | 타입 안정성 . | 컴파일 타임에 위젯 타입 검증 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징"
  },"448": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": ". | 생성 방식: SNew(WidgetClass) 형태로 사용하며, 항상 TSharedRef&lt;WidgetClass&gt;를 반환 | . TSharedRef&lt;SCheckBox&gt; MyCheckBox = SNew(SCheckBox) .IsChecked(true) .OnCheckStateChanged(this, &amp;MyClass::Handler); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법"
  },"449": {
    "doc": "Set Up Basic Layout",
    "title": "SVerticalBox",
    "content": "자식 위젯들을 수직 방향(위에서 아래로)으로 배치하는 레이아웃 컨테이너 . | 각 자식 위젯은 새로운 행에 배치됨 | SVerticalBox에 슬롯을 추가 . | .AddSlot() | + SVerticalBox::Slot() | . | . // 메인 세로 박스 SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ // 첫 번째 슬롯: 타이틀 텍스트 SNew(STextBlock) .Text(FText::FromString(TEXT(\"Advanced Deletion\"))) // 아래에 속성 추가 ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#sverticalbox"
  },"450": {
    "doc": "Set Up Basic Layout",
    "title": "SHorizontalBox",
    "content": "자식 위젯들을 수평 방향으로 배치하는 레이아웃 컨테이너 (왼쪽-&gt; 오른쪽) . | 각 자식은 새로운 열에 배치됨 | +SHorizontalBox::Slot() | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#shorizontalbox"
  },"451": {
    "doc": "Set Up Basic Layout",
    "title": "속성 지정자",
    "content": "각각의 컨테이너는 각자의 Slot 구조체를 가지고 있고, 이 Slot의 속성을 통해 레이아웃을 제어할 수 있다 . | SVerticalBox::Slot() | SHorizontalBox::Slot() | SGridPanel::Slot() 등등 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#속성-지정자"
  },"452": {
    "doc": "Set Up Basic Layout",
    "title": "주요 Slot 속성 지정자",
    "content": "| 속성 지정자 | 설명 | 적용 가능한 컨테이너 | . | AutoWidth() | 자식 위젯의 자연스러운 너비로 자동 조정 | SHorizontalBox | . | AutoHeight() | 자식 위젯의 자연스러운 높이로 자동 조정 | SVerticalBox | . | FillWidth(float) | 사용 가능한 수평 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SHorizontalBox | . | FillHeight(float) | 사용 가능한 수직 공간을 지정된 비율로 채움 (1.0 = 전체 공간) | SVerticalBox | . | Padding(FMargin) | 슬롯 내부의 여백 설정 (Left, Top, Right, Bottom) | 모두 | . | HAlign(HAlign) | 수평 정렬 방식 (Left, Center, Right, Fill) | 모두 | . | VAlign(VAlign) | 수직 정렬 방식 (Top, Center, Bottom, Fill) | 모두 | . | MaxWidth(float) | 최대 너비 제한 | SHorizontalBox | . | MaxHeight(float) | 최대 높이 제한 | SVerticalBox | . | Expose(ExposedSlot&amp;) | 슬롯을 외부에서 접근할 수 있도록 노출 | 모두 | . | AutoHeight/AutoWidth: 해당 자식 위젯의 DesiredSize에 맞춰 영역을 할 | FillHeight/FillWidth: 남은 공간을 지정된 가중치대로 자식들에게 분배 . | 예: FillHeight(1.0f), FillHeight(2.0f)로 지정하면 1:2 비율로 높이를 나눔 | . | HAlign/VAlign : 현재 위젯/슬롯의 자식에 대한 정렬 제어 . | 부모 레이아웃(SVerticalBox, SScrollBox 등)의 슬롯에서 설정 → 자식 위젯의 공간 배분을 결정 | 자식 위젯(예: STextBlock)에서 직접 설정 → 자신의 할당된 공간 내 정렬을 결정 | . | Padding: 각 자식 위젯의 Slot에 여백 부여 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%A3%BC%EC%9A%94-slot-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#주요-slot-속성-지정자"
  },"453": {
    "doc": "Set Up Basic Layout",
    "title": "STextBlock",
    "content": "순수한 텍스트 렌더링에 특화된 텍스트 표시를 위한 기본 위젯 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock"
  },"454": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 고성능 렌더링: DirectX/OpenGL 기반 하드웨어 가속 텍스트 렌더링 | 다국어 지원: FText와 통합된 LOC 시스템(로컬라이제이션) | 스타일 커스터마이징: 폰트, 색상, 정렬 등 완전한 제어 가능 | 동적 업데이트: 텍스트 내용 실시간 변경 가능 | 레이아웃 통합: 다른 슬레이트 위젯과 자유롭게 조합 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징-1"
  },"455": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": "TSharedRef&lt;STextBlock&gt; MyTextBlock = SNew(STextBlock) .Text(LOCTEXT(\"Greeting\", \"안녕하세요!\")) .Font(FSlateFontInfo(\"Roboto\", 16)) .ColorAndOpacity(FLinearColor::White); // 동적 바인딩 FText GetDynamicText() const; // 구현 SNew(STextBlock) .Text(this, &amp;MyClass::GetDynamicText) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법-1"
  },"456": {
    "doc": "Set Up Basic Layout",
    "title": "주요 속성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%A3%BC%EC%9A%94-%EC%86%8D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#주요-속성"
  },"457": {
    "doc": "Set Up Basic Layout",
    "title": ".Text",
    "content": "표시할 텍스트. FText 사용 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#text",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#text"
  },"458": {
    "doc": "Set Up Basic Layout",
    "title": ".Font",
    "content": "폰트 정보. 스타일, 크기, 폰트 패밀리 등 지정 . | 아래의 FSlateFontInfo 참고 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#font",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#font"
  },"459": {
    "doc": "Set Up Basic Layout",
    "title": ".ColorAndOpacity",
    "content": "텍스트 색상 및 투명도(FSlateColor) .ColorAndOpacity(FSlateColor(FLinearColor::Red)) // FLinearColor 바로 전달 .ColorAndOpacity(FLinearColor::Green) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#colorandopacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#colorandopacity"
  },"460": {
    "doc": "Set Up Basic Layout",
    "title": ".Justification",
    "content": "정렬 방식 (ETextJustify::Type) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#justification",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#justification"
  },"461": {
    "doc": "Set Up Basic Layout",
    "title": ".AutoWrapText",
    "content": "자동 줄바꿈 여부 .AutoWrapText(true) // 영역에 맞춰 자동 줄바꿈 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#autowraptext",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#autowraptext"
  },"462": {
    "doc": "Set Up Basic Layout",
    "title": ".MinDesiredWidth",
    "content": "최소 너비(줄바꿈용) .MinDesiredWidth(200.0f) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#mindesiredwidth",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#mindesiredwidth"
  },"463": {
    "doc": "Set Up Basic Layout",
    "title": ".WrappingPolicy",
    "content": "줄바꿈 정책 (UE5에서 도입, 텍스트 나누는 방식 선택) .WrappingPolicy(ETextWrappingPolicy::DefaultWrapping) . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#wrappingpolicy",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#wrappingpolicy"
  },"464": {
    "doc": "Set Up Basic Layout",
    "title": "STextBlock 속성 지정 정리",
    "content": "// 텍스트 블록에 적용 SNew(STextBlock) .Font(FontInfo) // FSlateFontInfo 구조체 사용 .Text(FText::FromString(\"Hello Unreal\")) .ColorAndOpacity(FLinearColor::White) .Justification(ETextJustify::Center); . | 지정자 | 설명 | 예시 코드 | . | .Text(FText) | 표시할 텍스트 지정 | .Text(FText::FromString(TEXT(“Hello”))) | . | .Font(const FSlateFontInfo&amp;) | 폰트 패밀리/크기/스타일 지정 | .Font(FSlateFontInfo(“Roboto-Bold”, 24)) | . | .ColorAndOpacity(FSlateColor) | 텍스트 색상 및 불투명도(알파) 지정 | .ColorAndOpacity(FLinearColor::Red) | . | .ShadowOffset(FVector2D) | 텍스트 그림자 오프셋(거리) | .ShadowOffset(FVector2D(1, 1)) | . | .ShadowColorAndOpacity(FLinearColor) | 텍스트 그림자 색상 및 알파 | .ShadowColorAndOpacity(FLinearColor::Black) | . | .Justification(ETextJustify::Type) | 텍스트 정렬(좌/중앙/우) | .Justification(ETextJustify::Center) | . | .WrapTextAt(float) | 지정한 너비에서 텍스트 줄바꿈 | .WrapTextAt(200.0f) | . | .MinDesiredWidth(float) | 최소 표시 너비 | .MinDesiredWidth(50.0f) | . | .LineHeightPercentage(float) | 줄 간격 비율(1.0=기본) | .LineHeightPercentage(1.2f) | . | .AutoWrapText(bool) | 컨테이너 너비에 맞춰 자동 줄바꿈 | .AutoWrapText(true) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock-%EC%86%8D%EC%84%B1-%EC%A7%80%EC%A0%95-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#stextblock-속성-지정-정리"
  },"465": {
    "doc": "Set Up Basic Layout",
    "title": "FSlateFontInfo",
    "content": "Slate 위젯에 텍스트 스타일 지정에 사용되는 구조체. 폰트 스타일, 크기 정보 . | STextBlock의 폰트 속성 지정자에 사용 | . struct FSlateFontInfo { UObject* FontObject; // 사용할 폰트 객체 (UFont 또는 FSlateFontInfo::GetFont) FName TypefaceFontName; // 폰트 페이스 이름(예: \"Bold\", \"Regular\") int32 Size; // 폰트 크기 FName FontMaterial; // 폰트 머티리얼 TEnumAsByte&lt;EFontHinting&gt; Hinting; // 폰트 힌팅 방식 bool bEnableOutline; // 아웃라인 사용 여부 float OutlineSize; // 아웃라인 크기 FLinearColor OutlineColor; // 아웃라인 색상 }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatefontinfo"
  },"466": {
    "doc": "Set Up Basic Layout",
    "title": "생성 방법",
    "content": "// 에디터에서 제공하는 폰트 사용 FSlateFontInfo FontInfo = FCoreStyle::Get().GetFontStyle(\"Bold\", 18); // 직접 지정 FSlateFontInfo FontInfo(\"Roboto-Regular\", 24); // 폰트 패밀리, 크기 // 경로로 지정 FSlateFontInfo FontInfo( FPaths::EngineContentDir() / TEXT(\"Slate/Fonts/Roboto-Regular.ttf\"), 20 ); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-방법-2"
  },"467": {
    "doc": "Set Up Basic Layout",
    "title": "FSlateColor",
    "content": "UI 요소의 색상 및 투명도(opacity)를 표현하고, 동적으로 바인딩하거나 테마 기반으로 자동 갱신할 수 있게 설계된 컬러 래퍼 구조체 . | .ColorAndOpacity 등 여러 스타일 속성에서 사용되는 색상 타입 | 내부적으로 FLinearColor 값을 갖음 | 직접 색상 지정 또는 Slate 색상 테마 (브러시/스타일) 참조 둘 다 지원 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatecolor",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#fslatecolor"
  },"468": {
    "doc": "Set Up Basic Layout",
    "title": "특징",
    "content": ". | 정적 색상: 고정된 FLinearColor 값 | 동적 바인딩: Slate Attribute 시스템을 통한 동적 색상 변경 | Slate 브러시/스타일 연동: 테마/스타일에서 정의된 색상 참조 가능 | 투명도(Opacity) 포함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%ED%8A%B9%EC%A7%95-2",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#특징-2"
  },"469": {
    "doc": "Set Up Basic Layout",
    "title": "생성 예시",
    "content": "// 정적 색상 지정 .ColorAndOpacity(FSlateColor(FLinearColor::Red)) .ColorAndOpacity(FSlateColor(FLinearColor(1, 0.5, 0, 1))) // 오렌지색, RGBA // FLinearColor 타입을 FSlateColor 생성자에 바로 전달해도 자동 변환 .ColorAndOpacity(FLinearColor::Green) // 동적 속성 바인딩 (예: 상태에 따른 색상 변경) .ColorAndOpacity(this, &amp;SMyWidget::GetTextColor) FSlateColor SMyWidget::GetTextColor() const { return bIsError ? FLinearColor::Red : FLinearColor::White; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%83%9D%EC%84%B1-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#생성-예시"
  },"470": {
    "doc": "Set Up Basic Layout",
    "title": "스타일 기반 참조",
    "content": ". | 스타일 시스템이 지정한 색상 사용 | 테마가 바뀌면 자동으로 색상이 바뀌도록 할 때 필수적 .ColorAndOpacity(FSlateColor::UseForeground()) .ColorAndOpacity(FSlateColor::UseSubduedForeground()) . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#%EC%8A%A4%ED%83%80%EC%9D%BC-%EA%B8%B0%EB%B0%98-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html#스타일-기반-참조"
  },"471": {
    "doc": "Set Up Basic Layout",
    "title": "Set Up Basic Layout",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Set%20Up%20Basic%20Layout.html"
  },"472": {
    "doc": "Slate",
    "title": "Slate",
    "content": "언리얼 엔진의 로우레벨 UI 프레임워크 . | SlateCore: UI 위젯, 레이아웃, 입력 처리 등 Slate의 핵심 로직을 담당 | Slate: 렌더링, 스타일링, 고수준 위젯 구현, Windows/OSX/Linux와의 통합 등 확장 기능 담당 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html"
  },"473": {
    "doc": "Slate",
    "title": "슬레이트 구조 특징",
    "content": ". | Slate의 UI는 SWidget이라는 추상 클래스를 루트로 하는 트리 구조 | 각 위젯(버튼, 텍스트, 리스트 등)은 SWidget을 상속한 C++ 클래스 . | 예: SButton, STextBlock, SListView 등 | . | 모든 위젯은 부모-자식 관계로 연결되어 트리 형태 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B5%AC%EC%A1%B0-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-구조-특징"
  },"474": {
    "doc": "Slate",
    "title": "슬레이트 동작 과정",
    "content": ". | Slate Application 구동 . | 엔진 초기화 시 FSlateApplication 싱글턴이 생성 | 이 객체가 Slate의 메인 루프, 입력 이벤트 분배, 렌더링 등을 총괄 | . | 위젯 트리 구성 . | 프로그래머가 C++로 SWidget 트리를 생성 (ex. SNew(SVerticalBox) + SNew(STextBlock) 형태) | 이 트리를 SlateApplication이 루트부터 관리 | . | 입력 이벤트 처리 . | OS 레벨의 입력(마우스, 키보드 등)이 SlateApplication에 전달됨 | Slate는 이를 루트 SWidget부터 트리 순회하며 적절한 위젯에 분배 | 각 위젯은 OnMouseDown, OnKeyDown 등 가상 메서드에서 처리 | . | Tick &amp; 업데이트 . | Slate 트리는 매 프레임마다 Tick(갱신)됨 | 애니메이션, 상태 변화, Focus 변경 등 UI 갱신이 여기서 처리 | . | 레이아웃 &amp; 측정 . | 각 SWidget은 ComputeDesiredSize, ArrangeChildren 등 메서드로 자기 크기와 자식 위치를 계산 | 위젯 트리를 재귀적으로 순회하며 레이아웃 패스를 수행 | . | 렌더링 . | 각 위젯의 OnPaint가 호출되어 FSlateDrawElement 명령을 발행 | Slate 렌더러가 DrawElement를 실제 GPU로 렌더링 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-동작-과정"
  },"475": {
    "doc": "Slate",
    "title": "슬레이트 다이어그램",
    "content": ". 클래스 관계 . | FSlateApplication → SWindow: 여러 윈도우(에디터 창 등)를 관리 | SWindow → SWidget: 각 윈도우는 하나의 루트 위젯 트리를 가짐 | SWidget → SPanel/SCompoundWidget: 각 위젯의 파생 구조를 통해 복잡한 UI 트리를 형성 | FSlateWindowElementList → FSlateDrawElement: 각 윈도우에서 발생하는 모든 드로우 명령을 버퍼링 | FSlateDrawElement ↔ FWidgetStyle: 드로우 요소마다 스타일 정보를 가짐 | FSlateApplication → FSlateRenderer: 실제 GPU 렌더링을 위해 렌더러로 명령을 위임 | . FSlateApplication . | Slate 전체의 엔트리 포인트이자 메인 루프 | 입력 이벤트(마우스, 키보드 등) 처리, UI 업데이트(Tick), 드로우 메시지 생성, 윈도우 관리, 렌더링 요청까지 Slate 관련 모든 핵심 흐름을 담당 | Tick, ProcessInput, GeneratePaintMessages, DrawWindows 등 메서드를 통해 매 프레임 UI 시스템의 상태를 갱신하고, 렌더링 파이프라인을 실행 | 여러 개의 SWindow 인스턴스를 직접적으로 관리 | . SWindow . | OS 창(Window)의 추상화 | 에디터 창, 툴팁, 팝업 등 각종 윈도우를 의미 | 각 SWindow는 자신의 루트 위젯(RootWidget, SWidget)을 하나 포함 . | 즉, 한 SWindow의 모든 Slate UI 요소는 하나의 SWidget 트리로 구성됨 | . | 창의 콘텐츠 설정, 네이티브 창 객체 반환, 뷰포트(창 영역) 크기 정보 제공 등의 역할을 담당 | . SWidget . | 모든 Slate 위젯(버튼, 텍스트, 패널 등)의 최상위 추상 베이스 클래스 | 모든 시각적 UI 요소는 SWidget을 상속하여 구현 | 주요 메서드: . | ComputeDesiredSize: 위젯이 필요로 하는 최소/최적 크기 계산 | ArrangeChildren: 자식 위젯 배치 | OnPaint: 실제로 드로우 요소를 생성(FSlateDrawElement)하는 렌더링 엔트리 포인트 | OnMouseButtonDown: 입력 이벤트 핸들링 | Tick: 프레임마다 상태 갱신 등 | . | . SWidget 컨테이너 상속 구조 (SCompoundWidget, SPanel) . | SCompoundWidget . | SWidget에서 파생되며, 단일 자식(Slot)만을 가질 수 있는 컨테이너 | 복잡한 단일 구조 위젯에 적합 | . | SPanel . | SWidget에서 파생되며, 여러 자식(Slot/배열)을 가질 수 있는 컨테이너 | 리스트, 박스, 그리드 등 여러 자식 위젯을 배치하는 레이아웃 위젯에서 사용 | . | . FSlateWindowElementList . | 실제 드로잉 명령(FSlateDrawElement)의 집합/버퍼 역할 | 각 SWindow의 OnPaint 과정에서 위젯 트리를 순회하며, SWidget들이 페인트 시 호출되는 OnPaint에서 DrawElement를 이 리스트에 기록 | Draw Call 최적화와 레이어 관리의 핵심 중간 계층 | . FSlateDrawElement . | 실제 GPU로 전달되는 드로우 명령을 표현하는 구조체 | 박스, 텍스트, 선, 이미지 등 다양한 유형의 그리기 명령을 포함 | SWidget이 OnPaint에서 시각적 요소를 그리고자 할 때, FSlateDrawElement를 만들어 FSlateWindowElementList에 추가함 | . FWidgetStyle . | 위젯의 시각적 스타일(컬러, 불투명도, 폰트 등)을 정의 | FSlateDrawElement와 연계되어, 각 드로우 요소에 스타일 속성을 부여 | 상위에서 하위로 스타일이 전파되어, 일관성 있는 UI 테마 구현이 가능 | . FSlateRenderer . | 실제 하드웨어(DirectX/OpenGL/Vulkan 등) 렌더러와의 인터페이스 | FSlateApplication이 그리기 명령을 넘기면, FSlateRenderer가 이를 플랫폼별로 변환/렌더링 | Slate의 플랫폼 독립성과 실제 렌더링 동작을 분리하는 핵심 계층 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#슬레이트-다이어그램"
  },"476": {
    "doc": "Slate",
    "title": "정리",
    "content": ". | FSlateApplication → SWindow → SWidget 트리 (OnPaint) → FSlateWindowElementList → FSlateDrawElement → FSlateRenderer (플랫폼별) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Slate.html#정리"
  },"477": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "목표 : 커스텀 에디터 탭 등록",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%AA%A9%ED%91%9C--%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%90%EB%94%94%ED%84%B0-%ED%83%AD-%EB%93%B1%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#목표--커스텀-에디터-탭-등록"
  },"478": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 매크로",
    "content": ". | SLATE_BEGIN_ARGS , SLATE_END_ARGS 매크로는 필수적으로 클래스 안에 들어가야 함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EB%A7%A4%ED%81%AC%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-매크로"
  },"479": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_BEGIN_ARGS / SLATE_END_ARGS",
    "content": "위젯의 생성자 인자 구조체인 FArguments를 정의 . | SLATE_BEGIN_ARGS는 구조체의 시작 | SLATE_END_ARGS는 구조체의 끝 | 시작과 끝 매크로 안에서 위젯의 속성, 이벤트 등을 선언 | . SLATE_BEGIN_ARGS(SMyWidget) // 시작 선언 : _Title(FText::FromString(\"Default Title\")) // 기본값 설정 {} SLATE_ARGUMENT(FText, Title) SLATE_ATTRIBUTE(int32, Count) SLATE_EVENT(FOnClicked, OnButtonClicked) SLATE_END_ARGS() // 끝 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_begin_args--slate_end_args"
  },"480": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ARGUMENT(Type, Name)",
    "content": "생성자 인자로 전달되는 불변 값을 선언 . | SLATE_ARGUMENT(FText, Title)은 FText 타입의 Title이라는 인자를 선언 | FArguments 구조체 내에서 _Title로 접근 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_argumenttype-name"
  },"481": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_ATTRIBUTE(Type, Name)",
    "content": "동적으로 변경 가능한 속성을 선언 . 외부 데이터와 바인딩하여 UI 요소가 실시간으로 업데이트되도록 할 수 있다 . | SLATE_ATTRIBUTE(int32, Count)은 Count라는 이름의 속성을 선언 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_attributetype-name"
  },"482": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_EVENT(DelegateType, Name)",
    "content": "위젯에서 발생하는 이벤트를 처리할 델리게이트를 선언 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_eventdelegatetype-name"
  },"483": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SLATE_NAMED_SLOT(OwnerArgsType, SlotType, SlotName)",
    "content": "사용자 정의 슬롯을 선언할 때 사용. 슬롯은 위젯의 특정 위치에 다른 위젯을 삽입할 수 있는 영역을 의미 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slate_named_slotownerargstype-slottype-slotname"
  },"484": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "매크로 정리",
    "content": "| 매크로 | 용도 | 사용 예시 | 설명 | . | SLATE_BEGIN_ARGS | 위젯 생성 인자 정의 시작 | SLATE_BEGIN_ARGS(SMyWidget) | 클래스의 생성 인자 정의 블록을 시작 | . | SLATE_END_ARGS | 위젯 생성 인자 정의 종료 | SLATE_END_ARGS() | 생성 인자 정의 블록을 종료 | . | SLATE_ARGUMENT | 단일 값 인자 정의 | SLATE_ARGUMENT(FText, InitialText) | 위젯 생성 시 전달되는 단일 값 인자 | . | SLATE_ATTRIBUTE | 바인딩 가능한 속성 정의 | SLATE_ATTRIBUTE(FText, DisplayText) | 동적으로 변경 가능한 속성(TAttribute로 래핑됨) | . | SLATE_EVENT | 이벤트 핸들러 정의 | SLATE_EVENT(FOnClicked, OnButtonClicked) | 위젯에서 발생하는 이벤트 핸들러 | . | SLATE_STYLE_ARGUMENT | 스타일 인자 정의 | SLATE_STYLE_ARGUMENT(FName, StyleName) | 스타일 세트에서 스타일을 지정하는 인자 | . | SLATE_DEFAULT_SLOT | 기본 슬롯 속성 정의 | SLATE_DEFAULT_SLOT(FArguments, Content) | 위젯의 기본 콘텐츠 슬롯을 정의 | . | SLATE_NAMED_SLOT | 명명된 슬롯 정의 | SLATE_NAMED_SLOT(FArguments, Header) | 특정 이름을 가진 슬롯을 정의 | . | SLATE_SUPPORTS_SLOT | 슬롯 타입 지원 선언 | SLATE_SUPPORTS_SLOT(SVerticalBox::FSlot) | 위젯이 지원하는 슬롯 타입 선언 | . | SLATE_USER_ARGS | 사용자 정의 인자 구조체 | SLATE_USER_ARGS() | 사용자 정의 인자 구조체 정의 시 사용 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#매크로-정리"
  },"485": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "SlateWidget 초기화 설정하기",
    "content": "Slate 위젯은 생성자(constructor) 대신 Construct() 함수를 통해 실질적인 초기화를 수행한다 . | 엔진에서 위젯 인스턴스를 만든 뒤 곧바로 Construct를 호출하여 속성(Arguments)과 함께 위젯의 동작을 설정함 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#slatewidget-초기화-설정하기"
  },"486": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "코드 예시",
    "content": "void SYourWidget::Construct(const FArguments&amp; InArgs) { // 1. 포커스 관련 설정 bCanSupportFocus = true; // 또는 false (위젯 용도에 따라) // 2. 마우스 이벤트 처리 설정 SetCanTick(true); // 틱 활성화 (애니메이션 등 필요시) bAcceptsInput = true; // 마우스/터치 입력 허용 // 3. 시각적 상태 설정 SetVisibility(EVisibility::Visible); // 기본 가시성 설정 // 4. 콘텐츠 구성 (가장 중요한 부분) ChildSlot [ // 위젯 계층 구조 정의 SNew(SBorder) .Padding(FMargin(5)) [ SNew(STextBlock) .Text(LOCTEXT(\"DefaultText\", \"Hello Slate!\")) ] ]; // 5. 인자에서 전달받은 값 적용 if (InArgs._SomeArgument.IsSet()) { // 인자 처리 로직 } } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#코드-예시"
  },"487": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "초기화 설정 정리",
    "content": "| 설정 | 설명 | 기본값 | 사용 예시 | . | bCanSupportFocus | 위젯이 키보드 포커스를 받을 수 있는지 설정 | false | bCanSupportFocus = true; | . | bAcceptsInput | 마우스/터치 입력 허용 여부 | false | bAcceptsInput = true; | . | SetVisibility() | 위젯의 가시성 설정 (Visible, Collapsed, Hidden, HitTestInvisible, SelfHitTestInvisible) | EVisibility::Visible | SetVisibility(EVisibility::Visible); | . | SetCanTick() | 위젯이 Tick 이벤트를 받을지 설정 (애니메이션, 실시간 업데이트 시 필요) | false | SetCanTick(true); | . | SetClipping() | 콘텐츠 클리핑 방식 (OnDemand, ClipToBounds, ClipToBoundsWithoutIntersecting, ClipToBoundsAlways) | EWidgetClipping::Inherit | SetClipping(EWidgetClipping::ClipToBounds); | . | SetCursor() | 마우스 오버 시 커서 모양 (Default, Hand, TextEdit, Crosshairs 등) | EMouseCursor::Default | SetCursor(EMouseCursor::Hand); | . | SetEnabled() | 위젯의 활성화/비활성화 상태 | true | SetEnabled(TAttribute(this, &amp;SMyWidget::IsEnabled)); | . | SetToolTipText() | 툴팁 텍스트 설정 | FText::GetEmpty() | SetToolTipText(LOCTEXT(“Tooltip”, “Click me!”)); | . | SetHAlign() / SetVAlign() | 수평/수직 정렬 (HAlign_Fill, VAlign_Center 등) | HAlign_Fill, VAlign_Fill | SetHAlign(HAlign_Center); | . | SetPadding() | 안쪽 여백 설정 | FMargin(0) | SetPadding(FMargin(5.0f)); | . | SetRenderTransform() | 변환 행렬 적용 (위치, 회전, 스케일) | FSlateRenderTransform() | SetRenderTransform(FSlateRenderTransform(FVector2D(10, 10))); | . | SetRenderOpacity() | 투명도 설정 (0.0 ~ 1.0) | 1.0f | SetRenderOpacity(0.5f); | . | SetForegroundColor() | 전경색 (텍스트, 아이콘 등) | FSlateColor::UseForeground() | SetForegroundColor(FLinearColor::White); | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%B4%88%EA%B8%B0%ED%99%94-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#초기화-설정-정리"
  },"488": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "커스텀 위젯 플로우 요약",
    "content": ". | 사용자 정의 Slate 위젯 클래스 구현 | 에디터 확장 코드에서 커스텀 Slate 위젯 인스턴스 생성 . | (예: 커스텀 패널, 탭, 도킹 윈도우 등에서 SNew(SMyWidget) 사용) | . | Slate 위젯 트리(Widget Tree)에 삽입 . | 에디터 패널/탭/도킹 윈도우 등의 컨테이너가 커스텀 Slate 위젯의 부모가 됨 | . | Slate Application이 매 프레임마다 Tick &amp; Render 호출 . | Slate 렌더링 파이프라인에 따라 모든 위젯을 탐색하며 그리기 | DirectX/OpenGL/Vulkan 등 RHI 기반 드로우콜로 변환 | . | 사용자 입력/이벤트 처리 및 갱신 . | Slate Application이 마우스/키보드/포커스 등 이벤트 분배 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9C%84%EC%A0%AF-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html#커스텀-위젯-플로우-요약"
  },"489": {
    "doc": "Spawn A Coustom Editor Tab",
    "title": "Spawn A Coustom Editor Tab",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/Spawn%20A%20Coustom%20Editor%20Tab.html"
  },"490": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html"
  },"491": {
    "doc": "String",
    "title": "FString",
    "content": "FString은 일반적인 문자열 데이터로 문자열 검색, 수정, 비교를 할 수 있다. | 데이터 구조 . | 메모리 상에 각 인스턴스마다 고유 문자 배열을 직접 저장 | 내부적으로 TArray&lt;TCHAR&gt; (=동적 배열 기반 유니코드 문자열) | C++의 std::wstring(wide string)과 비슷하지만, 언리얼 엔진 특화 기능(TCHAR, UTF-16, 매크로 등)이 있다 | . | 대표적 사용 예 . | 파일 경로, 로그 메시지 | 유저 입력 (채팅, 이름 등) | 임시 데이터 처리, 문자열 연산 | . | 특징 . | 수정 가능 | 문자열 조작이 자유로움 | 각 인스턴스가 자체 메모리 공간 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fstring"
  },"492": {
    "doc": "String",
    "title": "FName",
    "content": "FString과 다르게 문자열 전체 저장 X. 글로벌 네임 테이블에 저장되어 데이터를 경량화 . | 데이터 구조 . | 엔진 시작 시부터 종료까지 고유 문자열을 전역적으로 관리하는 글로벌 네임 테이블 사용 . | 실제 문자열 데이터는 네임 테이블에 한번만 등록됨 | . | 어떤 FName이 새로 생성될 때, 문자열이 이미 테이블에 있으면 기존 인덱스를 사용하고, 없으면 새로 추가함 | . | 문자열의 중복 저장을 막고, 모든 FName이 같은 문자열이면 동일한 인덱스를 공유한다 | . | 대표적인 사용 예 . | 오브젝트 식별에 주로 사용 | 변수명, 파라미터 이름 | 리소스/에셋 이름 | GameplayTags | . | 특징 . | 수정 불가 | 비교 검색이 매우 빠름 . | 문자열끼리 직접 비교하는 대신, 인덱스만 비교하면 되기 때문에 성능이 우수하다 | . | 대소문자 구분이 없다 | 가비지 컬렉션 대상이 아니다 (엔진이 꺼질 때 까지 유지) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#fname"
  },"493": {
    "doc": "String",
    "title": "FText",
    "content": "사용자에게 보여지는 텍스트에 주로 사용된다. 다국어 번역이 필요한 경우 사용. FText는 외부 API에서 받은 플레이어 이름 등을 UI에 표시할 때처럼, 현지화 테이블 미등록 텍스트 문자열에도 쓰인다. | 데이터 구조 | . 최상위 . | ITextData(인터페이스)의 TSharedRef 스마트 포인터만을 소유 | 실질적 데이터는 FTextData에 들어있다. class FText { private: TSharedRef&lt;ITextData, ESPMode::ThreadSafe&gt; TextData; ... }; . | . FTextData 구조체 . struct FTextData : ITextData { FString SourceString; // 원본 문자열 FCulturePtr TextCulture; // 해당 텍스트의 문화권(언어) 정보 FTextHistory TextHistory; // 텍스트 생성/변환 이력 (핵심!) ... }; . 현지화 히스토리 . | 다양한 하위 클래스를 통해 데이터 관리 가능 . | FTextHistory_LocalizedString : 현지화 키, 원본 텍스트, 로컬라이제이션 리소스 정보 등 저장 | FTextHistory_FormattedNumber : 숫자 포맷, 소수점, 지역화 등 정보 | FTextHistory_FormatString : 포맷 패턴, 인자 배열 등 | . | . class FTextHistory_LocalizedString : public FTextHistory_Base { FString SourceString; // 원본 텍스트 FString Namespace; // 현지화 네임스페이스 FString Key; // 현지화 키 FString LocalizedString; // 번역된 문자열(캐싱) ... }; . FText 구조 정리 . FText └─ TextData (FTextData) ├─ SourceString (원본) ├─ TextCulture (문화권) └─ TextHistory (생성/포맷/현지화 이력) ├─ 현지화키 ├─ 네임스페이스 ├─ 포맷정보 └─ 캐시된 번역값 등... | 대표적인 사용 예 . | UI 버튼/ 메뉴 텍스트 (시작, Continue 등) | 게임 대사, 퀘스트 설명, 튜토리얼 메시지 | 점수, 날짜, 숫자 등 표시 | 모든 다국어 지원 필요한 표시용 텍스트 | . | 특징 . | 현지화, 포맷, 문화권별 번역 자동 처리 | 직접 수정 불가. 변환 후 새로 만들어야 함 | 직접 비교/조작은 제한됨 . | FText끼리 == 연산은 데이터 주소 또는 히스토리 비교이므로, 실제 표시 문자열이 같아도 false가 나올 수 있음 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#ftext"
  },"494": {
    "doc": "String",
    "title": "정리",
    "content": "| 클래스 | 사용 목적 | 데이터 구조 | 특징 | . | FString | 임의 문자열, 수정/검색/연결 | TArray(인스턴스별 동적 배열) | 수정 가능, 조작 자유 | . | FText | 현지화/번역 표시 텍스트 | TSharedRef + FTextHistory | 현지화 지원, 수정 어려움, 포맷/언어 처리 | . | FName | 식별자/키/이름/빠른비교 | 글로벌 해시 테이블 인덱스+번호 | 비교 빠름, 대소문자 무시, 수정 불가 | . 참고 링크 . | String Handling | Why you should be using GameplayTags in Unreal Engine | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/String.html#정리"
  },"495": {
    "doc": "Subsystem",
    "title": "Subsystem",
    "content": "서브시스템은 코어 시스템 위에 추가되는 확장 레이어 (개발자가 선택적으로 구현) . 서브시스템 모듈을 통해 체계적인 게임 시스템을 커스텀하여 구축할 수 있음 (플러그인) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html"
  },"496": {
    "doc": "Subsystem",
    "title": "코어 시스템 vs 서브 시스템",
    "content": "| 특징 | 코어 시스템 (Core) | 서브시스템 (Subsystem) | . | 생성 주체 | 엔진 자동 생성 | 코어 시스템에 의해 생성 | . | 생명 주기 | 게임 실행부터 종료까지 유지 | 부모 시스템(게임/월드/플레이어)과 동기화 | . | 오버라이드 | 엔진 소스 수정 필요 (드문 경우) | 상속받아 자유롭게 확장 가능 | . | 예시 | UWorld, APlayerController | UMySaveSystem, UDialogueManager | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%BD%94%EC%96%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C-vs-%EC%84%9C%EB%B8%8C-%EC%8B%9C%EC%8A%A4%ED%85%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#코어-시스템-vs-서브-시스템"
  },"497": {
    "doc": "Subsystem",
    "title": "종류",
    "content": "| Subsystem 유형 | 주요 사용 예시 | . | UEngineSubsystem | 게임 메커니즘, 물리 시뮬레이션, 렌더링 프로세스 등 엔진의 수명 주기와 관련된 로직 및 시스템 | . | UGameInstanceSubsystem | 플레이어 진행 상황, 저장 데이터, 옵션 등 전체 게임 세션과 관련된 데이터를 저장하고 관리 | . | ULocalPlayerSubsystem | 로컬 플레이어의 입력, UI, 카메라, 사운드 등을 처리 | . | UWorldSubsystem | 환경 효과, 레벨 스트리밍, AI 생성 등 특정 레벨에 특화된 논리와 시스템을 구현 | . | UEditorSubsystem | 커스텀 에디터 툴, 에셋 관리 확장 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#종류"
  },"498": {
    "doc": "Subsystem",
    "title": "생명 주기",
    "content": "Subsystem이 속한 코어 모듈(Engine, GameInstance, World, LocalPlayer 등)의 생명주기에 종속됨 . Subsystem은 런타임 중 필요 시점에 자동으로 인스턴스화되며, 명시적으로 생성/삭제하지 않는다 . | Engine Subsystem (UEngineSubsystem) . | 시작: 엔진 초기화 시 생성 (UGameEngine/UEditorEngine 시작 시) | 종료: 엔진 종료 시 소멸 (에디터/게임 종료 시) | . | GameInstance Subsystem (UGameInstanceSubsystem) . | 시작: UGameInstance 생성 시 (게임 실행 시) | 종료: UGameInstance 소멸 시 (레벨 이동 없이 게임 종료 시) | . | World Subsystem (UWorldSubsystem) . | 시작: UWorld 생성 시 (레벨 로드 시) | 종료: UWorld 소멸 시 (레벨 언로드 시) | . | LocalPlayer Subsystem (ULocalPlayerSubsystem) . | 시작: ULocalPlayer 생성 시 (플레이어 로그인 시) | 종료: ULocalPlayer 소멸 시 (플레이어 로그아웃 시) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#생명-주기"
  },"499": {
    "doc": "Subsystem",
    "title": "나중에 쓰게되면 서브시스템 클래스 만드는 법 추가하기",
    "content": ". 참고 링크 . | doc - Programming Subsystems | What are subsystems? | subsystem-singleton | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#%EB%82%98%EC%A4%91%EC%97%90-%EC%93%B0%EA%B2%8C%EB%90%98%EB%A9%B4-%EC%84%9C%EB%B8%8C%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B2%95-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/Subsystem.html#나중에-쓰게되면-서브시스템-클래스-만드는-법-추가하기"
  },"500": {
    "doc": "Transform",
    "title": "Transform",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html"
  },"501": {
    "doc": "Transform",
    "title": "FVector",
    "content": "3차원 공간상의 위치, 방향, 속도, 크기 등 벡터 값을 표현할 때 사용 . | 오브젝트의 위치 (Location) : SetActorLocation(FVector(100.f, 200.f, 300.f)); | 이동 방향 및 속도 (Velocity, Direction) : FVector Direction = Target - Source; | 스케일(Scale) 값 (상대적 크기) | 힘(Force), 가속도(Acceleration) 등 물리 연산 | 충돌 처리에서 법선 벡터(Normal) 표현 | . | 데이터 구조 struct FVector { float X; float Y; float Z; }; . | 오른손 법칙 좌표계 : Z-위, X-앞, Y-오른쪽 | . | 특징 . | 기본적인 연산자 오버로딩 지원 (+, -, *, /, dot, cross 등) | 크기, 정규화, 내적(dot), 외적(cross) 등 벡터 연산 지원 | 단순 위치/방향뿐 아니라, 각종 수학적, 물리적 벡터 표현에 모두 사용 | 방향성과 크기를 함께 가짐 (예: 방향 벡터는 크기=1로 정규화) | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Size() | 없음 | float | 벡터의 크기를 반환합니다. | . | Normalize() | 없음 | 없음 | 벡터를 정규화합니다. | . | Dot() | const FVector&amp; Other | float | 두 벡터의 내적 | . | Cross() | const FVector&amp; Other | FVector | 두 벡터의 외적 | . | Rotation() | 없음 | FRotator | 벡터의 방향을 회전 값으로 반환 | . | Lerp() | const FVector&amp; A const FVector&amp; B float Alpha | FVector | 두 벡터 간의 선형 보간 | . | Size() / SizeSquared() |   | 벡터의 크기 또는 크기의 제곱을 반환 |   | . 배경 수학 . 벡터 연산(덧셈, 뺄셈, 스칼라 곱/나눗셈, 내적/외적 등)은 선형대수의 기본 연산. 내적(Dot Product): 두 벡터의 방향성이 얼마나 일치하는지 계산 → 코사인 법칙과 연관되어 각도 구하기, 투영, 정규화, 평면 법선 등 계산에 사용 . A·B = Ax * Bx + Ay * By + Az * Bz . 외적(Cross Product): 두 벡터에 수직인 벡터 산출 → 평면의 법선, 회전축 등 계산 . A×B = (Ay*Bz - Az*By, Az*Bx - Ax*Bz, Ax*By - Ay*Bx) . 정규화(Normalization) → 크기를 1로 맞춤 . V.Normalize() → V / |V| . 거리/길이 . V.Size() = sqrt(X^2 + Y^2 + Z^2) . 선형보간(LERP) . Lerp(A, B, Alpha) = (1-Alpha)*A + Alpha*B . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fvector"
  },"502": {
    "doc": "Transform",
    "title": "FRotator",
    "content": "오일러 각(Euler Angle)(Pitch, Yaw, Roll)로 3D 회전을 표현할 때 사용 . | 오브젝트 회전 : SetActorRotation(FRotator(0.f, 90.f, 0.f)); | 캐릭터, 카메라의 방향(회전) | Actor/Component의 회전값 저장 : GetActorRotation() | 블루프린트, 에디터의 회전값 입력 등 | . | 데이터 구조 struct FRotator { float Pitch; // X축 회전 (상하) float Yaw; // Z축 회전 (좌우) float Roll; // Y축 회전 (틸트) }; . | 세 개의 float값(Pitch, Yaw, Roll)로 오일러 각 표현 | . | 특징 . | 오일러 각 특성상 Gimbal Lock(짐벌락) 문제 발생 가능 | 사람에게 직관적으로 이해하기 쉬움 (디자이너, 에디터에서 많이 사용) | 내부적으로는 보통 Degree(각도) 단위 사용 (Radian 변환 필요시 지원) | FRotator는 내부적으로 회전 행렬 혹은 쿼터니언으로 변환 가능 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | Quaternion() | 없음 | FQuat | 오일러 각을 쿼터니언으로 변환 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | UnrotateVector() | const FVector&amp; V | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | GetNormalized() | 없음 | FVector | 회전된 벡터를 원래 방향으로 되돌림 | . | Clamp() | 없음 | FRotator | 회전 값을 제한 | . 배경 수학 . | 오일러 각(Euler Angle) : 세 축(X, Y, Z)에 대한 회전 각도(θx, θy, θz)로 회전을 표현. | 언리얼 엔진은 Z(Yaw) → Y(Pitch) → X(Roll) 순서로 회전 (즉, “Yaw → Pitch → Roll” 오더) | . 행렬 변환: 오일러 각은 각각의 축 회전을 행렬로 변환 후 곱셈해서 최종 회전값을 만듦 . R = Rz(Yaw) * Ry(Pitch) * Rx(Roll) . Gimbal Lock: 두 축이 일치하여 3차원 회전 자유도가 2차원으로 줄어드는 현상 . | 예: Pitch가 ±90°에 가까워지면, Roll과 Yaw가 같은 평면이 됨 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#frotator"
  },"503": {
    "doc": "Transform",
    "title": "FQuat",
    "content": "3D 공간에서 회전을 쿼터니언(Quaternion)으로 표현하여, 회전 연산의 정확성 및 안정성 확보 . | 모션 블렌딩, 본(스켈레톤) 등 애니메이션의 회전 보간 | 부드러운 연속 회전 (SLERP) | Gimbal Lock 방지가 중요한 복잡한 회전 연산 | . | 데이터 구조 struct FQuat { float X; // 허수 (벡터) float Y; // 허수 (벡터) float Z; // 허수 (벡터) float W; // 실수 (스칼라) 부분 }; . | 4개의 float형 멤버(X, Y, Z, W)로 구성 | 단위 쿼터니언(norm = 1) 으로 회전 표현 | . | 특징 . | 4차원 복소수로 회전 표현 | Gimbal Lock 문제 없음 | 회전 합성/보간에 최적화 (SLERP, NLERP 등 지원) | FRotator, FMatrix 등과 상호 변환 함수 제공 | 보통은 FRotator(에디터/코드) ↔ FQuat(엔진 내부)로 변환하며 사용 | . | 주요 메서드 | . | 메서드 | 매개변수 | 반환값 | 설명 | . | RotateVector() | const FVector&amp; V | FVector | 벡터를 회전 | . | Inverse() | 없음 | FQuat | 쿼터니언의 역을 반환 | . | Slerp() | const FQuat&amp; A const FQuat&amp; B float Alpha | FQuat | 두 쿼터니언 간의 구면 선형 보간을 수행 | . | ToAxisAndAngle() | FVector&amp; Axis float&amp; Angle | 없음 (출력 매개변수 사용) | 회전 축과 각도로 변환 | . | MakeFromEuler() | const FVector&amp; Euler | FQuat | 오일러 각도로부터 쿼터니언을 생성 | . 배경 수학 . | 쿼터니언(Quaternion): 실수부(w)와 허수부(x, y, z)로 구성된 4차원 수학 구조 Q = w + xi + yj + zk (i, j, k는 허수 단위벡터) . | 회전 표현: 3D 공간에서 임의의 축(axis)과 각도(θ)에 대한 회전 Q = [cos(θ/2), (axis * sin(θ/2))] . | 복합 회전: 쿼터니언 곱셈으로 연속 회전 표현 Q' = Q2 * Q1 (Q1 후 Q2 수행) . | 회전 적용: 점 P를 Q로 회전시키려면 P' = Q * P * Q⁻¹ (여기서 P는 벡터를 허수부로 취급한 쿼터니언) . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#fquat"
  },"504": {
    "doc": "Transform",
    "title": "FTransform",
    "content": "위치, 회전, 스케일을 함께 관리하여 오브젝트의 변환을 효율적으로 처리 . | 오브젝트의 전체 변환 설정: SetActorTransform(FTransform(Rotation, Translation, Scale)); | . | 데이터 구조 struct FTransform { FQuat Rotation; FVector Translation; FVector Scale3D; }; . | 특징 . | 위치, 회전, 스케일을 하나의 구조체로 관리 | 계층적 트랜스폼 계산에 유용 | 블루프린트에서 쉽게 사용할 수 있도록 지원 | . | 주요 메서드 | . 많아서 나중에 정리할랭 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#ftransform"
  },"505": {
    "doc": "Transform",
    "title": "정리",
    "content": "| 타입 | 목적/용도 | 데이터 구조 | 특징 요약 | . | FVector | 3D 위치, 방향, 벡터 | X, Y, Z (float) | 모든 위치/방향/벡터 연산에 사용 | . | FRotator | 오일러 각 기반 3D 회전 | Pitch, Yaw, Roll (float) | 직관적, Gimbal Lock 위험 | . | FQuat | 쿼터니언 기반 3D 회전 | X, Y, Z, W (float) | Gimbal Lock 없음, 고급 회전 | . | FTransform | 위치, 회전, 스케일 통합 변환 | 위치, 회전, 스케일 구조체 | Actor 변환, 부모-자식 변환 관리 | . 참고 링크 . | UE4 Transform Calculus | Vectors | Roll, Pitch, Yaw | Quaternion | Gimbal lock | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Transform.html#정리"
  },"506": {
    "doc": "UPlayer",
    "title": "UPlayer",
    "content": "플레이어 표현의 최상위 추상 클래스로, 플레이어와 게임 세계 간의 상호작용을 관리하는 기본 프레임워크를 제공 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html"
  },"507": {
    "doc": "UPlayer",
    "title": "특징",
    "content": ". | UObject를 상속받는 언리얼 엔진의 코어 클래스 | 순수 가상 함수를 포함한 추상 클래스 | 플레이어로서의 식별 정보, 네트워크 연결, 컨트롤러 정보를 추상적으로 제공 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#특징"
  },"508": {
    "doc": "UPlayer",
    "title": "ULocalPlayer",
    "content": "UPlayer를 상속받아 실제 로컬 머신에서 실행되는 플레이어를 표현하는 클래스 . | 상속 : UObject → UPlayer → ULocalPlayer | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#ulocalplayer",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#ulocalplayer"
  },"509": {
    "doc": "UPlayer",
    "title": "특징",
    "content": ". | 스플릿 스크린 및 다중 뷰포트 지원 | 로컬 플레이어(키보드/마우스/게임패드 직접 입력을 받는 플레이어) 전용 구현 | 컨트롤러 입력과 뷰포트 렌더링 간의 연결 관리 (ViewPort 및 PlayerController와 연동) | 각 플레이어별로 LocalPlayerSubsystem 생성 및 입력, UI, HUD 등의 독립적 관리 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%ED%8A%B9%EC%A7%95-1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#특징-1"
  },"510": {
    "doc": "UPlayer",
    "title": "역할",
    "content": ". | 로컬 입력 장치와의 연결 관리 (PlayerController 연결) | 입력 관리 (키보드, 마우스, 게임패드 등 각 플레이어별로 입력 독립 처리) | UI, HUD 시스템과 상호작용 및 개별화 | Player Profile 설정 관리 | 로컬 세이브 데이터 관리 | . 참고하면 좋은 링크 . | doc - ULocalPlayer | Unreal Engine 4 Gameplay Framework Overview | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/UPlayer.html#역할"
  },"511": {
    "doc": "Macro",
    "title": "Macro",
    "content": ". | 언리얼 전용 메타데이터 매크로는 코드 재사용성과 생산성을 높이기 위한 강력한 기능을 제공한다 | 함수나 변수마다 위에 매크로를 붙이지 않으면 언리얼 엔진의 리플렉션 시스템에 등록되지 않는다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/"
  },"512": {
    "doc": "Macro",
    "title": "매크로의 주요 기능",
    "content": ". | 리플렉션 시스템 통합 : 런타임에 클래스 정보 조회 가능 | 블루프린트 연동 : C++과 블루프린트 간의 상호 운용성 제공 | 직렬화 지원 : 객체 상태 저장 및 로드 가능 | 네트워크 복제 : 멀티플레이어 게임에서 변수 및 함수 복제 | 가비지 컬렉션 : UObject 파생 클래스의 자동 메모리 관리 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로의-주요-기능"
  },"513": {
    "doc": "Macro",
    "title": "빌드 시스템과 매크로 연동",
    "content": "1. 빌드 시스템 기본 구조 . | UBT(Unreal Build Tool) . | 모든 빌드 명령을 관리/자동화. | 각종 .Build.cs, .Target.cs 파일을 해석하여 모듈, 의존성, 플랫폼, 설정에 따라 빌드를 분기 | . | UnrealHeaderTool(UHT) . | 언리얼 리플렉션을 위해 추가적으로 동작하는 툴 | 리플렉션 매크로(UCLASS, UPROPERTY, 등)가 붙은 소스코드를 파싱 | 메타데이터와 Glue 코드(C++에선 자동 생성된 코드)를 생성 | . | . 2. 매크로와 빌드 파이프라인 . | UCLASS 등을 통해 매크로를 사용한 코드 작성 | UBT : 빌드 시작 | UHT : 헤더 파싱 &amp; Glue 코드(메타데이터) 생성 . | *.generated.h 를 반드시 #include로 포함해야 함 | 이 파일이 누락될 경우 컴파일 에러 발생 | . | C++ 컴파일러가 코드 + 자동코드 컴파일 | 런타임: 리플렉션 시스템 작동 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%97%B0%EB%8F%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#빌드-시스템과-매크로-연동"
  },"514": {
    "doc": "Macro",
    "title": "UHT (UnrealHeaderTool) 의 작동 과정",
    "content": ". | 소스 코드 스캐닝 . | UHT는 .h 헤더 파일을 파싱하여 UCLASS, USTRUCT, UFUNCTION, UPROPERTY 등의 매크로가 포함된 특수 주석을 검색 | 일반 C++ 파서와 달리, 언리얼 특수 매크로를 이해하는 커스텀 파서를 사용 | . | 메타데이터 추출 . | 매크로에 지정된 속성들(예: BlueprintCallable, EditAnywhere 등)을 분석 | 클래스 계층 구조, 프로퍼티 타입, 함수 시그니처 등의 정보를 추출 | . | 리플렉션 코드 생성 . | GENERATED_BODY() 매크로 위치에 대체될 실제 코드를 생성 | 생성되는 파일들은 주로 Intermediate/Build 폴더에 저장 | 주요 생성 파일: . | [ModuleName].generated.h | [ClassName].generated.cpp | . | . | 직렬화/리플렉션 시스템 통합 . | UObject 시스템이 런타임에 클래스 정보를 조회할 수 있도록 함 | 블루프린트와의 상호 운용을 위한 바인딩 코드를 생성 | . | . 생성되는 코드 예시 . | 원본 UCLASS(Blueprintable) class AMyActor : public AActor { GENERATED_BODY() UPROPERTY(EditAnywhere) float Health; }; . | UHT가 생성하는 코드 (간소화 된 예) | . // AMyActor.generated.h #define AMyActor_Extra_Code \\ public: \\ static UClass* StaticClass(); \\ virtual UClass* GetClass() const override; \\ static void __StaticDependenciesAssets(TArray&lt;FAssetData&gt;&amp; OutAssets); \\ private: \\ static UClass* PrivateStaticClass; \\ public: \\ DECLARE_CLASS(AMyActor, AActor, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(\"/Script/MyGame\"), NO_API) \\ DECLARE_REPLICATION_FRAGMENT(AMyActor) \\ enum {IsIntrinsic=COMPILED_IN_INTRINSIC}; // 리플렉션 데이터 구조체 static const FClassFunctionLinkInfo Z_Construct_UClass_AMyActor_Functions[]; static const FPropertyParamsBase* const Z_Construct_UClass_AMyActor_Properties[]; . UHT가 생성하는 정보 . | 클래스 등록용 StaticRegisterNatives | UPROPERTY 메타정보 배열 | 블루프린트용 함수 등록 | C++에서 런타임에 사용할 수 있는 메타데이터 구조체 | 에디터/런타임용 데이터 구조 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-unrealheadertool-의-작동-과정"
  },"515": {
    "doc": "Macro",
    "title": "UHT 처리의 특징",
    "content": ". | 템플릿 기반 코드 생성 . | 단순 복사-붙여넣기가 아닌, 템플릿을 기반으로 상황에 맞는 최적화된 코드 생성 | . | 의존성 분석 . | 클래스 간의 관계를 분석하여 올바른 초기화 순서 보장 | . | 크로스-레퍼런스 해결 . | 모듈 간 상호 참조 문제를 해결하기 위한 전방 선언(forward declaration) 생성 | . | 빌드 시스템 통합 . | 생성된 코드가 실제 컴파일 과정에 올바르게 포함되도록 Makefile/UBT 스크립트 조정 | . | 에러 체크 . | 잘못된 매크로 사용이나 충돌하는 설정을 빌드 전에 검출 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-%EC%B2%98%EB%A6%AC%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#uht-처리의-특징"
  },"516": {
    "doc": "Macro",
    "title": "매크로 카테고리",
    "content": "| 카테고리 | 주요 매크로 | 용도 | . | 코어 리플렉션 | UCLASS, USTRUCT, UENUM, UPROPERTY, UFUNCTION, GENERATED_BODY | 언리얼 리플렉션 시스템 등록 | . | 네트워크 복제 | Replicated, ReplicatedUsing, DOREPLIFETIME, RPC 관련 매크로 | 멀티플레이어 게임에서 변수/함수 동기화 | . | 메모리 관리 | UPROPERTY(), UObject 관련 매크로 | 가비지 컬렉션 및 메모리 안전성 보장 | . | 에디터 연동 | EditAnywhere, VisibleDefaultsOnly, BlueprintReadOnly, Category | 에디터 노출 및 편집 제어 | . | 플랫폼 특화 | PLATFORM_WINDOWS, PLATFORM_ANDROID, WITH_EDITOR, WITH_SERVER_CODE | 플랫폼/빌드 설정별 코드 분기 | . | 디버깅/로깅 | UE_LOG, UE_CHECK, UE_ASSERT, ensure(), check() | 런타임 검증 및 로깅 | . | 성능 최적화 | UE_INLINE, UE_NOINLINE, FORCEINLINE, CORE_API | 인라인 제어 및 DLL 인터페이스 정의 | . | 메타데이터 | UMETA, DisplayName, ClampMin, ToolTip | 추가 속성 지정 | . | 모듈/플러그인 | IMPLEMENT_MODULE, IMPLEMENT_GAME_MODULE, PLUGIN_API | 모듈 초기화 및 플러그인 시스템 통합 | . | 최신 기능 | UE_DEPRECATED, UE_NODISCARD, TOptional, TSoftObjectPtr 관련 매크로 | 현대적 C++ 기능 지원 | . 참고 링크 . | 빌드 파이프라인 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/Macro/#매크로-카테고리"
  },"517": {
    "doc": "2. Extend Content Browser Menu",
    "title": "1. Extend Content Browser Menu",
    "content": "에디터 내 Content Browser의 폴더/에셋을 우클릭할 때, “나만의 기능” 메뉴를 추가하기 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#1-extend-content-browser-menu"
  },"518": {
    "doc": "2. Extend Content Browser Menu",
    "title": "에디터 메뉴 시스템 확장 과정",
    "content": ". | 모듈 생성 및 초기화 . | Editor 타입의 모듈 생성 (uplugin의 “Type”: “Editor”) | . | 명령(Command) 정의 . | 메뉴에 바인딩될 명령(이름, 단축키, 아이콘, 툴팁 등)을 TCommands를 상속받아 정의 | . | 실제 동작 (Action) 바인딩 . | 실제 실행할 동작을 정의 (함수 구현) 한 후 델리게이트로 바인딩 | 보통 플러그인이나 에디터 모듈의 StartupModule()에서 이루어짐 | . | 메뉴 확장(Menu Extension) 적용 . | FExtender/FMenuExtensionDelegate 를 통해 기존 메뉴 섹션에 새로운 엔트리(항목)를 추가 | 원하는 위치 (섹션명)은 엔진 문서 참고 | . | UI 적용 및 정리 . | 에디터가 종료될 때 ShutdownModule()를 통해 리소스 및 이벤트 정리 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EC%97%90%EB%94%94%ED%84%B0-%EB%A9%94%EB%89%B4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%99%95%EC%9E%A5-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#에디터-메뉴-시스템-확장-과정"
  },"519": {
    "doc": "2. Extend Content Browser Menu",
    "title": "Delegate",
    "content": "이벤트 기반 프로그래밍을 구현하기 위한 강력한 시스템으로, C++의 함수 포인터나 콜백 시스템을 더 안전하고 유연하게 확장한 개념 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#delegate"
  },"520": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 특징",
    "content": ". | 타입 안전성: 컴파일 시점에 타입 검사를 수행 | 멤버 함수 바인딩: 객체 인스턴스와 함께 멤버 함수를 바인딩 가능 | 멀티캐스트 지원: 하나의 이벤트에 여러 함수를 등록 가능 | 다이나믹 델리게이트: 블루프린트와 연동 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-특징"
  },"521": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 사용하기",
    "content": "Delegate 타입 선언 : 매크로 사용 . DECLARE_DELEGATE(FMyDelegate); DECLARE_DELEGATE_RetVal_OneParam(ReturnType, DelegateName, ParamType); . | ReturnType: 반환 타입 (예: int32) | DelegateName: 델리게이트 타입 이름 (예: FMyDelegateWithReturn) | ParamType: 함수에 전달될 파라미터의 타입 (예: FString) | . 바인딩 : 위에 선언한 델리게이트 타입 객체에 함수 연결 . FMyDelegate MyDelegate; // 선언(위 매크로로 정의된 타입) MyDelegate.BindRaw(this, &amp;FMyClass::Handler); . | Bind~(), Add~(), Execute(), Broadcast() 등의 멤버 함수를 사용해 연결/호출 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-사용하기"
  },"522": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 종류",
    "content": "1. 단일 캐스트 델리게이트 (Single-cast Delegates) . | 하나의 함수만 바인딩 가능 | DECLARE_DELEGATE 매크로로 선언 | 반환 값이 있을 경우 DECLARE_DELEGATE_RetVal 사용 | . DECLARE_DELEGATE(FMyDelegate); // 기본 형태 DECLARE_DELEGATE_OneParam(FMyDelegateWithParam, FString); // 매개변수 하나 DECLARE_DELEGATE_RetVal_OneParam(int32, FMyDelegateWithReturn, FString); // 반환 값과 매개변수 // 사용 예 FMyDelegate MyDelegate; MyDelegate.BindUObject(this, &amp;AMyClass::MyFunction); MyDelegate.Execute(); . 2. 멀티캐스트 델리게이트 (Multi-cast Delegates) . | 여러 함수를 동시에 바인딩 가능 | DECLARE_MULTICAST_DELEGATE 매크로로 선언 | 반환 값 지원 안함 | . DECLARE_MULTICAST_DELEGATE(FMyMulticastDelegate); // 사용 예 FMyMulticastDelegate MyMulticastDelegate; MyMulticastDelegate.AddUObject(this, &amp;AMyClass::Function1); MyMulticastDelegate.AddUObject(OtherObject, &amp;AOtherClass::Function2); MyMulticastDelegate.Broadcast(); . 3. 다이나믹 델리게이트 (Dynamic Delegates) . | 블루프린트와 연동 가능 | 시리얼라이즈(직렬화) 지원 | 이름 기반 바인딩으로 런타임에 바인딩 가능 | DECLARE_DYNAMIC_DELEGATE로 선언 | . DECLARE_DYNAMIC_DELEGATE(FMyDynamicDelegate); // 사용 예 FMyDynamicDelegate MyDynamicDelegate; MyDynamicDelegate.BindDynamic(this, &amp;AMyClass::MyFunction); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-종류"
  },"523": {
    "doc": "2. Extend Content Browser Menu",
    "title": "델리게이트 바인딩 메서드",
    "content": "| 메서드 | 대상 유형 | 지원 Delegate 타입 | 자동 해제 | 용도/특징 | 주의점 | . | BindRaw | 일반 C++ 객체 | Single | X | 일반 포인터 대상, Raw C++ 객체 | 수명 관리 직접 필요 | . | AddRaw | 일반 C++ 객체 | Multi | X | 멀티캐스트 Delegate에 Raw 객체 바인딩 | 수명 관리 직접 필요 | . | BindUObject | UObject 파생 객체 | Single | O | Unreal UObject에 안전하게 바인딩 | GC 연동, 자동 해제 지원 | . | AddUObject | UObject 파생 객체 | Multi | O | 멀티캐스트 Delegate에 UObject 바인딩 | GC 연동, 자동 해제 지원 | . | BindSP | TSharedPtr 객체 | Single | O | TSharedPtr 기반 객체에 안전하게 바인딩 | WeakPtr로 자동 해제 | . | AddSP | TSharedPtr 객체 | Multi | O | 멀티캐스트 Delegate에 TSharedPtr 바인딩 | WeakPtr로 자동 해제 | . | BindLambda | 람다(익명함수) | Single | X | 임시 람다식 함수 직접 바인딩 | 캡처 객체 수명 주의 | . | AddLambda | 람다(익명함수) | Multi | X | 멀티캐스트 Delegate에 람다 함수 추가 | 캡처 객체 수명 주의 | . // Raw MyDelegate.BindRaw(this, &amp;FMyClass::Func); // this는 일반 C++ 객체 // UObject MyDelegate.BindUObject(this, &amp;UMyObject::Func); // this는 UObject 파생 클래스 // SharedPtr MyDelegate.BindSP(MySharedPtr, &amp;FMySharedClass::Func); // Lambda MyDelegate.BindLambda([](){ /* ... */ }); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#%EB%8D%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/#델리게이트-바인딩-메서드"
  },"524": {
    "doc": "2. Extend Content Browser Menu",
    "title": "2. Extend Content Browser Menu",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/2.%20Extend%20Content%20Browser%20Menu/"
  },"525": {
    "doc": "2. Moving Objects With Code",
    "title": "2. Moving Objects With Code",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/"
  },"526": {
    "doc": "2. Moving Objects With Code",
    "title": "FRotator",
    "content": "FRotator::FRotator(float InPitch, float InYaw, float InRoll) . | 매개변수: . | InPitch: Up/Down (-90°~+90° 권장) . | - : 아래 | + : 위 | . | InYaw: Left/Right (-180°~+180°) . | -: 왼쪽 (반시계) | +: 오른쪽 (시계) | . | InRoll: 비틀기 (-180°~+180°) . | -: 왼쪽 (↙) | +: 오른쪽 (↘) | . | . | . | 회전 종류 | 기준 축 | 평면 변화 | 비유 | . | Pitch | Y축 | XZ 평면 | 캐릭터가 머리를 위아래로 끄덕임 | . | Yaw | Z축 | XY 평면 | 캐릭터가 좌우로 고개를 돌려 방향 전환 | . | Roll | X축 | YZ 평면 | 비행기의 날개가 좌우로 기울어지는 동작 | . | Pitch 제한 : Pitch는 일반적으로 -90°~+90°로 제한됨 . | Pitch가 ±90°일 때 Gimbal Lock 발생 가능 → FQuat 사용 권장 | . | Yaw/Roll 범위: 360° 회전 시 정규화 | . 사용예시 . FRotator NewRotation(0.0f, 0.0f, 0.0f); // 초기화 NewRotation.Pitch = -45.0f; // 아래 45도로 고개 숙임 NewRotation.Yaw = -90.0f; // 왼쪽 90도로 방향 전환 NewRotation.Roll = 30.0f; // 오른쪽 30도로 몸체 기울이기 FRotator Rot(370.0f, -190.0f, 0.0f); // 360도 이상 일 때 정규화 FRotator Normalized = Rot.GetNormalized(); // (10°, 170°, 0°) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#frotator",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#frotator"
  },"527": {
    "doc": "2. Moving Objects With Code",
    "title": "SetActorLocation",
    "content": "벡터 통해 액터 위치 설정하기 . void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); SetActorLocation(FVector(0.f, 0.f, 50.f)); // 액터 위치 설정 FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorlocation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorlocation"
  },"528": {
    "doc": "2. Moving Objects With Code",
    "title": "SetActorRotation",
    "content": "void AItem::BeginPlay() { Super::BeginPlay(); UWorld* World = GetWorld(); SetActorLocation(FVector(0.f, 0.f, 50.f)); SetActorRotation(FRotator(0.f, 45.f, 0.f)); // 액터 회전 설정 FVector Location = GetActorLocation(); FVector Forward = GetActorForwardVector(); DRAW_VECTOR(Location, Location + Forward * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorrotation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#setactorrotation"
  },"529": {
    "doc": "2. Moving Objects With Code",
    "title": "Actor Wolrd Offset",
    "content": ". | BP . | Add Actor World Offset | Add Actor World Rotation | . | . 프레임 속도 조절 . | Edit -&gt; Project Settings | frame rate 검색 | Use Fixed Frame Rate 체크 | 원하는 프레임 수 설정 | . | 프레임 따라 움직이기 . | 프레임은 들쭉날쭉 하기때문에 비율로 조절해야 속도가 일정하게 찍힘 | . | . void AItem::Tick(float DeltaTime) { Super::Tick(DeltaTime); // movement rate in units of cm/s float MovementRate = 50.f; float RotationRate = 45.f; // MovementRate * DeltaTime (cm/s) * (s/frame) = (cm/frame) AddActorWorldOffset(FVector(MovementRate * DeltaTime, 0.f, 0.f)); AddActorWorldRotation(FRotator(0.f, RotationRate * DeltaTime, 0.f)); DRAW_SPHERE_SingleFrame(GetActorLocation()); DRAW_VECTOR_SingleFrame(GetActorLocation(), GetActorLocation() + GetActorForwardVector() * 100.f); } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#actor-wolrd-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/2.%20Moving%20Objects%20With%20Code/#actor-wolrd-offset"
  },"530": {
    "doc": "Math",
    "title": "Math",
    "content": " ",
    "url": "/docs/Math/",
    
    "relUrl": "/docs/Math/"
  },"531": {
    "doc": "Coding Standard",
    "title": "Coding Standard",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/"
  },"532": {
    "doc": "Coding Standard",
    "title": "저작권 고지",
    "content": "배포하는 모든 소스 파일(.h, .cpp, .xaml 등)에는 파일의 첫 줄에 반드시 다음과 같은 저작권 공지가 포함되어야 한다. // Copyright Epic Games, Inc. All Rights Reserved. 해당 줄이 없거나 형식이 다르면 오류 -&gt; 빌드 실패 처리됨 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A0%80%EC%9E%91%EA%B6%8C-%EA%B3%A0%EC%A7%80",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#저작권-고지"
  },"533": {
    "doc": "Coding Standard",
    "title": "클래스 구성",
    "content": "클래스는 읽는 사람을 우선으로 구성해야 한다. 대부분 클래스를 읽는 사람들은 public 인터페이스를 사용한다. 따라서 클래스는 . | public | protected | private | . 순으로 작성한다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-구성"
  },"534": {
    "doc": "Coding Standard",
    "title": "클래스 접두사",
    "content": "언리얼 엔진의 클래스에는 접두사가 있다. 해당 접두사를 알고있으면 어떤 클래스에서 파생됐는지 알 수 있다. | 접두사 | 클래스 | 예시 | . | A | AActor | AActor, APawn, AGameMode | . | U | UObject | UTexture, UBlueprintFunctionLibrary | . | S | SWidget | SButton, Swidget | . | F | 사용자 구조체 | FVector, FHitResult | . | I | 추상 인터페이스 | IInterface | . | T | 템플릿 클래스 | TArray&lt;T&gt;, TMap&lt;&lt;T&gt; | . | E | Enum 타입 | EGAmeState | . | G | globals 전역변수 | GEngine | . | b | Boolean 변수 | bHasFadedIn, bDied | . 사용예시 . typedef TArray&lt;FMytype&gt; FArrayOfMyTypes; . typedef에는 해당 타입에 적합한 문자가 접두사로 붙어야 한다. 위 예시는 사용자 구조체 타입을 받는 템플릿 클래스다. ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%91%EB%91%90%EC%82%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#클래스-접두사"
  },"535": {
    "doc": "Coding Standard",
    "title": "네이밍 규칙",
    "content": ". | 단어 사이에 언더스코어(_) 를 사용하지 않는다 | 단어의 첫 글자는 대문자로 표기한다 . | 예: MouseCoordinates (o), delta_x (x) | . | 타입명에는 추가로 대문자 접두사를 붙여 변수명과 구분한다 . | 예: FSkin (타입), Skin (FSkin 타입의 인스턴스) | . | 모든 변수는 한줄씩 선언한다 | 반환값이 있는 함수는 이름만으로 반환값을 명확히 한다 . | O: bool IsTeaFresh(FTea Tea) True 의미 명확 | X: bool CheckTea(FTea Tea) 어떤걸 반환할지 의미 불명확 | . | 반환값이 없는 절차 함수는 강한 동사+목적어 형식 . | 메서드의 목적어가 자기 자신이면 (맴버 함수) 생략 가능 | Handle, Process 등 모호한 동사 피하기 | . | bool 반환 함수는 항상 Yes/No 질문 형태를 취한다 . | IsVisible(), ShouldClearBuffer() | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#네이밍-규칙"
  },"536": {
    "doc": "Coding Standard",
    "title": "Const 정확성",
    "content": ". | 함수 인자가 함수 내에서 변경되지 않는다면, const pointer 또는 const reference로 전달 | 객체를 변경하지 않는 메서드는 const로 명시 | 컨테이너를 수정하지 않는 반복문은 const 반복자 사용 | . 사용예시 . void SomeMutatingOperation(FThing&amp; OutResult, const TArray&lt;Int32&gt;&amp; InArray) { // InArray는 수정되지 않음, OutResult는 아마 수정될것임 } void FThing::SomeNonMutatingOperation() const { // 이 코드는 FThing을 변경하지 않음 } TArray&lt;FString&gt; StringArray; for (const FString&amp; : StringArray) { // 반복문 내부에서 StringArray를 수정하지 않음 } . | 반환 타입에 const 사용 금지 (컴파일 경고 발생) . | 단 const 레퍼런스, 포인터 반환은 허용 | . | . // 좋은 예시 - const 참조 반환 const TArray&lt;FString&gt;&amp; GetSomeArray(); // 좋은 예시 - const 포인터 반환 const TArray&lt;FString&gt;* GetSomeArray(); // 나쁜 예시 - const 배열 반환 const TArray&lt;FString&gt; GetSomeArray(); // 나쁜 예시 - const 포인터를 const로 반환 const TArray&lt;FString&gt;* const GetSomeArray(); . | 포인터 자체를 const로 만들 때는 타입 뒤에 const . | 포인터가 가리키는 값이 아닌, 포인터 자체의 재할당을 막음 | . | . // 포인터는 재할당 불가, T는 변경 가능 T* const Ptr = ...; // 잘못된 사용: 불가(레퍼런스는 재할당 불가 특성상 의미 없음) T&amp; const Ref = ...; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-%EC%A0%95%ED%99%95%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#const-정확성"
  },"537": {
    "doc": "Coding Standard",
    "title": "주석",
    "content": ". | 클래스 주석 . | 이 클래스가 해결하는 문제 | 클래스 생성 이유 | . | 함수 (메서드) 주석 . | 함수 목적 기입 | . | 매개변수 주석 @param . | 측정 단위 | 예상 값 범위 | 불가능한 값 | 상태/오류 코드 의미 | . | 반환값 주석 @return . | 예상 반환 값 | . | 추가 정보 . | @warning 경고, @See보기 등을을 선택적으로 사용함 | . | . 사용예시 . /** The interface for drinkable objects. */ class IDrinkable { public: /** * Called when a player drinks this object. * @param OutFocusMultiplier - 반환 시, 마시는 사람의 집중력에 곱할 배수를 담는다. * @param OutThirstQuenchingFraction - 반환 시, 갈증 해소 정도(0~1)를 담는다. * @warning 반드시 음료가 제대로 준비된 후 호출해야 함. */ virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) = 0; }; /** 단일 찻잔 */ class FTea : public IDrinkable { public: /** * 주어진 물의 부피와 온도로 우려냈을 때, 차의 맛 변화량을 계산 * @param VolumeOfWater - 우릴 때 사용된 물의 양(mL) * @param TemperatureOfWater - 물의 온도(Kelvin) * @param OutNewPotency - 우려낸 후 차의 효능(0.97~1.04) * @return 차의 맛 강도 변화량(1분당 TTU) */ float Steep( const float VolumeOfWater, const float TemperatureOfWater, float&amp; OutNewPotency ); /** 설탕 당도 기준으로 감미를 추가 */ void Sweeten(const float EquivalentGramsOfSucrose); /** 일본 내 판매가(엔) */ float GetPrice() const { return Price; } virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) override; private: /** 가격(엔) */ float Price; /** 감미(설탕 환산 그램) */ float Sweetness; }; . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%A3%BC%EC%84%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#주석"
  },"538": {
    "doc": "Coding Standard",
    "title": "차후 더 추가 예정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%B0%A8%ED%9B%84-%EB%8D%94-%EC%B6%94%EA%B0%80-%EC%98%88%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#차후-더-추가-예정"
  },"539": {
    "doc": "Coding Standard",
    "title": "사용가능한 표준 라이브러리 목록",
    "content": ". | &lt;atomic&gt; : 신규 코드는 std::atomic 사용. 기존 TAtomic은 부분 구현만 되어 있음. | &lt;type_traits&gt; : 겹치는 부분은 표준 trait 사용. (표준 trait는 value/type 소문자, 기존 UE는 대문자 Value/Type 주의) | &lt;initializer_list&gt; : braced initializer 지원에 필수, 대체재 없음 | &lt;regex&gt; : 직접 사용 가능하나 에디터 전용 코드에 한정. 자체 구현 계획 없음. | &lt;limits&gt; : std::numeric_limits 전부 사용 가능 | &lt;cmath&gt; : 부동소수점 비교 함수만 사용 허용 | . 참고 링크 . | Coding Standard | Recommended Asset Naming Conventions | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/#%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%91%9C%EC%A4%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AA%A9%EB%A1%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/#사용가능한-표준-라이브러리-목록"
  },"540": {
    "doc": "3. Slate Widget",
    "title": "목표 : 에디터 확장을 더 깊게 다루기 위해 슬레이트(Slate) 코드를 직접 작성해보자",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EB%AA%A9%ED%91%9C--%EC%97%90%EB%94%94%ED%84%B0-%ED%99%95%EC%9E%A5%EC%9D%84-%EB%8D%94-%EA%B9%8A%EA%B2%8C-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8slate-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%9E%91%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#목표--에디터-확장을-더-깊게-다루기-위해-슬레이트slate-코드를-직접-작성해보자"
  },"541": {
    "doc": "3. Slate Widget",
    "title": "슬레이트가 어렵게 느껴지는 이유",
    "content": ". | 슬레이트 코드는 고유의 문법을 가지고 있다 . | 일반적인 C++ 코드와 매우 다르다 | . | 시각화가 어렵다 . | 위젯 레이아웃을 전부 코드로만 해야 한다는 것이 문제 | 변경한 내용을 바로바로 미리보기로 확인할 수 없다 | . | 다른 모듈과의 연동 . | 다른 모듈과 데이터를 주고받고 상호작용하는 것이 바로 연동(communication)이다 | 이 부분이 슬레이트 위젯을 구현할 때 가장 어렵고 중요하다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8%EA%B0%80-%EC%96%B4%EB%A0%B5%EA%B2%8C-%EB%8A%90%EA%BB%B4%EC%A7%80%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#슬레이트가-어렵게-느껴지는-이유"
  },"542": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터",
    "content": "모듈 간의 데이터 전달 문제(communication issue)를 해결하기 위해서는 반드시 이해해야 할 중요한 개념 . 언리얼 엔진에서는 new 키워드를 직접 써서 객체를 만들도록 허용하지 않는다 . | new 키워드로 메모리를 할당할 일이 있다면, 반드시 스마트 포인터와 함께 쓴다 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터"
  },"543": {
    "doc": "3. Slate Widget",
    "title": "UE에서 지원하는 스마트 포인터",
    "content": ". | Shared Pointer (TSharedPtr) | Shared Reference (TSharedRef) | Weak Pointer (TWeakPtr) | Unique Pointer (TUniquePtr) | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#ue%EC%97%90%EC%84%9C-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#ue에서-지원하는-스마트-포인터"
  },"544": {
    "doc": "3. Slate Widget",
    "title": "TSharedPtr (Shared Pointer, 공유 포인터)",
    "content": ". | 소유권(Owning) 보유: Shared Pointer는 해당 객체의 소유권을 갖는다 이 포인터가 존재하는 한 객체는 삭제되지 않음 . | 참조 카운팅(reference counting) 방식: 이 객체를 참조하는 Shared Pointer/Reference가 모두 사라지면 자동으로 삭제 . | null 할당 가능: 아직 가리키는 대상이 없어도 선언만 할 수 있다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Get() | 포인터가 가리키는 객체의 raw 포인터 반환 | T* | . | IsValid() | 포인터가 유효한 객체를 가리키는지 확인 | bool | . | Reset() | 포인터가 가리키는 객체 해제 | void | . | Pin() | TWeakPtr에서 TSharedPtr로 변환 (유효한 경우) | TSharedPtr&lt;T&gt; | . | ToSharedRef() | TSharedPtr을 TSharedRef로 변환 | TSharedRef&lt;T&gt; | . | GetSharedReferenceCount() | 참조 카운트 반환 | int32 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedptr-shared-pointer-%EA%B3%B5%EC%9C%A0-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedptr-shared-pointer-공유-포인터"
  },"545": {
    "doc": "3. Slate Widget",
    "title": "TSharedRef (Shared Reference, 공유 참조)",
    "content": "Shared Pointer와 거의 동일하지만 항상 유효한 객체만 가리킬 수 있다 . | null 할당 불가능: 항상 유효한 인스턴스가 존재해야 하므로, 슬레이트 함수 반환값 등에서 주로 사용 . | 따라서 Shared Reference는 언제나 Shared Pointer로 변환할 수 있다 . | 유효한 Shared Pointer는 언제나 Shared Reference로 변환이 가능하다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Get() | 포인터가 가리키는 객체의 raw 포인터 반환 | T* | . | IsValid() | 항상 true 반환 (TSharedRef는 null이 될 수 없음) | bool (항상 true) | . | ToSharedPtr() | TSharedRef를 TSharedPtr로 변환 | TSharedPtr&lt;T&gt; | . | GetSharedReferenceCount() | 참조 카운트 반환 | int32 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedref-shared-reference-%EA%B3%B5%EC%9C%A0-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tsharedref-shared-reference-공유-참조"
  },"546": {
    "doc": "3. Slate Widget",
    "title": "TWeakPtr (Weak Pointer, 약한 참조)",
    "content": ". | 소유권을 갖지 않음: Weak Pointer는 객체의 소유권이 없음 객체가 삭제되는 것을 막지 않는다 . | “참조 순환(Reference Cycle)” 문제를 해결할 때 매우 유용하다 즉, 객체가 살아있을 때만 약하게 참조하고, 객체가 삭제되면 자동으로 무효(null)가 된다 . | 사용할 때마다 “이 객체가 아직 살아 있나요?”라고 먼저 체크해야 하며, 살아있으면 사용할 수 있다 . | . 주요 메서드 . | 메서드 | 설명 | 반환 타입 | . | Pin() | 유효한 경우 TSharedPtr로 변환, 아니면 null | TSharedPtr&lt;T&gt; | . | IsValid() | 가리키는 객체가 아직 유효한지 확인 | bool | . | Expired() | 가리키는 객체가 더 이상 유효하지 않은지 확인 | bool | . ❓게임 개발에서는 잘 안 보이는 이유? . | 스마트 포인터들은 UObject 기반 오브젝트에서는 쓸 수 없다 | UObject 시스템 자체가 고유한 메모리 관리(가비지 컬렉션)를 사용하기 때문 | Object 포인터를 직접 스마트 포인터로 관리하면 엔진의 GC 시스템과 충돌이 생김 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tweakptr-weak-pointer-%EC%95%BD%ED%95%9C-%EC%B0%B8%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#tweakptr-weak-pointer-약한-참조"
  },"547": {
    "doc": "3. Slate Widget",
    "title": "스마트 포인터 생성",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#스마트-포인터-생성"
  },"548": {
    "doc": "3. Slate Widget",
    "title": "MakeShareable",
    "content": ". | 작동 방식: 이미 힙에 할당된 객체(raw pointer)를 스마트 포인터로 감쌈 | 효율성: 객체 생성과 참조 카운트 관리를 분리해서 처리하므로 메모리 할당이 2번 발생 . | 이미 존재하는 객체를 감싸는 유일한 방법일 때 유용 | . | 제한 사항: 객체가 public 생성자를 가져야 함 (private/protected 생성자 불가) . | 객체가 이미 생성되어 있어야 함 | . | . // MakeShareable 예제 class MyClass { public: MyClass() {} }; // public 생성자 필요 TSharedPtr&lt;MyClass&gt; Ptr = MakeShareable(new MyClass()); . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshareable",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshareable"
  },"549": {
    "doc": "3. Slate Widget",
    "title": "MakeShared",
    "content": ". | 작동 방식: 객체와 참조 카운트 컨트롤 블록을 한 번에 할당 | 효율성: 단일 메모리 할당으로 객체와 컨트롤 블록을 함께 할당하므로 일반적으로 더 나은 캐시 지역성 . | 하지만 UE 구현상의 이유로 실제로는 MakeShareable보다 약간 느릴 수 있음 | . | 장점: private/protected 생성자도 사용 가능 (Friend 선언으로 접근 가능) . | 더 현대적인 C++ 스타일 | . | . // MakeShared 예제 class MyClass { friend TSharedFromThis&lt;MyClass&gt;; MyClass() {} }; // private 생성자 가능 TSharedPtr&lt;MyClass&gt; Ptr = MakeShared&lt;MyClass&gt;(); . | 함수 | 설명 | 반환 타입 | . | MakeShared&lt;T&gt;(Args...) | 새로운 객체를 생성하고 TSharedRef 반환 | TSharedRef&lt;T&gt; | . | MakeShareable(new T) | 기존 객체를 스마트 포인터로 감싸기 | TSharedPtr&lt;T&gt; | . | StaticCastSharedPtr&lt;NewType&gt;() | 타입 안전한 static 캐스트 | TSharedPtr&lt;NewType&gt; | . | ConstCastSharedPtr&lt;NewType&gt;() | const 캐스트 | TSharedPtr&lt;NewType&gt; | . 슬레이트 위젯을 만들 때 자주 사용됨 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshared",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#makeshared"
  },"550": {
    "doc": "3. Slate Widget",
    "title": "커스텀 Slate 레이아웃 구현 과정",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%BB%A4%EC%8A%A4%ED%85%80-slate-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EA%B5%AC%ED%98%84-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#커스텀-slate-레이아웃-구현-과정"
  },"551": {
    "doc": "3. Slate Widget",
    "title": "1. Slate 위젯 클래스 정의",
    "content": ". | 대부분의 커스텀 슬레이트 위젯은 SCompoundWidget을 상속 | . #pragma once #include \"Widgets/SCompoundWidget.h\" class SMyCustomLayout : public SCompoundWidget {}; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-%EC%9C%84%EC%A0%AF-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#1-slate-위젯-클래스-정의"
  },"552": {
    "doc": "3. Slate Widget",
    "title": "2. Slate 속성 매크로(Arguments) 활용",
    "content": "| 매크로 | 역할 | 예시 | . | SLATE_ARGUMENT | “불변 값” 1회성 복사(생성자 인자) | SLATE_ARGUMENT(FText, Title) | . | SLATE_ATTRIBUTE | “동적 값”(TAttribute 바인딩) | SLATE_ATTRIBUTE(int32, Count) | . | SLATE_EVENT | “이벤트/Delegate” (콜백 함수) | SLATE_EVENT(FOnClicked, OnButtonClicked) | . | SLATE_ARGUMENT: 위젯의 생성자(Construct)에 전달될 “불변 값” 인자 | SLATE_ATTRIBUTE: 바인딩 가능한 동적 값(속성) . | TAttribute로 선언되어 외부의 값을 실시간으로 바꿀 수 있음 | . | SLATE_EVENT: Slate Delegate/이벤트(함수, 람다 등 콜백) | . // CustomButtonPanel.h class SCustomButtonPanel : public SCompoundWidget { public: SLATE_BEGIN_ARGS(SCustomButtonPanel) {} // 슬레이트 속성 정의 SLATE_ARGUMENT(FText, Title) SLATE_ARGUMENT(TArray&lt;FText&gt;, ButtonLabels) SLATE_EVENT(FOnInt32Selected, OnButtonSelected) SLATE_END_ARGS() void Construct(const FArguments&amp; InArgs); private: // 위젯 상태 변수 TArray&lt;FText&gt; ButtonLabels; FOnInt32Selected OnButtonSelected; }; . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-%EC%86%8D%EC%84%B1-%EB%A7%A4%ED%81%AC%EB%A1%9Carguments-%ED%99%9C%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#2-slate-속성-매크로arguments-활용"
  },"553": {
    "doc": "3. Slate Widget",
    "title": "3. Construct 함수 구현",
    "content": ". | ChildSlot을 이용해 Slate 레이아웃 선언 | ChildSlot(컨테이너의 루트)에 원하는 레이아웃 위젯(예: SVerticalBox, SHorizontalBox 등)으로 하위 위젯을 배치 | . void SMyCustomLayout::Construct(const FArguments&amp; InArgs) { Title = InArgs._Title; ChildSlot [ SNew(SVerticalBox) + SVerticalBox::Slot() .AutoHeight() [ SNew(STextBlock).Text(FText::FromString(Title)) ] + SVerticalBox::Slot() .FillHeight(1.0f) [ SNew(SButton) .Text(NSLOCTEXT(\"MyCustomLayout\", \"Button\", \"Click Me\")) // .OnClicked(....) ] ]; } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#3-construct-함수-구현"
  },"554": {
    "doc": "3. Slate Widget",
    "title": "4. Slate 스타일 및 Theme 적용",
    "content": ". | FSlateStyleSet을 사용해 스타일 정의 | FSlateBrush로 브러시 설정 | FSlateFontInfo로 폰트 설정 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B0%8F-theme-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#4-slate-스타일-및-theme-적용"
  },"555": {
    "doc": "3. Slate Widget",
    "title": "5. 이벤트 처리",
    "content": ". | 마우스/키보드 이벤트 바인딩 | 델리게이트를 사용한 커스텀 이벤트 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#5-이벤트-처리"
  },"556": {
    "doc": "3. Slate Widget",
    "title": "언리얼 에디터 슬레이트 계층 구조",
    "content": ". | 루트 레벨 (FSlateApplication) . | 모든 슬레이트 위젯의 최상위 관리자 . | 입력 이벤트, 렌더링 순서, 포커스 관리 | SMainFrame과 독립적인 팝업 창(SWindow_Standalone)을 자식으로 가짐 | . | . | 메인 프레임 (SMainFrame) . | 에디터 메인 창 (가장 바깥 윈도우) . | 상속 구조: SWindow → SMainFrame | . | . | 도킹 시스템 (SDockingArea) . | 탭/분할 레이아웃을 관리하는 컨테이너 | 여러 SDockTabStack(탭 묶음)을 포함하는 도킹 가능 영역 . | SSplitter : 수직/수평 영역 분할 | SDockTabStack : 탭 그룹 (ex. 왼쪽/가운데/오른쪽 스택) | SDockTab : 사용되는 실제 개별 패널 (ex. 콘텐츠 브라우저, 디테일 패널) | . | . | 탭 컨텐츠 (SDockTab → SCompoundWidget) . | 각 탭의 실제 UI 구현체 . | 커스텀 위젯은 반드시 SCompoundWidget을 상속받아 구현 | . | . | 기본 위젯 (Leaf Nodes) . | 최하위에 위치하는 실제 UI 요소 . | SextBlock, SButton, SImage 등 | . | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%90%EB%94%94%ED%84%B0-%EC%8A%AC%EB%A0%88%EC%9D%B4%ED%8A%B8-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/#언리얼-에디터-슬레이트-계층-구조"
  },"557": {
    "doc": "3. Slate Widget",
    "title": "3. Slate Widget",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/3.%20Slate%20Widget/"
  },"558": {
    "doc": "3. The Pawn Class",
    "title": "3. The Pawn Class",
    "content": "플레이어나 AI가 제어할 수 있는 액터를 나타내는 기본 클래스 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/"
  },"559": {
    "doc": "3. The Pawn Class",
    "title": "특징",
    "content": ". | 제어 가능성 . | 플레이어 컨트롤러나 AI 컨트롤러에 의해 제어될 수 있음 | . | 입력 처리 . | 플레이어 입력을 받을 수 있음 | SetupPlayerInputComponent() 메서드를 통해 입력 바인딩 설정 | . | 움직임 시스템 . | 기본적인 움직임 컴포넌트 제공 | UPawnMovementComponent 또는 그 파생 클래스 사용 | . | 카메라 처리 . | 기본적인 카메라 뷰 관리 기능 제공 | UCameraComponent를 사용하여 뷰 설정 가능 | . | 물리적 표현 . | 콜리전(충돌) 메시를 가지고 물리적 상호작용 가능 | USkeletalMeshComponent 또는 UStaticMeshComponent로 시각적 표현 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#특징"
  },"560": {
    "doc": "3. The Pawn Class",
    "title": "Actor 클래스와 차이점",
    "content": "| 특징 | Pawn 클래스 | Actor 클래스 | . | 제어 가능성 | 플레이어/AI에 의해 제어 가능 | 일반적으로 자동화된 동작만 수행 | . | 입력 처리 | 직접적인 입력 처리 가능 | 입력 처리 불가능 (별도 컴포넌트 필요) | . | 움직임 | 내장된 움직임 시스템 | 기본 움직임 시스템 없음 | . | 목적 | 게임 내 조종 가능한 엔티티 | 일반적인 게임 오브젝트 | . | 컨트롤러 | 컨트롤러에 연결 가능 | 컨트롤러 연결 불가 | . | 기본 컴포넌트 | 기본적인 움직임 컴포넌트 포함 | 빈 상태로 생성 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#actor-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%B0%A8%EC%9D%B4%EC%A0%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#actor-클래스와-차이점"
  },"561": {
    "doc": "3. The Pawn Class",
    "title": "컨트롤러 활성화",
    "content": "에디터에서 플레이어 컨트롤러 활성화 . | 사용할 Pawn 클릭 | Detail 패널에서 Pawn 검색 | Auto Poeese Player (플레이어 자동 빙의)에서 플레이어 설정 | . C++에서 플레이어 컨트롤러 활성화 . //생성자에서 AutoPossessPlayer = EAutoReceiveInput::Player0; . 단축키 . | 마우스 커서 활성화: 게임 플레이 상태에서 Shift + F1 | 컨트롤러 분리 : 마우스 커서 활성화 후 Detach 컨트롤러 아이콘 클릭 or 단축키 F8 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#컨트롤러-활성화"
  },"562": {
    "doc": "3. The Pawn Class",
    "title": "Switch Project UE Version",
    "content": ". | 버전을 바꾸고싶은 프로젝트의 ~.uproject 우클릭 | 추가 옵션 표시 클릭 | Switch Unreal Engine Version 클릭 | 원하는 버전 클릭하고 ok | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#switch-project-ue-version",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/3.%20The%20Pawn%20Class/#switch-project-ue-version"
  },"563": {
    "doc": "1. Quick Asset Actions",
    "title": "1. Quick Asset Actions",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/"
  },"564": {
    "doc": "1. Quick Asset Actions",
    "title": "에셋 액션",
    "content": "언리얼 에디터에서 에셋(Asset)에 대해 사용자가 직접 수행할 수 있는 특정 동작/명령 . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%97%90%EC%85%8B-%EC%95%A1%EC%85%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#에셋-액션"
  },"565": {
    "doc": "1. Quick Asset Actions",
    "title": "동작 방식 (5.3 이상)",
    "content": ". | C++에서 UAssetActionUtility 기반 커스텀 클래스 생성 . | UAssetActionUtility는 언리얼이 제공하는 에디터 확장용 베이스 클래스 | 이 클래스를 상속받아 C++ 또는 블루프린트에서 커스텀 명령(함수)을 구현 | . | 함수에 UFUNCTION(CallInEditor) 매크로 등록 . | 에디터에서 호출 가능한 함수로 등록 | 함수명은 명확하게 작성 | . | 에디터 유틸리티 블루프린트(Asset Action Utility BP) 생성 . | 플러그인 또는 프로젝트의 콘텐츠 브라우저에서 생성 | 부모 클래스로 1번에서 만든 커스텀 C++ 클래스를 선택 | (에디터가 이 BP 인스턴스를 통해 실제 액션을 인식) | . | 동작 실행 . | 에디터에서 에셋을 우클릭 → “스크립팅된 에셋 액션”에서 등록된 함수가 메뉴에 나타남 | 클릭 시 실제 동작 수행 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#동작-방식-53-이상"
  },"566": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈",
    "content": "모듈은 언리얼 엔진의 구성 블록이다. 에디터를 만들려면 자신만의 모듈을 만들어야 한다. ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈"
  },"567": {
    "doc": "1. Quick Asset Actions",
    "title": "모듈에서 알아야 할 세가지 주요 포인트",
    "content": ". | 모듈은 코드 분리를 강제한다. | 여러 개의 무작위 코드들이 서로 소통해야 할 때 매우 유용하다 | . | 모든 모듈은 Build.cs 파일이 필요하다. | 새 프로젝트 자체도 하나의 모듈이다. | 모듈은 자신의 빌드 파일을 가진다. [ModuleName].Build.cs [ProjectName].Build.cs . | . | 모듈은 Build.cs 파일에 추가하여 포함할 수 있다. | 다른 모듈에 위치한 헤더 파일을 포함해야 할 때 해당 헤더의 모듈 이름을 Build.cs 파일에 추가한다. | 보통 PublicDependencyModuleNames에 모듈 이름을 추가하는 경우가 많다 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%AA%A8%EB%93%88%EC%97%90%EC%84%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EC%84%B8%EA%B0%80%EC%A7%80-%EC%A3%BC%EC%9A%94-%ED%8F%AC%EC%9D%B8%ED%8A%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#모듈에서-알아야-할-세가지-주요-포인트"
  },"568": {
    "doc": "1. Quick Asset Actions",
    "title": "플러그인 생성하기",
    "content": ". | 언리얼 상단 메뉴 Edit &gt; Plugins 클릭 | 왼쪽 상단의 +ADD 버튼 클릭 | 여러가지 템플릿 목록에서 선택 (현재는 Blank 선택) . | 플러그인 이름이 곧 모듈 이름이다. | 한번 정하면 변경할 수 없다. | . | Create Plugin 버튼 클릭 | 비주얼 스튜디오로 돌아가 모두 로드 버튼 클릭 . | 프로젝트 소스 폴더 위에 플러그인 폴더 생성된 것 확인 | . | . // .uplugin \"Modules\": [ { \"Name\": \"BackgroundTool\", \"Type\": \"Editor\", // 만들 기능은 에디터 전용이므로 Runtime(게임 동작시 실행되는 타입) -&gt; Editor로 변경 \"LoadingPhase\": \"PreDefault\" // 플러그인이 언제 로드될지 결정함. PreDefault: 게임 모듈보다 먼저 로드됨 } ] . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#플러그인-생성하기"
  },"569": {
    "doc": "1. Quick Asset Actions",
    "title": "액터와 에셋",
    "content": ". | 에셋 : 콘텐트 브라우저 안에 존재하는 것 (머티리얼, 스태틱 매시 등) . | 에셋은 AssetActionUtility라는 내장 클래스를 사용 | . | 액터 : 레벨(뷰) 안에 존재하며 클릭할 수 있는 것 . | 액터는 ActorActionUtility라는 클래스를 사용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EC%95%A1%ED%84%B0%EC%99%80-%EC%97%90%EC%85%8B",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#액터와-에셋"
  },"570": {
    "doc": "1. Quick Asset Actions",
    "title": "Public/Private",
    "content": ". | 모듈을 하나 생성할 때 Pubilc, Private 폴더를 나눠서 생성할 수 있음 . | Pubilc : 헤더 | Private : cpp 소스 코드 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#publicprivate"
  },"571": {
    "doc": "1. Quick Asset Actions",
    "title": "build.cs",
    "content": ". | 인클루드 된 헤더에 빨간 밑줄 : 현재 모듈이 이 헤더 파일에 접근할 권한 없음 | . 접근권한 해결하기 . | 솔루션 탐색기에서 해당 헤더 검색 후 헤더가 들어있는 모듈 찾기 | 해당 모듈의 build.cs 소스 코드에 각각 private, pubilc 모듈 경로를 찾을수 있음 | 내가 쓸 build.cs에 private, pubilc에 해당하는 경로 붙여넣기 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#buildcs"
  },"572": {
    "doc": "1. Quick Asset Actions",
    "title": "테스트용 에셋 함수 구동하기 (5.3 이상)",
    "content": "함수 준비하기 : 플러그인 콘텐트 . | 플러그인의 콘텐트 폴더로 이동 | 플러그인 콘텐트 브라우저에서 마우스 오른쪽 버튼 클릭 | 에디터 유틸리티 -&gt; 에디터 유틸리티 블루 프린트 -&gt; 에셋 액션 유틸리티 선택하여 생성 | 더블 클릭하여 해당 에셋을 열고 우측 상단의 파일 클릭 | 부모 블루프린트 -&gt; 내가 만든 c++ 클래스 입력 | 컴파일 및 저장 클릭 | . 이 과정이 없으면 에디터는 사용자가 만든 에셋 액션을 전혀 인식하지 못함 . | C++ 클래스 = 설계도 | 에셋 액션 유틸리티 BP 에셋 = 실제 완성품 (에디터가 사용할 수 있는 인스턴스) | . 함수 사용하기 . | 메인 콘텐트에서 Blueprint 폴더 생성 | Blueprint 클래스 생성 | 해당 클래스 우클릭 -&gt; Scripted Asset Actions | 플러그인 콘텐트에서 추가한 c++ 클래스가 보임 | 클릭하여 동작 확인 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9A%A9-%EC%97%90%EC%85%8B-%ED%95%A8%EC%88%98-%EA%B5%AC%EB%8F%99%ED%95%98%EA%B8%B0-53-%EC%9D%B4%EC%83%81",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#테스트용-에셋-함수-구동하기-53-이상"
  },"573": {
    "doc": "1. Quick Asset Actions",
    "title": "디버그 헤더 만들기",
    "content": ". | 플러그인 안의 폴더를 오른쪽 버튼으로 클릭 | 새 항목 추가 선택 | 추가 창이 뜨면 위치를 플러그인 -&gt; 모듈 -&gt; public 폴더로 선택 | 만들 유형 헤더로 선택하고 Debug.h 이름 지정 | Debug.h의 함수를 사용할 cpp 파일에 #include “Debug.h” 추가 | . void PrintMessage(const FString&amp; Message, const FColor&amp; Color) { if (GEngine) { GEngine-&gt;AddOnScreenDebugMessage(-1, 8.f, Color, Message); // 화면 좌상단에 출력 } } void PrintLog(const FString&amp; Message) { UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *Message); // 콘솔 로그창에 출력 } . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%94%94%EB%B2%84%EA%B7%B8-%ED%97%A4%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#디버그-헤더-만들기"
  },"574": {
    "doc": "1. Quick Asset Actions",
    "title": "단축키",
    "content": ". | UE 상단에서 툴 -&gt; visual studio 새로고침 선택 | Ctrl + B : vs studio 빌드 | Ctrl + F5 : 편집기 (엔진) 실행 | Ctrl + Alt + F11 : 라이브 코딩 실행 | Alt + F12(피킹 정의) : Quick Info 주석 보기 | Ctrl + ` : 터미널 | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#%EB%8B%A8%EC%B6%95%ED%82%A4",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/1.%20Quick%20Asset%20Actions/#단축키"
  },"575": {
    "doc": "1. The Actor Class",
    "title": "1. The Actor Class",
    "content": "월드에 배치되는 독립적 객체 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/"
  },"576": {
    "doc": "1. The Actor Class",
    "title": "클래스 생성",
    "content": ". | 에디터 상단의 도구 (Tools) 클릭 | New C++ Class 클릭 | 엔진에서 제공하는 클래스 선택 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#클래스-생성"
  },"577": {
    "doc": "1. The Actor Class",
    "title": "언리얼 모듈 Public/Private 폴더",
    "content": "New C++ Class 를 통해 생성할 때 어디에 클래스를 생성할지 선택하게 된다 . | 폴더명 | 용도 및 특징 | . | Public | 다른 모듈(외부)에서 사용할 수 있게 공개하려는 헤더 파일 | . |   | 즉, ‘외부에 노출’되는 API/클래스/함수의 헤더(.h) 파일을 여기에 둠 | . | Private | 모듈 내부에서만 사용할 클래스/구현 파일 | . |   | 보통 소스(.cpp) 파일, 혹은 외부에 노출하지 않아도 되는 헤더(.h) 파일을 둠 | . | Public 폴더 : 다른 모듈에서 #include 가능 | Private 폴더 : 원칙적으로 해당 모듈 외부에서 #include 할 수 없음 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AA%A8%EB%93%88-publicprivate-%ED%8F%B4%EB%8D%94",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#언리얼-모듈-publicprivate-폴더"
  },"578": {
    "doc": "1. The Actor Class",
    "title": "Super::",
    "content": "상위 클래스의 함수를 호출할 때 사용되는 접두사 . | 부모(상위) 클래스의 함수, 생성자, 멤버 등에 접근할 때 사용 | . void AMyActor::BeginPlay() { Super::BeginPlay(); // 부모 클래스의 BeginPlay() 호출 // 이 아래에 자식에서의 추가 동작 구현 } . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#super",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#super"
  },"579": {
    "doc": "1. The Actor Class",
    "title": "Blueprint Creation",
    "content": "생성한 C++ 기반 클래스를 블루 프린트로 가져오기 . | 에디터 우클릭 -&gt; 블루 프린트 클래스 클릭 | ALL Classes에 가져오고 싶은 클래스 검색 | 선택 후 BP_ 붙여 네이밍하기 | 클래스 기반 블루 프린트 생성 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#blueprint-creation",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#blueprint-creation"
  },"580": {
    "doc": "1. The Actor Class",
    "title": "사용한 메서드 정리",
    "content": "GetWorld() . UWorld* UObject::GetWorld() const; . | 매개변수: 없음 | 리턴값: 현재 객체가 속한 월드의 포인터를 반환 . | 대부분의 Actor, Component 등에서 사용 가능 | . | . GetActorLocation() . FVector AActor::GetActorLocation() const; . | 매개변수: 없음 | 리턴값: FVector (액터의 월드 공간 위치) . | 액터가 현재 월드에서 어느 좌표에 있는지 반환 | . | . GetActorForwardVector() . FVector AActor::GetActorForwardVector() const; . | 매개변수: 없음 | 리턴값: FVector (액터의 앞 방향 벡터(Forward), 정규화됨) . | 로컬 Z축이 아닌, 로컬 X축 기준 (언리얼은 X가 Forward) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#사용한-메서드-정리"
  },"581": {
    "doc": "1. The Actor Class",
    "title": "Custom Header Files",
    "content": "매크로 전용 헤더 파일 만들기 . | Visual Studio 로 사용자 모듈 열기 | Games/사용자모듈/Source/사용자모듈이름 우클릭 | Add -&gt; New item 클릭 | 만들 종류로 헤더 파일 선택 -&gt; 헤더 이름 정하기 | 헤더가 들어갈 폴더 지정해주기 . | 예: 사용자 모듈\\Source\\사용자 모듈 이름 | . | . 참고하면 좋은 링크 . | Actor Lifecycle | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#custom-header-files",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/1.%20The%20Actor%20Class/#custom-header-files"
  },"582": {
    "doc": "C++ in UE",
    "title": "C++ in UE",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/"
  },"583": {
    "doc": "C++ in UE",
    "title": "Setting up Visual Studio",
    "content": "비주얼 스튜디오 세팅하기 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#setting-up-visual-studio",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#setting-up-visual-studio"
  },"584": {
    "doc": "C++ in UE",
    "title": "지도 스크롤 사용",
    "content": ". | 상단의 도구 -&gt; 설정 | 텍스트 편집기 -&gt; 모든 언어 | 스크롤 막대 -&gt; 세로 스크롤 막대에 지도 모드 사용 체크 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%A7%80%EB%8F%84-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#지도-스크롤-사용"
  },"585": {
    "doc": "C++ in UE",
    "title": "외부 종속성 숨기기",
    "content": ". | 텍스트 편집기 -&gt; C/C++ | 고급 -&gt; 검색/탐색 | 외부 종속성 폴더 숨기기 true 로 변경 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%99%B8%EB%B6%80-%EC%A2%85%EC%86%8D%EC%84%B1-%EC%88%A8%EA%B8%B0%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#외부-종속성-숨기기"
  },"586": {
    "doc": "C++ in UE",
    "title": "매크로 보기",
    "content": ". | 텍스트 편집기 -&gt; C/C++ | 뷰 -&gt; 비활성 코드 | 비활성 블록 표시 -&gt; False | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#매크로-보기"
  },"587": {
    "doc": "C++ in UE",
    "title": "Classes and Inheritance",
    "content": "클래스 상속 다이어그램 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#classes-and-inheritance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#classes-and-inheritance"
  },"588": {
    "doc": "C++ in UE",
    "title": "클래스에서 “Is A” VS “Has A”",
    "content": ". | Is A : 상속 관계 . | 예 : a Child is a Parent | 예 : a Child is not a Grandchild | . | Has A : 맴버 변수, 속성을 가지다 . | 예: a Package has a World | 예: a Level has Actors | . | . | 월드는 패키지의 서브 객체 | 레벨은 월드의 서브 객체 | 액터는 레벨의 서브 객체 | 컴포넌트는 액터의 서브 객체 | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C-is-a-vs-has-a",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#클래스에서-is-a-vs-has-a"
  },"589": {
    "doc": "C++ in UE",
    "title": "UE_LOG",
    "content": "로깅을 위한 핵심 매크로. UE_LOG 사용 시 로그 메시지를 파일에 자동으로 저장 . | 기본적으로 최대 10MB까지 기록되며, 초과 시 새 파일 생성 | . #define UE_LOG(LogCategory, Verbosity, Format, ...) \\ UE_LOG_IMPL(LogCategory, Verbosity, Format, ##__VA_ARGS__) . 사용 예시 . UE_LOG(LogTemp, Warning, TEXT(\"This is a warning message!\")); . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#ue_log",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#ue_log"
  },"590": {
    "doc": "C++ in UE",
    "title": "주의 사항",
    "content": "1. TEXT() 매크로 필수 . | 모든 문자열 포맷 TEXT()로 감싸기 | . UE_LOG(..., TEXT(\"Value: %.2f\"), 123.456); // 올바른 사용 UE_LOG(..., \"Value: %.2f\", 123.456); //컴파일 오류 . 2. FString 전달 . | FString은 반드시 * 연산자로 역참조하기 FString Name = \"Unreal\"; UE_LOG(..., TEXT(\"Engine: %s\"), *Name); . | . 3. 소수점 자릿수 초과 시 반올림 . | 사용자가 지정한 n의 다음 자리에서 반올림 | . float Value = 1.23456f; // UE_LOG 출력 테스트 UE_LOG(LogTemp, Warning, TEXT(\"%.0f\"), Value); // 1 (1.2에서 반올림) UE_LOG(LogTemp, Warning, TEXT(\"%.1f\"), Value); // 1.2 (1.23에서 반올림) . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#주의-사항"
  },"591": {
    "doc": "C++ in UE",
    "title": "LOG 파일 경로",
    "content": ". | 개발 중 (에디터/게임 실행 시) . | 프로젝트루트/Saved/Logs/ 폴더 내에 생성 | 파일명 형식: 프로젝트명.log (예: MyProject.log) | . | 패키징된 빌드 (Shipping 빌드) . | Windows: %LOCALAPPDATA%\\[프로젝트명]\\Saved\\Logs\\ | Mac/Linux: ~/Library/Logs/[프로젝트명]/ 또는 ~/.config/[프로젝트명]/Logs/ | . | 크래시 로그 . | 크래시 발생 시 Saved/Crashes/ 폴더에 별도 로그 저장됨 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-%ED%8C%8C%EC%9D%BC-%EA%B2%BD%EB%A1%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-파일-경로"
  },"592": {
    "doc": "C++ in UE",
    "title": "LOG 시스템 설정",
    "content": "1. 로그 파일 설정 . | DefaultEngine.ini | . [Core.Log] Global=Verbose // 기본 로그 레벨 설정 LogConsole=Warning // 콘솔 출력 레벨 LogFile=Log // 파일 기록 레벨 . 2. 런타임 로그 필터링 . // 특정 카테고리만 파일에 기록 (콘솔 명령어) Log LogMyCategory Verbose // 상세 기록 Log LogNoisyCategory Off // 해당 카테고리 기록 중지 . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#log-시스템-설정"
  },"593": {
    "doc": "C++ in UE",
    "title": "LogCategory 정리",
    "content": "| 카테고리 | 설명 | 사용 예시 | . | LogTemp | 임시 로깅용 (별도 정의 필요 없음) | UE_LOG(LogTemp, Warning, TEXT(“Temp message”)) | . | LogInit | 초기화 관련 로그 | UE_LOG(LogInit, Display, TEXT(“System initialized”)) | . | LogExit | 종료/해제 관련 로그 | UE_LOG(LogExit, Verbose, TEXT(“Resource released”)) | . | LogStreaming | 리소스 스트리밍 관련 | UE_LOG(LogStreaming, Display, TEXT(“Level streaming complete”)) | . | LogPhysics | 물리 시스템 관련 | UE_LOG(LogPhysics, Warning, TEXT(“Collision detected”)) | . | LogAI | AI 시스템 관련 | UE_LOG(LogAI, Verbose, TEXT(“Behavior tree updated”)) | . | LogAnimation | 애니메이션 시스템 | UE_LOG(LogAnimation, Error, TEXT(“Missing animation sequence”)) | . | LogNet | 네트워킹 관련 | UE_LOG(LogNet, Display, TEXT(“Packet received”)) | . | LogInput | 입력 시스템 관련 | UE_LOG(LogInput, Verbose, TEXT(“Controller input detected”)) | . | 사용자 정의 | DECLARE_LOG_CATEGORY_EXTERN으로 생성 | UE_LOG(LogMyGame, Log, TEXT(“Custom log”)) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#logcategory-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#logcategory-정리"
  },"594": {
    "doc": "C++ in UE",
    "title": "Verbosity 정리",
    "content": "| 레벨 | 설명 | 출력 대상 | 사용 예시 | . | Fatal | 치명적 오류 (크래시 발생) | 모든 출력 | UE_LOG(…, Fatal, TEXT(“Critical failure”)) | . | Error | 복구 불가능한 오류 | 에디터/콘솔/파일 | UE_LOG(…, Error, TEXT(“Invalid object”)) | . | Warning | 경고 (문제 가능성) | 에디터/콘솔/파일 | UE_LOG(…, Warning, TEXT(“Deprecated function”)) | . | Display | 일반 정보 (기본 레벨) | 에디터/콘솔/파일 | UE_LOG(…, Display, TEXT(“Level loaded”)) | . | Log | 일반 디버그 정보 | 에디터/파일 | UE_LOG(…, Log, TEXT(“Debug value: %d”), Value) | . | Verbose | 상세 디버그 정보 | 파일 (기본 설정) | UE_LOG(…, Verbose, TEXT(“Detailed trace”)) | . | VeryVerbose | 매우 상세한 정보 | 파일 (필터링 시) | UE_LOG(…, VeryVerbose, TEXT(“Frame-by-frame data”)) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#verbosity-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#verbosity-정리"
  },"595": {
    "doc": "C++ in UE",
    "title": "Format 정리",
    "content": "| 데이터 타입 | 포맷 스타일 | 사용 예시 | . | 기본 정수 | %d | UE_LOG(LogTemp, Display, TEXT(“Score: %d”), 42) | . | 8진수 | %o | UE_LOG(LogHex, Verbose, TEXT(“Octal: %o”), 42) | . | 16진수 (소문자) | %x | UE_LOG(LogHex, Verbose, TEXT(“Hex: 0x%x”), 255) | . | 16진수 (대문자) | %X | UE_LOG(LogHex, Verbose, TEXT(“Hex: 0x%X”), 255) | . | 부동소수점 (기본) | %f | UE_LOG(LogPhysics, Warning, TEXT(“Gravity: %f”), 9.8f) | . | 부동소수점 (고정) | %.2f | UE_LOG(LogMath, Display, TEXT(“PI: %.2f”), 3.141592) | . | 과학적 표기법 | %.3e | UE_LOG(LogSci, Log, TEXT(“Atomic: %.3e”), 0.000000123) | . | Bool (텍스트 변환) | %s + 삼항 연산자 | UE_LOG(LogSystem, Log, TEXT(“IsActive: %s”), bIsActive ? TEXT(“True”) : TEXT(“False”)) | . | 포인터 주소 | %p | UE_LOG(LogMemory, Warning, TEXT(“Ptr: %p”), MyObject) | . ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#format-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/C++%20in%20UE/#format-정리"
  },"596": {
    "doc": "Linear Algebra",
    "title": "Linear Algebra",
    "content": ". ",
    "url": "/docs/Math/linear%20algebra/",
    
    "relUrl": "/docs/Math/linear%20algebra/"
  },"597": {
    "doc": "Linear Algebra",
    "title": "lining up the variable",
    "content": "미지수가 3개인 방정식을 행렬로 만들어보자 . 예시 . \\[\\begin{cases} 2x + 3y - z = 11\\\\ 7y = 6 - x -4z\\\\ -8z + 3 = y \\end{cases}\\] . | 위와 같은 미지수가 3개인 방정식이 있다고 할 때, x y z = c 와 같은 꼴로 정리한다. | . \\[\\begin{cases} 2x + 3y - z = 11\\\\ x + 7y +4z = 6 \\\\ 0x - y -8z = -3 \\end{cases}\\] . | 그 후 값을 행렬에 넣어준다 | . \\[\\begin{pmatrix} \\begin{array}{ccc|c} 2 &amp; 3 &amp; -1 &amp; 11\\\\ 1 &amp; 7 &amp; 4 &amp; 6 \\\\ 0 &amp; -1 &amp; -8 &amp; -3 \\end{array} \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#lining-up-the-variable",
    
    "relUrl": "/docs/Math/linear%20algebra/#lining-up-the-variable"
  },"598": {
    "doc": "Linear Algebra",
    "title": "행렬 연산 표기",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/#%ED%96%89%EB%A0%AC-%EC%97%B0%EC%82%B0-%ED%91%9C%EA%B8%B0",
    
    "relUrl": "/docs/Math/linear%20algebra/#행렬-연산-표기"
  },"599": {
    "doc": "Linear Algebra",
    "title": "Switching two rows",
    "content": "행을 맞바꿀 때 사용하는 기호 . \\[{R_1 \\leftrightarrow R_2}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{R_1 \\leftrightarrow R_2} \\begin{pmatrix} 4 &amp; 5 &amp; 6 \\\\ 1 &amp; 2 &amp; 3 \\\\ \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#switching-two-rows",
    
    "relUrl": "/docs/Math/linear%20algebra/#switching-two-rows"
  },"600": {
    "doc": "Linear Algebra",
    "title": "Multplying a row by a constant",
    "content": "행에 곱셈을 할 때 사용하는 기호 . \\[{2R_1 \\rightarrow R_1}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{2R_1 \\rightarrow R_1} \\begin{pmatrix} 2 &amp; 4 &amp; 6 \\\\ 4 &amp; 5 &amp; 6 \\end{pmatrix}\\] . ",
    "url": "/docs/Math/linear%20algebra/#multplying-a-row-by-a-constant",
    
    "relUrl": "/docs/Math/linear%20algebra/#multplying-a-row-by-a-constant"
  },"601": {
    "doc": "Linear Algebra",
    "title": "Add a row to another row",
    "content": "행에 덧셈을 할 때 사용하는 기호 . \\[{R_1 + R_2 \\rightarrow R_1}\\] . | 예시 | . \\[\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{pmatrix} \\xrightarrow{R_1 + R_2 \\rightarrow R_1} \\begin{pmatrix} 5 &amp; 7 &amp; 9 \\\\ 4 &amp; 5 &amp; 6 \\end{pmatrix}\\] . 참고하면 좋은 링크 . | 선형대수 1: 벡터 공간과 열 공간 | . ",
    "url": "/docs/Math/linear%20algebra/#add-a-row-to-another-row",
    
    "relUrl": "/docs/Math/linear%20algebra/#add-a-row-to-another-row"
  },"602": {
    "doc": "Operations on two matrices",
    "title": "Operations on two matrices",
    "content": "두 행렬에 대한 연산 . ",
    "url": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/",
    
    "relUrl": "/docs/Math/linear%20algebra/Operations%20on%20two%20matrices/"
  },"603": {
    "doc": "Matrices as vectors",
    "title": "Matrices as vectors",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/",
    
    "relUrl": "/docs/Math/linear%20algebra/Matrices%20as%20vectors/"
  },"604": {
    "doc": "Computer Graphics",
    "title": "Computer Graphics",
    "content": "참고 링크 . | GAMES101 : 현대 컴퓨터 그래픽 소개 | . ",
    "url": "/docs/Computer%20Graphics/",
    
    "relUrl": "/docs/Computer%20Graphics/"
  },"605": {
    "doc": "Graphics rendering pipeline",
    "title": "Graphics rendering pipeline",
    "content": "3D 좌표로 표현된 기하학적 객체의 장면을 2D 디스플레이에 렌더링하는 데 필요한 일련의 단계 . | 참고 링크 Graphics Programming Compendium | 참고 링크 a trip through the graphics pipeline | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/"
  },"606": {
    "doc": "UObject",
    "title": "UObject",
    "content": "언리얼 엔진의 모든 객체 지향 시스템의 기반이 되는 핵심 클래스. | 게임플레이 요소, 컴포넌트, 에셋 등 거의 모든 UE5 객체가 UObject에서 파생됨 | UObject 객체를 생성함으로써 리플렉션, 가비지 컬렉션(GC), 직렬화 등의 기능을 사용할 수 있다 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/"
  },"607": {
    "doc": "UObject",
    "title": "개발자가 직접 사용하는 도구 (원인)",
    "content": ". | 객체 생성 및 관리 . | NewObject(), IsValid(), ConditionalBeginDestroy() | . | 라이프사이클 관리 . | PostInitProperties(), BeginDestroy(), AddToRoot() | . | 메타데이터 시스템 . | UPROPERTY(meta=(...)), UFUNCTION() 지정자 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC-%EC%9B%90%EC%9D%B8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#개발자가-직접-사용하는-도구-원인"
  },"608": {
    "doc": "UObject",
    "title": "UObject를 사용함으로써 자동으로 얻는 기능 (결과)",
    "content": ". | 리플렉션 . | UCLASS()로 등록한 클래스가 블루프린트/파이썬에서 자동 인식 | . | 가비지 컬렉션 . | UPROPERTY() 참조가 없어지면 GC가 자동으로 객체 제거 | . | 직렬화 . | SaveGame 지정 시 별도 코드 없이도 디스크에 저장 가능 | . | 에디터 통합 . | EditAnywhere 메타데이터로 자동으로 디테일 패널 생성 | . | . UObject 상속 계층 구조 . UObject (최상위 베이스 클래스) ├─ UActorComponent (액터 컴포넌트 베이스) │ ├─ USceneComponent (변환 기능 포함) │ │ ├─ UPrimitiveComponent (렌더링 가능) │ │ │ ├─ UMeshComponent (메시 기반) │ │ │ │ ├─ USkeletalMeshComponent (스켈레탈 메시) │ │ │ │ └─ UStaticMeshComponent (스태틱 메시) │ │ │ └─ ULightComponent (라이트 소스) │ │ └─ UCameraComponent (카메라) │ └─ UAudioComponent (사운드) ├─ AActor (월드 배치 객체) │ ├─ APawn (플레이어/AI 제어 가능) │ │ ├─ ACharacter (캐릭터 메시/이동 포함) │ │ └─ ADefaultPawn (기본 이동 기능) │ └─ AStaticMeshActor (스태틱 메시 배치) ├─ UDataAsset (데이터 전용 에셋) │ ├─ UPrimaryDataAsset (프라이머리 에셋 시스템) │ └─ UAnimSequence (애니메이션 데이터) ├─ UBlueprintFunctionLibrary (블루프린트 함수) │ ├─ UKismetSystemLibrary (시스템 유틸리티) │ └─ UKismetMathLibrary (수학 함수) └─ 기타 주요 클래스 ├─ UGameInstance (게임 인스턴스) ├─ UWorld (월드 컨텍스트) ├─ UUserWidget (UMG 위젯) └─ UMaterial (머티리얼) . 주의사항 . | 스택 할당 금지: 반드시 힙에 생성 (GC 관리 대상이어야 함) | 다중 상속 제한: UObject를 다중 상속할 때는 주의가 필요 (일반적으로 UInterface 사용) | 표준 C++ 타입과의 호환성: std::vector 등은 UPROPERTY()로 표시할 수 없으며, TArray를 사용함 | 아주 가벼운 데이터만 다룰 경우 USTRUCT를 권장 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%96%BB%EB%8A%94-%EA%B8%B0%EB%8A%A5-%EA%B2%B0%EA%B3%BC",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject를-사용함으로써-자동으로-얻는-기능-결과"
  },"609": {
    "doc": "UObject",
    "title": "UObject의 내부 구조",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject의-내부-구조"
  },"610": {
    "doc": "UObject",
    "title": "UClass",
    "content": ". | UClass는 UObject 객체의 청사진 (UObject 타입에 대한 메타데이터와 구조 정보) | 프로퍼티의 이름/타입/위치(오프셋) . | (예: “고양이” 종류의 객체는 “고양이 클래스” DNA를 가짐) | . | 모든 UObject는 자신의 클래스 정보 (UClass)를 가리키는 ClassPrivate 포인터를 갖는다 | . class UClass : public UObject { TArray&lt;UProperty*&gt; Properties; // 프로퍼티 목록 (예: 체력, 공격력) TArray&lt;UFunction*&gt; Functions; // 함수 목록 (예: 점프(), 공격()) UClass* SuperClass; // 부모 클래스 (상속 관계) UObject* ClassDefaultObject; // CDO 포인터 // ... 기타 메타데이터 }; . 동작 예시 . UMyObject* Obj = NewObject&lt;UMyObject&gt;(); UClass* ObjClass = Obj-&gt;GetClass(); // 데이터 추출 . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uclass"
  },"611": {
    "doc": "UObject",
    "title": "CDO (Class Default Object)",
    "content": ". | UClass가 관리하는 특별한 UObject 인스턴스 | 모든 UObject 인스턴스의 초기값을 제공하는 원본 . | (예: “고양이 클래스”의 기본 색상=검정, 기본 체력=100) | . | . | 클래스가 언리얼 모듈에 로드될 때 한 번만 생성됨 | . 내부 구조와 CDO의 관계 다이어그램 . | UClass : 모든 인스턴스가 공유하는 “청사진” | CDO : 인스턴스들이 참조하는 변하지 않는 원본 | UObject 인스턴스 : CDO의 기본값을 복사받아 생성된 개별 객체 | . CDO 접근 방법 . // CDO 얻기 UMyObject* Defaults = GetDefault&lt;UMyObject&gt;(); // 기본값 사용 예시 float DefaultHealth = Defaults-&gt;Health; // 에디터에서 설정한 Health 값 . CDO 실제 활용 . | 에디터 연동 (인스턴스 초기값 세팅) UPROPERTY(EditDefaultsOnly, Category=\"Settings\") float Health; // CDO에서만 편집 가능 . | 런타임 검사 if (MyObj-&gt;Health == GetDefault&lt;UMyObject&gt;()-&gt;Health) { UE_LOG(LogTemp, Warning, TEXT(\"체력이 기본값입니다!\")); } . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#cdo-class-default-object"
  },"612": {
    "doc": "UObject",
    "title": "UObject 객체 생성 과정",
    "content": ". | UClass 로드 : 엔진 시작 시 UMyObject::StaticClass() 호출 → UClass 생성 | CDO 생성 : UClass 초기화 과정에서 GetDefaultObject()가 CDO 생성 | UObject 인스턴스 생성 : NewObject() 시 CDO의 프로퍼티 값을 복사 | . CDO vs 인스턴스 . | 비교 항목 | CDO | 일반 인스턴스 | . | 생성 시점 | 모듈 로드 시 1회 | NewObject() 호출 시 | . | 수정 가능성 | 에디터에서만 (런타임 X) | 런타임 자유롭게 변경 가능 | . | 메모리 위치 | 영구적 (게임 종료 시까지) | GC에 의해 삭제 가능 | . | 용도 | 기본값 템플릿 | 실제 게임 내 객체 | . | 에디터에서 Health=200 변경 → 모든 새 인스턴스는 Health=200으로 생성됨 | 기존 인스턴스는 영향 없음 (이미 생성된 객체는 독립적) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#uobject-객체-생성-과정"
  },"613": {
    "doc": "UObject",
    "title": "ObjectFlags",
    "content": "객체의 상태를 나타내는 비트 플래그 . enum EObjectFlags { RF_Public = 0x00000001, // 에디터에 노출 여부 RF_Transactional= 0x00002000, // Undo/Redo 지원 RF_Transient = 0x00004000, // 임시 객체 (저장 안 됨) // ... 30여 가지 플래그 }; . | UObject 인스턴스는 자신만의 ObjectFlags를 보유 | UClass는 UObject의 파생 클래스이므로, UClass도 자신만의 ObjectFlags를 가짐 | . ObjectFlags 내부 구조 다이어그램 . | UObject 인스턴스의 ObjectFlags: 개별 인스턴스의 런타임 상태 제어 . | 이 객체만의 상태 플래그 | . | UClass의 ObjectFlags: 클래스 전체의 정적 특성 정의, 추상 클래스 여부, 블루프린트 노출 . | 클래스 전체에 적용되는 플래그 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#objectflags"
  },"614": {
    "doc": "UObject",
    "title": "서브오브젝트 시스템 (Subobject System)",
    "content": "다른 UObject (주로 AActor나 UActorComponent)에 종속된 자식 객체 . | “서브오브젝트”란 별도 클래스가 아니라, Outer 체계를 활용한 소유 관계/구조 | 모든 컴포넌트는 서브오브젝트임 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-subobject-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-시스템-subobject-system"
  },"615": {
    "doc": "UObject",
    "title": "서브오브젝트의 특징",
    "content": ". | 생명주기 : 부모 종속 / 부모 객체가 파괴되면 함께 파괴됨 (GC 대상) | 생성 시점 제한 : 반드시 부모의 생성자에서 CreateDefaultSubobject&lt;T&gt;()로 생성해야 함 | 자동 직렬화 : 부모와 함께 저장/로드됨 (에디터에서 편집 가능) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트의-특징"
  },"616": {
    "doc": "UObject",
    "title": "Suboject vs UObject",
    "content": "| 비교 항목 | 서브오브젝트 | 일반 UObject | . | 생성 방법 | CreateDefaultSubobject&lt;T&gt;() (생성자 내에서만 호출 가능) | NewObject&lt;T&gt;() (런타임 어디서나 가능) | . | 생명주기 | 부모 종속(부모 삭제 시 함께 삭제) | 독립적 | . | 에디터 노출 | 부모의 디테일 패널에 자동 표시 | 별도 에셋 또는 인스턴스로 관리 | . | 사용 사례 | 액터의 컴포넌트(Mesh, Camera 등) | 독립적인 데이터 에셋 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#suboject-vs-uobject",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#suboject-vs-uobject"
  },"617": {
    "doc": "UObject",
    "title": "서브오브젝트 구조",
    "content": "class UObject { protected: UObject* Outer; // 상위 객체 (서브오브젝트인 경우 소유자) FName Name; // 고유 이름 (Outer + Name으로 식별) UClass* Class; // 타입 정보 // 기타... }; . | Outer : 서브 오브젝트의 소유자 (예: USceneComponent의 Outer는 일반적으로 소유자 AActor) | Name : 같은 소유자를 가진 그룹에서 고유하게 가져야함 (중복 시 경고 발생) | 블루프린트: 에디터에서 Add Component 버튼으로 추가 가능 | AActor: Actor의 경우 추가로 Components 배열 사용 | . UClass와의 관계 . | UClass는 서브오브젝트 목록을 직접 관리하지 않음 | UPROPERTY 메타데이터를 통해 리플렉션 및 자동 탐색이 이루어짐 | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-구조"
  },"618": {
    "doc": "UObject",
    "title": "서브오브젝트 탐색 방식",
    "content": "1. 리플렉션 기반 탐색 (UPROPERTY) . | UPROPERTY()로 표시된 멤버만 탐색 가능 UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* Comp; // 서브오브젝트는 UPROPERTY로 노출됨 }; . | . 2. Outer 체인 탐색 . | AActor가 아닌 일반 UObject 서브오브젝트를 찾을 때 사용 | . // 모든 서브오브젝트 순회 (예시 코드) TArray&lt;UObject*&gt; Subobjects; GetObjectsWithOuter(MyActor, Subobjects); // MyActor를 Outer로 가진 객체 찾기 // 결과 출력 for (UObject* Obj : Subobjects) { UE_LOG(LogTemp, Warning, TEXT(\"Subobject: %s\"), *Obj-&gt;GetName()); } . 3. AActor 특수 처리 . | AActor만 Components 배열을 명시적으로 별도 관리 | . class AActor : public UObject { TArray&lt;UActorComponent*&gt; Components; // 서브오브젝트 명시적 관리 }; // FindComponentByClass 활용 (최적화된 탐색) UMyComponent* MyComp = FindComponentByClass&lt;UMyComponent&gt;(); . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%83%90%EC%83%89-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-탐색-방식"
  },"619": {
    "doc": "UObject",
    "title": "서브오브젝트 생성 및 과정",
    "content": "// MyActor.h UCLASS() class AMyActor : public AActor { GENERATED_BODY() public: UPROPERTY(VisibleAnywhere) UMyComponent* MyComp; // 서브오브젝트 포인터 AMyActor() { // 생성자에서 서브오브젝트 생성 MyComp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT(\"MyComp\")); } }; . | 생성자 호출 . | 반드시 부모 객체의 생성자 내에서 호출 . | 예외: UActorComponent는 InitializeComponent()에서 추가 초기화 | . | . | 메모리 할당 . | 엔진은 UMyComponent 인스턴스를 생성하고, Outer를 AMyActor로 설정 | . | 이름 등록 . | TEXT(“MyComp”)를 이름으로 지정, 중복 검사 수행 | . | 리플렉션 연동 . | UPROPERTY가 없어도 서브오브젝트 생성 (에디터에서 수정 불가. 블루 프린트 노출 X) | UPROPERTY가 있으면 디테일 패널에 노출 | . | Actor에 등록 . | AActor 전용으로 Actor와 연관된 오브젝트가 아닐 경우 패스됨 | AActor의 경우 Components 배열에 자동 추가 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-생성-및-과정"
  },"620": {
    "doc": "UObject",
    "title": "서브오브젝트 다이어그램",
    "content": ". | 실선: 명시적 참조 (AActor의 Components 배열) | 점선: 암시적 참조 (Outer 포인터) | . ",
    "url": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#%EC%84%9C%EB%B8%8C%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/Unreal%20Engine%205/Coding%20Standard/UObject/#서브오브젝트-다이어그램"
  },"621": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/C++/",
    
    "relUrl": "/docs/C++/"
  },"622": {
    "doc": "C++",
    "title": "스마트 포인터",
    "content": ". | C++11부터 표준 라이브러리에 포함됨 | raw pointer보다 스마트 포인터 사용이 권장됨 | 상황에 맞는 스마트 포인터를 선택하고, 반드시 소유권 규칙을 명확히 해야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0",
    
    "relUrl": "/docs/C++/#스마트-포인터"
  },"623": {
    "doc": "C++",
    "title": "스마트 포인터 종류",
    "content": "1. std::unique_ptr . | 단일 소유권(Exclusive ownership): 오직 하나의 포인터만 객체를 소유 | 소유자가 사라질 때(포인터 scope 종료, 소멸자 호출 등) 자동으로 자원 해제 | 복사가 금지되어 있고, 소유권 이동은 move(이동)만 허용 | 용도: 소유권 이전(transfer)이 명확하고, 참조 카운팅이 필요 없는 객체 | . #include &lt;memory&gt; void func() { std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42); // std::unique_ptr&lt;int&gt; ptr2 = ptr1; // 컴파일 에러! 복사 불가 std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1); // 소유권 이동 } . 2. std::shared_ptr . | 공유 소유권(Shared ownership): 여러 개의 포인터가 동일한 객체를 소유 | 내부적으로 참조 카운트(reference count) 관리 . | (카운트가 0이 되면 자원 해제) | . | 용도: 여러 곳에서 동시에 객체를 소유/관리해야 할 때 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42); std::shared_ptr&lt;int&gt; ptr2 = ptr1; // 복사 가능, 참조 카운트 증가 // ptr1과 ptr2가 모두 소멸되면 메모리 해제 } . 3. std::weak_ptr . | 비소유 참조(Non-owning reference): shared_ptr로 관리되는 객체를 참조하지만, 참조 카운트에는 관여하지 않음 | 주로 순환 참조(circular reference) 방지 목적 | 용도: shared_ptr들 사이에서 서로 참조(특히 그래프, 트리 등)할 때 메모리 누수 방지 | . #include &lt;memory&gt; void func() { std::shared_ptr&lt;int&gt; shared = std::make_shared&lt;int&gt;(42); std::weak_ptr&lt;int&gt; weak = shared; // 소유권 없음, 참조 카운트 변하지 않음 if (auto locked = weak.lock()) { // shared_ptr로 잠금 가능 // 객체가 아직 살아있을 때만 접근 가능 int value = *locked; } } . 스마트 포인터의 장점 . | 자동 메모리 관리: RAII(Resource Acquisition Is Initialization) 패턴 적용 | 예외 안전성: 예외 발생 시에도 자원 누수 없음 | 명확한 소유권 모델: 객체의 라이프사이클이 코드상에서 드러남 | . 스마트 포인터의 단점 . | 순환 참조 문제: shared_ptr만 사용하면 서로를 참조하는 객체들에서 해제가 안 될 수 있음(→ weak_ptr로 해결) | 성능 오버헤드: 특히 shared_ptr의 참조 카운트 갱신 비용 | 사용법 혼동 주의: 소유권 이전/공유 규칙이 코딩 컨벤션으로 정립되어야 함 | . ",
    "url": "/docs/C++/#%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%A2%85%EB%A5%98",
    
    "relUrl": "/docs/C++/#스마트-포인터-종류"
  },"624": {
    "doc": "C++",
    "title": "람다",
    "content": ". | C++11에서 도입된 기능으로, 이름 없는 함수(익명 함수)를 만들 수 있게 해줌 | 간단한 함수 객체(functor)나 콜백(callback) 등을 즉석에서 정의 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#람다"
  },"625": {
    "doc": "C++",
    "title": "기본 문법과 구조",
    "content": "람다 함수의 기본 형태 . // [캡처](매개변수) -&gt; 반환타입 { 함수본문 } [capture](parameters) -&gt; return_type { // 함수 본문 ... } // 예시 [my_mod](int v_) -&gt; int { return v_ % my_mod; } . | [capture] : 외부 변수(스코프 밖의 변수)를 람다 내부에서 사용할 때 어떻게 사용할지 지정 | (parameters) : 함수의 매개변수 목록 | -&gt; return_type : 반환 타입 (void 는 -&gt; 생략 가능 / 컴파일러가 추론) | . ",
    "url": "/docs/C++/#%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95%EA%B3%BC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/C++/#기본-문법과-구조"
  },"626": {
    "doc": "C++",
    "title": "c++98 함수 객체 vs C++11 람다",
    "content": "c++98 . struct Compare { bool operator()(int a, int b) { return a &lt; b; } }; std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), Compare()); // 함수 객체 전달 . c++11 . std::vector&lt;int&gt; v; std::sort(v.begin(), v.end(), [](int a, int b) { return a &lt; b; // 람다로 간결하게 표현 }); . ",
    "url": "/docs/C++/#c98-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-vs-c11-%EB%9E%8C%EB%8B%A4",
    
    "relUrl": "/docs/C++/#c98-함수-객체-vs-c11-람다"
  },"627": {
    "doc": "C++",
    "title": "람다 핵심 개념 : 캡처 리스트",
    "content": "외부 변수를 람다에서 어떻게 참조할지 결정 . | 캡처 형태 | 의미 | 예시 | . | [] | 아무것도 캡처하지 않음 | []() { /* ... */ } | . | [=] | 모든 외부 변수를 값으로 복사 | [=]() { cout &lt;&lt; x; } | . | [&amp;] | 모든 외부 변수를 참조로 사용 | [&amp;]() { x = 42; } | . | [x, &amp;y] | 특정 변수 선택적 캡처 | [x, &amp;y]() { y += x; } | . [] . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 외부 변수 캡처 없음 → 오직 매개변수만 사용 가능 auto lambda = [](int a, int b) { return a + b; }; std::cout &lt;&lt; lambda(3, 5); // 출력: 8 // std::cout &lt;&lt; lambda(x, y); // ⚠️ x, y는 매개변수로 전달해야 함 } . [=] . | 원본 보존 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 값으로 복사 (x, y의 복사본 사용) auto lambda = [=]() { std::cout &lt;&lt; x + y; // 출력: 30 (원본 x, y는 변경되지 않음) }; lambda(); x = 100; // 원본 수정 lambda(); // 출력: 30 (복사본은 영향 없음) } . | 람다가 생성될 때 [=]는 현재 스코프의 모든 변수 (x 등)를 값으로 복사해 저장 . | 람다 객체 내부에 int x_copy = x; 같은 복사본이 생김 | . | 람다는 항상 자신이 가진 복사본(x_copy)을 참조하므로, 원본이 변경되어도 복사본은 변하지 않음 | . [&amp;] . | 원본 제어 필요시 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // 모든 외부 변수를 참조로 캡처 (원본 직접 접근) auto lambda = [&amp;]() { x = 30; // 원본 수정 std::cout &lt;&lt; y; // 출력: 20 }; lambda(); std::cout &lt;&lt; x; // 출력: 30 (람다에서 수정된 값) } . [x, &amp;y] . | 특정 변수만 선택적으로 캡처할 때 사용 | . #include &lt;iostream&gt; int main() { int x = 10, y = 20; // x는 값으로, y는 참조로 캡처 auto lambda = [x, &amp;y]() { y += x; // y는 원본 참조 (y = 20 + 10) // x = 5; // x는 복사본이므로 수정 불가 (mutable 키워드 필요) }; lambda(); std::cout &lt;&lt; y; // 출력: 30 (원본 y 변경됨) } . 참고 링크 . | 람다(lambda) 함수 | . ",
    "url": "/docs/C++/#%EB%9E%8C%EB%8B%A4-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90--%EC%BA%A1%EC%B2%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/C++/#람다-핵심-개념--캡처-리스트"
  },"628": {
    "doc": "C++",
    "title": "아래부터 나중에 추가 정리해야 할 것",
    "content": ". 언리얼 엔진5의 스마트 포인터 UE5는 C++ 표준 라이브러리와의 호환성 문제(예: 모듈 경계, 플랫폼별 동작 차이)로 자체 스마트 포인터를 제공합니다. (1) TSharedPtr&lt;&gt; C++의 std::shared_ptr&lt;&gt;과 유사하지만 UE5 전용 최적화가 적용됨. 관리 대상: UObject를 상속받지 않은 일반 C++ 클래스. 특징: . 참조 카운팅 + 스레드 안전성 지원. TWeakPtr&lt;&gt;으로 약한 참조 가능. MakeShared&lt;&gt;()로 생성 최적화. (2) TUniquePtr&lt;&gt; C++의 std::unique_ptr&lt;&gt;과 거의 동일하지만 UE5 메모리 할당자와 통합됨. 관리 대상: UObject가 아닌 객체. 특징: . 복사 불가능, 이동만 가능. MakeUnique&lt;&gt;()로 생성. (3) FObjectPtr (UE5+) UObject 전용으로 설계된 경량 포인터. C++ 표준과 무관하며, UE5의 가비지 컬렉션 시스템과 연동됩니다. 특징: . UObject의 안전한 참조를 위해 사용 (예: 크로스-스레드 접근 방지). TSharedPtr&lt;&gt;과 달리 참조 카운팅 없이 엔진 내부에서 관리. | C++ vs UE5 스마트 포인터 비교 기능 C++ (std) UE5 차이점 공유 소유권 std::shared_ptr&lt;&gt; TSharedPtr&lt;&gt; UE5는 스레드 안전성 강화. 독점 소유권 std::unique_ptr&lt;&gt; TUniquePtr&lt;&gt; UE5는 할당자 통합. 약한 참조 std::weak_ptr&lt;&gt; TWeakPtr&lt;&gt; 동일한 개념. 가비지 컬렉션 없음 FObjectPtr UObject 전용. 생성 방법 std::make_shared&lt;&gt; MakeShared&lt;&gt; UE5는 커스텀 메모리 풀 사용 가능. | . ",
    "url": "/docs/C++/#%EC%95%84%EB%9E%98%EB%B6%80%ED%84%B0-%EB%82%98%EC%A4%91%EC%97%90-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%A6%AC%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83",
    
    "relUrl": "/docs/C++/#아래부터-나중에-추가-정리해야-할-것"
  },"629": {
    "doc": "Realistic Landscapes",
    "title": "Realistic Landscapes",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/Realistic%20Landscapes/"
  },"630": {
    "doc": "Learn the basics",
    "title": "Learn the basics",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Learn%20the%20basics/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Learn%20the%20basics/"
  },"631": {
    "doc": "Computer architecture",
    "title": "Computer architecture",
    "content": ". | SRISHTI:Computer Architecture | . ",
    "url": "/docs/Computer%20architecture/",
    
    "relUrl": "/docs/Computer%20architecture/"
  },"632": {
    "doc": "GPU Architecture",
    "title": "GPU Architecture",
    "content": "GPU에서 실행되는 애플리케이션 프로그램을 준비할 때 GPU 하드웨어 설계의 주요 기능을 이해하고 CPU와의 유사점과 차이점을 파악하고자 한다. | 참고링크 Conrnell Virtual Workshop | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/"
  },"633": {
    "doc": "Create Custom Editor Tools",
    "title": "Create Custom Editor Tools",
    "content": "빠른 작업 효율 향상을 위해 랜덤 배치 툴을 구현해보자 . 참고 링크 . | AssetRegistry | EditorUtilityLibrary | FMessageDialog | SNotificationList | FSlateNotificationManager | ContentBrowser | . ",
    "url": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Create%20Custom%20Editor%20Tools/"
  },"634": {
    "doc": "Material",
    "title": "Material",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/"
  },"635": {
    "doc": "Unreal Engine 5",
    "title": "Unreal Engine 5",
    "content": "참고하면 좋은 링크 . | UnrealEngine c++ Guide | blueprints vs c++ | Exploring Unreal’s physics framework | Unreal Engine UI Tutorials | Unreal Engine C++ API Reference | UE Classes API | . ",
    "url": "/docs/Unreal%20Engine%205/",
    
    "relUrl": "/docs/Unreal%20Engine%205/"
  },"636": {
    "doc": "Unreal Engine 5",
    "title": "Coordinate System",
    "content": "UE 좌표계는 왼손 좌표계 기준 . | 축 | 방향 | + | - | . | X | 깊이 | 앞(카메라와 멀어짐) | 뒤 (카메라와 가까워짐) | . | Y | 측면 | 오른쪽 | 왼쪽 | . | Z | 높이 | 위 | 아래 | . 참고하면 좋은 링크 . | coordinate-system | Coordinate System and Spaces | . ",
    "url": "/docs/Unreal%20Engine%205/#coordinate-system",
    
    "relUrl": "/docs/Unreal%20Engine%205/#coordinate-system"
  },"637": {
    "doc": "Unreal Engine 5",
    "title": "Level Editor Viewport",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#level-editor-viewport",
    
    "relUrl": "/docs/Unreal%20Engine%205/#level-editor-viewport"
  },"638": {
    "doc": "Unreal Engine 5",
    "title": "카메라 동작",
    "content": ". | 우측 카메라 아이콘으로 속도 조절 가능 . | 왼쪽 클릭 : 카메라 수평 이동 | 오른쪽 클릭 : 카메라 상하 이동 | 왼쪽 클릭 + C : 줌인 (확대) | 클릭 + WASD : 카메라 이동 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%B9%B4%EB%A9%94%EB%9D%BC-%EB%8F%99%EC%9E%91",
    
    "relUrl": "/docs/Unreal%20Engine%205/#카메라-동작"
  },"639": {
    "doc": "Unreal Engine 5",
    "title": "View Modes",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#view-modes",
    
    "relUrl": "/docs/Unreal%20Engine%205/#view-modes"
  },"640": {
    "doc": "Unreal Engine 5",
    "title": "Show",
    "content": "왼쪽 Show (표시)를 이용해 레벨에서 보고 싶은 에셋 플래그 on/off 설정 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#show",
    
    "relUrl": "/docs/Unreal%20Engine%205/#show"
  },"641": {
    "doc": "Unreal Engine 5",
    "title": "Lit",
    "content": "레벨 라이팅 설정 on/off, 와이어 프레임 등 여러가지 설정 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#lit",
    
    "relUrl": "/docs/Unreal%20Engine%205/#lit"
  },"642": {
    "doc": "Unreal Engine 5",
    "title": "perspective",
    "content": "카메라 원근 설정. 직교 투영으로 오브젝트트 배치 편하게 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#perspective",
    
    "relUrl": "/docs/Unreal%20Engine%205/#perspective"
  },"643": {
    "doc": "Unreal Engine 5",
    "title": "맨 우측 화면 분할 아이콘",
    "content": "4개의 개별 뷰포트로 분할 가능 . ",
    "url": "/docs/Unreal%20Engine%205/#%EB%A7%A8-%EC%9A%B0%EC%B8%A1-%ED%99%94%EB%A9%B4-%EB%B6%84%ED%95%A0-%EC%95%84%EC%9D%B4%EC%BD%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/#맨-우측-화면-분할-아이콘"
  },"644": {
    "doc": "Unreal Engine 5",
    "title": "맨 좌측 리스트 아이콘",
    "content": ". | Show FPS 로 프레임 보기 가능 . | ctrl + shift + H | . | Bookmarks 를 통해 시점 저장, 불러오기 가능 . | ctrl + 0 ~ 9 으로 북마크 저장 | 키보드 0 ~ 9 으로 저장한 북마크 불러오기 | . | 게임 뷰 . | 단축키 : G | 아이콘 사라짐 | . | 몰입 모드 . | 단축키 : F11 | 화면 크게 | . | 고해상도 스크린샷 . | 우측 상단 캡처 지정 아이콘 클릭 -&gt; 캡처 사각형 지정 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EB%A7%A8-%EC%A2%8C%EC%B8%A1-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%95%84%EC%9D%B4%EC%BD%98",
    
    "relUrl": "/docs/Unreal%20Engine%205/#맨-좌측-리스트-아이콘"
  },"645": {
    "doc": "Unreal Engine 5",
    "title": "Object manipulate 오브젝트 조종",
    "content": ". | 오브젝트 선택 . | 단축키 : Q | . | 오브젝트 움직이기 (기즈모 사용) . | 단축키 : W | . | 오브젝트 회전 . | 단축키 : E | . | 오브젝트 스케일 조절 . | 단축키 : R | . | . ",
    "url": "/docs/Unreal%20Engine%205/#object-manipulate-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%A1%B0%EC%A2%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/#object-manipulate-오브젝트-조종"
  },"646": {
    "doc": "Unreal Engine 5",
    "title": "스냅",
    "content": "스냅 유무를 아이콘을 통해 on/off. 스냅에 쓸 단위도 조절 가능 . | 그리드 아이콘 : 오브젝트 이동 스냅 | 각도 아이콘 : 오브젝트 회전 각도 스냅 | 스케일 아이콘 : 오브젝트 스케일 스냅 | 표면 스냅 아이콘 : 오브젝트 가져올 때 표면에 어떻게 놓을 것인지 설정 . | on/off로 표면에 딱 붙일 것인지 설정 | 오프셋으로 표면에서 얼마나 떨어트릴 것인지 설정 | 언리얼 엔진의 1 unit = 1cm | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%8A%A4%EB%83%85",
    
    "relUrl": "/docs/Unreal%20Engine%205/#스냅"
  },"647": {
    "doc": "Unreal Engine 5",
    "title": "좌표",
    "content": "오브젝트 조종 옆에 있는 아이콘을 통해 어떤 좌표를 사용할 것인지 조절 가능 . | 단축키 : ctrl + ` | 세계 좌표에 있는 경우 세계 아이콘 표시 | 로컬 좌표에 있는 경우 로컬 아이콘 표시 | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%A2%8C%ED%91%9C",
    
    "relUrl": "/docs/Unreal%20Engine%205/#좌표"
  },"648": {
    "doc": "Unreal Engine 5",
    "title": "오브젝트 복사",
    "content": ". | Alt + 기즈모 이동을 통해 복사 | 여러개 복사하고 싶으면 shift로 오브젝트 다중 선택 후 Alt + 기즈모 이동 . | 회전도 복사 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%B3%B5%EC%82%AC",
    
    "relUrl": "/docs/Unreal%20Engine%205/#오브젝트-복사"
  },"649": {
    "doc": "Unreal Engine 5",
    "title": "Panels 패널",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/#panels-%ED%8C%A8%EB%84%90",
    
    "relUrl": "/docs/Unreal%20Engine%205/#panels-패널"
  },"650": {
    "doc": "Unreal Engine 5",
    "title": "Outliner",
    "content": "world에 있는 모든 오브젝트 목록 . | 아웃라이너에서 오브젝트 이름으로 오브젝트 찾기 가능 | 아웃라이너에서 오브젝트 이름 누른 뒤 F 키를 통해 오브젝트로 이동 | . ",
    "url": "/docs/Unreal%20Engine%205/#outliner",
    
    "relUrl": "/docs/Unreal%20Engine%205/#outliner"
  },"651": {
    "doc": "Unreal Engine 5",
    "title": "Details",
    "content": "선택한 오브젝트 속성 변경 . | Location : 월드 좌표에서의 오브젝트 위치 | Physics . | Simulate physics : 체크 박스에 체크하면 물리학 활성화 | . | . ",
    "url": "/docs/Unreal%20Engine%205/#details",
    
    "relUrl": "/docs/Unreal%20Engine%205/#details"
  },"652": {
    "doc": "Home",
    "title": "Home",
    "content": ". ✨2025-05-02 . | 깃허브 블로그 개설 | 커스텀 설정 추가 (custom.scss) . | site-title font : Darumadrop One 으로 변경 | .nav-list-link : color 수정 | . | . ✨2025-05-03 . | 커스텀 설정 추가 . | 마크다운 font : Noto Sans KR 로 변경 | 인용 블록 : border-radius 추가, 색상 변경 | 코드 블록 : font Rubik 으로 변경, border-radius 추가, Rouge github 테마로 폰트 색상 변경 | . | . ✨2025-05-04 . | 커스텀 설정 추가 . | 테이블 : font IBM Plex Sans KR 로 변경, 라인 색상 변경, 사이드 라인 제거 | 링크 버튼 : btn-purple color 변경 | 인용 블록 종류 추가 : warning, highlight, note, important, new | . | . ✨2025-05-06 . | 로고 추가 | 푸터 추가 | . ✨2025-06-22 . | LaTex 기호 적용 | . ✨2025-07-11 . | 외부 링크 새 탭으로 열리게 적용 | . ",
    "url": "/",
    
    "relUrl": "/"
  }
}
