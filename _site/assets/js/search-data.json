{"0": {
    "doc": "1. GPU 특성",
    "title": "1. GPU 특성",
    "content": ". ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html"
  },"1": {
    "doc": "1. GPU 특성",
    "title": "1. Design: GPU vs. CPU",
    "content": ". GPU는 원래 그래픽 렌더링을 위해 설계되었다. 3D 객체를 구성하는 수천 개의 독립적인 폴리곤을 셰이딩, 텍스처링, 렌더링하는 데 매우 효과적이다. | Core (녹색 영역) : 명령어 실행 및 계산 처리 (연산, 레지스터 조작 등) | Control (금색 영역) : 명령어 해석 및 실행 제어 (제어 신호 생성, 흐름 제어 등) | L1 Cache (보라 영역) : 데이터 / 명령어 저장 (코어에 가장 가까운 고속 캐시 메모리) | L2/L3 chache (파랑 영역) : L1 보다 느리지만 더 큼. L3는 여러 코어 간 공유되는 경우가 많음 | . ☑️ 위 그림으로 알수 있는 점 . | CPU는 GPU만큼 산술 논리 장치나 부동 소수점 장치가 많지 않다. (Core 녹색 영역) . | 하지만 CPU 코어의 ALU와 FPU는 더 많은 기능을 갖추고 있다. | . | CPU는 GPU보다 캐시 메모리가 더 많다. | GPU는 병렬화 될 수 있는 워크로드를 위해 설계되었다. | core의 각 행마다 Control이 하나씩 있는 것으로 나타난다. | . | . | 특징 | CPU | GPU | . | 목적 | 범용 컴퓨팅 (다양한 작업 처리) | 병렬 컴퓨팅 (그래픽 및 대량 데이터 처리) | . | 코어 수 | 적음 (일반적으로 2~64개) | 매우 많음 (수백 ~ 수천 개의 코어) | . | 작업 유형 | 직렬 처리에 최적화 | 병렬 처리에 최적화 | . | 사용 사례 | 운영체제, 일반 소프트웨어, 논리 연산 | 그래픽 렌더링, 머신러닝, 과학 계산 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#1-design-gpu-vs-cpu"
  },"2": {
    "doc": "1. GPU 특성",
    "title": "2. Performance: GPU vs. CPU",
    "content": ". 아래의 그림은 연산 능력을 초당 수십억 번의 부동 소수점 연산( Gflop/s )으로 측정하여 보여준다. | Single Precision (단정밀도) : 부동 소수점 수의 32비트 표현 | Double Percision (배정밀도) : 부동 소수점 수의 64비트 표현 | . 단정밀도는 배정밀도보다 두 배 빠르게 처리될 수 있는 경우가 많다. ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#2-performance-gpu-vs-cpu"
  },"3": {
    "doc": "1. GPU 특성",
    "title": "3. Threads, Cores 재정의",
    "content": ". GPU는 그래픽 파이프라인의 두 가지 핵심 속성을 통해 속도가 가속화된다. | 렌더링은 일반적으로 많은 독립적인 오브젝트 (예:표면을 근사화하는 작은 삼각형 메시)로 구성된다. | 각 오브젝트를 렌더링하는데 필요한 단계의 순서는 기본적으로 모든 오브젝트에 동일하다. | 따라서 계산 단계가 모든 오브젝트에 대해 한번번에 병렬로 수행될 수 있다. | . | . GPU와 CPU 간의 용어 비교 . | GPU 용어 | GPU에서의 간단한 정의 | CPU에서의 대응 개념 | . | Thread | 하나의 CUDA 코어에서 실행되는 명령어와 데이터의 흐름. SIMT 모델에서 실행됨. | 일반적으로 명시적 대응 없음. | . | CUDA Core | SIMT 명령어의 일부를 처리하는 단일 연산 유닛. | 벡터 유닛 내의 벡터 레인 | . | Warp | 32개의 스레드로 구성된 그룹. 서로 다른 데이터에 동일한 명령어 스트림을 함께 실행한다. | 벡터 연산에서의 벡터 | . | Kernel | GPU에서 실행되는 함수. 커널은 여러 스레드 블록으로 구성될 수 있다. | CPU의 스레드 | . | Streaming Multiprocessor (SM) | 스레드 블록을 실행할 수 있는 단위. GPU의 물리적 유닛. | CPU의 코어 | . ❓ 스레드 블록 . | 스레드 블록 (Thread Block) . | 여러 스레드가 모여 하나의 논리적 단위로 구성되는 실행 단위 | . | CUDA 프로그래밍에서 스레드는 블록 단위로 묶여 실행된다. | 하나의 블록은 n ~ n백개의 스레드를 포함할 수 있다. | 블록은 SM(Streaming Multiprocessor)에 배정된다. | . ❓ 명령어 스트림 . | 명령어 스트림 (Instruction Stream) . | 스레드들이 공유하는 명령어의 흐름 (제어 흐름 분기(조건문)가 영향을 줌) | . | 스트림(stream)이라는 말은 일련의 명령어가 순차적으로 흐르는 데이터 흐름을 의미 | SIMT 모델에서 말하는 “명령어 스트림”은 모든 스레드가 따르는 동일한 명령어 흐름 | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-%EC%9E%AC%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#3-threads-cores-재정의"
  },"4": {
    "doc": "1. GPU 특성",
    "title": "4. SIMT (Single Instruction, Multiple Threads)",
    "content": ". | 한 명령어를 여러 스레드가 동시에 실행하는 GPU 실행 모델 | . __global__ void add(int *a, int *b, int *c) { int idx = threadIdx.x; c[idx] = a[idx] + b[idx]; } . | 위 함수가 32개의 스레드에서 실행되면 모든 스레드가 같은 c[idx] = a[idx] + b[idx] 명령어 수행. | 각 스레드는 자신만의 idx 값을 사용해서 다른 데이터에 접근함. | . SIMT에서 제어 흐름 분기 예시 . | SIMT에서는 선택한 스레드를 활성화 또는 비활성화할 수 있다 | . | 활성 스레드: 명령과 데이터 처리. | 비활성 스레드: 아무런 작업도 수행하지 않음. 로컬 데이터가 변경되지 않은 상태로 유지됨. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#4-simt-single-instruction-multiple-threads"
  },"5": {
    "doc": "1. GPU 특성",
    "title": "5. Warps",
    "content": ". | 런타임 시, 스레드 블록은 SIMT 실행을 위해 워프로 나뉜다. | 하나의 완전한 워프는 연속된 스레드 인덱스를 가진 32개의 스레드 묶음으로 구성된다. | 워프에 포함된 스레드들은 32개의 CUDA 코어 집합에 의해 함께 처리된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#5-warps"
  },"6": {
    "doc": "1. GPU 특성",
    "title": "6. Kernels (in software)",
    "content": ". 연결된 GPU 에서 병렬로 실행되도록 설계된 함수를 커널이라고 한다. | C++ 함수 선언 앞에 __global__ 지정자가 있는 것으로 식별된다. | . | 커널은 한 번만 실행되는 것이 아니라, GPU의 N개의 서로 다른 스레드 에 의해 N번 병렬로 실행된다. | 각 스레드에는 메모리 주소를 계산하고 제어 결정을 내리는 데 사용할 수 있는 고유 ID(실제로는 인덱스)가 할당된다. | . CUDA 커널이 스레드 배열에 의해 실행되는 방식 . 커널 호출은 GPU에서 사용할 스레드 수를 지정하는 특수 인수를 제공해야 한다. 특수 인수는 아래와 같다. func&lt;&lt;&lt;1, N&gt;&gt;&gt;(x, y, z) . // 커널 함수 정의: 두 벡터를 더해서 결과 저장 __global__ void addVectors(int *a, int *b, int *c, int N) { int idx = threadIdx.x; if (idx &lt; N) { c[idx] = a[idx] + b[idx]; } } int main() { const int N = 256; // 커널 호출: 블록 1개, 스레드 256개로 구성 addVectors&lt;&lt;&lt;1, N&gt;&gt;&gt;(d_a, d_b, d_c, N); } . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#6-kernels-in-software"
  },"7": {
    "doc": "1. GPU 특성",
    "title": "7. Streaming multiprocessors (in hardware)",
    "content": ". GPU에서 커널 호출은 하나 이상의 스트리밍 멀티프로세서에 의해 실행된다. 각 SM의 CUDA 코어는 항상 32개 세트로 배열되어 SM이 스레드의 전체 워프를 실행하는 데 사용할 수 있다. | GPU가 커널 호출을 실행하는 데 실제로 사용하는 SM의 수는 호출에 지정된 스레드 블록 수로 제한된다. | 예를 들어 fun&lt;&lt;&lt;M, N&gt;&gt;&gt;(x, y, z) 이 있을 때, 각 SM에 할당할 수 있는 블록은 최대 M개이다. | 스레드 블록은 여러 SM으로 분할될 수 없다. | 사용 가능한 SM보다 블록이 많은 경우, 동일한 SM에 여러 블록을 할당할 수 있다. | . | . | 매 사이클 마다 각 SM의 스케줄러 는 사용 가능한 32개의 CUDA 코어 세트에서 실행될 스레드의 전체 워프를 할당한다. | SM에는 레지스터 , L1 캐시 , 상수 캐시, 공유 메모리가 포함된다. | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#7-streaming-multiprocessors-in-hardware"
  },"8": {
    "doc": "1. GPU 특성",
    "title": "☑️ 정리",
    "content": "[Kernel] ↓ ┌────────┐ │ Thread Block 1 │ ←→ SM 1 │ Thread Block 2 │ ←→ SM 2 │ ... │ │ Thread Block N │ ←→ SM n └────────┘ ↓ ↓ Warp 1 Warp 2 ... (각 32개 Thread) ↓ CUDA Core (Thread 실행) . | 하나의 커널(GPU 함수)은 수많은 스레드 블록으로 구성 | 각 스레드 블록은 하나의 SM에 할당되어 실행된다. | SM이 스레드 블록을 실행한다 = 스케줄링, 메모리, 명령어 분배 등 전체 실행을 관리한다 | . | 스레드 블록 내부의 스레드들은 32개 단위로 워프로 나뉨 | 각 스레드는 CUDA 코어에서 개별적으로 연산을 수행한다. | CUDA Core가 연산을 수행한다 = 각 스레드의 명령을 ALU 단위에서 실제 계산으로 처리한다 | . | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#%EF%B8%8F-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/1.%20GPU%20%ED%8A%B9%EC%84%B1.html#️-정리"
  },"9": {
    "doc": "1. Material Basic",
    "title": "1. Material Basic",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html"
  },"10": {
    "doc": "1. Material Basic",
    "title": "1. Data Types",
    "content": "constant - 1 float . constant2Vector - 2 floats . constant3Vector - 3 floats . 어떤 포지션과 묶느냐에 따라 floats 값이 RGB or XYZ 가 될 수 있다. | Base Color에 1 vector, 2 vector 를 넣어도 엔진에서 자동으로 입력을 처리한다. | (r 1, g 0, b 0) 이런 식 | . | Color에서 constant value 값 . | 0 : black | 1 : white | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#1-data-types"
  },"11": {
    "doc": "1. Material Basic",
    "title": "2. Roghness",
    "content": "표면의 반사 정도를 제어 . | 0 : 거울 반사 (정반사) | 1 : 완전 무광 (난반사) | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#2-roghness"
  },"12": {
    "doc": "1. Material Basic",
    "title": "3. Lerp",
    "content": "Linear Interpolation (선형 보간법) 약어 . | 입력 A : 시작 포인트 | 입력 B : 끝 포인트 | 알파 : 보간 계수 (두 값 사이에서 어느 지점에 위치하는지를 나타내는 비율이자 가중치) | 리턴 : 보간된 값 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#3-lerp"
  },"13": {
    "doc": "1. Material Basic",
    "title": "UV Mapping",
    "content": "2D 이미지를 3D 모델 표면에 투영하는 것 . | u : 수평 | v : 수직 | . | Texture coordinate Node . | tiling : 크기가 커질수록 텍스쳐는 작아지고 반복됨 | mutilply 사용으로도 타일링 가능 | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#uv-mapping"
  },"14": {
    "doc": "1. Material Basic",
    "title": "component mask",
    "content": "벡터 배열 중 가져오고 싶은 인덱스만 마스킹 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#component-mask"
  },"15": {
    "doc": "1. Material Basic",
    "title": "append",
    "content": "값1, 값2 합쳐서 매개변수로 사용하고 싶을때 쓰임 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#append"
  },"16": {
    "doc": "1. Material Basic",
    "title": "4. Opacity",
    "content": "투명도를 주고싶으면 블렌드 모드를 바꿔야 함. (디폴트 Opaque(불투명)) . | material blend mode -&gt; Translucent(반투명) 변경 -&gt; Opacity 속성 활성화 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#4-opacity"
  },"17": {
    "doc": "1. Material Basic",
    "title": "5. moving texture",
    "content": ". | speed (음수로 두면 -&gt; 방향으로 감) | time | distance = speed * time | subtract . | -로도 검색 가능 | append를 쓰면 speed에 음수로 방향 | subtract를 쓰면 speed는 늘 양수 (subtract가 뺄셈처리) | . | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#5-moving-texture"
  },"18": {
    "doc": "1. Material Basic",
    "title": "6. Panner",
    "content": "위 무빙 텍스쳐를 쉽게 하나로 만든 형태 . | 입력 coordinate : 텍스쳐 UV 좌표 | 입력 Time : UV 이동에 사용할 시간 값 | 입력 Speed : UV 좌표의 이동 속도를 설정하는 2D vector | 출력 UV : 입력된 UV 좌표를 시간과 속도에 따라 변형한 결과를 출력 | . ❓ 왜 speed 를 양수로 하면 왼쪽으로 가는것 처럼 보일까? . | Speed X 값이 양수일 때, 위의 계산에 따라 UV 좌표의 U 값이 증가 | 이는 텍스처의 샘플링 위치가 오른쪽으로 이동함을 의미 | 따라서 실제로 화면에서 보이는 텍스처는 왼쪽으로 이동하는 것처럼 보임 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#6-panner"
  },"19": {
    "doc": "1. Material Basic",
    "title": "7. Material Instance",
    "content": ". | M_material | MI_materialInstance | . | 머티리얼 인스턴스를 만들고 머티리얼 파라미터를 추가해 빠르게 머티리얼을 수정할 수 있다. | 머티리얼 인스턴스는 창이 다름 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#7-material-instance"
  },"20": {
    "doc": "1. Material Basic",
    "title": "8. Comment",
    "content": ". | 노드 클릭 / 드래그 후 C 버튼 눌러서 주석 달기 가능 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#8-comment"
  },"21": {
    "doc": "1. Material Basic",
    "title": "9. Sine 표현식",
    "content": "사인 함수를 호출하는 노드 . | 입력 : 라디안 단위 각도 | 출력 : 입력의 라디안 사인을 계산한 결과 (-1 ~ 1) | . | 객체를 상하로 흔들거나 파도, 진동 등 주기적 변동 구현에 사용 | 입력값을 라디안 단위로 해석하여 사용함 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-%ED%91%9C%ED%98%84%EC%8B%9D",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#9-sine-표현식"
  },"22": {
    "doc": "1. Material Basic",
    "title": "10. Saturate",
    "content": "0 ~ 1 범위로 한정 시킴 = 클램핑 . 클램핑이 뭐야 ❓Clamp wiki Link . | 입력 : 클램핑할 값 | 출력 : 0 이하 = 0 / 1 이상 = 1 / 그 외 = 원본값 유지 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#10-saturate"
  },"23": {
    "doc": "1. Material Basic",
    "title": "11. Sine_Remapped",
    "content": ". | 입력 sine Phase : 보간 계수 | 입력 Value1 (V3) : 0으로 맵핑될 때 반환할 시작 벡터 | 입력 Value2 (V3) : 1로 맵핑될 때 반환할 목표 벡터 | 출력 Remapped Sine (Vec3) : lerp(val1, val2, (sin(Sine Phase) + 1) / 2) 로 선형보간한 결과 | . | Sine Phase(실수)를 사인파로 계산한 뒤 [-1,1] 범위의 출력을 Value 1 (V3)와 Value 2 (V3) 사이의 벡터로 선형 보간하여 반환 | 내부적으로 sin(Sine Phase)의 결과에 +1을 더해 0~2로 이동시킨 뒤 0.5로 스케일링 하여 0~1 범위로 remap | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#11-sine_remapped"
  },"24": {
    "doc": "1. Material Basic",
    "title": "12. world position offset",
    "content": ". | 입력 World Position Offset (V3) : 오브젝트 버텍스에 더해질 월드 공간 오프셋 벡터 | 출력 (V3): 최종 버텍스 위치 | . | 간단한 이동 애니메이션이나 주기적 바운스 효과(Sind_Remapped 사용) 를 줄 때 사용한다 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#12-world-position-offset"
  },"25": {
    "doc": "1. Material Basic",
    "title": "13. CheapContrast",
    "content": ". | 입력 in (Scalar) : 대비를 조정할 입력 채널 (흑백 값) | 입력 Contrast (Scalar) : 대비 증가 강도. 값이 커질수록 대비 강도 증가 | . | 흑백 마스크 대비 보정할 때 사용 | 내부 동작 수식 Remapped = ( (In – 0.5) * (1 + Contrast) ) + 0.5 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#13-cheapcontrast"
  },"26": {
    "doc": "1. Material Basic",
    "title": "Texture Sample UVs 혼합하기",
    "content": "❓ 흑백 텍스쳐 샘플 노드가 2개 있을 때, 1번 텍스쳐 샘플의 R 채널과 0을 2번 텍스쳐 샘플의 UV로 넣는 과정은 어떤 결과가 나올까? . | (R, 0)은 “2번 텍스쳐의 수평 위치를 1번 택스쳐의 R값으로 조정”한다는 뜻! | 예: R = 0.3 → 2번 텍스쳐의 30% 위치의 색상을 가져옴. | 수직은 0으로 고정이므로 R 값에 따라 수평으로만 왜곡시키는 효과를 냄 | . 과정 상세 설명 . | 1번 텍스쳐 (흑백) / R 채널만 사용 (흑백이므로 R=G=B). 값은 0 ~ 1 사이 | Append 노드로 (R, 0) 생성 / 예 픽셀 R은 0.7 → (0.7, 0) | 2번 텍스쳐에 (R, 0)을 UV로 입력 | 원래 UV가 (0.5, 0.5)라면, 새 UV는 (0.5 + 0.7, 0.5 + 0) = (1.2, 0.5) 같은 식으로 계산. | . 결과 . | 1번 텍스쳐의 밝은 부분(R≈1) → 2번 텍스쳐가 오른쪽으로 밀림. | 어두운 부분(R≈0) → 2번 텍스쳐가 왼쪽으로 수축. | 수직(V) 방향은 0으로 고정되므로 위아래 왜곡은 없음. | . UV 혼합은 그라데이션 왜곡, 노이즈 패턴 변형, 동적 텍스쳐 오프셋 등에 활용 . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-%ED%98%BC%ED%95%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#texture-sample-uvs-혼합하기"
  },"27": {
    "doc": "1. Material Basic",
    "title": "14. Name Reroute Node",
    "content": "Material Editor 전용으로 제공되는 노드. 와이어가 얽히지 않도록 중앙 리루트 지점을 만들어 그래프를 깔끔하게 유지 할 수 있다. | Declaration (선언) 노드 : 오직 입력(Input) 만 갖고, 값을 ‘이름’으로 보관 | Usage: 오직 출력(Output) 만 갖고, 해당 이름의 값을 그래프 전역에 사용 가능. | . 사용방법 . | 와이어 두번 클릭 | 마우스 오른쪽 버튼 클릭 | 이름을 가진 경유 노드로 변환 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#14-name-reroute-node"
  },"28": {
    "doc": "1. Material Basic",
    "title": "15. 1-x / OneMinus",
    "content": "색상 반전, 마스크 반전에 쓰임 . | 입력 input (float) : 연산 대상 X의 값. 스칼라일 경우 단일 채널, 벡터일 경우 각 채널별로 처리 | 출력 float : 계산 결과 1 - Input을 각 채널에 적용한 값 출력 | . | 출력 예시 : OneMinus((0.2, 0.5, 1.0)) → (0.8, 0.5, 0.0) | . 📌 단축키 . | 단축키 | 동작 | . | 숫자 1, 2, 3, 4 키 + 좌클릭 | 해당 constant vector 노드 생성 | . | T + 좌클릭 | texture sample | . | L + 좌클릭 | lerp | . | m + 좌클릭 | multiply | . | alt -&gt; 기즈모 이동 | 오브젝트 복사 | . | ctrl + D | 이전 행동 다시 반복 | . | 좌클릭 + f2 | 파일 이름 변경 | . | S + 좌클릭 | 머티리얼 파라미터 추가 | . | c + 좌클릭 | comment 주석달기 | . | Alt + 핀 클릭 | 모든 연결 끊기 | . ",
    "url": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/1.%20Material%20Basic.html#15-1-x--oneminus"
  },"29": {
    "doc": "2. Master Material",
    "title": "2. Master Material",
    "content": ". ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html"
  },"30": {
    "doc": "2. Master Material",
    "title": "1. Master Material",
    "content": "마스터 머티리얼을 만들고 이 마스터 머티리얼의 여러 인스턴스만 사용하는 방법을 통해 공간 절약, 씬의 성능 상향이 가능함. ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#1-master-material",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#1-master-material"
  },"31": {
    "doc": "2. Master Material",
    "title": "2. Albedo vs Diffuse",
    "content": "베이스 컬러에 쓰이는 텍스쳐가 두 가지 용어를 혼합하여 쓰길래 두 키워드의 차이점이 무엇인지 궁금해졌다. ❓베이스 컬러에 들어가는 알베도와 디퓨즈의 차이점이 뭐지? . | Albedo : 물리 기반 렌더링(PBR)에서 도입. 표면이 반사하는 확산 반사 비율 또는 색상을 의미 | Diffuse : 전통적인 3D 그래픽스에서 디퓨즈 맵은 표면의 기본 색상을 정의한다. 빛의 영향을 받아 명암이 생기는 재질 표현에 사용 | . Albedo vs Diffuse 정리 . | 항목 | Albedo | Diffuse | . | 정의 | 순수한 반사율 (빛의 간섭 없음) | 빛의 난반사로 인한 색상 + 명암 | . | 사용 예 | PBR (물리 기반 렌더링) | 전통적 라이팅 모델 (램버트 반사 등) | . | 데이터 | 환경광의 영향이 제거된 순수 색상 | 그림자/광택 일부 포함 가능 | . | 예시 | Unreal, Unity등에서 PBR 재질의 Base Color로 사용 | Photoshop 등에서 조명까지 표현한 diffuse map 제작 가능 | . | Diffuse 텍스처에는 실제 광원이 없어도 명암이 들어감. | 조명 대응 불가 (광원 위치를 바꿔도 그림자는 바뀌지 않음) | . | . | 텍스처에 조명, 그림자, 반사 등을 “베이크”해서 포함시킨 것 = diffuse map | 조명과 독립적인 순수한 색상. 빛은 셰이더에서 계산함 = Albedo | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#2-albedo-vs-diffuse",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#2-albedo-vs-diffuse"
  },"32": {
    "doc": "2. Master Material",
    "title": "3. Texture Coordinate",
    "content": "UV 매핑을 제어하는 노드로 머티리얼이 메시 표면에 어떻게 텍스쳐를 투영할지 결정한다. | 모델의 각 정점(Vertex)에는 UV 좌표(0~1 범위의 2D 좌표)가 할당되어 있으며, 이 노드는 해당 좌표를 조정하거나 변형할 때 사용할 수 있다. | . | 기본 출력: UV 채널의 2D 벡터(X, Y). 각 성분은 일반적으로 0.0 ~ 1.0 범위 . | X(U): 가로 축 좌표 (좌 → 우) | Y(V): 세로 축 좌표 (하 → 상) | . | Coordinate Index: 다중 UV 채널을 선택할 수 있다. | 정적 메시의 Lightmap UV(UV1) 등 추가 좌표 계층을 활용할 때 유용 | . | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#3-texture-coordinate",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#3-texture-coordinate"
  },"33": {
    "doc": "2. Master Material",
    "title": "4. Vector4",
    "content": ". | Vector4 노드의 R,G,B,A에 각각 U tile, V tile, U offset, V offset 이라고 이름을 붙여 텍스쳐 타일링에 사용할 수 있다. | 타일링 *= multiply | 오프셋 += add | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#4-vector4",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#4-vector4"
  },"34": {
    "doc": "2. Master Material",
    "title": "5. static swich parameter",
    "content": "머티리얼 그래프 내에서 분기를 정의하고, 머티리얼 인스턴스 에디터에서 체크박스로 설정 가능하게 해준다. | 정적(static) 이 붙은 이유 : 런타임에 변경되지 않고 머티리얼 컴파일 타임에 결정됨 | 사용되지 않는 쪽의 분기는 완전히 제거되어 실행 시간이 최적화 | . | 입력 A : A 로직 (스위치가 True일 때 적용) | 입력 B : B 로직 (스위치가 False일 때 적용) | 출력 : True는 A, False는 B 출력 | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#5-static-swich-parameter",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#5-static-swich-parameter"
  },"35": {
    "doc": "2. Master Material",
    "title": "Color Control",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#color-control",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#color-control"
  },"36": {
    "doc": "2. Master Material",
    "title": "RGB 표현",
    "content": "❓언리얼 엔진에서는 RGB가 0~255 값이 아니라고? . | 언리얼에서는 RGB 표현을 정규화된 0~1 범위로 사용한다. | 0~255 와 0~1 두 범위 모두 동일한 색상을 나타내지만, 사용하는 컨텍스트와 시스템에 따라 다른 스케일로 표현된다. | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#rgb-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#rgb-표현"
  },"37": {
    "doc": "2. Master Material",
    "title": "왜 언리얼 엔진은 0~1 범위를 사용할까?",
    "content": ". | 수학적 일관성 . | 3D 그래픽스에서는 벡터 연산이 빈번하게 일어남 | 0~1 범위는 퍼센트 개념과 연결되며, 모든 계산을 비율 기반으로 통일할 수 있다. | 예: 0.5 = 50% 밝기 -&gt; 0.5 * 2.0 = 1.0 (100%) | . | . | HDR (High Dynamic Range) 지원 . | 0~1 범위를 벗어나는 값 (예: 2.0) 으로 더 밝은 빛을 표현할 수 있다. | . | GPU 친화적 . | 현대 GPU는 부동소수점(float) 계산에 최적화되어 있어 0~1 범위가 셰이더 연산과 호환성이 좋다. | . | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#%EC%99%9C-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84%EC%9D%80-01-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#왜-언리얼-엔진은-01-범위를-사용할까"
  },"38": {
    "doc": "2. Master Material",
    "title": "RGB 정규화 방법",
    "content": ". | 0~255 -&gt; 0~1 (정규화) = 값 / 255 | . RGB(255, 127, 0) -&gt; RGB(1.0, 0.498, 0.0) . | 0~1 -&gt; 0~255 (역정규화) = 값 * 255 (반올림 적용) | . RGB(0.5, 0.75, 1.0) -&gt; RGB(128, 191, 255) . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#rgb-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#rgb-정규화-방법"
  },"39": {
    "doc": "2. Master Material",
    "title": "1. 밝기: Brightness",
    "content": ". | RGB 값에 1보다 큰 수를 곱하는 것으로 설정 가능. | RGB는 0.0 ~ 1.0 범위로 표현됨 . | 0.0 = 완전한 어둠 (검정) | 1.0 = 최대 밝기 (순수한 색상) | . | R * 2 = R의 밝기 2배 증가 | R * 0.5 = R의 밝기 50% 감소 | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#1-%EB%B0%9D%EA%B8%B0-brightness",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#1-밝기-brightness"
  },"40": {
    "doc": "2. Master Material",
    "title": "2. 채도: Satration",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#2-%EC%B1%84%EB%8F%84-satration",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#2-채도-satration"
  },"41": {
    "doc": "2. Master Material",
    "title": "desaturation (탈색)",
    "content": "특정 색상을 흑백(grayscale)에 가깝게 변환하는 데 사용되는 노드. 이 노드를 사용하여 채도를 조절한다. | 입력 input (V3) : 일반적으로 텍스쳐의 RGB가 입력됨 | 입력 Fraction (V1) : 채도를 얼마나 줄일지 결정하는 값. | 0 : 원본 색상 유지 | 1 : 완전히 회색 | . | 출력 (V3) : desaturation 적용 결과 | . 내부 연산 공식 . Gray = R * 0.3 + G * 0.59 + B * 0.11 Output = lerp(Input, Gray, Fraction) . | Gray는 NTSC 표준 기반의 가중 평균. 인간의 눈이 가장 민감한 녹색에 높은 가중치를 둠 | . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#desaturation-%ED%83%88%EC%83%89",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#desaturation-탈색"
  },"42": {
    "doc": "2. Master Material",
    "title": "3. 대비: Contrast",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#3-%EB%8C%80%EB%B9%84-contrast",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#3-대비-contrast"
  },"43": {
    "doc": "2. Master Material",
    "title": "power",
    "content": "입력 값의 지수 승(power/exponentiation) 을 계산하는 노드 . Output = Base ^ Exponent . | 입력 Base (V,V3) : 일반적으로 RGB 텍스쳐 입력 | 입력 Exponent (V) : 지수 값. | 출력 (V, V3): 계산된 결과 값 (Base의 Exponent 승) | . ❓왜 Contrast 조절에 Power를 쓰는거야? . | power는 단순 곱셈으로는 할 수 없는 비선형적인 변화를 제공하기 때문이다 | . 곱셈 (Multiply) vs 지수승 (Power) . | 특성 | 곱셈 | 지수승 | . | 수학적 표현 | RGB × Scale | RGB ^ Gamma | . | 연산 유형 | 모든 픽셀의 밝기를 균일하게 스케일링 어두운 영역과 밝은 영역이 동일한 비율로 변화 | 비선형변환으로 밝기 분포를 비균형적으로 조정 | . | 밝기 변화 | 모든 픽셀 균일하게 스케일링 | 밝은 픽셀은 더 밝게 어두운 픽셀은 더 어둡게 (분포 왜곡) | . | 대비(Contrast) 영향 | 대비 유지 | 대비 증가 (Gamma &gt; 1) 대비 감소 (Gamma &lt; 1) | . | 시각적 효과 | 전체적으로 밝아지거나 어두워짐 | 어두운 영역과 밝은 영역의 차이 강조 or 완화 | . | 사용 예시 | 밝기 조정, 라이트 강도 증감 | Contrast 조정, 감마 보정 | . RGB (0.2, 0.5, 0.8) Power(2.0) -&gt; RGB(0.04, 0.25, 0.64) // 어두운 부분은 급격히 어두워지고 밝은 픽셀은 상대적으로 덜 영향받음. = 대비 강해짐 . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#power",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#power"
  },"44": {
    "doc": "2. Master Material",
    "title": "4. 색조: Tint",
    "content": "Base color의 RGB에 다른 색상의 RGB를 곱해서 얻을 수 있다. | 채널별 스케일링 . | 곱해지는 색상의 각 채널 값이 원본 색상의 해당 채널을 강화하거나 약화시킴 | 1.0 : 해당 채널 100% 유지 | 0.5 : 해당 채널 50% 감소 | 0.0 : 해당 채널 완전히 제거 | . | . // 원본 색상 RGB(0.8, 0.5, 0.2) // Tint 색상 RGB(1.0, 0.3, 0.3) // 결과 -&gt; R은 유지, G/B는 감소 (0.8*1.0, 0.5*0.3, 0.2*0.3) = (0.8, 0.15, 0.06) . ",
    "url": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#4-%EC%83%89%EC%A1%B0-tint",
    
    "relUrl": "/docs/Unreal%20Engine%205/2.%20Master%20Material.html#4-색조-tint"
  },"45": {
    "doc": "GPU Architecture",
    "title": "GPU Architecture",
    "content": "GPU에서 실행되는 애플리케이션 프로그램을 준비할 때 GPU 하드웨어 설계의 주요 기능을 이해하고 CPU와의 유사점과 차이점을 파악하고자 한다. | 참고링크 Conrnell Virtual Workshop | . ",
    "url": "/docs/Computer%20architecture/GPU%20Architecture/",
    
    "relUrl": "/docs/Computer%20architecture/GPU%20Architecture/"
  },"46": {
    "doc": "Computer Graphics",
    "title": "Computer Graphics",
    "content": " ",
    "url": "/docs/Computer%20Graphics/",
    
    "relUrl": "/docs/Computer%20Graphics/"
  },"47": {
    "doc": "Linear Algebra",
    "title": "Linear Algebra",
    "content": " ",
    "url": "/docs/Math/linear%20algebra/",
    
    "relUrl": "/docs/Math/linear%20algebra/"
  },"48": {
    "doc": "Math",
    "title": "Math",
    "content": " ",
    "url": "/docs/Math/",
    
    "relUrl": "/docs/Math/"
  },"49": {
    "doc": "Graphics rendering pipeline",
    "title": "Graphics rendering pipeline",
    "content": "3D 좌표로 표현된 기하학적 객체의 장면을 2D 디스플레이에 렌더링하는 데 필요한 일련의 단계 . | 참고 링크 Graphics Programming Compendium | 참고 링크 a trip through the graphics pipeline | . ",
    "url": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/",
    
    "relUrl": "/docs/Computer%20Graphics/Graphics%20rendering%20pipeline/"
  },"50": {
    "doc": "Computer architecture",
    "title": "Computer architecture",
    "content": " ",
    "url": "/docs/Computer%20architecture/",
    
    "relUrl": "/docs/Computer%20architecture/"
  },"51": {
    "doc": "Material",
    "title": "Material",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/Material/",
    
    "relUrl": "/docs/Unreal%20Engine%205/Material/"
  },"52": {
    "doc": "C++",
    "title": "C++",
    "content": " ",
    "url": "/docs/C++/",
    
    "relUrl": "/docs/C++/"
  },"53": {
    "doc": "Unreal Engine 5",
    "title": "Unreal Engine 5",
    "content": " ",
    "url": "/docs/Unreal%20Engine%205/",
    
    "relUrl": "/docs/Unreal%20Engine%205/"
  },"54": {
    "doc": "Home",
    "title": "Home",
    "content": ". ✨2025-05-02 . | 깃허브 블로그 개설 | 커스텀 설정 추가 (custom.scss) . | site-title font : Darumadrop One 으로 변경 | .nav-list-link : color 수정 | . | . ✨2025-05-03 . | 커스텀 설정 추가 . | 마크다운 font : Noto Sans KR 로 변경 | 인용 블록 : border-radius 추가, 색상 변경 | 코드 블록 : font Rubik 으로 변경, border-radius 추가, Rouge github 테마로 폰트 색상 변경 | . | . ✨2025-05-04 . | 커스텀 설정 추가 . | 테이블 : font IBM Plex Sans KR 로 변경, 라인 색상 변경, 사이드 라인 제거 | 링크 버튼 : btn-purple color 변경 | 인용 블록 종류 추가 : warning, highlight, note, important, new | . | . ✨2025-05-06 . | 로고 추가 | 푸터 추가 | . ",
    "url": "/",
    
    "relUrl": "/"
  }
}
